/****************************************************************************************		FILE:	TE32K.c*				Replacement for Text Edit routines*		*		EDIT HISTORY:**			v1.2	32 December 1992	Roy Wood <rrwood@canrem.com>**			v1.2a	11 January 1994		Michael J. Lowe <michaell@gsb.usyd.edu.au>**											- implemented tripple click support*											- implemented TE32KFeatureFlag*												- te32KFOutlineHilite*												- te32KFShowCarridgeReturns*											- implemented TE32KGetHiliteRgn for 'Drag and Drop'*											- numerous bug fixes*														*											- Changes for THINK C 6.0x/7.0x*											- Changes for MPW*											- Changes for Universal Headers*											- Changes for Mac on RISC SDK**			v1.2b	Summer, Autumn 1997	Cyril Moorzin <mcyril@deeds.spb.ru>**											- numerous bug fixes*											- RavelQUILL adaptation****************************************************************************************///#pragma segment TE32K#include <LowMem.h>#include <Errors.h>#include <Events.h>#include <Memory.h>#include <Scrap.h>#include <string.h>#include "TE32K.h"#include "quoting.h"#define	EXTRALINESTARTS		32L#define	EXTRATEXTBUFF		256L#define	LEFTARROW			28#define	RIGHTARROW			29#define UPARROW				30#define DOWNARROW			31#define	TAB					'\t'#define DELETE				0x08#define	RETURN				0x0D#define	ENTER				0x03#define ToShort(l)		(((l)<-32768L) ? ((short)-32768) : (((l)>32767L) ? (short)32767 : (short)(l)))Handle			TE32KScrpHandle = nil;long			TE32KScrpLength = 0L;TE32KHandle		clickedTE32KH = nil;RGBColor		returnGray = {0x8000, 0x8000, 0x8000},				quoteGray = {0xc000, 0xc000, 0xc000},				quote1Gray = {0xa000, 0xa000, 0xa000},				quoteGrayFg = {0x0000, 0x0000, 0x0000},				quote1GrayFg = {0x0000, 0x0000, 0x0000},				kludgeBack = {0xf000, 0x3000, 0x3000},				kludgeColor = {0x0000, 0x0000, 0x0000};static long		LineEndIndex(long, TE32KHandle);static void		CalParagraph(long, TE32KHandle, long *, long *);static long 	paraLines(long, TE32KHandle);static void 	updateLine(long, TE32KHandle, short, LongRect *);static void		invertSelRange(long, long, TE32KHandle);static void		xorCaret(TE32KHandle);//static long		TE32KIndexToLine(long, TE32KHandle);static short	shiftKeyDown(void);static void		getSelRangeRgn(RgnHandle, long,long,TE32KHandle);static void 	MyClickLoop(void);/**************************************************************************************/void TE32KSetFontStuff(short txFont, short txFace, short txMode, short txSize, TE32KHandle te){	register short		i;	short				oldFont,oldFace,oldSize,oldMode;	GrafPtr				oldPort;	FontInfo			theFontInfo;	GrafPtr 			currentPort;		currentPort = (*te)->inPort;		GetPort (&oldPort);	SetPort (currentPort);	oldFont = currentPort->txFont;	oldFace = currentPort->txFace;	oldSize = currentPort->txSize;	oldMode = currentPort->txMode;		TextFont ((*te)->txFont = txFont);	TextFace ((*te)->txFace = txFace);	TextSize ((*te)->txSize = txSize);	TextMode ((*te)->txMode = txMode);		for (i=0;i<256;i++)		(*te)->theCharWidths[i] = CharWidth((unsigned char) i);		GetFontInfo(&theFontInfo);	(*te)->lineHeight = theFontInfo.ascent + theFontInfo.descent + theFontInfo.leading;	(*te)->fontAscent = theFontInfo.ascent;		if ((*te)->tabChars)		(*te)->tabWidth = (*te)->tabChars * (*te)->theCharWidths[' '];		TextFont (oldFont);	TextFace (oldFace);	TextSize (oldSize);	TextMode (oldMode);		SetPort (oldPort);}/**************************************************************************************/void SetLongRect (LongRect *theLongRect, long left, long top, long right, long bottom){	theLongRect->left = left;	theLongRect->top = top;	theLongRect->right = right;	theLongRect->bottom = bottom;}void RectToLongRect (Rect *theRect, LongRect *theLongRect){	theLongRect->left = (long) theRect->left;	theLongRect->top = (long) theRect->top;	theLongRect->right = (long) theRect->right;	theLongRect->bottom =  (long) theRect->bottom;}void LongRectToRect (LongRect *theLongRect, Rect *theRect){	SetRect  (theRect, ToShort  (theLongRect->left), ToShort  (theLongRect->top),					ToShort  (theLongRect->right), ToShort  (theLongRect->bottom));}void OffsetLongRect (LongRect *theLongRect, long x, long y){	theLongRect->left += x;	theLongRect->top += y;	theLongRect->right += x;	theLongRect->bottom += y;}/**************************************************************************************/long TE32KIndexToLine (long selIndex, TE32KHandle te){	register long i, delta;	if (te) {		if ((selIndex <= 0L) || ((*te)->nLines <= 1L) || ((*te)->teLength < 1L))			return 0L;		else {			if (selIndex >= (*te)->teLength)				return ((*te)->nLines - 1L);			else {				i = ((*te)->nLines) >> 1;				delta = ((*te)->nLines) >> 1;				if (delta < 1L) 					delta = 1L;				while (delta > 0L) {					if (selIndex == (*te)->lineStarts[i])						delta = 0L;					else {						if (selIndex > (*te)->lineStarts[i]) {							if (selIndex < (*te)->lineStarts[i+1])								delta = 0L;							else								i += delta;						} else 							i -= delta;					}					if (delta) {						delta >>= 1;						if (delta < 1L) delta = 1L;					}				}			}		}		if (i < 0L)			i = 0L;		else 			if (i >= (*te)->nLines)				i = (*te)->nLines - 1L;		return i;	} else 		return 0L;}/**************************************************************************************/static void	xorCaret (TE32KHandle te){	GrafPtr		oldPort;	PenState	oldPenState;	Point		selPt;	RgnHandle	oldClipRgn;	Rect		theClipRect;	if ((te != 0) &&		(*te)->active &&		((*te)->selStart == (*te)->selEnd) &&		!(*te)->suppressCaret)					//¥	check if suppress caret here	{		if (!(*te)->caretState && (((*te)->selStart < 0) || ((*te)->selEnd > (*te)->teLength)))			return;		GetPort(&oldPort);		SetPort((*te)->inPort);		GetPenState(&oldPenState);		oldClipRgn = NewRgn();		GetClip (oldClipRgn);		theClipRect.left = (short) (*te)->viewRect.left;		theClipRect.top = (short) (*te)->viewRect.top;		theClipRect.right = (short) (*te)->viewRect.right;		theClipRect.bottom = (short) (*te)->viewRect.bottom;		ClipRect (&theClipRect);		PenNormal ();		PenMode (patXor);		selPt.h = ToShort ((*te)->selPoint.h);		selPt.v = ToShort ((*te)->selPoint.v);		MoveTo (selPt.h - 1, selPt.v);		Line (0, -(*te)->fontAscent);		(*te)->caretTime = TickCount() + GetCaretTime ();		(*te)->caretState = !(*te)->caretState; 		SetClip (oldClipRgn);		DisposeRgn (oldClipRgn);		SetPenState (&oldPenState);		SetPort (oldPort);	}}/**************************************************************************************/void TE32KInit(){	if (TE32KScrpHandle == nil) {		TE32KScrpHandle = NewHandle(0L);		TE32KScrpLength = 0L;	}}/**************************************************************************************/TE32KHandle	TE32KNew (LongRect *destRect, LongRect *viewRect){	TE32KHandle		nte;	Handle			hText;	GrafPtr			activePort;	FontInfo		theFontInfo;	LongPoint		selPt;	nte = (TE32KHandle) NewHandle (sizeof(TE32KRec) + (long)sizeof(long)*EXTRALINESTARTS);	if (MemError()) 		return ((TE32KHandle) nil);	hText = NewHandle (EXTRATEXTBUFF);	if (MemError()) {		DisposeHandle ((Handle) nte);		return ((TE32KHandle) nil);	}		(*nte)->destRect = *destRect;	(*nte)->viewRect = *viewRect;		GetPort (&activePort);	GetFontInfo (&theFontInfo);		(*nte)->lineHeight = theFontInfo.ascent + theFontInfo.descent + theFontInfo.leading;	(*nte)->fontAscent = theFontInfo.ascent;	(*nte)->selStart = 	(*nte)->selEnd = 	(*nte)->teLength = 0L;	(*nte)->hText = hText;	(*nte)->txFont = activePort->txFont;	(*nte)->txFace = activePort->txFace;	(*nte)->txMode = activePort->txMode;	(*nte)->txSize = activePort->txSize;	(*nte)->inPort = activePort;	(*nte)->tabWidth = 25;	(*nte)->tabChars = 0;	(*nte)->maxLineWidth = 32767;	(*nte)->clikStuff = false;	(*nte)->crOnly = 0x00;	(*nte)->featureFlags = 0;	(*nte)->nLines = 1L;	(*nte)->lineStarts[0] =	(*nte)->lineStarts[1] = 0L;	(*nte)->active = true;	(*nte)->caretState = false;	(*nte)->caretTime = TickCount();	(*nte)->dblClick = false;	(*nte)->clickTime = TickCount();	(*nte)->clickLoc = -1L;	TE32KGetPoint((*nte)->selStart, &selPt, nte);	(*nte)->selPoint = selPt;	(*nte)->suppressCaret = 0;		//¥	Added by Cyril	(*nte)->theVScroll = NULL;		//¥	Added by Cyril	(*nte)->clikLoop = nil;	TE32KSetFontStuff((*nte)->txFont, (*nte)->txFace, (*nte)->txMode, (*nte)->txSize, nte);	return (nte);}void TE32KDispose(TE32KHandle te){	if (te) {		if ((*te)->hText)			DisposeHandle((*te)->hText);		DisposeHandle((Handle) te);	}}/**************************************************************************************/void TE32KCalText(TE32KHandle te){	register unsigned char	*charPtr;	register long			charCount;	register short			*theCharWidths, lineLength, crOnly, maxLineWidth;	register unsigned char	ch;	long					nLines, maxLineStarts, sizeTE32KHandle;	unsigned char			*charBase;	Point					cursorPt;	short					rightSide, destLeftSide, tabWidth, maxRewind;	unsigned char			*oldCharPtr;	long					oldCharCount, tempOffset;	if (te) {		(*te)->lineStarts[0] =			/* assume the worst can happen and prepare for it */		(*te)->lineStarts[1] = 0L;		(*te)->nLines = 1L;				sizeTE32KHandle  = GetHandleSize ((Handle) te);		maxLineStarts = (sizeTE32KHandle - (long) sizeof(TE32KRec))/(long) sizeof(long) - 2;				crOnly = (*te)->crOnly;		maxLineWidth = (*te)->maxLineWidth;				lineLength = nLines = 0L;				charBase = (unsigned char *) *((*te)->hText);		charPtr = charBase;		charCount = (*te)->teLength;				if (charCount > 0L) {			rightSide = (short) ((*te)->destRect.right);			destLeftSide = (short) ((*te)->destRect.left + 1L);			cursorPt.h = destLeftSide;			tabWidth = (long) (*te)->tabWidth;						theCharWidths = (*te)->theCharWidths;						while (charCount--) {				ch = *charPtr++;				lineLength++;								if (!crOnly) {					if (ch == TAB)						cursorPt.h = destLeftSide + ((cursorPt.h - destLeftSide + tabWidth)/tabWidth)*tabWidth;					else if (ch != '\r' && ch != '\n')						cursorPt.h += theCharWidths[ch];				}								if ((ch == '\r' || ch == '\n') || (ch != ' ' && cursorPt.h >= rightSide) || (!crOnly && lineLength > maxLineWidth)) {					if ((ch != ' ' && cursorPt.h >= rightSide) || (!crOnly && lineLength > maxLineWidth)) {						/* I should probably add a hook for custom word-breaking */												maxRewind = charPtr - charBase - (*te)->lineStarts[nLines];						oldCharPtr = charPtr;						oldCharCount = charCount;												charPtr--;						charCount++;						maxRewind--;												while (*charPtr != ' ' && maxRewind > 0) {							charPtr--;							charCount++;							maxRewind--;						}												if (maxRewind <= 0) {							charPtr = oldCharPtr;							charCount = oldCharCount;						} else {							charPtr++;							charCount--;						}					}										if (nLines >= maxLineStarts) {						tempOffset = charPtr - charBase;																		sizeTE32KHandle = (long) sizeof(TE32KRec) + (long) sizeof(long)*(nLines + EXTRALINESTARTS);						maxLineStarts = (sizeTE32KHandle - (long) sizeof(TE32KRec))/(long) sizeof(long) - 2;												SetHandleSize((Handle) te,sizeTE32KHandle);						if (MemError()) return;												charBase = (unsigned char *) *((*te)->hText);						charPtr = charBase + tempOffset;						theCharWidths = (*te)->theCharWidths;					}										(*te)->lineStarts[++nLines] = charPtr - charBase;										cursorPt.h = destLeftSide;					lineLength = 0L;				}			}						if (nLines >= maxLineStarts) {				sizeTE32KHandle = (long) sizeof(TE32KRec) + (long) sizeof(long)*(nLines + EXTRALINESTARTS);								SetHandleSize((Handle) te,sizeTE32KHandle);				if (MemError()) return;			}						(*te)->lineStarts[++nLines] = charPtr - charBase;				(*te)->nLines = nLines;		}	}}void TE32KUseTextHandle (Handle hText, long textLength, TE32KHandle te){	LongPoint	selPt;	if (te) {		if ((*te)->hText) DisposeHandle((*te)->hText);				SetHandleSize(hText, textLength + EXTRATEXTBUFF);				(*te)->hText = hText;		(*te)->teLength =				(*te)->selStart =		(*te)->selEnd = textLength;				TE32KGetPoint((*te)->selStart, &selPt, te);		(*te)->selPoint = selPt;				TE32KCalText(te);	}}void TE32KSetText(Ptr textPtr,long textLength, TE32KHandle te){	Handle		hText;	LongPoint	selPt;	if (te) {		hText = NewHandle(textLength + EXTRATEXTBUFF);		if (MemError()) return;				if ((*te)->hText) DisposeHandle((*te)->hText);				HLock(hText);		BlockMoveData(textPtr,*hText,textLength);		HUnlock(hText);				(*te)->hText = hText;		(*te)->teLength =				(*te)->selStart =		(*te)->selEnd = textLength;				TE32KGetPoint((*te)->selStart,&selPt,te);		(*te)->selPoint = selPt;				TE32KCalText(te);	}}Handle	TE32KGetText(TE32KHandle te){	if (te) {		return (*te)->hText;	} else return nil;}void	TE32KUpdate(LongRect *updateLongRect,TE32KHandle te){	LongRect					tempLongRect;	Rect						theClipRect,viewRect,updateRect;	GrafPtr						oldPort,currentPort;	RgnHandle					oldClipRgn;	register unsigned char		*textPtr;	register long				firstLine,lastLine,i,thisStart,nextStart,tabWidth;	Point						cursorPt;	short						oldFont,oldFace,oldSize,oldMode;	short						rightSide,destLeftSide;	LongPoint					selPt;	unsigned char				oldCaretState;	RGBColor					fgSaveColor, fgSaveColorFg, fgSaveQColor, fgSaveQColorFg;	Boolean						showReturns, isCurrentPortColor, ColorQuotes, prvHadquotes;	short						qstart, qend;	Rect						tttRect;	if ((te != 0) && ((*te)->inPort != 0))	{		showReturns = TE32KFeatureFlag(te32KFShowCarridgeReturns, TE32KBitTest, te);//¥	Cyril++		ColorQuotes = TE32KFeatureFlag(te32KFColorQuotes, TE32KBitTest, te);				tempLongRect = (*te)->viewRect;		LongRectToRect(&tempLongRect,&viewRect);				tempLongRect = *updateLongRect;		tempLongRect.top = (*te)->destRect.top + ((updateLongRect->top - (*te)->destRect.top)/(*te)->lineHeight)*(*te)->lineHeight;		tempLongRect.bottom = (*te)->destRect.top + ((updateLongRect->bottom - (*te)->destRect.top + (*te)->lineHeight - 1L)/(*te)->lineHeight)*(*te)->lineHeight;		LongRectToRect(&tempLongRect,&updateRect);				if (SectRect(&viewRect,&updateRect,&theClipRect))		{			GetPort(&oldPort);			currentPort = (*te)->inPort;			SetPort(currentPort);						isCurrentPortColor =  (((CGrafPtr)currentPort)->portVersion & 0x8000) != 0;						GetClip(oldClipRgn = NewRgn());			ClipRect(&theClipRect);						oldCaretState = (*te)->caretState;			if ((*te)->selStart == (*te)->selEnd && oldCaretState)				xorCaret(te);						firstLine = ((long) theClipRect.top - (*te)->destRect.top)/(long) (*te)->lineHeight;			lastLine = ((long) theClipRect.bottom - (*te)->destRect.top - 1L)/(long) (*te)->lineHeight;						if (firstLine < 0) firstLine = 0;			if (lastLine >= (*te)->nLines) lastLine = (*te)->nLines - 1L;			if (firstLine > lastLine) lastLine = firstLine;						EraseRect(&theClipRect);						if (firstLine < (*te)->nLines && (*te)->teLength > 0L) {				rightSide = theClipRect.right;				cursorPt.h = destLeftSide = (short) (*te)->destRect.left + 1L;				cursorPt.v = (short) ((*te)->destRect.top + firstLine * (long) (*te)->lineHeight + (long) (*te)->fontAscent);								oldFont = currentPort->txFont;				oldFace = currentPort->txFace;				oldSize = currentPort->txSize;				oldMode = currentPort->txMode;								TextFont((*te)->txFont);				TextFace((*te)->txFace);				TextSize((*te)->txSize);				TextMode((*te)->txMode);								HLock((*te)->hText);								textPtr = (unsigned char *) *((*te)->hText);				tabWidth = (long) (*te)->tabWidth;								while (firstLine <= lastLine) {					i = thisStart = (*te)->lineStarts[firstLine];					nextStart = (*te)->lineStarts[firstLine+1];										if (nextStart > thisStart && (textPtr[nextStart-1] == '\r' || textPtr[nextStart-1] == '\n'))						nextStart--;										prvHadquotes = false;														MoveTo(cursorPt.h,cursorPt.v);					while (thisStart < nextStart) {						while (i<nextStart && textPtr[i]!=TAB)							i++;												if (i > thisStart)						{							char	back_char;														if (thisStart)								back_char = textPtr[thisStart-1];							else								back_char = '\r';														if (ColorQuotes && (prvHadquotes ||								(back_char == '\r' &&								hasInitials ((char *) &(textPtr[thisStart]), &qstart, &qend ))))							{								GetBackColor(&fgSaveColor);								GetForeColor(&fgSaveColorFg);																if (prvHadquotes)								{									RGBBackColor(&fgSaveQColor);									RGBForeColor(&fgSaveQColorFg);								}								else								{									if ((quotingnest ((char *) &(textPtr[thisStart]), qstart, qend) & 1) == 1)									{										RGBBackColor(&quoteGray);										fgSaveQColor = quoteGray;																				RGBForeColor(&quoteGrayFg);										fgSaveQColorFg = quoteGrayFg;									}									else									{										RGBBackColor(&quote1Gray);										fgSaveQColor = quote1Gray;										RGBForeColor(&quote1GrayFg);										fgSaveQColorFg = quote1GrayFg;									}									tttRect.left = (short) ((*te)->viewRect.left);									tttRect.right = (short) ((*te)->viewRect.right);									tttRect.top = cursorPt.v - (*te)->fontAscent;									tttRect.bottom = tttRect.top + (*te)->lineHeight;																		EraseRect (&tttRect);								}																prvHadquotes = true;								DrawText(&(textPtr[thisStart]), 0, (short) (i - thisStart));								RGBForeColor(&fgSaveColorFg);								RGBBackColor(&fgSaveColor);							}							else							{								GetForeColor(&fgSaveColorFg);								GetBackColor(&fgSaveColor);								if (ColorQuotes && (prvHadquotes ||									(back_char == '\r' &&									(textPtr[thisStart] == '\1' || !strncmp ((char *) &(textPtr[thisStart]), "SEEN-BY: ", 9)))))								{									RGBBackColor(&kludgeBack);									RGBForeColor(&kludgeColor);									tttRect.left = (short) ((*te)->viewRect.left);									tttRect.right = (short) ((*te)->viewRect.right);									tttRect.top = cursorPt.v - (*te)->fontAscent;									tttRect.bottom = tttRect.top + (*te)->lineHeight;																		EraseRect (&tttRect);								}								DrawText(&(textPtr[thisStart]), 0, (short) (i - thisStart));								RGBForeColor(&fgSaveColorFg);								RGBBackColor(&fgSaveColor);							}						}												if (i<nextStart && textPtr[i]==TAB) {							MoveTo(destLeftSide + ((currentPort->pnLoc.h - destLeftSide + tabWidth)/tabWidth)*tabWidth,currentPort->pnLoc.v);							i++;						}						thisStart = i;						if (currentPort->pnLoc.h > theClipRect.right)							thisStart = nextStart;					}					prvHadquotes = false;/*					if (showReturns && thisStart < (*te)->teLength && textPtr[thisStart]) {						if (isCurrentPortColor) {							GetForeColor(&fgSaveColor);							RGBForeColor(&returnGray);						}						DrawChar('¦');						if (isCurrentPortColor)							RGBForeColor(&fgSaveColor);					}*/					if (showReturns &&						thisStart < (*te)->teLength &&						(textPtr[nextStart] == '\r' || textPtr[nextStart] == '\n'))					{						if (isCurrentPortColor) {							GetForeColor(&fgSaveColor);							RGBForeColor(&returnGray);						}												TextFont (4);						DrawChar('¦');						TextFont ((*te)->txFont);												if (isCurrentPortColor)							RGBForeColor(&fgSaveColor);					}//					if (thisStart < (*te)->teLength &&//						(textPtr[nextStart] == '\r' || textPtr[nextStart] == '\n'))//						prvHadquotes = false;					firstLine++;					cursorPt.v += (*te)->lineHeight;				}									HUnlock((*te)->hText);								TextFont(oldFont);				TextFace(oldFace);				TextSize(oldSize);				TextMode(oldMode);			}						if ((*te)->selStart < (*te)->selEnd)				invertSelRange((*te)->selStart,(*te)->selEnd,te);			else {				TE32KGetPoint((*te)->selStart,&selPt,te);				(*te)->selPoint = selPt;								if (oldCaretState) xorCaret(te);			}						SetClip(oldClipRgn);			DisposeRgn(oldClipRgn);						SetPort(oldPort);		}	}}void	TE32KScroll	(long horiz,long vert,TE32KHandle te){	LongRect	updateLongRect;	Rect		scrollRect;	RgnHandle	updateRgn;	GrafPtr		oldPort;	LongPoint	selPt;	if ((te != 0) && (*te)->inPort && (horiz || vert)) {		GetPort(&oldPort);		SetPort((*te)->inPort);				(*te)->destRect.left += horiz;		(*te)->destRect.top += vert;		(*te)->destRect.right += horiz;		(*te)->destRect.bottom += vert;				(*te)->selPoint.h += horiz;		(*te)->selPoint.v += vert;		selPt = (*te)->selPoint;				scrollRect.left = (short) ((*te)->viewRect.left);		scrollRect.top = (short) ((*te)->viewRect.top);		scrollRect.right = (short) ((*te)->viewRect.right);		scrollRect.bottom = (short) ((*te)->viewRect.bottom);				if (horiz < ((*te)->viewRect.right-(*te)->viewRect.left) ||			vert < ((*te)->viewRect.bottom-(*te)->viewRect.top)) {						ScrollRect(&scrollRect,(short) horiz,(short) vert,updateRgn = NewRgn());						updateLongRect.left = (**updateRgn).rgnBBox.left;			updateLongRect.top = (**updateRgn).rgnBBox.top;			updateLongRect.right = (**updateRgn).rgnBBox.right;			updateLongRect.bottom = (**updateRgn).rgnBBox.bottom;			DisposeRgn(updateRgn);						TE32KUpdate(&updateLongRect,te);						if ((*te)->caretState) xorCaret(te);			(*te)->selPoint = selPt;			xorCaret(te);		} else {			updateLongRect = (*te)->viewRect;			TE32KUpdate(&updateLongRect,te);						if ((*te)->caretState) xorCaret(te);			(*te)->selPoint = selPt;			xorCaret(te);		}				SetPort(oldPort);	}}void	TE32KActivate(TE32KHandle te){	if ((te != 0) && !((*te)->active)) {		(*te)->caretState = false;					invertSelRange((*te)->selStart,(*te)->selEnd,te);		(*te)->active = true;		invertSelRange((*te)->selStart,(*te)->selEnd,te);	}}void	TE32KIdle(TE32KHandle te){	if ((te != 0) && (*te)->active && TickCount() >= (*te)->caretTime) {		if ((*te)->selStart == (*te)->selEnd)			xorCaret(te);	}}void	TE32KDeactivate(TE32KHandle te){	if ((te != 0) && (*te)->active) {		if ((*te)->selStart == (*te)->selEnd) {			if ((*te)->caretState)				xorCaret(te);			(*te)->active = false;		} else {			invertSelRange((*te)->selStart,(*te)->selEnd,te);			(*te)->active = false;			invertSelRange((*te)->selStart,(*te)->selEnd,te);		}	}}void	TE32KGetPoint(long selIndex,LongPoint *selPt,TE32KHandle te){	register unsigned char	*textPtr;	register short			*theCharWidths;	register long			i,thisStart,tabWidth;	long					x,y,lineIndex,destLeftSide;	unsigned char			ch;	LongPoint				origPt;	short					clikStuff;	if (te) {		if (selIndex<=0L || (*te)->teLength<1L) {			selPt->h = (*te)->destRect.left + 1L;			selPt->v = (*te)->destRect.top + (*te)->fontAscent;			(*te)->clikStuff = false;						return;		}				clikStuff = (*te)->clikStuff;		(*te)->clikStuff = false;				origPt = *selPt;				i = TE32KIndexToLine(selIndex,te);				y = (*te)->destRect.top + ((*te)->lineHeight * i) + (*te)->fontAscent;				selPt->v = y;				if (!(*te)->crOnly && clikStuff && i > 0 && selIndex == (*te)->lineStarts[i]) {			i--;			selPt->v -= (*te)->lineHeight;		} else if (selIndex < (*te)->lineStarts[i] || (selIndex == (*te)->lineStarts[i] && i < 1)) {			selPt->h = (*te)->destRect.left + 1L;			return;		}						HLock((*te)->hText);				lineIndex  = i;		textPtr = (unsigned char *) *((*te)->hText);				destLeftSide = (*te)->destRect.left + 1L;		x = destLeftSide;				thisStart = (*te)->lineStarts[lineIndex];				theCharWidths = (*te)->theCharWidths;				if (textPtr[selIndex-1] != '\r' && textPtr[selIndex-1] != '\n') {			tabWidth = (long) (*te)->tabWidth;						while (thisStart < selIndex) {				ch = textPtr[thisStart++];								if (ch == TAB)					x = destLeftSide + ((x - destLeftSide + tabWidth)/tabWidth)*tabWidth;				else					x += theCharWidths[ch];			}		}				HUnlock((*te)->hText);				selPt->h = x;	}}long	TE32KGetOffset(LongPoint *selPt,TE32KHandle te){	register unsigned char	*textPtr;	register short			*theCharWidths;	register long			i,delta,firstChar,lastChar,tabWidth;	unsigned char			done;	long					x,y,selIndex,horiz,destLeftSide;	if (te) {		if ((*te)->teLength < 1L)			return(0L);				horiz = selPt->h;				y = selPt->v - (*te)->destRect.top;				i = y / (long) (*te)->lineHeight;				if (i < 0L)			return(0L);				if (i >= (*te)->nLines)			return((*te)->teLength);				theCharWidths = (*te)->theCharWidths;				HLock((*te)->hText);				textPtr = (unsigned char *) *((*te)->hText);				destLeftSide = (*te)->destRect.left + 1L;		x = destLeftSide;		delta = 0L;				firstChar = (*te)->lineStarts[i];		lastChar = (*te)->lineStarts[i+1L];				tabWidth = (long) (*te)->tabWidth;				if (firstChar<lastChar && x+delta<horiz) {			done = false;					while (!done) {				if (textPtr[firstChar] != TAB)					delta = (long) theCharWidths[textPtr[firstChar]];				else					delta = (destLeftSide + ((x - destLeftSide + tabWidth)/tabWidth)*tabWidth) - x;								firstChar++;								if (firstChar >= lastChar) {						if (textPtr[lastChar - 1L] == '\r' || textPtr[lastChar - 1L] == '\n')						selIndex = lastChar - 1L;					else						selIndex = lastChar;										done = true;				} else if (x+delta >= horiz) {					if (horiz >= x + (delta >> 1))						selIndex = firstChar;					else						selIndex = --firstChar;										done = true;				} else					x += delta;			}		} else selIndex = firstChar;		HUnlock((*te)->hText);				return (selIndex);	}	return(0L);}static void	getSelRangeRgn(RgnHandle selectedRgn, long selStart,long selEnd,TE32KHandle te){	Rect		viewRect, tempRect1, tempRect2, tempRect3, theRect;	long		firstLine, lastLine;	LongPoint	selPt;	RgnHandle	tempRgn;		viewRect.left = (short) ((*te)->viewRect.left);	viewRect.top = (short) ((*te)->viewRect.top);	viewRect.right = (short) ((*te)->viewRect.right);	viewRect.bottom = (short) ((*te)->viewRect.bottom);		if (selStart > selEnd) {		firstLine = selStart;		selStart = selEnd;		selEnd = firstLine;	}		firstLine = TE32KIndexToLine(selStart, te);	lastLine = TE32KIndexToLine(selEnd, te);		TE32KGetPoint(selStart, &selPt, te);		selPt.v -= (*te)->fontAscent;	if (selStart <= (*te)->lineStarts[firstLine])		selPt.h--;			if (selPt.h < -32768L)		tempRect1.left = (short) -32768;	else if (selPt.h > 32767L)		tempRect1.left = (short) 32767;	else		tempRect1.left = (short) selPt.h;		if (selPt.v < -32768L)		tempRect1.top = (short) -32768;	else if (selPt.v > 32767L)		tempRect1.top = (short) 32767;	else		tempRect1.top = (short) selPt.v;		if (firstLine != lastLine) {		tempRect1.right = viewRect.right;		tempRect1.bottom = tempRect1.top + (*te)->lineHeight;	} else {		TE32KGetPoint(selEnd,&selPt,te);				selPt.v -= (*te)->fontAscent;		selPt.v += (*te)->lineHeight;				if (selPt.h < -32768L)			tempRect1.right = (short) -32768;		else if (selPt.h > 32767L)			tempRect1.right = (short) 32767;		else			tempRect1.right = (short) selPt.h;				if (selPt.v < -32768L)			tempRect1.bottom = (short) -32768;		else if (selPt.v > 32767L)			tempRect1.bottom = (short) 32767;		else			tempRect1.bottom = (short) selPt.v;	}		if (SectRect(&viewRect, &tempRect1, &theRect))		RectRgn(selectedRgn, &theRect);		if (lastLine > firstLine + 1L) {		TE32KGetPoint(selEnd, &selPt, te);				tempRect2.left = viewRect.left;		tempRect2.top = tempRect1.bottom;		tempRect2.right = viewRect.right;				selPt.v -= (*te)->fontAscent;				if (selPt.v < -32768L)			tempRect2.bottom = (short) -32768;		else if (selPt.v > 32767L)			tempRect2.bottom = (short) 32767;		else			tempRect2.bottom = (short) selPt.v;				selPt.v += (*te)->fontAscent;				if (SectRect(&viewRect, &tempRect2, &theRect)) {			RectRgn(tempRgn=NewRgn(), &theRect);			UnionRgn(tempRgn, selectedRgn, selectedRgn);			DisposeRgn(tempRgn);		}	}		if (lastLine > firstLine && selEnd > (*te)->lineStarts[lastLine]) {		if (lastLine == firstLine + 1L)			TE32KGetPoint(selEnd, &selPt, te);				selPt.v -= (*te)->fontAscent;				if (selPt.v < -32768L)			tempRect3.top = (short) -32768;		else if (selPt.v > 32767L)			tempRect3.top = (short) 32767;		else			tempRect3.top = (short) selPt.v;				selPt.v += (*te)->lineHeight;				if (selPt.v < -32768L)			tempRect3.bottom = (short) -32768;		else if (selPt.v > 32767L)			tempRect3.bottom = (short) 32767;		else			tempRect3.bottom = (short) selPt.v;						tempRect3.left = viewRect.left;				if (selPt.h < -32768L)			tempRect3.right = (short) -32768;		else if (selPt.h > 32767L)			tempRect3.right = (short) 32767;		else			tempRect3.right = (short) selPt.h;				if (SectRect(&viewRect, &tempRect3, &theRect)) {			RectRgn(tempRgn=NewRgn(), &theRect);			UnionRgn(tempRgn, selectedRgn, selectedRgn);			DisposeRgn(tempRgn);		}	}}void TE32KGetHiliteRgn(RgnHandle selectedRgn, TE32KHandle te){	getSelRangeRgn(selectedRgn, (*te)->selStart,(*te)->selEnd, te);}static void	invertSelRange(long selStart,long selEnd,TE32KHandle te){	GrafPtr			oldPort;	Boolean			ColorQuotes;	LongPoint		selPt;	PenState		penState;	unsigned char	oldMode;	RGBColor		fgSaveColor, fgSaveColorFg;	short			qstart, qend;	if (te)	{		ColorQuotes = TE32KFeatureFlag(te32KFColorQuotes, TE32KBitTest, te);		// Clear caret		if ((*te)->caretState)			xorCaret(te);				// Invert caret		if (selStart == selEnd) {			TE32KGetPoint(selStart,&selPt,te);			(*te)->selPoint = selPt;			(*te)->selStart = selStart;			(*te)->selEnd = selStart;						xorCaret(te);			return;		}						// else Invert selection range		GetPort(&oldPort);		SetPort((*te)->inPort);				if (!ColorQuotes || !(*te)->active)		{			RgnHandle		selectedRgn;			selectedRgn = NewRgn();			getSelRangeRgn(selectedRgn, selStart, selEnd, te);			if (!EmptyRgn(selectedRgn)) {				oldMode = LMGetHiliteMode();				LMSetHiliteMode(1);				if ((*te)->active)					InvertRgn(selectedRgn);				else if (TE32KFeatureFlag(te32KFOutlineHilite, TE32KBitTest, te)) {					GetPenState(&penState);					PenMode(srcXor);					FrameRgn(selectedRgn);					SetPenState(&penState);				}				LMSetHiliteMode(oldMode);			}			DisposeRgn(selectedRgn);		}		else		{			Rect		viewRect, tempRect1, theRect;			long		firstLine, lastLine, i;			RgnHandle	tempRgn;			viewRect.left = (short) ((*te)->viewRect.left);			viewRect.top = (short) ((*te)->viewRect.top);			viewRect.right = (short) ((*te)->viewRect.right);			viewRect.bottom = (short) ((*te)->viewRect.bottom);						if (selStart > selEnd) {				firstLine = selStart;				selStart = selEnd;				selEnd = firstLine;			}						firstLine = TE32KIndexToLine(selStart, te);			lastLine = TE32KIndexToLine(selEnd, te);						if (firstLine == lastLine)			{							TE32KGetPoint(selStart, &selPt, te);				selPt.v -= (*te)->fontAscent;				if (selStart <= (*te)->lineStarts[firstLine])					selPt.h--;									if (selPt.h < -32768L)					tempRect1.left = (short) -32768;				else if (selPt.h > 32767L)					tempRect1.left = (short) 32767;				else					tempRect1.left = (short) selPt.h;							if (selPt.v < -32768L)					tempRect1.top = (short) -32768;				else if (selPt.v > 32767L)					tempRect1.top = (short) 32767;				else					tempRect1.top = (short) selPt.v;								TE32KGetPoint(selEnd,&selPt,te);								selPt.v -= (*te)->fontAscent;				selPt.v += (*te)->lineHeight;								if (selPt.h < -32768L)					tempRect1.right = (short) -32768;				else if (selPt.h > 32767L)					tempRect1.right = (short) 32767;				else					tempRect1.right = (short) selPt.h;								if (selPt.v < -32768L)					tempRect1.bottom = (short) -32768;				else if (selPt.v > 32767L)					tempRect1.bottom = (short) 32767;				else					tempRect1.bottom = (short) selPt.v;								if (SectRect(&viewRect, &tempRect1, &theRect))				{					char	back_char;										if ((*te)->lineStarts[firstLine])						back_char = ((*(*te)->hText))[(*te)->lineStarts[firstLine]-1];					else						back_char = '\r';					GetBackColor(&fgSaveColor);					GetForeColor(&fgSaveColorFg);					if (back_char == '\r' &&						hasInitials ((char *) &(((*(*te)->hText))[(*te)->lineStarts[firstLine]]), &qstart, &qend ))					{						if ((quotingnest ((char *) &(((*(*te)->hText))[(*te)->lineStarts[firstLine]]), qstart, qend) & 1) == 1)						{							RGBBackColor(&quoteGray);							RGBForeColor(&quoteGrayFg);						}						else						{							RGBBackColor(&quote1Gray);							RGBForeColor(&quote1GrayFg);						}					}					else						if (back_char == '\r' &&							(((*(*te)->hText))[(*te)->lineStarts[firstLine]] == '\1' ||							!strncmp ((char *) &(((*(*te)->hText))[(*te)->lineStarts[firstLine]]), "SEEN-BY: ", 9)))						{							RGBBackColor(&kludgeBack);							RGBForeColor(&kludgeColor);						}										oldMode = LMGetHiliteMode();					LMSetHiliteMode(1);										if ((*te)->active)						InvertRect(&theRect);					else						if (TE32KFeatureFlag(te32KFOutlineHilite, TE32KBitTest, te))						{							GetPenState(&penState);							PenMode(srcXor);							FrameRect(&theRect);							SetPenState(&penState);						}										LMSetHiliteMode(oldMode);					RGBForeColor(&fgSaveColorFg);					RGBBackColor(&fgSaveColor);				}			}			else			{				TE32KGetPoint(selStart, &selPt, te);				selPt.v -= (*te)->fontAscent;				if (selStart <= (*te)->lineStarts[firstLine])					selPt.h--;								if (selPt.h < -32768L)					tempRect1.left = (short) -32768;				else if (selPt.h > 32767L)					tempRect1.left = (short) 32767;				else					tempRect1.left = (short) selPt.h;							if (selPt.v < -32768L)					tempRect1.top = (short) -32768;				else if (selPt.v > 32767L)					tempRect1.top = (short) 32767;				else					tempRect1.top = (short) selPt.v;								tempRect1.right = viewRect.right;				tempRect1.bottom = tempRect1.top + (*te)->lineHeight;								if (SectRect(&viewRect, &tempRect1, &theRect))				{					char	back_char;										if ((*te)->lineStarts[firstLine])						back_char = ((*(*te)->hText))[(*te)->lineStarts[firstLine]-1];					else						back_char = '\r';					GetBackColor(&fgSaveColor);					GetForeColor(&fgSaveColorFg);					if (back_char == '\r' &&						hasInitials ((char *) &(((*(*te)->hText))[(*te)->lineStarts[firstLine]]), &qstart, &qend ))					{						if ((quotingnest ((char *) &(((*(*te)->hText))[(*te)->lineStarts[firstLine]]), qstart, qend) & 1) == 1)						{							RGBBackColor(&quoteGray);							RGBForeColor(&quoteGrayFg);						}						else						{							RGBBackColor(&quote1Gray);							RGBForeColor(&quote1GrayFg);						}					}					else						if (back_char == '\r' &&							(((*(*te)->hText))[(*te)->lineStarts[firstLine]] == '\1' ||							!strncmp ((char *) &(((*(*te)->hText))[(*te)->lineStarts[firstLine]]), "SEEN-BY: ", 9)))						{							RGBBackColor(&kludgeBack);							RGBForeColor(&kludgeColor);						}					oldMode = LMGetHiliteMode();					LMSetHiliteMode(1);										if ((*te)->active)						InvertRect(&theRect);					else						if (TE32KFeatureFlag(te32KFOutlineHilite, TE32KBitTest, te))						{							GetPenState(&penState);							PenMode(srcXor);							FrameRect(&theRect);							SetPenState(&penState);						}										LMSetHiliteMode(oldMode);					RGBForeColor(&fgSaveColorFg);					RGBBackColor(&fgSaveColor);				}				for (i = firstLine+1; i <= lastLine-1; i++)				{					TE32KGetPoint((*te)->lineStarts[i], &selPt, te);										selPt.v -= (*te)->fontAscent;										tempRect1.left = viewRect.left;									if (selPt.v < -32768L)						tempRect1.top = (short) -32768;					else if (selPt.v > 32767L)						tempRect1.top = (short) 32767;					else						tempRect1.top = (short) selPt.v;										tempRect1.right = viewRect.right;					tempRect1.bottom = tempRect1.top + (*te)->lineHeight;										if (SectRect(&viewRect, &tempRect1, &theRect))					{						char	back_char;												if ((*te)->lineStarts[i])							back_char = ((*(*te)->hText))[(*te)->lineStarts[i]-1];						else							back_char = '\r';						GetBackColor(&fgSaveColor);						GetForeColor(&fgSaveColorFg);						if (back_char == '\r' &&							hasInitials ((char *) &(((*(*te)->hText))[(*te)->lineStarts[i]]), &qstart, &qend ))						{							if ((quotingnest ((char *) &(((*(*te)->hText))[(*te)->lineStarts[i]]), qstart, qend) & 1) == 1)							{								RGBBackColor(&quoteGray);								RGBForeColor(&quoteGrayFg);							}							else							{								RGBBackColor(&quote1Gray);								RGBForeColor(&quote1GrayFg);							}						}						else							if (back_char == '\r' &&								(((*(*te)->hText))[(*te)->lineStarts[i]] == '\1' ||								!strncmp ((char *) &(((*(*te)->hText))[(*te)->lineStarts[i]]), "SEEN-BY: ", 9)))							{								RGBBackColor(&kludgeBack);								RGBForeColor(&kludgeColor);							}						oldMode = LMGetHiliteMode();						LMSetHiliteMode(1);												if ((*te)->active)							InvertRect(&theRect);						else							if (TE32KFeatureFlag(te32KFOutlineHilite, TE32KBitTest, te))							{								GetPenState(&penState);								PenMode(srcXor);								FrameRect(&theRect);								SetPenState(&penState);							}												LMSetHiliteMode(oldMode);						RGBForeColor(&fgSaveColorFg);						RGBBackColor(&fgSaveColor);					}				}				if (selEnd > (*te)->lineStarts[lastLine])				{					TE32KGetPoint(selEnd, &selPt, te);										selPt.v -= (*te)->fontAscent;										if (selPt.v < -32768L)						tempRect1.top = (short) -32768;					else if (selPt.v > 32767L)						tempRect1.top = (short) 32767;					else						tempRect1.top = (short) selPt.v;										selPt.v += (*te)->lineHeight;										if (selPt.v < -32768L)						tempRect1.bottom = (short) -32768;					else if (selPt.v > 32767L)						tempRect1.bottom = (short) 32767;					else						tempRect1.bottom = (short) selPt.v;										tempRect1.left = viewRect.left;										if (selPt.h < -32768L)						tempRect1.right = (short) -32768;					else if (selPt.h > 32767L)						tempRect1.right = (short) 32767;					else						tempRect1.right = (short) selPt.h;										if (SectRect(&viewRect, &tempRect1, &theRect))					{						char	back_char;												if ((*te)->lineStarts[lastLine])							back_char = ((*(*te)->hText))[(*te)->lineStarts[lastLine]-1];						else							back_char = '\r';						GetBackColor(&fgSaveColor);						GetForeColor(&fgSaveColorFg);						if (back_char == '\r' &&							hasInitials ((char *) &(((*(*te)->hText))[(*te)->lineStarts[lastLine]]), &qstart, &qend ))						{							if ((quotingnest ((char *) &(((*(*te)->hText))[(*te)->lineStarts[lastLine]]), qstart, qend) & 1) == 1)							{								RGBBackColor(&quoteGray);								RGBForeColor(&quoteGrayFg);							}							else							{								RGBBackColor(&quote1Gray);								RGBForeColor(&quote1GrayFg);							}						}						else							if (back_char == '\r' &&								(((*(*te)->hText))[(*te)->lineStarts[lastLine]] == '\1' ||								!strncmp ((char *) &(((*(*te)->hText))[(*te)->lineStarts[lastLine]]), "SEEN-BY: ", 9)))							{								RGBBackColor(&kludgeBack);								RGBForeColor(&kludgeColor);							}						oldMode = LMGetHiliteMode();						LMSetHiliteMode(1);												if ((*te)->active)							InvertRect(&theRect);						else							if (TE32KFeatureFlag(te32KFOutlineHilite, TE32KBitTest, te))							{								GetPenState(&penState);								PenMode(srcXor);								FrameRect(&theRect);								SetPenState(&penState);							}												LMSetHiliteMode(oldMode);						RGBForeColor(&fgSaveColorFg);						RGBBackColor(&fgSaveColor);					}				}			}		}				SetPort(oldPort);	}}void	TE32KClick(Point startPoint,unsigned char extend,TE32KHandle te){	register long				selIndex,selAnchor,selLast,teLength, selLine;	register unsigned char		*textPtr;	LongPoint					selPt,tempPt;	Point						mousePt;	GrafPtr						oldPort;	unsigned char				ch;	long						oldClickLoc,wordStart,wordEnd;	if ((te != 0) && (*te)->active) {		clickedTE32KH = te;				teLength = (*te)->teLength;				selPt.h = (long) startPoint.h;		selPt.v = (long) startPoint.v;				selIndex = TE32KGetOffset(&selPt,te);				oldClickLoc = (*te)->clickLoc;		(*te)->clickLoc = selIndex;		if ((*te)->caretState)			xorCaret(te);				if (!extend && teLength > 0L && TickCount() < (*te)->clickTime + GetDblTime() && (*te)->dblClick && oldClickLoc == selIndex) {			if ((*te)->selStart != (*te)->selEnd)				invertSelRange((*te)->selStart,(*te)->selEnd,te);						selLine = TE32KIndexToLine(selIndex, te);			wordStart = (*te)->selStart = (*te)->lineStarts[selLine];			wordEnd = (*te)->selEnd = (*te)->lineStarts[selLine+1];			invertSelRange((*te)->selStart,(*te)->selEnd,te);						while (Button()) {				if ((*te)->clikLoop)					(*((*te)->clikLoop)) ((Handle) te);								GetMouse(&mousePt);				selPt.h = mousePt.h;				selPt.v = mousePt.v;							selIndex = TE32KGetOffset(&selPt,te);								if (selIndex < 0)					selIndex = 0;				else if (selIndex > teLength)					selIndex = teLength;								selLine = TE32KIndexToLine(selIndex, te);				if (selIndex < wordStart)					selIndex = (*te)->lineStarts[selLine];				else if (selIndex > wordEnd)					selIndex = (*te)->lineStarts[selLine+1];							if (selIndex < wordEnd && wordEnd < (*te)->selEnd) {					invertSelRange(wordEnd, (*te)->selEnd, te);					(*te)->selEnd = wordEnd;				}							if (selIndex > wordStart && wordStart > (*te)->selStart) {					invertSelRange((*te)->selStart, wordStart, te);					(*te)->selStart = wordStart;				}							if (selIndex < (*te)->selStart || (selIndex > (*te)->selStart && selIndex < wordStart)) {					invertSelRange(selIndex, (*te)->selStart, te);					(*te)->selStart = selIndex;				} else if (selIndex > (*te)->selEnd || (selIndex < (*te)->selEnd && selIndex > wordEnd)) {					invertSelRange((*te)->selEnd, selIndex, te);					(*te)->selEnd = selIndex;				}			}		} else if (!extend && teLength > 0L && TickCount() < (*te)->clickTime + GetDblTime() && oldClickLoc == selIndex) {			(*te)->dblClick = true;			if ((*te)->selStart != (*te)->selEnd)				invertSelRange((*te)->selStart,(*te)->selEnd,te);						selAnchor = selIndex;			textPtr = (unsigned char *) *((*te)->hText);						while (selIndex > 0L) {				ch = textPtr[selIndex-1L];								if ((ch>='a' && ch<='z') || (ch>='A' && ch<='Z') || (ch>='0' && ch<='9') ||					(ch>='' && ch<='¯') || (ch>='à' && ch<='ñ') || ch=='-')					selIndex--;				else					break;			}						if (selIndex < 0L)				(*te)->selStart =  0L;			else				(*te)->selStart = selIndex;						wordStart = (*te)->selStart;			selIndex = selAnchor;			teLength = (*te)->teLength;						while (selIndex < teLength) {				ch = textPtr[selIndex];								if ((ch>='a' && ch<='z') || (ch>='A' && ch<='Z') || (ch>='0' && ch<='9') ||					(ch>='' && ch<='¯') || (ch>='à' && ch<='ñ') || ch=='-')					selIndex++;				else					break;			}						if (selIndex > teLength)				(*te)->selEnd =  teLength;			else				(*te)->selEnd = selIndex;						wordEnd = (*te)->selEnd;						invertSelRange((*te)->selStart,(*te)->selEnd,te);						while (Button()) {				if ((*te)->clikLoop)					(*((*te)->clikLoop)) ((Handle) te);								GetMouse(&mousePt);				selPt.h = mousePt.h;				selPt.v = mousePt.v;							selIndex = TE32KGetOffset(&selPt,te);								if (selIndex < 0)					selIndex = 0;				else if (selIndex > teLength)					selIndex = teLength;								if (selIndex < wordStart)					while (selIndex > 0) {						ch = textPtr[selIndex - 1];												if ((ch>='a' && ch<='z') || (ch>='A' && ch<='Z') || (ch>='0' && ch<='9') ||							(ch>='' && ch<='¯') || (ch>='à' && ch<='ñ') || ch=='-')							selIndex--;						else							break;					}				else if (selIndex > wordEnd)					while (selIndex < teLength) {						ch = textPtr[selIndex];												if ((ch>='a' && ch<='z') || (ch>='A' && ch<='Z') || (ch>='0' && ch<='9') ||							(ch>='' && ch<='¯') || (ch>='à' && ch<='ñ') || ch=='-')							selIndex++;						else							break;					}							if (selIndex < wordEnd && wordEnd < (*te)->selEnd) {					invertSelRange(wordEnd, (*te)->selEnd, te);					(*te)->selEnd = wordEnd;				}							if (selIndex > wordStart && wordStart > (*te)->selStart) {					invertSelRange((*te)->selStart, wordStart, te);					(*te)->selStart = wordStart;				}							if (selIndex < (*te)->selStart || (selIndex > (*te)->selStart && selIndex < wordStart)) {					invertSelRange(selIndex, (*te)->selStart, te);					(*te)->selStart = selIndex;				} else if (selIndex > (*te)->selEnd || (selIndex < (*te)->selEnd && selIndex > wordEnd)) {					invertSelRange((*te)->selEnd, selIndex, te);					(*te)->selEnd = selIndex;				}			}		} else {			(*te)->dblClick = false;			if (!extend) {				if ((*te)->selStart != (*te)->selEnd)					invertSelRange((*te)->selStart,(*te)->selEnd,te);								(*te)->selStart = selIndex;				(*te)->selEnd = selIndex;									(*te)->clikStuff = false;				TE32KGetPoint(selIndex,&selPt,te);								if ((*te)->crOnly)					(*te)->selPoint = selPt;				else {					(*te)->clikStuff = true;					TE32KGetPoint(selIndex,&tempPt,te);										if ((selPt.h - startPoint.h)*(selPt.h - startPoint.h) + (selPt.v - startPoint.v)*(selPt.v - startPoint.v) <						(tempPt.h - startPoint.h)*(tempPt.h - startPoint.h) + (tempPt.v - startPoint.v)*(tempPt.v - startPoint.v))							(*te)->selPoint = selPt;					else							(*te)->selPoint = tempPt;				}								xorCaret(te);			}														if (extend || StillDown()) {				if (extend) {					if (selIndex >= (*te)->selEnd) {						selAnchor = (*te)->selStart;						selLast = (*te)->selEnd;					} else {						selAnchor = (*te)->selEnd;						selLast = (*te)->selStart;					}				} else {					selAnchor = selIndex;					selLast = selIndex;				}								GetPort(&oldPort);				SetPort((*te)->inPort);								if (extend) goto DOHILITE;								while (StillDown()) {					if (selIndex >= selAnchor) {						(*te)->selStart = selAnchor;						(*te)->selEnd = selIndex;					} else {						(*te)->selStart = selIndex;						(*te)->selEnd = selAnchor;					}										if ((*te)->clikLoop)						(*((*te)->clikLoop)) ((Handle) te);										GetMouse(&mousePt);										selPt.h = (long) mousePt.h;					selPt.v = (long) mousePt.v;										selIndex = TE32KGetOffset(&selPt,te);		DOHILITE:					if (selLast >= selAnchor) {						if (selIndex > selLast)							invertSelRange(selLast,selIndex,te);												else if (selIndex>=selAnchor && selIndex<selLast)							invertSelRange(selIndex,selLast,te);												else if (selIndex<selAnchor) {							invertSelRange(selAnchor,selLast,te);							invertSelRange(selIndex,selAnchor,te);						}					} else {						if (selIndex < selLast)							invertSelRange(selIndex,selLast,te);												else if (selIndex<=selAnchor && selIndex>selLast)							invertSelRange(selLast,selIndex,te);												else if (selIndex>selAnchor) {							invertSelRange(selLast,selAnchor,te);							invertSelRange(selAnchor,selIndex,te);						}					}										selLast = selIndex;				}								SetPort(oldPort);												if (selIndex >= selAnchor) {					(*te)->selStart = selAnchor;					(*te)->selEnd = selIndex;				} else {					(*te)->selStart = selIndex;					(*te)->selEnd = selAnchor;				}			}		}				(*te)->clickTime = TickCount();				clickedTE32KH = 0L;	}}void	TE32KSetSelect(long selStart,long selEnd, TE32KHandle te){	long temp;		if (te) {		if (selStart > selEnd) {			temp = selStart;			selStart = selEnd;			selEnd = temp;		}				// Constrain selection to bounds of text		if (selStart > (*te)->teLength)			selStart = (*te)->teLength;		if (selEnd > (*te)->teLength)			selEnd = (*te)->teLength;				// Hilite new selection		if (selStart != (*te)->selStart || selEnd != (*te)->selEnd) {			// Dehilite old selection			if ((*te)->active || TE32KFeatureFlag(te32KFOutlineHilite, TE32KBitTest, te)) {				if ((*te)->selStart != (*te)->selEnd)					invertSelRange((*te)->selStart,(*te)->selEnd,te);				else if ((*te)->caretState)					xorCaret(te);			}						// Store new selection					(*te)->selStart = selStart;			(*te)->selEnd = selEnd;						// Hilite new selection			if ((*te)->active || TE32KFeatureFlag(te32KFOutlineHilite, TE32KBitTest, te))				invertSelRange(selStart, selEnd, te);		}	}}OSErr TE32KToScrap(void){	OSErr err = noErr;	if ((TE32KScrpHandle != 0) && TE32KScrpLength > 0L) {		HLockHi(TE32KScrpHandle);		err = PutScrap (TE32KScrpLength, 'TEXT', (Ptr) *TE32KScrpHandle);		if (err)			HUnlock(TE32KScrpHandle);		return err;	}	return noScrapErr;}OSErr TE32KFromScrap(void){	long offset;	OSErr err;	if ((TE32KScrpHandle != 0) && (err = GetScrap(0L,'TEXT',&offset)) > 0L) {		TE32KScrpLength = GetScrap(TE32KScrpHandle, 'TEXT', &offset);				if (TE32KScrpLength > 0L)			return(noErr);		else if (TE32KScrpLength == 0L)			return(noTypeErr);		else			return(TE32KScrpLength);	}		if (TE32KScrpHandle == NULL)		return(noScrapErr);	else		return(err);}void TE32KCopy(TE32KHandle te){	if ((te != 0) && (TE32KScrpHandle != 0) && (*te)->selStart < (*te)->selEnd) {		SetHandleSize(TE32KScrpHandle,(*te)->selEnd - (*te)->selStart);				if (!MemError() && GetHandleSize(TE32KScrpHandle) >= ((*te)->selEnd - (*te)->selStart)) {			TE32KScrpLength = (*te)->selEnd - (*te)->selStart;						HLock(TE32KScrpHandle);			HLock((*te)->hText);			BlockMoveData(*((*te)->hText) + (*te)->selStart,*TE32KScrpHandle,TE32KScrpLength);						HUnlock((*te)->hText);			HUnlock(TE32KScrpHandle);		}	}}void	TE32KCut(TE32KHandle te){	if ((te != 0) && (TE32KScrpHandle != 0) && (*te)->selStart < (*te)->selEnd) {		TE32KCopy (te);		TE32KDelete (te);	}}void	TE32KDelete(TE32KHandle te){	LongRect			updateRect;	register long		*theLine,*otherLine,theLineStart,i,delta;	long				firstLine,lastLine;	Rect				tempRect, tempRect1;	RgnHandle			updateRgn, saveRgn;	GrafPtr				oldPort;	if ((te != 0) && ((*te)->selStart < (*te)->selEnd)) {		invertSelRange((*te)->selStart,(*te)->selEnd,te);						firstLine = TE32KIndexToLine((*te)->selStart,te);		lastLine = TE32KIndexToLine((*te)->selEnd,te);				updateRect = (*te)->viewRect;		updateRect.top = (*te)->destRect.top + (firstLine + 1L) * (*te)->lineHeight;		LongRectToRect(&updateRect,&tempRect);			//¥	try to fix erasing above text (if selection there)	Cyril, 23.07.1997			GetPort(&oldPort);		SetPort((*te)->inPort);				saveRgn = NewRgn ();		GetClip (saveRgn);		LongRectToRect (&(*te)->viewRect, &tempRect1);		ClipRect (&tempRect1);				ScrollRect(&tempRect,0,-(*te)->lineHeight * (lastLine - firstLine),updateRgn = NewRgn());		tempRect = (**updateRgn).rgnBBox;		DisposeRgn(updateRgn);		SetClip (saveRgn);		DisposeRgn (saveRgn);				SetPort(oldPort);	//¥				if ((*te)->selEnd != (*te)->teLength) {			HLock((*te)->hText);			BlockMoveData(*((*te)->hText) + (*te)->selEnd,*((*te)->hText) + (*te)->selStart,(*te)->teLength - (*te)->selEnd);			HUnlock((*te)->hText);		}				delta = (*te)->selEnd - (*te)->selStart;				theLine = &((*te)->lineStarts[firstLine + 1L]);		otherLine = &((*te)->lineStarts[lastLine + 1L]);		i = (*te)->nLines - lastLine;				while (i--) {			theLineStart = *(otherLine++);			theLineStart -= delta;			*(theLine++) = theLineStart;		}				(*te)->teLength -= delta;		(*te)->selEnd = (*te)->selStart;		(*te)->nLines -= (lastLine - firstLine);				RectToLongRect(&tempRect,&updateRect);		TE32KUpdate(&updateRect,te);	/* update scrolled stuff */				updateLine(firstLine,te,true,0L);	}}void	TE32KInsert(Ptr textPtr,register long textLength,TE32KHandle te){	register long				*theLine,*otherLine,i,numCRs;	long						firstLine,teLength,maxLineStarts,sizeTE32KHandle;	register unsigned char		*charPtr,*charBase;	RgnHandle					updateRgn, saveRgn;	Rect						tempRect;	GrafPtr						oldPort;	if ((te != 0) && (textPtr != 0) && (textLength > 0L)) {		if ((*te)->selStart < (*te)->selEnd)			invertSelRange((*te)->selStart,(*te)->selEnd,te);			firstLine = TE32KIndexToLine((*te)->selStart,te);				teLength = (*te)->teLength + textLength;				if (GetHandleSize((*te)->hText) < teLength) {			SetHandleSize((*te)->hText,teLength + EXTRATEXTBUFF);						if ((MemError() != noErr) || (GetHandleSize ((*te)->hText) < teLength + EXTRATEXTBUFF))				return;		}				HLock((*te)->hText);				if ((*te)->teLength - (*te)->selStart)			BlockMoveData(*((*te)->hText) + (*te)->selStart,*((*te)->hText) + (*te)->selStart + textLength,(*te)->teLength - (*te)->selStart);				BlockMoveData(textPtr,*((*te)->hText) + (*te)->selStart,textLength);				HUnlock((*te)->hText);				i = textLength;		numCRs = 0L;		charPtr = (unsigned char *) textPtr;				while (i--) {			if ((*charPtr == '\r') || (*charPtr == '\n'))				numCRs++;						charPtr++;		}				if (numCRs) {			sizeTE32KHandle  = GetHandleSize((Handle) te);			maxLineStarts = (sizeTE32KHandle - (long) sizeof(TE32KRec))/(long) sizeof(long) - 2;						if ((*te)->nLines + numCRs >= maxLineStarts) {				sizeTE32KHandle = (long) sizeof(TE32KRec) + (long) sizeof(long)*((*te)->nLines + numCRs + EXTRALINESTARTS);				maxLineStarts = (sizeTE32KHandle - (long) sizeof(TE32KRec))/(long) sizeof(long) - 2;								SetHandleSize((Handle) te,sizeTE32KHandle);								if (MemError())					return;			}						theLine = &((*te)->lineStarts[(*te)->nLines]);			otherLine = &((*te)->lineStarts[(*te)->nLines + numCRs]);			i = (*te)->nLines - firstLine;						while (i--)				*(otherLine--) = *(theLine--) + textLength;						charPtr = (unsigned char *) (*((*te)->hText) + (*te)->selStart) + 1L;			charBase = (unsigned char *) *((*te)->hText);			theLine = &((*te)->lineStarts[firstLine + 1L]);			i = numCRs;						while (i--) {				while (*charPtr != '\r' && *charPtr != '\n')					charPtr++;								charPtr++;								*theLine++ = charPtr - charBase;			}				//¥	try to fix shifting above text (if selection there)	Cyril, 23.07.1997				GetPort(&oldPort);			SetPort((*te)->inPort);						saveRgn = NewRgn ();			GetClip (saveRgn);			LongRectToRect(&((*te)->viewRect),&tempRect);			ClipRect (&tempRect);			tempRect.top = (*te)->destRect.top + (firstLine + 1L) * (*te)->lineHeight;						ScrollRect(&tempRect,0,(*te)->lineHeight * numCRs,updateRgn = NewRgn());			DisposeRgn(updateRgn);				SetClip (saveRgn);			DisposeRgn (saveRgn);			SetPort(oldPort);	//¥		}		else		{			theLine = &((*te)->lineStarts[firstLine + 1L]);			i = (*te)->nLines - firstLine;						while (i--)				*(theLine++) += textLength;		}						(*te)->teLength = teLength;		(*te)->selStart += textLength;		(*te)->selEnd = (*te)->selStart;		(*te)->nLines += numCRs;				do {			updateLine(firstLine,te,true,0L);						if (numCRs) {				theLine = (*te)->lineStarts;				charPtr = (unsigned char *) *((*te)->hText);								do { firstLine++; } while (firstLine < (*te)->nLines && charPtr[theLine[firstLine] - 1L] != '\r' && charPtr[theLine[firstLine] - 1L] != '\n');			}			} while (numCRs--);	}}void	TE32KPaste(TE32KHandle te){	if ((te != 0) && (TE32KScrpHandle != 0) && (TE32KScrpLength > 0L)) {		if ((*te)->selStart < (*te)->selEnd)			TE32KDelete( te);				HLock(TE32KScrpHandle);			TE32KInsert(*TE32KScrpHandle,TE32KScrpLength,te);		HUnlock(TE32KScrpHandle);	}}Handle TE32KScrapHandle(){	return(TE32KScrpHandle);}long TE32KGetScrapLen(){	return(TE32KScrpLength);}void TE32KSetScrapLen(long newLength){	TE32KScrpLength = newLength;}void TE32KSelView(TE32KHandle te){	register long	deltaV, deltaH, screenLines, lineHeight, viewTop, viewBot, selPtV, ascent;	LongPoint selPt;	if (te) {		TE32KGetPoint((*te)->selStart, &selPt, te);		selPtV = selPt.v;		viewTop = (*te)->viewRect.top;		viewBot = (*te)->viewRect.bottom;		lineHeight = (*te)->lineHeight;		ascent = (*te)->fontAscent;				deltaV = viewTop - (*te)->destRect.top;		deltaV = deltaV - (deltaV/lineHeight)*lineHeight;				if (selPtV - ascent < viewTop) {			deltaV += viewTop - (selPtV - ascent);		} else if (selPtV > viewBot) {			screenLines = (viewBot - viewTop) / lineHeight;						deltaV -= (selPtV - ascent + lineHeight) - (viewTop + screenLines * lineHeight);		}						if (selPt.h <= (*te)->viewRect.left) {			deltaH = (*te)->viewRect.left - selPt.h;			deltaH = (2L + deltaH/(*te)->lineHeight) * (*te)->lineHeight;						if ((*te)->destRect.left + deltaH > (*te)->viewRect.left)				deltaH = (*te)->viewRect.left - (*te)->destRect.left;		} else if (selPt.h > (*te)->viewRect.right) {			deltaH = selPt.h - (*te)->viewRect.right;			deltaH = -(2L + deltaH/(*te)->lineHeight) * (*te)->lineHeight;		} else deltaH = 0L;				if (deltaV || deltaH)			TE32KScroll(deltaH,deltaV,te);	}}static	void DoDeleteKey(TE32KHandle te){	Rect			tempRect;	RgnHandle		updateRgn;	short				chWidth;	long			firstLine;	register short	*theCharWidths;	register long	i,*lineStarts,selIndex,*otherLine;	LongRect		updateRect;	LongPoint		selPt;	unsigned char	ch,prevChar;	GrafPtr			oldPort;	Boolean			ColorQuotes, wasQuote = false;	short			qstart, qend;	char	back_char;								ColorQuotes = TE32KFeatureFlag(te32KFColorQuotes, TE32KBitTest, te);	if ((*te)->selStart < (*te)->selEnd)		TE32KDelete(te);	else if ((*te)->selStart > 0L) {		ch = ((unsigned char *) *((*te)->hText))[(*te)->selStart - 1L];				if ((*te)->selStart >= 2L)			prevChar = ((unsigned char *) *((*te)->hText))[(*te)->selStart - 2L];		else			prevChar = '\0';				firstLine = TE32KIndexToLine((*te)->selStart,te);				HLock((*te)->hText);		if ((*te)->lineStarts[firstLine])			back_char = ((*(*te)->hText))[(*te)->lineStarts[firstLine]-1];		else			back_char = '\r';		if (ColorQuotes)			wasQuote = (back_char == '\r') &&				hasInitials ((char *) &(((*(*te)->hText))[(*te)->lineStarts[firstLine]]), &qstart, &qend );		BlockMoveData(*((*te)->hText) + (*te)->selStart,*((*te)->hText) + (*te)->selStart - 1L,(*te)->teLength - (*te)->selEnd);		HUnlock((*te)->hText);				(*te)->teLength--;		(*te)->selStart--;		(*te)->selEnd = (*te)->selStart;				if ((ch == '\r' || ch == '\n') && ((*te)->crOnly || (*te)->teLength == (*te)->selStart || prevChar == '\r' || prevChar == '\n')) {			lineStarts = &((*te)->lineStarts[firstLine]);			otherLine = &((*te)->lineStarts[firstLine + 1L]);						i = (*te)->nLines - firstLine;						while (i--) {				selIndex = *(otherLine++);				*(lineStarts++) = --selIndex;			}						(*te)->nLines--;									if (firstLine > 0L)				firstLine--;									updateRect = (*te)->viewRect;			updateRect.top = (*te)->destRect.top + firstLine * (*te)->lineHeight;			updateRect.bottom = updateRect.top + (*te)->lineHeight;			TE32KUpdate(&updateRect,te);						LongRectToRect(&updateRect,&tempRect);			tempRect.top = tempRect.bottom;						if ((*te)->viewRect.bottom < -32768L)				tempRect.bottom = -32768;			else if ((*te)->viewRect.bottom > 32767L)				tempRect.bottom = 32767;			else				tempRect.bottom = (short) (*te)->viewRect.bottom;									GetPort(&oldPort);			SetPort((*te)->inPort);					ScrollRect(&tempRect,0,-(*te)->lineHeight,updateRgn = NewRgn());			tempRect = (**updateRgn).rgnBBox;			DisposeRgn(updateRgn);						SetPort(oldPort);						TE32KGetPoint((*te)->selStart,&selPt,te);			(*te)->selPoint = selPt;						RectToLongRect(&tempRect,&updateRect);						if ((*te)->caretState)				xorCaret(te);					TE32KUpdate(&updateRect,te);		} else {			lineStarts = &((*te)->lineStarts[(*te)->nLines]);			i = (*te)->nLines - firstLine;						if (ch == '\r' || ch == '\n')				i++;									while (i--)				(*(lineStarts--))--;						theCharWidths = (*te)->theCharWidths;						if (ch == TAB)				chWidth = (*te)->tabWidth;			else				chWidth = theCharWidths[ch];						if (ch == '\r' || ch == '\n') {				firstLine--;								updateRect.top = (*te)->destRect.top + firstLine * (*te)->lineHeight;				updateRect.bottom = updateRect.top + (*te)->lineHeight;				updateRect.left = (*te)->viewRect.left;				updateRect.right = (*te)->viewRect.right;			} else {				updateRect.top = (*te)->destRect.top + firstLine * (*te)->lineHeight;				updateRect.bottom = updateRect.top + (*te)->lineHeight;				updateRect.left = (*te)->selPoint.h - chWidth;				updateRect.right = (*te)->viewRect.right;			}						if ((*te)->caretState)				xorCaret(te);						if ((*te)->lineStarts[firstLine])				back_char = ((*(*te)->hText))[(*te)->lineStarts[firstLine]-1];			else				back_char = '\r';			if ((*te)->crOnly)				TE32KUpdate(&updateRect,te);			else				if (ColorQuotes &&					(wasQuote !=						(back_char == '\r' &&							hasInitials ((char *) &(((*(*te)->hText))[(*te)->lineStarts[firstLine]]), &qstart, &qend ))))					updateLine(firstLine,te,true,0L);				else					updateLine(firstLine,te,true,&updateRect);		}	}}static void DoArrowKeys(unsigned char ch, TE32KHandle te){	LongPoint		selPt,tempPt1,tempPt2;	long			firstLine,selIndex;	unsigned char	currentChar;	if ((*te)->caretState)		xorCaret(te);		if (!shiftKeyDown()) {		if (ch==LEFTARROW || ch==RIGHTARROW) {			if ((*te)->selStart < (*te)->selEnd)				invertSelRange((*te)->selStart,(*te)->selEnd,te);						if (ch==LEFTARROW && (*te)->selStart >= 0L) {				currentChar = ((unsigned char *) *(*te)->hText)[(*te)->selStart - 1L];								firstLine = TE32KIndexToLine((*te)->selStart,te);								(*te)->clikStuff = false;				TE32KGetPoint((*te)->selStart,&selPt,te);								if (!(*te)->crOnly && firstLine > 0 && (*te)->selStart == (*te)->lineStarts[firstLine] && currentChar != '\r'  && currentChar != '\n' && (*te)->selPoint.h == selPt.h && (*te)->selPoint.v == selPt.v) {					(*te)->clikStuff = true;					TE32KGetPoint((*te)->selStart,&selPt,te);										(*te)->selPoint = selPt;					(*te)->selEnd = (*te)->selStart;										return;				} else {					if (((*te)->selStart == (*te)->selEnd) && (*te)->selStart > 0)						(*te)->selStart--;					(*te)->selEnd = (*te)->selStart;				}			} else if (ch==RIGHTARROW && (*te)->selEnd <= (*te)->teLength) {				currentChar = ((unsigned char *) *(*te)->hText)[(*te)->selEnd];								firstLine = TE32KIndexToLine((*te)->selEnd,te);								(*te)->clikStuff = true;				TE32KGetPoint((*te)->selEnd,&selPt,te);								if (!(*te)->crOnly && firstLine > 0 && (*te)->selEnd == (*te)->lineStarts[firstLine] && (*te)->selPoint.h == selPt.h && (*te)->selPoint.v == selPt.v) {					(*te)->clikStuff = false;					TE32KGetPoint((*te)->selEnd,&selPt,te);										(*te)->selPoint = selPt;					(*te)->selStart = (*te)->selEnd;										return;				} else if (!(*te)->crOnly && firstLine < (*te)->nLines - 1L && (*te)->selStart + 1L == (*te)->lineStarts[firstLine + 1L] && currentChar != '\r' && currentChar != '\n') {					(*te)->selEnd++;										(*te)->clikStuff = true;					TE32KGetPoint((*te)->selEnd,&selPt,te);										(*te)->selPoint = selPt;					(*te)->selStart = (*te)->selEnd;										return;				} else {					if (((*te)->selStart == (*te)->selEnd) && ((*te)->selEnd < (*te)->teLength))						(*te)->selEnd++;					(*te)->selStart = (*te)->selEnd;				}			}						invertSelRange((*te)->selStart,(*te)->selEnd,te);		}				else if (ch==UPARROW || ch==DOWNARROW) {			if ((*te)->selStart < (*te)->selEnd) {				invertSelRange((*te)->selStart,(*te)->selEnd,te);								if (ch == DOWNARROW)					TE32KGetPoint((*te)->selEnd,&selPt,te);				else					TE32KGetPoint((*te)->selStart,&selPt,te);								(*te)->selPoint = selPt;			}											if (ch==UPARROW) {				selPt = (*te)->selPoint;								firstLine = TE32KIndexToLine((*te)->selStart,te);								if (firstLine > 0L) {					selPt.v -= (*te)->lineHeight;					(*te)->selStart = TE32KGetOffset(&selPt,te);					(*te)->selEnd = (*te)->selStart;					firstLine = TE32KIndexToLine((*te)->selStart,te);										if (!(*te)->crOnly && (*te)->selStart == (*te)->lineStarts[firstLine]) {						(*te)->clikStuff = false;						TE32KGetPoint((*te)->selStart,&tempPt1,te);												(*te)->clikStuff = true;						TE32KGetPoint((*te)->selStart,&tempPt2,te);												if ((selPt.h - tempPt1.h)*(selPt.h - tempPt1.h) + (selPt.v - tempPt1.v)*(selPt.v - tempPt1.v) <							(selPt.h - tempPt2.h)*(selPt.h - tempPt2.h) + (selPt.v - tempPt2.v)*(selPt.v - tempPt2.v))								(*te)->selPoint = tempPt1;						else								(*te)->selPoint = tempPt2;												return;					} else {						(*te)->clikStuff = false;						TE32KGetPoint((*te)->selStart,&selPt,te);						(*te)->selPoint = selPt;					}				}			} else if (ch == DOWNARROW) {				selPt = (*te)->selPoint;								firstLine = TE32KIndexToLine((*te)->selStart,te);								if (firstLine < (*te)->nLines) {					selPt.v += (*te)->lineHeight;					(*te)->selEnd = TE32KGetOffset(&selPt,te);					(*te)->selStart = (*te)->selEnd;					firstLine = TE32KIndexToLine((*te)->selEnd,te);										if (!(*te)->crOnly && (*te)->selStart == (*te)->lineStarts[firstLine]) {						(*te)->clikStuff = false;						TE32KGetPoint((*te)->selStart,&tempPt1,te);												(*te)->clikStuff = true;						TE32KGetPoint((*te)->selStart,&tempPt2,te);												if ((selPt.h - tempPt1.h)*(selPt.h - tempPt1.h) + (selPt.v - tempPt1.v)*(selPt.v - tempPt1.v) <							(selPt.h - tempPt2.h)*(selPt.h - tempPt2.h) + (selPt.v - tempPt2.v)*(selPt.v - tempPt2.v))								(*te)->selPoint = tempPt1;						else								(*te)->selPoint = tempPt2;												return;					} else {						(*te)->clikStuff = false;						TE32KGetPoint((*te)->selEnd,&selPt,te);						(*te)->selPoint = selPt;					}				}			}						(*te)->selEnd = (*te)->selStart;						invertSelRange((*te)->selStart,(*te)->selEnd,te);			}		}		else {		if (ch==LEFTARROW) {			if ((*te)->selStart > 0L) {				invertSelRange((*te)->selStart - 1L,(*te)->selStart,te);				(*te)->selStart--;			}		} else if (ch==RIGHTARROW) {			if ((*te)->selEnd < (*te)->teLength) {				invertSelRange((*te)->selEnd,(*te)->selEnd + 1L,te);				(*te)->selEnd++;			}		} else if (ch==UPARROW) {			firstLine = TE32KIndexToLine((*te)->selStart,te);						if (firstLine > 0L) {				TE32KGetPoint((*te)->selStart,&selPt,te);				selPt.v -= (*te)->lineHeight;				selIndex = TE32KGetOffset(&selPt,te);								invertSelRange(selIndex,(*te)->selStart,te);								(*te)->selStart = selIndex;			}		} else if (ch==DOWNARROW) {			firstLine = TE32KIndexToLine((*te)->selEnd,te);						if (firstLine < (*te)->nLines - 1L) {				TE32KGetPoint((*te)->selEnd,&selPt,te);				selPt.v += (*te)->lineHeight;				selIndex = TE32KGetOffset(&selPt,te);								invertSelRange((*te)->selEnd,selIndex,te);								(*te)->selEnd = selIndex;			}		}	}}static void DoNormalChar(unsigned char ch,TE32KHandle te){	Rect			tempRect;	RgnHandle		updateRgn;	short			chWidth,destLeftSide;	register short	*theCharWidths;	long			teLength,firstLine;	register long	i,*lineStarts,delta;	LongPoint		selPt;	unsigned char	prevChar;	GrafPtr			oldPort;	short			oldFont,oldFace,oldSize,oldMode;	Boolean			ColorQuotes, wasQuote = false, needaflush = false;	short			qstart, qend;	Rect			tttRect;	RGBColor		fgSaveColor, fgSaveColorFg;	char			back_char;	//¥	Cyril++	ColorQuotes = TE32KFeatureFlag(te32KFColorQuotes, TE32KBitTest, te);	teLength = (*te)->teLength + 1L;		if (GetHandleSize((*te)->hText) < teLength) {		SetHandleSize((*te)->hText,teLength + EXTRATEXTBUFF);				if (MemError() || GetHandleSize((*te)->hText) < teLength)			return;	}		if ((*te)->caretState)		xorCaret(te);		selPt = (*te)->selPoint;		selPt.h--;		firstLine = TE32KIndexToLine((*te)->selStart,te);		if ((*te)->selStart > 0)	{		if (TE32KIndexToLine((*te)->selStart - 1,te) != firstLine)		{		//	Debugger ();			needaflush = true;		}	}		if ((*te)->selStart > 0L)		prevChar = ((unsigned char *) *(*te)->hText)[(*te)->lineStarts[firstLine] - 1L];	else		prevChar = '\r';		if (	(*te)->crOnly ||			prevChar =='\r' ||			prevChar =='\n' ||			!(ch == ' ' && (*te)->selStart == (*te)->lineStarts[firstLine]))	{		if (selPt.h < -32768L)			tempRect.left = -32768;		else if (selPt.h > 32767L)			tempRect.left = 32767;		else			tempRect.left = (short) selPt.h;				if ((*te)->viewRect.right < -32768L)			tempRect.right = -32768;		else if ((*te)->viewRect.right > 32767L)			tempRect.right = 32767;		else			tempRect.right = (short) (*te)->viewRect.right;				selPt.v -= (*te)->fontAscent;				if (selPt.v < -32768L)			tempRect.top = -32768;		else if (selPt.v > 32767L)			tempRect.top = 32767;		else			tempRect.top = (short) selPt.v;				tempRect.bottom = tempRect.top + (*te)->lineHeight;				GetPort(&oldPort);		SetPort((*te)->inPort);				oldFont = ((*te)->inPort)->txFont;		oldFace = ((*te)->inPort)->txFace;		oldSize = ((*te)->inPort)->txSize;		oldMode = ((*te)->inPort)->txMode;				TextFont((*te)->txFont);		TextFace((*te)->txFace);		TextSize((*te)->txSize);		TextMode((*te)->txMode);				theCharWidths = (*te)->theCharWidths;				if (ch == TAB) {			destLeftSide = (*te)->destRect.left + 1L;			delta = (*te)->tabWidth;			chWidth = (destLeftSide + ((tempRect.left + 1 - destLeftSide + delta)/delta)*delta) - (tempRect.left + 1);		} else chWidth = theCharWidths[ch];				if (tempRect.left < tempRect.right) {//¥		try avoid wide symbol corruption			tempRect.left++;			if ((*te)->lineStarts[firstLine])				back_char = ((*(*te)->hText))[(*te)->lineStarts[firstLine]-1];			else				back_char = '\r';			if (ColorQuotes &&				(wasQuote = ((back_char == '\r') &&					hasInitials ((char *) &(((*(*te)->hText))[(*te)->lineStarts[firstLine]]), &qstart, &qend ))))			{				GetBackColor(&fgSaveColor);				GetForeColor(&fgSaveColorFg);				if ((quotingnest ((char *) &(((*(*te)->hText))[(*te)->lineStarts[firstLine]]), qstart, qend) & 1) == 1)				{					RGBBackColor(&quoteGray);					RGBForeColor(&quoteGrayFg);				}				else				{					RGBBackColor(&quote1Gray);					RGBForeColor(&quote1GrayFg);				}				ScrollRect(&tempRect,chWidth,0,updateRgn = NewRgn());				RGBForeColor(&fgSaveColorFg);				RGBBackColor(&fgSaveColor);			}			else				ScrollRect(&tempRect,chWidth,0,updateRgn = NewRgn());			tempRect.left--;//¥						if (tempRect.left+1 + chWidth > tempRect.right)				ClipRect(&tempRect);						MoveTo(tempRect.left+1,tempRect.top + (*te)->fontAscent);			if (ch != TAB)				DrawChar(ch);						if (tempRect.left+1 + chWidth > tempRect.right) {				tempRect.left = -32768;				tempRect.top = -32768;				tempRect.right = 32767;				tempRect.bottom = 32767;				ClipRect(&tempRect);			}						DisposeRgn(updateRgn);		}				TextFont(oldFont);		TextFace(oldFace);		TextSize(oldSize);		TextMode(oldMode);				SetPort(oldPort);	}		HLock((*te)->hText);	BlockMoveData(*((*te)->hText) + (*te)->selStart,*((*te)->hText) + (*te)->selStart + 1L,(*te)->teLength - (*te)->selStart);	HUnlock((*te)->hText);		((unsigned char *) *((*te)->hText))[(*te)->selStart] = ch;		lineStarts = &((*te)->lineStarts[(*te)->nLines]);	i = (*te)->nLines - firstLine;		if (!(*te)->crOnly && prevChar != '\r'  && prevChar != '\n' && ch == ' ' && (*te)->selStart == (*te)->lineStarts[firstLine])		i++;		while (i--)		(*(lineStarts--))++;			(*te)->teLength++;	(*te)->selStart++;	(*te)->selEnd = (*te)->selStart;	(*te)->selPoint.h += (long) chWidth;	if ((*te)->lineStarts[firstLine])		back_char = ((*(*te)->hText))[(*te)->lineStarts[firstLine]-1];	else		back_char = '\r';	if (needaflush ||		(ColorQuotes &&			(wasQuote !=				(back_char == '\r' &&					hasInitials ((char *) &(((*(*te)->hText))[(*te)->lineStarts[firstLine]]), &qstart, &qend )))))	{		updateLine(firstLine,te,true,0L);				if (needaflush && firstLine != 0)			updateLine(firstLine-1,te,true,0L);	}	else		if (!(*te)->crOnly)			updateLine(firstLine,te,false,0L);		xorCaret(te);}static void DoReturnChar(TE32KHandle te){	Rect			tempRect;	RgnHandle		updateRgn;	long			teLength,firstLine,lastLine,deltaLines,numAffected,tempFirstLine;	register long	i,*lineStarts,selIndex,*otherLine;	LongPoint		selPt;	LongRect		updateRect;	unsigned char	prevChar,doWrap;	GrafPtr			oldPort;	Rect			tempRect1;	RgnHandle		saveRgn;	teLength = GetHandleSize((Handle) te);	lastLine  = (teLength - (long) sizeof(TE32KRec))/(long) sizeof(long) - 2;		if ((*te)->nLines + 1L >= lastLine) {		teLength = (long) sizeof(TE32KRec) + (long) sizeof(long)*((*te)->nLines + 1L + EXTRALINESTARTS);				SetHandleSize((Handle) te,teLength);				if (MemError()  || GetHandleSize((Handle) te) < teLength)			return;	}			teLength = (*te)->teLength + 1L;		if (GetHandleSize((*te)->hText) < teLength) {		SetHandleSize((*te)->hText,teLength + EXTRATEXTBUFF);				if (MemError() || GetHandleSize((*te)->hText) < teLength)			return;	}				if ((*te)->selStart > 0L)		prevChar = ((unsigned char *) *((*te)->hText))[(*te)->selStart - 1L];	else		prevChar = '\r';		if ((*te)->caretState)		xorCaret(te);		HLock((*te)->hText);	BlockMoveData(*((*te)->hText) + (*te)->selStart,*((*te)->hText) + (*te)->selStart + 1L,(*te)->teLength - (*te)->selStart);	HUnlock((*te)->hText);		((unsigned char *) *((*te)->hText))[(*te)->selStart] = RETURN;		firstLine = TE32KIndexToLine((*te)->selStart,te);		lineStarts = &((*te)->lineStarts[(*te)->nLines]);	otherLine = &((*te)->lineStarts[(*te)->nLines + 1L]);	i = (*te)->nLines - firstLine;			while (i--) {		selIndex = *(lineStarts--);		*(otherLine--) = ++selIndex;	}		(*te)->lineStarts[firstLine + 1L] = (*te)->selStart + 1L;		(*te)->nLines++;	(*te)->teLength++;	(*te)->selStart++;	(*te)->selEnd = (*te)->selStart;		LongRectToRect(&((*te)->viewRect),&tempRect);		selPt = (*te)->selPoint;	selPt.v -= (*te)->fontAscent;	selPt.v += (*te)->lineHeight;		if (selPt.v < -32768L)		tempRect.top = -32768;	else if (selPt.v > 32767L)		tempRect.top = 32767;	else		tempRect.top = (short) selPt.v;	//¥	try to fix shifting above text (if selection there)	Cyril, 10.08.1997	GetPort(&oldPort);	SetPort((*te)->inPort);	saveRgn = NewRgn ();	GetClip (saveRgn);	LongRectToRect (&(*te)->viewRect, &tempRect1);	ClipRect (&tempRect1);		ScrollRect(&tempRect, 0, (*te)->lineHeight, updateRgn = NewRgn());	DisposeRgn(updateRgn);	SetClip (saveRgn);	DisposeRgn (saveRgn);	SetPort(oldPort);//¥		if (!(*te)->crOnly) {		doWrap = false;		tempFirstLine = firstLine;				if (tempFirstLine > 0L && LineEndIndex(tempFirstLine - 1L,te) != (*te)->lineStarts[tempFirstLine]) {			doWrap = true;			tempFirstLine--;		} else if (LineEndIndex(tempFirstLine,te) != (*te)->lineStarts[tempFirstLine + 1L])			doWrap = true;						if (doWrap) {			CalParagraph(tempFirstLine,te,&deltaLines,&numAffected);						if (deltaLines == 0L) {				updateRect = (*te)->viewRect;				updateRect.top = (*te)->destRect.top + tempFirstLine * (*te)->lineHeight;				updateRect.bottom = updateRect.top + (*te)->lineHeight * numAffected;			} else if (deltaLines > 0L) {				firstLine += deltaLines;								LongRectToRect(&((*te)->viewRect),&tempRect);				tempRect.top = (*te)->destRect.top + (tempFirstLine + numAffected - deltaLines) * (*te)->lineHeight;								GetPort(&oldPort);				SetPort((*te)->inPort);								ScrollRect(&tempRect,0,(*te)->lineHeight * deltaLines,updateRgn = NewRgn());				DisposeRgn(updateRgn);								SetPort(oldPort);								updateRect = (*te)->viewRect;				updateRect.top = (*te)->destRect.top + tempFirstLine * (*te)->lineHeight;				updateRect.bottom = updateRect.top + (*te)->lineHeight * numAffected;			} else {				firstLine += deltaLines;								LongRectToRect(&((*te)->viewRect),&tempRect);				tempRect.top = (*te)->destRect.top + (tempFirstLine - 1L + numAffected) * (*te)->lineHeight;								GetPort(&oldPort);				SetPort((*te)->inPort);					updateRgn = NewRgn();				ScrollRect(&tempRect,0,(*te)->lineHeight * deltaLines,updateRgn);				DisposeRgn(updateRgn);								SetPort(oldPort);								updateRect = (*te)->viewRect;				updateRect.top = (*te)->destRect.top + tempFirstLine * (*te)->lineHeight;				updateRect.bottom = updateRect.top + (*te)->lineHeight * numAffected;			}						TE32KUpdate(&updateRect,te);		}						firstLine++;				CalParagraph(firstLine,te,&deltaLines,&numAffected);				if (deltaLines > 0L) {			LongRectToRect(&((*te)->viewRect),&tempRect);			tempRect.top = (*te)->destRect.top + (firstLine + numAffected - deltaLines) * (*te)->lineHeight;						GetPort(&oldPort);			SetPort((*te)->inPort);				ScrollRect(&tempRect,0,(*te)->lineHeight * deltaLines,updateRgn = NewRgn());			DisposeRgn(updateRgn);						SetPort(oldPort);		} else if (deltaLines < 0L) {			LongRectToRect(&((*te)->viewRect),&tempRect);			tempRect.top = (*te)->destRect.top + (firstLine - 1L + numAffected) * (*te)->lineHeight;						GetPort(&oldPort);			SetPort((*te)->inPort);				updateRgn = NewRgn();			ScrollRect(&tempRect,0,(*te)->lineHeight * deltaLines,updateRgn);			DisposeRgn(updateRgn);						SetPort(oldPort);		}				updateRect = (*te)->viewRect;		updateRect.top = (*te)->destRect.top + (firstLine - 1L) * (*te)->lineHeight;		updateRect.bottom = updateRect.top + (*te)->lineHeight * (numAffected + 1L);				if ((*te)->caretState)			xorCaret(te);				TE32KUpdate(&updateRect,te);				TE32KGetPoint((*te)->selStart,&selPt,te);		(*te)->selPoint = selPt;	} else {		updateRect = (*te)->viewRect;		TE32KGetPoint((*te)->selStart,&selPt,te);		(*te)->selPoint = selPt;				if ((*te)->nLines - firstLine >= 2L && (*te)->lineStarts[firstLine+1L]+1L < (*te)->lineStarts[firstLine + 2L]) {			updateRect.top = (*te)->destRect.top + firstLine * (*te)->lineHeight;			updateRect.bottom = updateRect.top + (*te)->lineHeight + (*te)->lineHeight;			TE32KUpdate(&updateRect,te);		} else {			TE32KGetPoint((*te)->selStart,&selPt,te);			(*te)->selPoint = selPt;			xorCaret(te);		}	}}static	void OverTypeSelection(unsigned char ch,TE32KHandle te){	TE32KDelete(te);		if (ch==RETURN)		DoReturnChar(te);	else if (ch==TAB || ch >= (unsigned char) 0x20)		DoNormalChar(ch,te);}void TE32KKey(unsigned char ch, TE32KHandle te){	if ((te != 0) && (*te)->active) {		ObscureCursor();				if (ch == ENTER)			ch = RETURN;				if (ch == DELETE)			DoDeleteKey(te);					else if (ch==LEFTARROW || ch==RIGHTARROW || ch==UPARROW || ch==DOWNARROW)			DoArrowKeys(ch,te);				else if ((*te)->selStart < (*te)->selEnd && (ch >= 0x20 || ch==TAB || ch==RETURN))			OverTypeSelection(ch,te);				else if (ch==TAB || ch >= (unsigned char) 0x20)			DoNormalChar(ch,te);				else if (ch==RETURN)			DoReturnChar(te);				if ((*te)->selStart == (*te)->selEnd && !(*te)->caretState)			xorCaret(te);					TE32KSelView(te);	}}static long paraLines(long firstLine, TE32KHandle te){	long					lastLine, nLines;	register unsigned char	*charBase;	register long			*lineStarts;	if ((*te)->crOnly)		return(1L);		lastLine = firstLine + 1L;	nLines = (*te)->nLines;	charBase = (unsigned char *) *((*te)->hText);	lineStarts = &((*te)->lineStarts[lastLine]);		while (lastLine < nLines && charBase[*lineStarts - 1L] != '\r' && charBase[*lineStarts - 1L] != '\n') {		lastLine++;		lineStarts++;	}		return(lastLine - firstLine);}static long	LineEndIndex(long firstLine, TE32KHandle te){	register unsigned char	*charPtr;	register long			charCount;	register short			*theCharWidths,crOnly,maxLineWidth,lineWidth;	register unsigned char	ch;	unsigned char			*charBase;	Point					cursorPt;	short						rightSide,destLeftSide,tabWidth;	short						lineStatus;	unsigned char			*oldCharPtr;	long					maxRewind;		if ((*te)->crOnly)		return((*te)->lineStarts[firstLine + 1L]);		maxLineWidth = (*te)->maxLineWidth;	crOnly = (*te)->crOnly;		charBase = (unsigned char *) *((*te)->hText);	charPtr = charBase + (*te)->lineStarts[firstLine];	charCount = (*te)->teLength - (*te)->lineStarts[firstLine];		if (charCount > (*te)->teLength)		charCount = (*te)->teLength;		lineStatus = 0;	lineWidth = 0;		if (charCount) {		rightSide = (short) ((*te)->destRect.right);		destLeftSide = (short) ((*te)->destRect.left + 1L);		cursorPt.h = destLeftSide;		tabWidth = (long) (*te)->tabWidth;				theCharWidths = (*te)->theCharWidths;				ch = ' ';				while (charCount-- && ch != '\r' && ch != '\n') {			ch = *charPtr++;			lineWidth++;						if (ch == TAB)				cursorPt.h = destLeftSide + ((cursorPt.h - destLeftSide + tabWidth)/tabWidth)*tabWidth;			else if (ch != '\r' && ch != '\n')				cursorPt.h += theCharWidths[ch];						if ((cursorPt.h >= rightSide && ch != ' ') || (!crOnly && lineWidth > maxLineWidth)) {				maxRewind = charPtr - charBase - (*te)->lineStarts[firstLine];				oldCharPtr = charPtr;								charPtr--;				maxRewind--;								while (*charPtr != ' ' && maxRewind > 0) {					charPtr--;					maxRewind--;				}								if (maxRewind <= 0)					charPtr = oldCharPtr;								else					charPtr++;								charCount = 0;			}		}	}		return(charPtr - charBase);}#define	NUMTEMPLINES	32static void	CalParagraph(long firstLine, TE32KHandle te, long *theDeltaLines, long *theNumAffected){	register unsigned char	*charPtr;	register short			*theCharWidths;	register long			charCount,*lineStarts,*otherLine,i;	register long			crOnly,lineWidth,maxLineWidth;	register unsigned char	ch;	register long			nLines;	long					maxLineStarts,sizeTE32KHandle,oldCharCount;	unsigned char			*charBase;	Point					cursorPt;	short						rightSide,destLeftSide,tabWidth,maxRewind;	unsigned char			*oldCharPtr;	long					tempLineStarts[NUMTEMPLINES],oldNumLines,deltaLines;		if ((*te)->crOnly) {		*theDeltaLines = 0L;		*theNumAffected = 0L;		return;	}		deltaLines = 0L;		oldNumLines = paraLines(firstLine,te);		for (i=0;i<oldNumLines && i <NUMTEMPLINES;i++)		tempLineStarts[i] = (*te)->lineStarts[firstLine + i];			sizeTE32KHandle  = GetHandleSize((Handle) te);	maxLineStarts = (sizeTE32KHandle - (long) sizeof(TE32KRec))/(long) sizeof(long) - 2;		nLines = 0;	tempLineStarts[nLines] = (*te)->lineStarts[firstLine];		crOnly = (*te)->crOnly;	maxLineWidth = (*te)->maxLineWidth;	lineWidth = 0;		charBase = (unsigned char *) *((*te)->hText);	charPtr = charBase + (*te)->lineStarts[firstLine];		charCount = (*te)->teLength - (*te)->lineStarts[firstLine];	ch = *charPtr;		if (charCount > 0L) {		rightSide = (short) ((*te)->destRect.right);		destLeftSide = (short) ((*te)->destRect.left + 1L);		cursorPt.h = destLeftSide;		tabWidth = (long) (*te)->tabWidth;				theCharWidths = (*te)->theCharWidths;				ch = ' ';				while (ch != '\r' && ch != '\n' && charCount--) {			ch = *charPtr++;			lineWidth++;						if (ch != '\r' && ch != '\n') {				if (ch == TAB)					cursorPt.h = destLeftSide + ((cursorPt.h - destLeftSide + tabWidth)/tabWidth)*tabWidth;				else					cursorPt.h += theCharWidths[ch];								if ((cursorPt.h >= rightSide && ch != ' ') || (!crOnly && lineWidth > maxLineWidth)) {					maxRewind = charPtr - charBase - tempLineStarts[nLines];					oldCharPtr = charPtr;					oldCharCount = charCount;										charPtr--;					charCount++;					maxRewind--;										while (*charPtr != ' ' && maxRewind > 0) {						charPtr--;						charCount++;						maxRewind--;					}										if (maxRewind <= 0) {						charPtr = oldCharPtr;						charCount = oldCharCount;					} else {						charPtr++;						charCount--;					}										nLines++;										if (nLines < NUMTEMPLINES) {						if (tempLineStarts[nLines] == charPtr - charBase) {							oldNumLines = nLines;							goto STOPWRAPPING;						} else tempLineStarts[nLines] = charPtr - charBase;					} else goto STOPWRAPPING;										cursorPt.h = destLeftSide;					lineWidth = 0;				}			}		}				nLines++;				if (nLines < NUMTEMPLINES)			tempLineStarts[nLines] = charPtr - charBase;STOPWRAPPING:		deltaLines = nLines - oldNumLines;		if (nLines >= NUMTEMPLINES) {			TE32KCalText(te);			deltaLines = (*te)->nLines - firstLine - oldNumLines;		} else {			if (deltaLines == 0L) {				for (i = 1;i <= nLines;i++)					(*te)->lineStarts[firstLine + i] = tempLineStarts[i];			} else if (deltaLines < 0L) {				lineStarts = &((*te)->lineStarts[firstLine + 1L]);								for (i = 1;i <= nLines;i++)					*(lineStarts++) = tempLineStarts[i];								otherLine = &((*te)->lineStarts[firstLine + oldNumLines + 1L]);				i = (*te)->nLines - firstLine - oldNumLines + 1L;								while (i--)					*(lineStarts++) = *(otherLine++);								(*te)->nLines += deltaLines;			} else {				if ((*te)->nLines + deltaLines >= maxLineStarts) {					sizeTE32KHandle = (long) sizeof(TE32KRec) + (long) sizeof(long)*((*te)->nLines + deltaLines + EXTRALINESTARTS);					maxLineStarts = (sizeTE32KHandle - (long) sizeof(TE32KRec))/(long) sizeof(long) - 2;										SetHandleSize((Handle) te,sizeTE32KHandle);										if (MemError()) {						nLines = (*te)->nLines;						deltaLines = (*te)->nLines;						goto EXITPOINT;					}				}								lineStarts = &((*te)->lineStarts[(*te)->nLines]);				otherLine = &((*te)->lineStarts[(*te)->nLines + deltaLines]);				i = (*te)->nLines - firstLine - oldNumLines;								while (i--)					*(otherLine--) = *(lineStarts--);									for (i = nLines;i >= 0;i--)					*(otherLine--) = tempLineStarts[i];								(*te)->nLines += deltaLines;			}		}	}	EXITPOINT:	*theNumAffected = nLines;	*theDeltaLines = deltaLines;}static void updateLine(register long firstLine, TE32KHandle te,short doFirst, LongRect *updateClipRect){	Rect			tempRect;	RgnHandle		updateRgn;	LongRect		updateRect;	LongPoint		selPt;	unsigned char	doWrap;	long			deltaLines,numAffected;	GrafPtr			oldPort;	updateRect = (*te)->viewRect;	updateRect.top = (*te)->destRect.top + firstLine * (*te)->lineHeight;	updateRect.bottom = updateRect.top + (*te)->lineHeight;		if (updateClipRect) {		if (updateRect.top < updateClipRect->top)			updateRect.top = updateClipRect->top;		if (updateRect.bottom > updateClipRect->bottom)			updateRect.bottom = updateClipRect->bottom;		if (updateRect.left < updateClipRect->left)			updateRect.left = updateClipRect->left;		if (updateRect.right > updateClipRect->right)			updateRect.right = updateClipRect->right;	}		doWrap = false;		if (firstLine > 0L && LineEndIndex(firstLine - 1L,te) != (*te)->lineStarts[firstLine]) {		doWrap = true;		firstLine--;	} else if (LineEndIndex(firstLine,te) != (*te)->lineStarts[firstLine + 1L])		doWrap = true;			if (!doWrap && doFirst)		TE32KUpdate(&updateRect,te);		else if (doWrap) {		CalParagraph(firstLine,te,&deltaLines,&numAffected);				if (deltaLines == 0L) {			updateRect = (*te)->viewRect;			updateRect.top = (*te)->destRect.top + firstLine * (*te)->lineHeight;			updateRect.bottom = updateRect.top + (*te)->lineHeight * numAffected;		} else if (deltaLines > 0L) {			LongRectToRect(&((*te)->viewRect),&tempRect);			tempRect.top = (*te)->destRect.top + (firstLine + numAffected - deltaLines) * (*te)->lineHeight;						GetPort(&oldPort);			SetPort((*te)->inPort);				ScrollRect(&tempRect,0,(*te)->lineHeight * deltaLines,updateRgn = NewRgn());			DisposeRgn(updateRgn);						SetPort(oldPort);						updateRect = (*te)->viewRect;			updateRect.top = (*te)->destRect.top + firstLine * (*te)->lineHeight;			updateRect.bottom = updateRect.top + (*te)->lineHeight * numAffected;		} else {			LongRectToRect(&((*te)->viewRect),&tempRect);			tempRect.top = (*te)->destRect.top + (firstLine - 1L + numAffected) * (*te)->lineHeight;						GetPort(&oldPort);			SetPort((*te)->inPort);				ScrollRect(&tempRect,0,(*te)->lineHeight * deltaLines,updateRgn = NewRgn());						SetPort(oldPort);						updateRect.left = (**updateRgn).rgnBBox.left;			updateRect.top = (**updateRgn).rgnBBox.top;			updateRect.right = (**updateRgn).rgnBBox.right;			updateRect.bottom = (**updateRgn).rgnBBox.bottom;						DisposeRgn(updateRgn);						TE32KUpdate(&updateRect,te);						updateRect = (*te)->viewRect;			updateRect.top = (*te)->destRect.top + firstLine * (*te)->lineHeight;			updateRect.bottom = updateRect.top + (*te)->lineHeight * numAffected;		}				TE32KUpdate(&updateRect, te);	}	TE32KGetPoint((*te)->selStart,&selPt,te);	(*te)->selPoint = selPt;}static short shiftKeyDown(){	KeyMap	theKeyMap;	GetKeys(theKeyMap);		if (theKeyMap[1] & 0x01)		return(true);	else		return(false);}static void MyClickLoop(void){	short		lineHeight;	Rect		viewRect;	Point		mousePoint;	RgnHandle	saveClip;	long		hDelta,vDelta;	if (clickedTE32KH) {		LongRectToRect(&((**clickedTE32KH).viewRect), &viewRect);		lineHeight = (**clickedTE32KH).lineHeight;			hDelta = 0;		vDelta = 0;				GetMouse(&mousePoint);		if (!PtInRect(mousePoint, &viewRect)) {			if (mousePoint.v > viewRect.bottom && (**clickedTE32KH).viewRect.bottom < (**clickedTE32KH).destRect.top + (long) lineHeight * (**clickedTE32KH).nLines)				vDelta = (mousePoint.v - viewRect.bottom) / lineHeight;			else if (mousePoint.v < viewRect.top && (**clickedTE32KH).viewRect.top > (**clickedTE32KH).destRect.top)				vDelta = (mousePoint.v - viewRect.top) / lineHeight;									if (mousePoint.h > viewRect.right && (**clickedTE32KH).viewRect.right < (**clickedTE32KH).destRect.right)				hDelta = -lineHeight;			else if (mousePoint.h<viewRect.left && (**clickedTE32KH).viewRect.left > (**clickedTE32KH).destRect.left)				hDelta = lineHeight;		}				if (hDelta || vDelta) {			GetClip(saveClip = NewRgn());			viewRect = (*((**clickedTE32KH).inPort)).portRect;			ClipRect(&viewRect);						TE32KScroll(hDelta, vDelta, clickedTE32KH);						SetClip(saveClip);			DisposeRgn(saveClip);		}	}}void TE32KAutoView(char autoView, TE32KHandle te){#pragma unused (autoView, te)/*	if (te) {		if (!autoView) (*te)->clikLoop = nil;		else (*te)->clikLoop = (TE32KProcPtr) MyClickLoop;	}*/}short TE32KFeatureFlag(short feature, short action, TE32KHandle te){	switch (action) {		case TE32KBitClear:			(*te)->featureFlags &= ~(1 << feature);			break;		case TE32KBitSet:			(*te)->featureFlags |= (1 << feature);			break;		case TE32KBitTest:			return ((*te)->featureFlags >> feature) & 1;	}	return (0);}void TE32KSetClickLoop(TE32KProcPtr clickProc, TE32KHandle te){	(*te)->clikLoop = clickProc;}void TE32KCopyToScrap(TE32KHandle te){	long scrpLength;		if ((te != 0) && ((*te)->selStart < (*te)->selEnd)) {		scrpLength = (*te)->selEnd - (*te)->selStart;				HLock((*te)->hText);		ZeroScrap ();				(void) PutScrap(scrpLength, 'TEXT', *((*te)->hText) + (*te)->selStart);		HUnlock((*te)->hText);	}}void TE32KCutToScrap(TE32KHandle te){	if ((te != 0) && ((*te)->selStart < (*te)->selEnd)) {		TE32KCopyToScrap(te);		TE32KDelete(te);	}}void TE32KPasteFromScrap(TE32KHandle te){	Handle scrpHandle;	long scrpLength, offset;		if (te) {		scrpHandle = NewHandle(0);		if (!MemError()) {			scrpLength = GetScrap(scrpHandle, 'TEXT', &offset);			if (scrpLength > 0) {				if ((*te)->selStart < (*te)->selEnd)					TE32KDelete(te);								HLock(scrpHandle);					TE32KInsert(*scrpHandle, scrpLength, te);				HUnlock(scrpHandle);			}			DisposeHandle(scrpHandle);		}	}}