#include <Sound.h>#include <stdio.h>#include <string.h>#include "TE32K.h"#include "DialogLib.h"#include "PopUpLib.h"#include "myTEdit.h"/*본본본본본본본본본본본본본본본본본본본본본본본본본본본본본본본본본본본본본본*///#include "Ravel_FTN.h"#include "ravel_msg_base.h"#include "Ravel_Prefs.h"#include "Preferences.h"#include "nodelist.h"#include "pktparse.h"#include "stringutl.h"#include "CommonData.h"#include "WindowsList.h"#include "WAddressee.h"#include "WNodes.h"#include "Templates.h"/*본본본본본본본본본본본본본본본본본본본본본본본본본본본본본본본본본본본본본본*/#include "rMenus.h"/*본본본본본본본본본본본본본본본본본본본본본본본본본본본본본본본본본본본본본본*/extern	short	viewFont;static	Rect	originalView = {0,0,0,0};typedef struct _wloc {	Point	topleft;	short	bottom;	} wloc;typedef struct _oneRecord {	addr	address;	Str63	name;	} oneRec, *oneRecPtr;pascal void LDEFAddressee (short lMessage, Boolean lSelect, Rect *lRect, Cell lCell,				short lDataOffset, short lDataLen, ListHandle lHandle);pascal void LDEFAddressee (short lMessage, Boolean lSelect, Rect *lRect, Cell lCell,				short lDataOffset, short lDataLen, ListHandle lHandle){	short 		leftDraw, topDraw, k, locked;		short		oldSize, oldFont;	FontInfo 	fi;	long		i, j;	pktmsg		*m;	Point		drawpt;	char		tmp[128];	unsigned char	oldMode;	PenState	penState;	oneRec		*curAddr;		if ((lMessage == lInitMsg) || (lMessage == lCloseMsg))		return ;		leftDraw = lRect->left+(*lHandle)->indent.h;	topDraw = lRect->top+(*lHandle)->indent.v;		switch (lMessage)	{	case lDrawMsg:			SetPort ((*lHandle)->port);			if (lDataLen == 4)		{			oldFont = ((*lHandle)->port)->txFont;			oldSize = ((*lHandle)->port)->txSize;						TextFont (viewFont);			TextSize (viewSize);						GetFontInfo (&fi);			SetPt ( &drawpt, leftDraw, topDraw+fi.leading+fi.ascent );			memcpy ( (Ptr) &curAddr, *((*lHandle)->cells)+lDataOffset, 4 );						EraseRect (lRect);			MoveTo ( drawpt.h + 2, drawpt.v );			DrawText (&curAddr->name[1], 0, curAddr->name[0]);			MoveTo ( drawpt.h + 220, drawpt.v );			printaddr (&curAddr->address, tmp);			DrawText (tmp, 0, strlen (tmp));			TextFont (oldFont);			TextSize (oldSize);		}		else			EraseRect (lRect);		if (!lSelect)			break;	case lHiliteMsg:			oldMode = LMGetHiliteMode();		LMSetHiliteMode(1);		if (((WindowPeek)(*lHandle)->port)->hilited)			InvertRect (lRect);		else		{			GetPenState (&penState);			PenMode (srcXor);			FrameRect (lRect);			SetPenState (&penState);		}		LMSetHiliteMode(oldMode);				break;	}}void WAddresseeEventProcessor (EventRecord *event, windowsQElPtr dialogInfo, long info){	DialogPtr	dialog;	ListHandle	list;	RGBColor	color, color1;	LongRect	tlRect;	short		iType, ii, dummy, neww, newh, newc, menuItem, oldTE;	Handle		iHandle;	Rect		iRect, rView, rDataBnds;	Point		cellSize, theCell;	Point		where;			long		lSizeVH, nm, jj;		Str255		stemp, stemp1;		char		key;		MenuHandle	hMenu;		WindowPtr	window;	FontInfo	fi;	windowsQElPtr	dInfo;	commonDataPtr	pcommon;	GrafPtr			oldPort;	PScrapStuff		pScrpInf;	oneRecPtr	padRec;	addr		tempaddr;	BroadcastRec	bc;	register void (*EventProcessor) (EventRecord *event, struct _window *dialogInfo, long info);	switch (info & 0xFFFF)	{	case actionSetSize:				originalView.left = ((wloc *) event)->topleft.h;		originalView.top = ((wloc *) event)->topleft.v;		originalView.bottom = ((wloc *) event)->bottom;				break;		case actionGetSize:				((wloc *) event)->topleft.h = originalView.left;		((wloc *) event)->topleft.v = originalView.top;		((wloc *) event)->bottom = originalView.bottom;				break;		case actionCreate:		if (dInfo = windowsOpened (wtAddressee, 0, 0))		{			SelectWindow (dInfo->dialog);			break;		}				dialog = FrontWindow ();		if (!dialog)			iRect = (*LMGetGrayRgn ())->rgnBBox;		else			iRect = (*(((WindowPeek)dialog)->contRgn))->rgnBBox;				dialog = GetNewDialog (134, NULL, (WindowPtr) -1);		((WindowPeek)dialog)->windowKind = myKind_top;				SetPort ( dialog );		if (!originalView.bottom)		{			originalView.left = iRect.right / 2 -				(dialog->portRect.right - dialog->portRect.left) / 2;			originalView.top = iRect.bottom / 2 -				(dialog->portRect.bottom - dialog->portRect.top) / 2;					originalView.bottom = 1;		}				MoveWindow (dialog, originalView.left, originalView.top, false);		ShowWindow ( dialog );		pcommon = (commonDataPtr) NewPtrClear (sizeof (commonAddressee));				pcommon->cAddressee.dialog = dialog;				TextFont (viewFont);		TextSize (viewSize);		TextFont (viewFont);		TextSize (viewSize);		GetFontInfo (&fi);		GetDialogItem ( dialog, 4, &iType, &iHandle, &iRect );		iRect.bottom = iRect.top + fi.ascent + fi.descent;		SetDialogItem ( dialog, 4, iType, iHandle, &iRect );		pcommon->cAddressee.addr[0] = littleTENew (dialog, 4, false, true);		(*pcommon->cAddressee.addr[0])->txFont = viewFont;		(*pcommon->cAddressee.addr[0])->txSize = viewSize;		GetDialogItem ( dialog, 5, &iType, &iHandle, &iRect );		iRect.bottom = iRect.top + fi.ascent + fi.descent;		SetDialogItem ( dialog, 5, iType, iHandle, &iRect );		pcommon->cAddressee.addr[1] = littleTENew (dialog, 5, false, false);		(*pcommon->cAddressee.addr[1])->txFont = viewFont;		(*pcommon->cAddressee.addr[1])->txSize = viewSize;		GetDialogItem ( dialog, 3, &iType, &iHandle, &rView );		SetRect ( &rDataBnds, 0, 0, 1, 0 );		rView.right -= 15;		SetPt ( &cellSize, 0, 0 );		list = LNew (						&rView,						&rDataBnds,						cellSize,						132,						dialog,						true,						false,						false,						true					);		(*list)->selFlags = 0x82;		(*list)->port->txFont = viewFont;		(*list)->port->txSize = viewSize;		LActivate ( true, list );		LSetDrawingMode ( false, list );		if (event == NULL)		{			LAddRow (1, 0, list);			SetPt (&theCell, 0, 0);			LSetCell (&dialogInfo, sizeof (oneRecPtr), theCell, list);		}		else		{			short	padref;			long	recs, counter;						GetDialogItem (dialog, 1, &iType, &iHandle, &iRect);			SetControlTitle ((ControlHandle) iHandle, "\pSave");						pcommon->cAddressee.parrent = (Ptr) dialogInfo;						if (FSOpen (padname, 0, &padref) == fnfErr)			{				Create (padname, 0, 'RvlQ', 'NPad');				FSOpen (padname, 0, &padref);			}					GetEOF (padref, &recs);						recs /= sizeof (oneRec);					for (jj = 0; jj < recs; jj++)			{				padRec = (oneRecPtr) NewPtr (counter = sizeof (oneRec));								FSRead (padref, &counter, padRec);							dummy = LAddRow (1, 0x7FFF, list);				SetPt (&theCell, 0, dummy);				LSetCell (&padRec, sizeof (oneRecPtr), theCell, list);			}						FSClose (padref);		}		LSetDrawingMode ( true, list );				pcommon->cAddressee.list = list;		pcommon->cAddressee.TE = 0;		pcommon->cAddressee.mode = (long) event;				TE32KSetText ("", 0, pcommon->cAddressee.addr[0]);		TE32KSetText ("", 0, pcommon->cAddressee.addr[1]);		TextFont (0);		TextSize (0);				windowsAdd (dialog, wtAddressee, pcommon, WAddresseeEventProcessor, WAddresseeDialogProcessor);				dInfo = windowsLookUp (dialog);				SetWRefCon (dialog, (long) dInfo);		dInfo->inFront = true;		WAddresseeEventProcessor (NULL, dInfo, ((long) inMenuBar << 16) | mouseDown);		break;	case actionClose:		TE32KDispose ((dialogInfo->common)->cAddressee.addr[0]);		TE32KDispose ((dialogInfo->common)->cAddressee.addr[1]);				LSetDrawingMode ( false, (dialogInfo->common)->cAddressee.list );		for (ii=0; ii<(*(dialogInfo->common)->cAddressee.list)->dataBounds.bottom; ii++)		{			SetPt (&theCell, 0, 0);						dummy = 4;			LGetCell (&padRec, &dummy, theCell, (dialogInfo->common)->cAddressee.list);			LDelRow (1, theCell.v, (dialogInfo->common)->cAddressee.list);			DisposePtr ((Ptr) padRec);		}				LDispose ((dialogInfo->common)->cAddressee.list);				DisposePtr ((Ptr) dialogInfo->common);				DisposeDialog (dialogInfo->dialog);		windowsKill (dialogInfo->dialog);		break;			case actionActive:		break;	case actionBroadcast:		GetPort (&oldPort);		SetPort (dialogInfo->dialog);		switch (((BroadcastRecPtr) event)->synctype)		{		case broadClose:					WAddresseeEventProcessor (NULL, dialogInfo, actionClose);			break;		case broadGlobalResync:			tempaddr.zone = ((BroadcastRecPtr) event)->area >> 16;			tempaddr.net = ((BroadcastRecPtr) event)->area & 0xFFFF;			tempaddr.node = ((BroadcastRecPtr) event)->message >> 16;			tempaddr.point = ((BroadcastRecPtr) event)->message & 0xFFFF;			printaddr ( &tempaddr, (char *) &stemp1[1] );			stemp1[0] = strlen ((char *) &stemp1[1]);						if ( GetNameFromAddr ( &tempaddr, stemp ) )			{				RectToLongRect (&(dialogInfo->dialog)->portRect, &tlRect);				GetBackColor (&color1);				color.red = color.green = color.blue = 0xFFFF;				RGBBackColor(&color);				TE32KSetText ((char *) &stemp[1], stemp[0], (dialogInfo->common)->cAddressee.addr[0]);				TE32KUpdate (&tlRect, (dialogInfo->common)->cAddressee.addr[0]);								TE32KSetText ((char *) &stemp1[1], stemp1[0], (dialogInfo->common)->cAddressee.addr[1]);				TE32KUpdate (&tlRect, (dialogInfo->common)->cAddressee.addr[1]);				//				color.red = color.green = color.blue = 50000;				RGBBackColor(&color1);			}			break;		}			SetPort (oldPort);		break;		case actionMenu:		SetPort (dialogInfo->dialog);		menuItem = (info >> 16) & 0xFF;				switch ((info >> 24) & 0xFF)		{		case editM:					GetBackColor (&color1);			color.red = color.green = color.blue = 0xFFFF;			RGBBackColor(&color);			switch (menuItem)			{			case iCut:								TE32KCutToScrap ((dialogInfo->common)->cAddressee.addr[(dialogInfo->common)->cAddressee.TE]);				break;			case iCopy:								TE32KCopyToScrap ((dialogInfo->common)->cAddressee.addr[(dialogInfo->common)->cAddressee.TE]);				break;			case iPaste:								TE32KPasteFromScrap ((dialogInfo->common)->cAddressee.addr[(dialogInfo->common)->cAddressee.TE]);				break;			case iClear:								TE32KDelete ((dialogInfo->common)->cAddressee.addr[(dialogInfo->common)->cAddressee.TE]);				break;			}//			color.red = color.green = color.blue = 50000;			RGBBackColor(&color1);			break;				case msgM:					switch (menuItem)			{			case mSend:								if ((*(dialogInfo->common)->cAddressee.list)->dataBounds.bottom == 0)				{					SysBeep (10);					break;				}				iHandle = NewHandle ((*(dialogInfo->common)->cAddressee.list)->dataBounds.bottom * sizeof (oneRec));				HLock (iHandle);										for (ii=0; ii<(*(dialogInfo->common)->cAddressee.list)->dataBounds.bottom; ii++)				{					SetPt (&theCell, 0, ii);										dummy = 4;					LGetCell (&padRec, &dummy, theCell, (dialogInfo->common)->cAddressee.list);										((oneRecPtr)(*iHandle))[ii] = *padRec;				}				Broadcast (wtMsgEdit, editSendto, 0, (long) iHandle);				WAddresseeEventProcessor (event, dialogInfo, actionClose);				DisposeHandle (iHandle);				break;			}						break;				case nodeM:			switch (menuItem)			{			case nBrowse:								WNodeEventProcessor ((EventRecord *) 2L, (windowsQElPtr) &(*homesystem)->mainAddr.ad, actionCreate);				Broadcast (wtNodelist, broadGlobalResync, broadGlobalResync, (long) dialogInfo);				break;							default:							{					notePtr		tempNote = notepad;									menuItem -= nFirstCustom;										ii = 0;					while ( ii != menuItem )					{						tempNote = tempNote->next_note;						ii++;					}					printaddr (&tempNote->pad_address, (char *)&stemp1[1]);					stemp1[0] = strlen ((char *)&stemp1[1]);										GetBackColor (&color1);					color.red = color.green = color.blue = 0xFFFF;					RGBBackColor(&color);					RectToLongRect (&(dialogInfo->dialog)->portRect, &tlRect);					TE32KSetText ((char *) &stemp1[1], stemp1[0], (dialogInfo->common)->cAddressee.addr[1]);					TE32KUpdate (&tlRect, (dialogInfo->common)->cAddressee.addr[1]);										TE32KSetText ((char *) &tempNote->pad_name[1], tempNote->pad_name[0], (dialogInfo->common)->cAddressee.addr[0]);					TE32KUpdate (&tlRect, (dialogInfo->common)->cAddressee.addr[0]);//					color.red = color.green = color.blue = 50000;					RGBBackColor(&color1);				}							break;			}		}				break;		case actionOpen:			break;		case mouseDown:		if ((info >> 16) != inMenuBar)			where = event->where;		switch (info >> 16)		{		case inMenuBar:					recalcWindowMenu ();			hMenu = GetMenuHandle (fileM + 256);			(*hMenu)->enableFlags = 1L | (1L << fClose) | (1L << fQuit);						hMenu = GetMenuHandle (editM + 256);			(*hMenu)->enableFlags = 1L;			if ((*(dialogInfo->common)->cAddressee.addr[(dialogInfo->common)->cAddressee.TE])->selStart !=				(*(dialogInfo->common)->cAddressee.addr[(dialogInfo->common)->cAddressee.TE])->selEnd)				(*hMenu)->enableFlags |= (1L << iCopy) | (1L << iCut) | (1L << iClear);						pScrpInf = InfoScrap ();			if (pScrpInf->scrapSize != 0 && pScrpInf->scrapSize < MName)				(*hMenu)->enableFlags |= (1L << iPaste);			hMenu = GetMenuHandle (msgM + 256);			if (!(dialogInfo->common)->cAddressee.mode)				(*hMenu)->enableFlags = 1L | (1L << mSend);			else				(*hMenu)->enableFlags = 0L;			hMenu = GetMenuHandle (nodeM + 256);			(*hMenu)->enableFlags = 1L | (-1L << nFirstCustom);						if (yep ())				(*hMenu)->enableFlags |= (1L << nBrowse);			hMenu = GetMenuHandle (shuffleM + 256);			(*hMenu)->enableFlags = 0;			hMenu = GetMenuHandle (windowM + 256);			(*hMenu)->enableFlags = 0;			DrawMenuBar ();			break;		case inContent:					FindWindow (event->where, &window);						if (window != FrontWindow ())			{				if (((WindowPeek)FrontWindow ())->windowKind == myKind_top)					SysBeep (10);				else					SelectWindow (window);			}			else			{				SetPort (dialogInfo->dialog);				GlobalToLocal (&where);				GetDialogItem (dialogInfo->dialog, 3, &iType, &iHandle, &iRect);				if (PtInRect (where, &iRect))				{					if (LClick (where, event->modifiers, (dialogInfo->common)->cAddressee.list))					{						if ((dialogInfo->common)->cAddressee.mode && (dialogInfo->common)->cAddressee.parrent)						{							SetPt (&theCell, 0, 0);													if ( LGetSelect (true, &theCell, (dialogInfo->common)->cAddressee.list) )							{								dummy = 4;								LGetCell (&padRec, &dummy, theCell, (dialogInfo->common)->cAddressee.list);								EventProcessor = ((windowsQElPtr) (dialogInfo->common)->cAddressee.parrent)->EventProcessor;								bc.synctype = broadGlobalSync;								bc.area = (long) padRec;								bc.message = 0;								EventProcessor ((EventRecord *) &bc,									(windowsQElPtr) (dialogInfo->common)->cAddressee.parrent,											actionBroadcast);							}						}					}				}				else				{					oldTE = (dialogInfo->common)->cAddressee.TE;					(dialogInfo->common)->cAddressee.TE = -1;					GetDialogItem (dialogInfo->dialog, 4, &iType, &iHandle, &iRect);					if (PtInRect (where, &iRect))						(dialogInfo->common)->cAddressee.TE = 0;					else					{						GetDialogItem (dialogInfo->dialog, 5, &iType, &iHandle, &iRect);						if (PtInRect (where, &iRect))							(dialogInfo->common)->cAddressee.TE = 1;					}										if ((dialogInfo->common)->cAddressee.TE == -1)					{						(dialogInfo->common)->cAddressee.TE = oldTE;						break;					}										if (oldTE != (dialogInfo->common)->cAddressee.TE)					{						TE32KDeactivate ((dialogInfo->common)->cAddressee.addr[oldTE]);						TE32KActivate ((dialogInfo->common)->cAddressee.addr[(dialogInfo->common)->cAddressee.TE]);					}					else					{						GetBackColor (&color1);						color.red = color.green = color.blue = 0xFFFF;						RGBBackColor(&color);						TE32KClick (where, (event->modifiers & shiftKey) != 0, (dialogInfo->common)->cAddressee.addr[oldTE]);//						color.red = color.green = color.blue = 50000;						RGBBackColor(&color1);					}				}/*								GetDialogItem (dialogInfo->dialog, 4, &iType, &iHandle, &iRect);								if (PtInRect (where, &iRect))				{					color.red = color.green = color.blue = 0xFFFF;					RGBBackColor(&color);					TE32KClick (where, (event->modifiers & shiftKey) != 0, (dialogInfo->common)->cAddressee.te);					color.red = color.green = color.blue = 50000;					RGBBackColor(&color);				}*/			}			break;		case inDrag:			FindWindow (event->where, &window);						if (window != FrontWindow ())			{				if (((WindowPeek)FrontWindow ())->windowKind == myKind_top)					SysBeep (10);				else					SelectWindow (window);			}			else			{				DragWindow ( dialogInfo->dialog, event->where, &qd.screenBits.bounds );				originalView = (*(((WindowPeek)(dialogInfo->dialog))->contRgn))->rgnBBox;			}						break;		case inGoAway:					if (TrackGoAway (dialogInfo->dialog, event->where))			{				WAddresseeEventProcessor (event, dialogInfo, actionClose);			}						break;		}			break;		case keyDown:	case autoKey:				SetPort (dialogInfo->dialog);		key = event->message & 0xFF;				switch (key)		{		case 0x1B:			WAddresseeEventProcessor (event, dialogInfo, actionClose);			break;						case EnterKey:		case ReturnKey:			WAddresseeEventProcessor (event, dialogInfo, actionClose);			break;				case TabKey:					TE32KDeactivate ((dialogInfo->common)->cAddressee.addr[(dialogInfo->common)->cAddressee.TE]);			TE32KActivate ((dialogInfo->common)->cAddressee.addr[1 - (dialogInfo->common)->cAddressee.TE]);			(dialogInfo->common)->cAddressee.TE = 1 - (dialogInfo->common)->cAddressee.TE;			break;				case DeleteFwdKey:						GetBackColor (&color1);			color.red = color.green = color.blue = 0xFFFF;			RGBBackColor(&color);			myTEDel ((dialogInfo->common)->cAddressee.addr[(dialogInfo->common)->cAddressee.TE]);//			color.red = color.green = color.blue = 50000;			RGBBackColor(&color1);			break;		default:					if (key < 0x20 && key > 0)				break;					case RightArrowKey:		//	Right		case LeftArrowKey:		//	Left		case BackSpaceKey:					GetBackColor (&color1);			color.red = color.green = color.blue = 0xFFFF;			RGBBackColor(&color);			TE32KKey (key, (dialogInfo->common)->cAddressee.addr[(dialogInfo->common)->cAddressee.TE]);//			color.red = color.green = color.blue = 50000;			RGBBackColor(&color1);						break;		}		break;			case updateEvt:		SetPort (dialogInfo->dialog);				BeginUpdate (dialogInfo->dialog);		DrawDialog (dialogInfo->dialog);		EndUpdate (dialogInfo->dialog);		GetBackColor (&color1);		color.red = color.green = color.blue = 0xFFFF;		RGBBackColor(&color);				GetDialogItem (dialogInfo->dialog, 4, &iType, &iHandle, &iRect);		EraseRect (&iRect);		RectToLongRect (&iRect, &tlRect);		InsetRect (&iRect, -2, -2);		FrameRect (&iRect);		TE32KUpdate (&tlRect, (dialogInfo->common)->cAddressee.addr[0]);		GetDialogItem (dialogInfo->dialog, 5, &iType, &iHandle, &iRect);		EraseRect (&iRect);		RectToLongRect (&iRect, &tlRect);		InsetRect (&iRect, -2, -2);		FrameRect (&iRect);		TE32KUpdate (&tlRect, (dialogInfo->common)->cAddressee.addr[1]);//		color.red = color.green = color.blue = 50000;		RGBBackColor(&color1);		LUpdate ( (dialogInfo->dialog)->visRgn, (dialogInfo->common)->cAddressee.list );		DefaultButton (dialogInfo->dialog, 1);		GetDialogItem ( dialogInfo->dialog, 3, &iType, &iHandle, &iRect );		InsetRect (&iRect, -1, -1);		FrameRect (&iRect);		break;	case nullEvent:				GetPort (&oldPort);		SetPort (dialogInfo->dialog);				TE32KIdle ((dialogInfo->common)->cAddressee.addr[(dialogInfo->common)->cAddressee.TE]);		break;	}}void WAddresseeDialogProcessor (EventRecord *event, windowsQElPtr dialogInfo, long info){	DialogPtr	dialog;	short		iHit, dummy;	Point		where, theCell;	short		iType, ii;	Handle		iHandle;	Rect		iRect;	addr		tempaddr;	char		tmp[128];	oneRecPtr	padRec;	if (IsDialogEvent (event))	{		if (DialogSelect (event, &dialog, &iHit))		{			switch (iHit)			{			case 1:								if ((dialogInfo->common)->cAddressee.mode)				{					short	padref;					long	recs, counter, jj;					if (FSOpen (padname, 0, &padref) == fnfErr)					{						Create (padname, 0, 'RvlQ', 'NPad');						FSOpen (padname, 0, &padref);					}									SetFPos (padref, fsFromStart, 0L);										recs = (*(dialogInfo->common)->cAddressee.list)->dataBounds.bottom;									for (jj = 0; jj < recs; jj++)					{						SetPt (&theCell, 0, jj);						dummy = 4;						LGetCell (&padRec, &dummy, theCell, (dialogInfo->common)->cAddressee.list);											counter = sizeof (oneRec);						FSWrite (padref, &counter, padRec);					}										SetEOF (padref, recs * sizeof (oneRec));										FSClose (padref);					WAddresseeEventProcessor (event, dialogInfo, actionClose);				}				else				{					if ((*(dialogInfo->common)->cAddressee.list)->dataBounds.bottom == 0)					{						SysBeep (10);						event->what = 0;						break;					}										iHandle = NewHandle ((*(dialogInfo->common)->cAddressee.list)->dataBounds.bottom * sizeof (oneRec));					HLock (iHandle);												for (ii=0; ii<(*(dialogInfo->common)->cAddressee.list)->dataBounds.bottom; ii++)					{						SetPt (&theCell, 0, ii);												dummy = 4;						LGetCell (&padRec, &dummy, theCell, (dialogInfo->common)->cAddressee.list);												((oneRecPtr)(*iHandle))[ii] = *padRec;					}					Broadcast (wtMsgEdit, editSendto, 0, (long) iHandle);					WAddresseeEventProcessor (event, dialogInfo, actionClose);					DisposeHandle (iHandle);				}								event->what = 0;				break;							case 2:							WAddresseeEventProcessor (event, dialogInfo, actionClose);				event->what = 0;				break;							case 6:							if (!(*(dialogInfo->common)->cAddressee.addr[0])->teLength ||					(*(dialogInfo->common)->cAddressee.addr[0])->teLength >= MName)				{					SysBeep (10);					event->what = 0;					break;				}								if (!(*(dialogInfo->common)->cAddressee.addr[1])->teLength ||					(*(dialogInfo->common)->cAddressee.addr[1])->teLength >= 64)				{					SysBeep (10);					event->what = 0;					break;				}				tempaddr.zone = -1;				tempaddr.net = -1;				tempaddr.node = -1;				tempaddr.point = 0;								memcpy (tmp, *(*(dialogInfo->common)->cAddressee.addr[1])->hText,					(*(dialogInfo->common)->cAddressee.addr[1])->teLength);				tmp[(*(dialogInfo->common)->cAddressee.addr[1])->teLength] = 0;								parseaddr (&tempaddr, tmp);								if (tempaddr.zone == -1 ||					tempaddr.net == -1 ||					tempaddr.node == -1)				{					SysBeep (10);					event->what = 0;					break;				}				padRec = (oneRecPtr) NewPtrClear (sizeof (oneRec));								memcpy (&padRec->name[1], *(*(dialogInfo->common)->cAddressee.addr[0])->hText,					(*(dialogInfo->common)->cAddressee.addr[0])->teLength);				padRec->name[0] = (*(dialogInfo->common)->cAddressee.addr[0])->teLength;				padRec->address = tempaddr;								dummy = LAddRow (1, 0x7FFF, (dialogInfo->common)->cAddressee.list);				SetPt (&theCell, 0, dummy);				LSetCell (&padRec, sizeof (oneRecPtr), theCell, (dialogInfo->common)->cAddressee.list);								event->what = 0;				break;			case 7:							SetPt (&theCell, 0, 0);							if ( LGetSelect (true, &theCell, (dialogInfo->common)->cAddressee.list) )				{					dummy = 4;					LGetCell (&padRec, &dummy, theCell, (dialogInfo->common)->cAddressee.list);					LDelRow (1, theCell.v, (dialogInfo->common)->cAddressee.list);					DisposePtr ((Ptr) padRec);				}								event->what = 0;				break;			}		}	}}