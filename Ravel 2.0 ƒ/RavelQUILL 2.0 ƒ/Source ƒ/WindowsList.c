#include "TE32K.h"#include "PopUpLib.h"#include "myTEdit.h"//#include "Ravel_FTN.h"#include "ravel_msg_base.h"#include "Ravel_Prefs.h"#include "Preferences.h"//#include "BaseManager.h"#include "CommonData.h"#include "WindowsList.h"#include "rMenus.h"QHdr	windowsList;long getFrontWindowType(long *areanumber){	long			result = -1;	WindowPtr		window;	windowsQElPtr	dialogInfo;		if (windowsLookUp(window = FrontWindow ()) && (dialogInfo = (windowsQElPtr) GetWRefCon (window)))	{		result = dialogInfo->dialogType;		switch (result)		{		case wtNodelist:		case wtAreasSelect:		case wtAreasList:					*areanumber = -1;			break;					case wtMsgView:					*areanumber = (dialogInfo->common)->cMsgView.area_number;			break;				case wtMsgEdit:					*areanumber = (dialogInfo->common)->cMsgEdit.area_number;			break;					case wtSubjects:			*areanumber = (dialogInfo->common)->cSubjList.area_number;			break;		}	}	return result;}long sendCommandToWindow (long windowType, long areanumber, WinComPtr WCP){	windowsQElPtr	wQ = windowsOpened (windowType, areanumber, -1);	long			result = -1;	register void	(*EventProcessor) (EventRecord *event, struct _window *dialogInfo, long info);	BroadcastRec	bc;		if (wQ)	{		EventProcessor = wQ->EventProcessor;		if (EventProcessor)		{			bc.synctype = WCP->command;			bc.area = areanumber;			bc.message = 0;			bc.param[0] = (long)WCP;			EventProcessor ((EventRecord *) &bc, wQ, actionBroadcast);			result = WCP->result;		}	}		return result;}/*windowsQElPtr windowsLookUp(DialogPtr dialog){	WindowPtr win = GetDialogWindow(dialog);	return windowsLookUp(win);}*/windowsQElPtr windowsLookUp (DialogPtr dialog){	windowsQElPtr	wQ;			if (!dialog)		return NULL;		wQ = (windowsQElPtr) windowsList.qHead;	while (wQ)	{		if (wQ->dialog == dialog)			break;			wQ = wQ->qLink;	}		return wQ;}windowsQElPtr windowsOpened (long dialogtype, long area_number, long message_number){	windowsQElPtr	wQ;		wQ = (windowsQElPtr) windowsList.qHead;	while (wQ)	{		if (wQ->dialogType == dialogtype)			switch (wQ->dialogType)			{			case wtAreasList:							return wQ;							case wtMsgView:							if ((wQ->common)->cMsgView.area_number == area_number &&						(message_number == -1 ||						(wQ->common)->cMsgView.message_number == message_number))					return wQ;				break;						case wtMsgEdit:							if ((wQ->common)->cMsgEdit.area_number == area_number)					return wQ;				break;							case wtSubjects:				if ((wQ->common)->cSubjList.area_number == area_number)					return wQ;				break;			case wtNodelist:							return wQ;			case wtAreasSelect:							return wQ;			}			wQ = wQ->qLink;	}		return NULL;}void windowsInit (void){	windowsList.qFlags = 0;	windowsList.qHead = NULL;	windowsList.qTail = NULL;}void windowsAdd (DialogPtr dialog, long dialogType, commonDataPtr common,		void (*EventProcessor) (EventRecord *event, struct _window *dialogInfo, long info),		void (*DialogProcessor) (EventRecord *event, struct _window *dialogInfo, long info)){	windowsQElPtr	dialogInfo;		dialogInfo = (windowsQElPtr) NewPtrClear (sizeof (windowsQEl));		dialogInfo->dialog = dialog;	dialogInfo->dialogType = dialogType;	dialogInfo->common = common;	dialogInfo->EventProcessor = EventProcessor;	dialogInfo->DialogProcessor = DialogProcessor;	Enqueue ((QElemPtr) dialogInfo, &windowsList);}void windowsKill (DialogPtr dialog){	windowsQElPtr	wQ = windowsLookUp (dialog);	if (wQ)	{		Dequeue ((QElemPtr) wQ, &windowsList);		DisposePtr ((Ptr) wQ);	}}void recalcWindowMenu (void){	windowsQElPtr	wQ;	long			i, j;	MenuHandle		hMenu;	Str255			stemp;	WindowPtr		front = FrontWindow ();	Boolean			need;	short			passed;		hMenu = GetMenuHandle (windowM + 256);	i = CountMenuItems (hMenu);		for (j = i; j > wAreas; j--)		DeleteMenuItem (hMenu,j);	SetItemMark (hMenu, wAreas, noMark);	wQ = windowsLookUp (front);	if (wQ == windowsOpened (wtAreasList, 0, 0))	{		SetItemMark (hMenu, wAreas, checkMark);	}	wQ = (windowsQElPtr) windowsList.qHead;	i = 0;		while (wQ)	{		if (wQ->dialogType != wtAreasList)			i++;		wQ = wQ->qLink;	}		if (i)	{		passed = 1;				for (i = wtMsgView; i <= wtNodelist && passed < 32; i++)		{			need = true;			wQ = (windowsQElPtr) windowsList.qHead;			while (wQ)			{				if (wQ->dialogType == i)				{					if (need)					{						AppendMenu (hMenu, "\p(-");						need = false;					}										GetWTitle (wQ->dialog, stemp);					AppendMenu (hMenu, stemp);										if (front == wQ->dialog)						SetItemMark (hMenu, CountMenuItems (hMenu), checkMark);									if (passed < 10)						SetItemCmd (hMenu, CountMenuItems (hMenu), 0x30 + passed);					passed++;										if (passed > 31)						break;				}							wQ = wQ->qLink;			}		}	}}void selectWindow (short item){	windowsQElPtr	wQ;	long			i;	MenuHandle		hMenu;	WindowPtr		front = FrontWindow ();	Boolean			need;	short			passed;	Str255			stemp;		hMenu = GetMenuHandle (windowM + 256);	item -= wFirstCustom - 1;	passed = 0;	for (i = wtMsgView; i <= wtNodelist && passed < 32; i++)	{		need = true;		wQ = (windowsQElPtr) windowsList.qHead;		while (wQ)		{			if (wQ->dialogType == i)			{				if (need)				{					passed++;					need = false;				}								if (item == passed)				{					SelectWindow (wQ->dialog);					break;				}				passed++;			}					wQ = wQ->qLink;		}		if (wQ && item == passed)		{			SelectWindow (wQ->dialog);			break;		}	}}void Broadcast (long todialog, long synctype, long area, long message){	Boolean			doo;	windowsQElPtr	wQ;	BroadcastRec	bc;	register void (*EventProcessor) (EventRecord *event, struct _window *dialogInfo, long info);		if (synctype == actionClose)	{		doo = false;		do {					wQ = (windowsQElPtr) windowsList.qHead;			while (wQ)			{				if (wQ->dialogType == todialog)				{					EventProcessor = wQ->EventProcessor;					if (EventProcessor)					{						bc.synctype = actionClose;						bc.area = area;						bc.message = message;						EventProcessor ((EventRecord *) &bc, wQ, actionBroadcast);						doo = true;												break;					}				}							doo = false;				wQ = wQ->qLink;			}				} while (doo);	}	else	{		wQ = (windowsQElPtr) windowsList.qHead;		while (wQ)		{			if (wQ->dialogType == todialog)			{				EventProcessor = wQ->EventProcessor;				if (EventProcessor)				{					bc.synctype = synctype;					bc.area = area;					bc.message = message;					EventProcessor ((EventRecord *) &bc, wQ, actionBroadcast);				}			}					wQ = wQ->qLink;		}	}}Boolean SuchWindow (long dialogtype){	windowsQElPtr	wQ;	wQ = (windowsQElPtr) windowsList.qHead;	while (wQ)	{		if (wQ->dialogType == dialogtype)			return true;			wQ = wQ->qLink;	}	return false;}