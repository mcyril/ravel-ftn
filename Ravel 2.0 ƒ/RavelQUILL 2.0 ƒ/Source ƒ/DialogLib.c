// #include <QDOffscreen.h>// #include <Packages.h>#include <Palettes.h>// #include <GestaltEqu.h>#include <stdarg.h>#include <Icons.h>#include "DialogLib.h"enum {	MBarHeightAddr = 0x0BAA,	ChunkyDepth = 0x0D60};#define DepthScreen	*(short *)(ChunkyDepth)#define stepH		16#define stepV		16#define zoomSteps	15Boolean EffectsOn = true;/* Draw 3d-rectangle with depth "depth" points */void Frame3DRect (Rect *myRect, short depth, Boolean state){	short 		j;	PenState 	oldstate;	long 		bwgray1, bwgray2;	Rect		r;	GrafPtr 	currPort;	GetPort (&currPort);	r = *myRect;	InsetRect (&r, -1, -1);	GetPenState (&oldstate);	PenNormal ();	if (HasColorPort (currPort)) {		if (state) {			bwgray1 = whiteColor;			bwgray2 = blackColor;		} else {			bwgray1 = blackColor;			bwgray2 = whiteColor;		}		for (j = 0; j < depth; j++) {			InsetRect (&r, 1, 1); 			MoveTo (r.right-1, r.top+1);			ForeColor (bwgray1);			LineTo (r.right-1, r.bottom-2);			MoveTo (r.right-2, r.bottom-1);			LineTo (r.left, r.bottom-1);			ForeColor (bwgray2);			LineTo (r.left, r.top);			LineTo (r.right-2, r.top);		}	} else {		ForeColor (blackColor);		FrameRect (&r);	}	SetPenState (&oldstate);	ForeColor (blackColor);}/* Draw 3d color rectangle */void FrameColorRect (Rect *myRect){	Rect		r;	GrafPtr 	currPort;	GetPort (&currPort);	r = *myRect;	ForeColor (blackColor);	if (HasColorPort (currPort)) {		MoveTo (r.right-1, r.top);		LineTo (r.right-1, r.bottom-1);		LineTo (r.left, r.bottom-1);		MoveTo (r.left+1, r.bottom-1);		LineTo (r.left+1, r.top+1);		LineTo (r.right-2, r.top+1);		ForeColor (whiteColor);		MoveTo (r.right-2, r.top+1);		LineTo (r.right-2, r.bottom-2);		LineTo (r.left+1, r.bottom-2);		MoveTo (r.left, r.bottom-2);		LineTo (r.left, r.top);		LineTo (r.right-2, r.top);	} else		FrameRect (&r);	ForeColor (blackColor);}/* Activate/deactivate item */void ActivateItem (DialogPtr theDialog, short theID, Boolean state){	Rect 		itemRect;	PenState	oldPenState;	GetItemRect  (theDialog, theID, &itemRect);	GetPenState (&oldPenState);	PenSize (2, 2);	InsetRect (&itemRect, -4, -4);	if (state) 		PenMode (patCopy);	else 		PenMode (patBic);	FrameRect (&itemRect);	SetPenState (&oldPenState);}void BoxString (DialogPtr theDialog, short theID, Str255 itemName, Str255 dot3){	Rect	textbox;	short	textlen;	Str255	temp;	GetItemRect (theDialog, theID, &textbox);	BlockMove ((Ptr) itemName, (Ptr) temp, itemName[0]+1);	textlen = textbox.right-textbox.left;	EraseRect (&textbox);	MoveTo (textbox.left, textbox.bottom-4);	if (StringWidth (temp) > textlen) {		while ((StringWidth (temp)+StringWidth (dot3) > textlen) && temp[0])			temp[0] -= 1;		DrawString (temp);		DrawString (dot3);	} else		DrawString (temp);}void BoxText (DialogPtr theDialog, short theID, Str255 theStr, short theJust){	Rect	theBox;	GetItemRect (theDialog, theID, &theBox);	EraseRect (&theBox);	TETextBox (&theStr[1], (long)theStr[0], &theBox, theJust);}void ClickCheck (DialogPtr theDialog, short theItem){	short	checkValue;	Rect		theBox;	short	theType;	Handle	theHandle;		GetDialogItem (theDialog, theItem, &theType, &theHandle, &theBox);	checkValue = GetControlValue ((ControlHandle)theHandle);	SetControlValue ((ControlHandle)theHandle, 1-checkValue);}void DefaultButton (DialogPtr theDialog, short theID){	Rect		theBox;	PenState	oldPenState;//	SetDialogDefaultItem(theDialog, theID);	GetPenState(&oldPenState);	GetItemRect (theDialog, theID, &theBox);	InsetRect (&theBox, -4, -4);	PenSize (3, 3);	FrameRoundRect (&theBox, 16, 16);	SetPenState (&oldPenState);}void Default1Button (DialogPtr	theDialog, short theID){//	Rect		theBox;	SetDialogDefaultItem(theDialog, theID);//	GetItemRect (theDialog, theID, &theBox);//	InsetRect (&theBox, -1, -1);//	FrameRect (&theBox);}pascal void Draw2HDLines (DialogPtr theDialog, short theID){	Rect	theBox;	GetItemRect (theDialog, theID, &theBox);	MoveTo(theBox.left, theBox.top);	LineTo(theBox.right, theBox.top);	MoveTo(theBox.left, theBox.bottom);	LineTo(theBox.right, theBox.bottom);}pascal void DrawDBox (DialogPtr theDialog, short theID){	Rect	theBox;	GetItemRect (theDialog, theID, &theBox);	FrameRect (&theBox);}void DrawDIcon (DialogPtr theDialog, short IconID, short theItem){	Rect	theBox;	GetItemRect (theDialog, theItem, &theBox);	PlotIcon (&theBox, GetIcon (IconID));}pascal void DrawDShadow (DialogPtr theDialog, short theID){	Rect	theBox;	GetItemRect (theDialog, theID,  &theBox);	FrameRectShadow (&theBox);}pascal void DrawHDLine (DialogPtr theDialog, short theID){	Rect	theBox;	GetItemRect (theDialog, theID, &theBox);	MoveTo (theBox.left, theBox.top);	LineTo (theBox.right, theBox.top);}pascal void DrawVDLine (DialogPtr theDialog, short theID){	Rect	theBox;	GetItemRect (theDialog, theID, &theBox);	MoveTo(theBox.left, theBox.top);	LineTo(theBox.left, theBox.bottom);}void FrameRectShadow (Rect *theBox){	FrameRect (theBox);	MoveTo(theBox->right, theBox->top + 2);	LineTo(theBox->right, theBox->bottom);	LineTo(theBox->left + 2, theBox->bottom);}/*RGBColor *GetGrayColor (short index) {	CTabHandle 	grayCTable;	if (index) 		index += 244;	grayCTable = GetCTable (8);	return (&(*grayCTable)->ctTable[index].rgb);}*/void FrameOutline (Rect *itemRect){	Frame3DRect (itemRect, 1, true);}void DrawColorLine (Rect *itemRect){//	PenState 	oldstate;//	Pattern		myGray1, myGray2;//	Boolean		color;	Boolean hor;//	RGBColor	oldfore, oldback;		EraseRect (itemRect);	ForeColor (blackColor);	hor = (itemRect->right-itemRect->left > itemRect->bottom-itemRect->top);	if (hor) {		MoveTo (itemRect->left, itemRect->top);		LineTo (itemRect->right-1, itemRect->top);	} else {		MoveTo (itemRect->left, itemRect->top);		LineTo (itemRect->left, itemRect->bottom);	}	ForeColor (whiteColor);	if (hor) {		MoveTo (itemRect->left+1, itemRect->top+1);		LineTo (itemRect->right, itemRect->top+1);	} else {		MoveTo (itemRect->left+1, itemRect->top+1);		LineTo (itemRect->left+1, itemRect->bottom);	}		ForeColor (blackColor);}void FalseClick (DialogPtr theDialog, short theItem){	Rect		theBox;	short	theType;	Handle	theHandle;	unsigned long		finalTicks;		GetDialogItem(theDialog, theItem, &theType, &theHandle, &theBox);	if (theType == 	4) {		HiliteControl((ControlHandle)theHandle, 1); 		Delay(3L, &finalTicks);		HiliteControl((ControlHandle)theHandle, 0); 	}}unsigned char GetButtonState (DialogPtr theDialog, short theButton){	Rect	theBox;	short		theType;	ControlHandle	theHandle;		GetDialogItem(theDialog, theButton, &theType, (Handle *) &theHandle, &theBox);	if ((theType >= 4) && (theType <= 7))		return((**theHandle).contrlHilite);	else 		return false;}Boolean GetCheck (DialogPtr theDialog, short theItem){	Rect		theBox;	short		theType;	Handle	theHandle;		GetDialogItem(theDialog, theItem, &theType, &theHandle, &theBox);	if (GetControlValue((ControlHandle)theHandle))		return(1);	else		return(0);}short GetDInt (DialogPtr theDialog, short theID){	Rect	theBox;	short	theType;	Handle	theHandle;	Str255	theStr;	long	theLong;		GetDialogItem(theDialog, theID, &theType, &theHandle, &theBox);	GetDialogItemText(theHandle, theStr);	StringToNum(theStr, &theLong);	return ((short)theLong);}long GetDLong (DialogPtr theDialog, short theID){	Rect	theBox;	short	theType;	Handle	theHandle;	Str255	theStr;	long	theLong;		GetDialogItem(theDialog, theID, &theType, &theHandle, &theBox);	GetDialogItemText(theHandle, theStr);	StringToNum(theStr, &theLong);	return (theLong);}void GetItemRect (DialogPtr dialog, short itemNo, Rect *r){	short		itemType;	Handle		itemHandle;	GetDialogItem (dialog, itemNo, &itemType, &itemHandle, r);}short GetPopUpItem (DialogPtr theDialog, short theItem){	Rect	theBox;	short	theType;	Handle	theHandle;		GetDialogItem (theDialog, theItem, &theType, &theHandle, &theBox);	return (GetControlValue ((ControlHandle)theHandle));}void GetText (DialogPtr theDialog, short theID, Str255 theStr){	Rect	theBox;	short	theType;	Handle	theHandle;		GetDialogItem (theDialog, theID, &theType, &theHandle, &theBox);	GetDialogItemText (theHandle, theStr);}Boolean SetRadioButton (DialogPtr dialog, short item1, short item2, short item){	register short i;	short type;	Handle itemHdl;	Rect box;	if (item < item1 || item > item2) 		item = item1;	for (i = item1; i <= item2; i++) {		GetDialogItem (dialog, i, &type, &itemHdl, &box);		SetControlValue ((ControlHandle)itemHdl, (item == i) ? 1 : 0);	}	return TRUE;}short GetRadioButton (DialogPtr dialog, short item1, short item2){	register short i;	short type;	Handle itemHdl;	Rect box;	for (i = item1; i <= item2; i++) {		GetDialogItem(dialog, i, &type, &itemHdl, &box);		if (GetControlValue((ControlHandle)itemHdl))			return i;	}	return 0;}Boolean HasColor (){	SysEnvRec	myComputer;		SysEnvirons (2, &myComputer);	return ((myComputer.hasColorQD != 0) && (DepthScreen > 1));}Boolean HasColorPort (GrafPtr port){	return ((((CGrafPtr)port)->portVersion & 0x8000) != 0);}Boolean HasRectColor (Rect r){	SysEnvRec	myComputer;		SysEnvirons (2, &myComputer);	if (myComputer.hasColorQD) {		GDHandle		curDev;		PixMapHandle	myPixMap;		LocalToGlobal ((Point*) &r);		LocalToGlobal (1 + (Point*) &r);		curDev = GetMaxDevice(&r);		myPixMap = (**curDev).gdPMap;		return ((**myPixMap).pixelSize > 1);	}	return false;}void HiliteItem (DialogPtr theDialog, short theItem, Boolean theState){	Rect		theBox;	short		theType;	Handle	theHandle;		GetDialogItem(theDialog, theItem, &theType, &theHandle, &theBox);	if (theHandle)		HiliteControl ((ControlHandle) theHandle, (theState) ? 0 : 255);}void HiliteRect (Rect *rect){	Pattern		myGray;	PenState	oldPenState;	GetPenState (&oldPenState);	PenNormal();	GetIndPattern (&myGray, 0, 4);	PenPat (&myGray);	PenMode (patBic);	PaintRect (rect);	SetPenState (&oldPenState); }ListHandle InitListItem (DialogPtr dialog, short itemNo,							 short cellVSize, short selFlags){	Rect		itemRect, dataBounds;	Point		cellSize;	short		cellHSize;	ListHandle	list;	GetItemRect (dialog, itemNo, &itemRect);	InsetRect (&itemRect, 1, 1);	itemRect.right -= 15;	cellHSize = itemRect.right-itemRect.left;	SetRect (&dataBounds, 0, 0, 1, 0);	SetPt (&cellSize, cellHSize, cellVSize);	list = LNew (&itemRect, &dataBounds, cellSize, 0, (WindowPtr) dialog, false, false, false, true);	(*list)->selFlags = selFlags;	return list;}void PutResourcesToList (DialogPtr dialog, ListHandle list, ResType restype,							Boolean oneResource, short resID){	Point 	cell;	short 	countRes, rID, offset, len;	Handle 	rh;	ResType rType;	Str255 	name, buffer;	Boolean place;		countRes = (oneResource) ? Count1Resources (restype) : CountResources (restype);	LSetDrawingMode (false, list); 					while (countRes > 0) {		SetResLoad (false);		rh = (oneResource) ? Get1IndResource (restype, countRes) : GetIndResource (restype, countRes);		GetResInfo (rh, &rID, &rType, name);		SetResLoad (true);		place = false;		SetPt (&cell, 0, 0);		while ((cell.v < (*list)->dataBounds.bottom) && !place) {			LGetCellDataLocation (&offset, &len, cell, list);			BlockMove ((*(*list)->cells)+offset, buffer+1, len);			buffer[0] = len;			place = (IUCompString (name, buffer) <= 0);			if (!place)				cell.v++; 		}		LAddRow (1, cell.v, list);		BlockMove (name+1, buffer, name[0]);		LSetCell (buffer, (short) name[0], cell, list);		if (resID == rID)			LSetSelect (TRUE, cell, list);		countRes--; 	}	LSetDrawingMode (true, list);	LUpdate (dialog->visRgn, list);}void PutStringToList (ListHandle list, Str255 name, short mode){	Point 	cell;	short 	offset, len;	Str255 	buffer;	Boolean place;		switch (mode) {		case putAtTop:			SetPt (&cell, 0, 0);			break;				case putAtBottom:			SetPt (&cell, 0, (*list)->dataBounds.bottom+1);			break;				case putWithSorting:	 							place = false;			SetPt (&cell, 0, 0);			while ((cell.v < (*list)->dataBounds.bottom) && !place) {				LGetCellDataLocation (&offset, &len, cell, list);				BlockMove ((*(*list)->cells)+offset, buffer+1, len);				buffer[0] = len;				place = (IUCompString (name, buffer) <= 0);				if (!place)					cell.v++; 			}			break;	}	LAddRow (1, cell.v, list);	if (cell.v >= (*list)->dataBounds.bottom)		cell.v = (*list)->dataBounds.bottom-1;	BlockMove (name+1, buffer, name[0]);	LSetCell (buffer, (short) name[0], cell, list);}Boolean GetListState (ListHandle list){	Point 	cell;		SetPt (&cell, 0, 0);	return (LGetSelect (true, &cell, list));}void UpdateListItem (DialogPtr dialog, short itemNo, ListHandle list){	Rect itemRect;//	RGBColor oldFore, oldBack;	GetItemRect (dialog, itemNo, &itemRect);	if (EffectsOn) {		InsetRect (&itemRect, -1, -1);		FrameOutline (&itemRect);		InsetRect (&itemRect, 1, 1);	}//	if (HasColorPort (dialog)) {//		GetForeColor (&oldFore);//		GetBackColor (&oldBack);//		ForeColor (blackColor);//		BackColor (whiteColor);//	}	EraseRect (&itemRect);	FrameRect (&itemRect);	LSetDrawingMode (TRUE, list);	LUpdate (dialog->visRgn, list);//	if (HasColorPort (dialog)) {//		RGBForeColor (&oldFore);//		RGBBackColor (&oldBack);//	}}Boolean CreateOffscreenBitMap (GrafPtr *newOffscreen, Rect *inBounds){	GrafPtr savePort, newPort;	GetPort(&savePort);	newPort = (GrafPtr) NewPtr (sizeof (GrafPort));	if (MemError () != noErr) return FALSE;												OpenPort (newPort);	newPort->portRect = *inBounds;	newPort->portBits.bounds = *inBounds;	RectRgn (newPort->clipRgn, inBounds);	RectRgn (newPort->visRgn, inBounds);	newPort->portBits.rowBytes = ((inBounds->right-inBounds->left+15)>>4)<<1;	newPort->portBits.baseAddr = NewPtr (newPort->portBits.rowBytes*(long)(inBounds->bottom-inBounds->top));	if(MemError() != noErr) {		SetPort (savePort);		ClosePort (newPort);		DisposePtr ((Ptr) newPort);		return FALSE;	}	EraseRect (inBounds);	*newOffscreen = newPort;	SetPort(savePort);	return TRUE;}void DestroyOffscreenBitMap(GrafPtr oldOffscreen){	ClosePort (oldOffscreen);	DisposePtr (oldOffscreen->portBits.baseAddr);	DisposePtr ((Ptr)oldOffscreen);}Boolean CreateOffscreenPixMap (CGrafPtr *newOffscreen, Rect *inBounds){	GrafPtr 		savePort;	CGrafPtr 		newPort;	PixMapHandle	gPixMap;	Ptr				offBaseAddr;	unsigned short	bytesPerRow, temp;	GDHandle		mainDevice;	CTabHandle		cTable;	short			depth;	GetPort (&savePort);	newPort = (CGrafPtr) NewPtr (sizeof (CGrafPort));	if (MemError () != noErr) return false;												OpenCPort (newPort);	newPort->portRect = *inBounds;	gPixMap = newPort->portPixMap;	mainDevice = GetMainDevice ();	depth = (**(**mainDevice).gdPMap).pixelSize;	cTable = (**(**mainDevice).gdPMap).pmTable;	HandToHand ((Handle *) &cTable);	temp = ((unsigned short)depth)*(inBounds->right-inBounds->left);	temp = (temp+31)/32;    bytesPerRow = temp*4;	(*gPixMap)->rowBytes = bytesPerRow | 0x8000;	(*gPixMap)->bounds = *inBounds;	(*gPixMap)->pmVersion = 0;	(*gPixMap)->packType = 0;	(*gPixMap)->packSize = 0;	(*gPixMap)->hRes = 0x00480000;	(*gPixMap)->vRes = 0x00480000;	(*gPixMap)->pixelSize = depth;	(*gPixMap)->planeBytes = 0;	(*gPixMap)->pmReserved = 0;	(*gPixMap)->pixelType = 0;	(*gPixMap)->cmpCount = 1;	(*gPixMap)->cmpSize = depth; 	(*gPixMap)->pmTable = cTable;	offBaseAddr = NewPtr ((unsigned long) bytesPerRow*(inBounds->bottom-inBounds->top+1));	(*gPixMap)->baseAddr = offBaseAddr;	if (MemError () != noErr) {		DisposeHandle ((Handle) (*gPixMap)->pmTable);		SetPort (savePort);		CloseCPort (newPort);		DisposePtr ((Ptr) newPort);		return false;	}	RectRgn (newPort->clipRgn, inBounds);	RectRgn (newPort->visRgn, inBounds);	EraseRect (inBounds);	*newOffscreen = newPort;	SetPort (savePort);	return TRUE;}void DestroyOffscreenPixMap (CGrafPtr oldOffscreen){	DisposePtr ((*oldOffscreen->portPixMap)->baseAddr);	DisposeHandle ((Handle) (*oldOffscreen->portPixMap)->pmTable);	CloseCPort (oldOffscreen);	DisposePtr ((Ptr)oldOffscreen);}void SaveRect (GrafPtr src, CGrafPtr offscreen, Rect *rSrc){	PixMapPtr	gPixMap;		gPixMap = *(offscreen->portPixMap);	CopyBits (&src->portBits, (BitMap *) gPixMap,			 rSrc, &gPixMap->bounds, srcCopy, 0L);}void RestoreRect (GrafPtr src, CGrafPtr offscreen, Rect *rSrc){	PixMapPtr	gPixMap;		gPixMap = *(offscreen->portPixMap);	CopyBits ((BitMap *)gPixMap, &src->portBits, 			 &gPixMap->bounds, rSrc, srcCopy, 0L);}PixMapHandle CreatePixMap (Rect *inBounds){	PixMapHandle	gPixMap;	unsigned short	bytesPerRow, temp, depth;	GDHandle		mainDevice;	gPixMap = (PixMapHandle) NewHandleClear (sizeof (PixMap));	if (gPixMap) {		mainDevice = GetMainDevice ();		depth = (**(**mainDevice).gdPMap).pixelSize;		temp = ((unsigned short)depth)*(inBounds->right-inBounds->left);		temp = (temp+31)/32;	    bytesPerRow = temp*4;		(*gPixMap)->pmTable = (**(**mainDevice).gdPMap).pmTable;		(*gPixMap)->rowBytes = bytesPerRow | 0x8000;		(*gPixMap)->bounds = *inBounds;		(*gPixMap)->hRes = 0x00480000;		(*gPixMap)->vRes = 0x00480000;		(*gPixMap)->pixelSize = depth;		(*gPixMap)->cmpCount = 1;		(*gPixMap)->cmpSize = depth; 		(*gPixMap)->baseAddr = NewPtrClear ((unsigned long) bytesPerRow*(inBounds->bottom-inBounds->top+1));		if (MemError () == noErr) 			return gPixMap;		DisposeHandle ((Handle) gPixMap);	} 	return 0;}void DestroyPixMap (PixMapHandle gPixMap){	DisposePtr ((*gPixMap)->baseAddr);	DisposeHandle ((Handle) gPixMap);}void MakeInversePixMap (PixMapPtr src, PixMapPtr dst){	Rect srcRect, dstRect, bounds;	short count;		bounds = src->bounds;	count = bounds.right-bounds.left;	SetRect (&srcRect, bounds.left, bounds.top, bounds.left+1, bounds.bottom);	SetRect (&dstRect, bounds.right-1, bounds.top, bounds.right, bounds.bottom);	while (count) {		CopyBits ((BitMap *) src, (BitMap *) dst, &srcRect, &dstRect, srcCopy, 0L);		OffsetRect (&srcRect, 1, 0);		OffsetRect (&dstRect, -1, 0);		count--;	}}/**************************************************************************/GrafPtr OpenPanel (DialogPtr dialog, Rect *hotRect, Rect *rBounds, PixMapHandle *saved){	Point		dlgLeftPoint;	Rect		rOffscreenBounds, rMaxBounds;	OSErr 		err;	GDHandle 	gdh;	GrafPtr		myPortPtr;	SetPort ((GrafPtr) dialog);	SetPt (&dlgLeftPoint, hotRect->right, hotRect->bottom);	LocalToGlobal (&dlgLeftPoint);	SetRect (&rOffscreenBounds, 0, 0, rBounds->right+2, rBounds->bottom+2);	while (!PtInScreen (dlgLeftPoint, 0, rBounds->bottom))		dlgLeftPoint.v -= stepV;	while (!PtInScreen (dlgLeftPoint, rBounds->right, 0))		dlgLeftPoint.h -= stepH;	OffsetRect (rBounds, dlgLeftPoint.h, dlgLeftPoint.v);	rMaxBounds = *rBounds;	InsetRect (rBounds, -1, -1);	err = NewScreenBuffer (rBounds, false, &gdh, saved);	if (err == noErr) {		myPortPtr = (GrafPtr) NewPtr (sizeof (GrafPort));		OpenPort (myPortPtr);		SetPort (myPortPtr);		CopyBits (&myPortPtr->portBits, (BitMap *) StripAddress (**saved),			 rBounds, &(**saved)->bounds, srcCopy, 0L);		EraseRect (&rMaxBounds);		FrameRectShadow (&rMaxBounds);		return (myPortPtr);	} else		return 0;}void ClosePanel (DialogPtr dialog, GrafPtr myPortPtr, Rect *rBounds, PixMapHandle saved){	CopyBits ((BitMap *) StripAddress (*saved), &myPortPtr->portBits, 			 &(*saved)->bounds, rBounds, srcCopy, 0L);	ClosePort (myPortPtr);	DisposePtr ((Ptr) myPortPtr);	DisposeScreenBuffer (saved);	SetPort ((GrafPtr) dialog);}/**************************************************************************/CGrafPtr OpenCPanel (DialogPtr dialog, Rect *hotRect, Rect *rBounds, PixMapHandle *saved){	Point		dlgLeftPoint;	Rect		rOffscreenBounds, rMaxBounds;	OSErr 		err;	GDHandle 	gdh;	CGrafPtr	myPortPtr;	SetPort ((GrafPtr) dialog);	SetPt (&dlgLeftPoint, hotRect->right, hotRect->bottom);	LocalToGlobal (&dlgLeftPoint);	SetRect (&rOffscreenBounds, 0, 0, rBounds->right+2, rBounds->bottom+2);	while (!PtInScreen (dlgLeftPoint, 0, rBounds->bottom))		dlgLeftPoint.v -= stepV;	while (!PtInScreen (dlgLeftPoint, rBounds->right, 0))		dlgLeftPoint.h -= stepH;	OffsetRect (rBounds, dlgLeftPoint.h, dlgLeftPoint.v);	rMaxBounds = *rBounds;	InsetRect (rBounds, -1, -1);	err = NewScreenBuffer (rBounds, false, &gdh, saved);	if (err == noErr) {		myPortPtr = (CGrafPtr) NewPtr (sizeof (CGrafPort));		OpenCPort (myPortPtr);		SetPort ((GrafPtr) myPortPtr);		CopyBits ((BitMap *) (*myPortPtr->portPixMap), (BitMap *) **saved,			 rBounds, &(**saved)->bounds, srcCopy, 0L);		EraseRect (&rMaxBounds);		FrameRectShadow (&rMaxBounds);		return (myPortPtr);	} else		return 0;}void CloseCPanel (DialogPtr dialog, CGrafPtr myPortPtr, Rect *rBounds, PixMapHandle saved){	CopyBits ((BitMap *) *saved, (BitMap *) (*myPortPtr->portPixMap), 			 &(*saved)->bounds, rBounds, srcCopy, 0L);	CloseCPort (myPortPtr);	DisposePtr ((Ptr) myPortPtr);	DisposeScreenBuffer (saved);	SetPort ((GrafPtr) dialog);}/**************************************************************************/void CreateOffscreenBuffer (Rect *bounds, short depth, GWorldPtr *gWorld){	GWorldPtr		currPort;	GDHandle		currDev;	GetGWorld (&currPort, &currDev);	NewGWorld (gWorld, depth, bounds, nil, nil, 0);	if (!LockPixels (GetGWorldPixMap (*gWorld))) DebugStr ("\pPixMap lock failed!");	SetGWorld (*gWorld, nil);	ForeColor (blackColor);	BackColor (whiteColor);	EraseRect (bounds);	PenPat (&qd.black);	SetGWorld (currPort, currDev);}	/**************************************************************************/Boolean PtInScreen (Point pt, short offsetH, short offsetV){	Point		tP;	tP = pt;	tP.h += offsetH;	tP.v += offsetV;	return (PtInRect (tP, &qd.screenBits.bounds));}void DrawProgressBar (DialogPtr theDialog, short itemNo){	Rect box;	GetItemRect (theDialog, itemNo, &box);	InsetRect (&box, -1, -1);	Frame3DRect (&box, 1, 1);}void RedrawProgressBar (DialogPtr theDialog, short itemNo){	Rect	box;	GetItemRect (theDialog, itemNo, &box);	InsetRect (&box, 1, 1);	EraseRect (&box);}void FillProgressBar (DialogPtr theDialog, short itemNo, 				unsigned long max, unsigned long current){	Rect	box;	float	limit;	short	currY;	GetItemRect (theDialog, itemNo, &box);	limit = (float)(box.right-box.left)/(float)max;	if (current > max) 		current = max;	currY = current*limit;	if (currY) {		box.right = box.left + currY;		InsetRect (&box, 2, 2);		FillRect (&box, &qd.black);	}}void PutText (DialogPtr theDialog, short theID, Str255 theStr){	Rect	theBox;	short	theType;	Handle	theHandle;		SetPort (theDialog);	GetDialogItem (theDialog, theID, &theType, &theHandle, &theBox);	EraseRect (&theBox);	SetDialogItemText (theHandle, theStr);	InvalItem (theDialog, theID);}void SetButton (DialogPtr theDialog, short theButton, short theState){	Rect	theBox;	short	theType;	Handle	theHandle;		GetDialogItem (theDialog, theButton, &theType, &theHandle, &theBox);	HiliteControl ((ControlHandle)theHandle, theState);}void SetButtonTitle (DialogPtr theDialog, short theButton, Str255 theTitle){	Rect	theBox;	short	theType;	Handle	theHandle;		GetDialogItem (theDialog, theButton, &theType, &theHandle, &theBox);	SetControlTitle ((ControlHandle)theHandle, theTitle);}void SetCheck (DialogPtr theDialog, short theItem, Boolean theMode){	PushButton (theDialog, theItem, (theMode) ? 1 : 0);}short SetPopUpItem (DialogPtr theDialog, short theItem, short num){	Rect	theBox;	short	theType;	Handle	theHandle;		GetDialogItem(theDialog, theItem, &theType, &theHandle, &theBox);	SetControlValue((ControlHandle)theHandle, num);	return 0;}void SetUserItem (DialogPtr theDialog, short itemNo, Handle hook){ 	short		itemType;	Handle		itemHandle;	Rect		itemRect;	GetDialogItem (theDialog, itemNo, &itemType, &itemHandle, &itemRect);#if powerc	SetDialogItem (theDialog, itemNo, 0, (Handle) NewRoutineDescriptor ((ProcPtr) hook, uppUserItemProcInfo, GetCurrentISA ()), &itemRect);#else		SetDialogItem (theDialog, itemNo, 0, hook, &itemRect);#endif}void DisposeUserItem (DialogPtr theDialog, short itemNo){	short		itemType;	Handle		itemHandle;	Rect		itemRect;	GetDialogItem (theDialog, itemNo, &itemType, &itemHandle, &itemRect);	DisposeRoutineDescriptor ((UniversalProcPtr) itemHandle);}Boolean System7(){	long 	gestaltAnswer;	Boolean	result = FALSE;	if( ! Gestalt(gestaltVersion, &gestaltAnswer) ) {		Gestalt (gestaltSystemVersion, &gestaltAnswer);		if( (int)gestaltAnswer >= 0x0700 ) result = TRUE;	}	return(result);}short GetSystemVersion (){	long 	gestaltAnswer;	short	result = 0x0000;	if (!Gestalt (gestaltVersion, &gestaltAnswer)) {		Gestalt (gestaltSystemVersion, &gestaltAnswer);		result = (short) gestaltAnswer;	}	return result;}Boolean System607(){	long 	gestaltAnswer;	Boolean	result = FALSE;	if( ! Gestalt(gestaltVersion, &gestaltAnswer) ) {		Gestalt (gestaltSystemVersion, &gestaltAnswer);		if( (int)gestaltAnswer >= 0x0607 ) result = TRUE;	}	return (result);}Boolean TrackButton (DialogPtr theDialog, short theItem){	Rect	theBox;	short		theType;	Handle	theHandle;	Point 	where, old;	if (GetButtonState (theDialog, theItem)) return false;	GetDialogItem (theDialog, theItem, &theType, &theHandle, &theBox);	HiliteControl ((ControlHandle) theHandle, 1); 	GetMouse (&old);	if (StillDown()) {		while (WaitMouseUp()) {			GetMouse (&where);			if (!DeltaPoint (old, where)) continue;			HiliteControl ((ControlHandle) theHandle, (PtInRect (where, &theBox)) ? 1 : 0); 			old = where;			}	}	HiliteControl ((ControlHandle) theHandle, 0);	return (PtInRect (old, &theBox));}void ZoomGlobalRect (Rect *r2, Boolean direction){	short 		i;	Rect 		r[zoomSteps], r1;	Rect		*rs, *rd;	long 		dleft, dright, dtop, dbottom;	long 		bLeft, bRight, bTop, bBottom;	PenState	oldstate;	GrafPtr		oldport, globalPort;	long		nx;		if (!EffectsOn) return;	LocalToGlobal((Point*) r2);	LocalToGlobal(1 + (Point*) r2);	GetPort (&oldport);	globalPort = (GrafPtr) NewPtr (sizeof (GrafPort));	OpenPort (globalPort);	r1 = globalPort->portRect;	InsetRect (&r1, (r1.right-r1.left)/2-1, (r1.bottom-r1.top)/2-1);	if (direction) {		rs = &r1;		rd = r2;	} else {		rs = r2;		rd = &r1;	}	bLeft = (long)rs->left << 8;	bRight = (long)rs->right << 8;	bTop = (long)rs->top << 8;		bBottom = (long)rs->bottom << 8;		dleft = ((long)(rd->left-rs->left) << 8) / zoomSteps;	dright = ((long)(rd->right-rs->right) << 8) / zoomSteps;	dtop = ((long)(rd->top-rs->top) << 8) / zoomSteps;	dbottom = ((long)(rd->bottom-rs->bottom) << 8) / zoomSteps;	GetPenState (&oldstate);	PenMode (patXor);	PenPat (&qd.gray);	r[0] = r1;	for (i=1; i<zoomSteps; i++) {		bLeft += dleft;		bRight += dright;		bTop += dtop;		bBottom += dbottom;		SetRect (&(r[i]), (short)(bLeft >> 8), (short)(bTop >> 8),						(short) (bRight >> 8), (short) (bBottom >> 8));	}	FrameRect (&(r[0]));	FrameRect (&(r[1]));	FrameRect (&(r[2]));	Delay (1, (unsigned long *) &nx);	for (i=3; i<zoomSteps; i++) {		FrameRect (&(r[i]));		FrameRect (&(r[i-3]));		Delay (1, (unsigned long *) &nx);	}	FrameRect (&(r[zoomSteps-3]));	FrameRect (&(r[zoomSteps-2]));	FrameRect (&(r[zoomSteps-1]));	SetPenState (&oldstate);	ClosePort (globalPort);	DisposePtr ((Ptr) globalPort);	SetPort (oldport);}/*void MakeBackRegion (DialogPtr dialog, short items, ...){	va_list ap;	Rect frame;	short itemNo, i;	RgnHandle 	reg;		if (!EffectsOn) return;	SetPort (dialog);	reg = NewRgn ();	va_start (ap, items);	OpenRgn ();	FrameRect (&dialog->portRect);	for (i = 0; i < items; i++) {#if powerc		itemNo = va_arg (ap, long);#else 		itemNo = va_arg (ap, short);#endif		GetItemRect (dialog, itemNo, &frame);		InsetRect (&frame, 1, 1);		FrameRect (&frame);	}	CloseRgn (reg);	if (HasColor ()) {		GrayBackColor (BackMain);		GrayForeColor (BackMain);		FillRgn (reg, &qd.black);	} else {		FillRgn (reg, &qd.gray);		FrameRect (&dialog->portRect);	}	DisposeRgn (reg);	if (HasColor ()) {		GrayForeColor (ForeMain);		GrayBackColor (BackMain);	} else {		ForeColor (blackColor);		BackColor (whiteColor);	}}*/void ShadowTextBox (Rect *r, Boolean center, Str255 text){	FontInfo 	fi;	short 		bottom, left;		GetFontInfo (&fi);	bottom = r->bottom-(r->bottom-r->top-fi.descent-fi.ascent)/2-fi.descent;	if (center)		left = r->left+(r->right-r->left-StringWidth (text))/2;	else 		left = r->left+5;	MoveTo (left, bottom);	TextMode (srcBic);	DrawString (text);	MoveTo (left-1, bottom-1);	TextMode (srcOr);	DrawString (text);	TextMode (srcCopy);}void ShadowText (DialogPtr dialog, short itemNo, Boolean center, Str255 text){	Rect 		r;	GetItemRect (dialog, itemNo, &r);	ShadowTextBox (&r, center, text);}typedef struct itemList {	struct itemList	*nextItem;	short			itemNo;	short 			itemType;	Handle			itemHandle;	short			value;	short			hilite;	Str255			text;} itemList, *itemListPtr;Ptr SaveItems (DialogPtr dialog, short items, ...){	va_list 	ap;	itemListPtr	item, firstItem;	short		i, itemNo;	Handle		itemHandle;	Rect		itemRect;		firstItem = 0;	va_start (ap, items);	for (i = 0; i < items; i++) {		itemNo = va_arg (ap, short); 		item = (itemListPtr) NewPtrClear (sizeof (itemList));		if (firstItem) 			firstItem->nextItem = item;		else			firstItem = item;		GetDialogItem (dialog, itemNo, &item->itemType, &itemHandle, &itemRect);		item->itemNo = itemNo;		switch (item->itemType) {			case userItem:			case iconItem:			case picItem:				item->itemHandle = itemHandle;				break;							case ctrlItem+btnCtrl:			case ctrlItem+chkCtrl:			case ctrlItem+radCtrl:			case ctrlItem+resCtrl:				item->value = GetControlValue ((ControlHandle)itemHandle);				item->hilite = (*(ControlHandle)itemHandle)->contrlHilite;				break;							case statText:			case editText:				GetDialogItemText (itemHandle, item->text);				break;							default:				break;		}	}	return ((Ptr) firstItem);}void RestoreItems (DialogPtr dialog, Ptr firstItem){	itemListPtr	item, oldItem;	Handle		itemHandle;	short		itemType;	Rect		itemRect;		item = (itemListPtr) firstItem;	while (item) {		GetDialogItem (dialog, item->itemNo, &itemType, &itemHandle, &itemRect);		switch (item->itemType) {			case userItem:			case iconItem:			case picItem:				SetDialogItem (dialog, item->itemNo, item->itemType, item->itemHandle, &itemRect);				break;							case ctrlItem+btnCtrl:			case ctrlItem+chkCtrl:			case ctrlItem+radCtrl:			case ctrlItem+resCtrl:				SetControlValue ((ControlHandle)itemHandle, item->value);				(*(ControlHandle)itemHandle)->contrlHilite = item->hilite;				break;							case statText:			case editText:				SetDialogItemText (itemHandle, item->text);				break;							default:				break;		}		oldItem = item;		item = item->nextItem;		DisposePtr ((Ptr) oldItem);	}}void PushButton (DialogPtr theDialog, short theButton, short theState){	Rect	theBox;	short	theType;	Handle	theHandle;		GetDialogItem (theDialog, theButton, &theType, &theHandle, &theBox);	SetControlValue ((ControlHandle)theHandle, theState);}short PopButton (DialogPtr theDialog, short theButton){	Rect	theBox;	short	theType;	Handle	theHandle;		GetDialogItem (theDialog, theButton, &theType, &theHandle, &theBox);	return GetControlValue ((ControlHandle)theHandle);}void InvalItem (DialogPtr dialog, short itemNo){	Rect itemRect;	GrafPtr	oldport;		GetPort (&oldport);	SetPort ((GrafPtr) dialog);	GetItemRect (dialog, itemNo, &itemRect);	InvalRect (&itemRect);	SetPort (oldport);}void UpdtButton (DialogPtr dialog, short itemNo, short state){	if (GetButtonState (dialog, itemNo) != state)		SetButton (dialog, itemNo, state);}ControlHandle GetItemControl (DialogPtr dialog, short itemNo){	ControlHandle control;	short iType;	Rect iRect;			GetDialogItem (dialog, itemNo, &iType, (Handle *) &control, &iRect); 	return control;}void DrawIconItem (DialogPtr dialog, Rect *destRect, Ptr iconData, short iconType){	Rect 		bounds;		PixMap	 	ciconMap;	RGBColor	fore, back;		bounds = *destRect;	if (HasColorPort (dialog)) {		GetForeColor (&fore);		GetBackColor (&back);		ForeColor (blackColor);		BackColor (whiteColor);	}	InsetRect (destRect, -1, -1);	EraseRect (destRect);	InsetRect (destRect, 1, 1);//	FrameRect (destRect);//	InsetRect (destRect, 2, 2);	if (iconData) {		OffsetRect (&bounds, -bounds.left, -bounds.top);		ciconMap.bounds = bounds;		ciconMap.pmVersion = 0;		ciconMap.packType = 0;		ciconMap.packSize = 0;		ciconMap.hRes = 0x00480000;		ciconMap.vRes = 0x00480000;		ciconMap.planeBytes = 0;		ciconMap.pmReserved = 0;		ciconMap.pixelType = 0;		ciconMap.cmpCount = 1;		ciconMap.baseAddr = iconData;		switch (iconType) {			case kLarge8BitIcon:				ciconMap.rowBytes = 32 | 0x8000;				ciconMap.pixelSize = 8;				ciconMap.cmpSize = 8;				ciconMap.pmTable = GetCTable (8);				CopyBits ((BitMap *)&ciconMap, (BitMap*)*((CGrafPtr)dialog)->portPixMap, &bounds, destRect, srcCopy, NULL);				DisposeCTable (ciconMap.pmTable);				break;						case kLarge4BitIcon:				ciconMap.rowBytes = 16 | 0x8000;				ciconMap.pixelSize = 4;				ciconMap.cmpSize = 4;				ciconMap.pmTable = GetCTable (4);				CopyBits ((BitMap *)&ciconMap, (BitMap*)*((CGrafPtr)dialog)->portPixMap, &bounds, destRect, srcCopy, NULL);				DisposeCTable (ciconMap.pmTable);				break;				case kSmall8BitIcon:				ciconMap.rowBytes = 16 | 0x8000;				ciconMap.pixelSize = 8;				ciconMap.cmpSize = 8;				ciconMap.pmTable = GetCTable (8);				CopyBits ((BitMap *)&ciconMap, (BitMap*)*((CGrafPtr)dialog)->portPixMap, &bounds, destRect, srcCopy, NULL);				DisposeCTable (ciconMap.pmTable);				break;						case kSmall4BitIcon:				ciconMap.rowBytes = 8 | 0x8000;				ciconMap.pixelSize = 4;				ciconMap.cmpSize = 4;				ciconMap.pmTable = GetCTable (4);				CopyBits ((BitMap *)&ciconMap, (BitMap*)*((CGrafPtr)dialog)->portPixMap, &bounds, destRect, srcCopy, NULL);				DisposeCTable (ciconMap.pmTable);				break;											case kLargeIcon:				{					BitMap iconMap;										iconMap.baseAddr = iconData;					iconMap.rowBytes = 4;					iconMap.bounds = bounds;					CopyBits (&iconMap, &dialog->portBits, &bounds, destRect, srcCopy, nil);				}				break;				case kSmallIcon:				{					BitMap iconMap;										iconMap.baseAddr = iconData;					iconMap.rowBytes = 2;					iconMap.bounds = bounds;					CopyBits (&iconMap, &dialog->portBits, &bounds, destRect, srcCopy, nil);				}				break;		}	}	if (HasColorPort (dialog)) {		RGBForeColor (&fore);		RGBBackColor (&back);	}}/*****************************************************************************/void NormalizeMenuItem (Str255 item){	short i;	if ((item[0] >= 1) && (item[1] == '-'))		item[1] = 'Ð';	for (i=1; i<=item[0]; i++) {		switch (item[i]) {			case '^': item[i] = '~'; break;			case '!': item[i] = '|'; break;			case '<': item[i] = '²'; break;			case '/': item[i] = '|'; break;			case '(': item[i] = '['; break;		}	}}void AddResMenuWithSort (MenuHandle menu, ResType type){	short i, j, count, mcount;	Handle resHandle;	OSType resType;	short resID;	Str255 name, nameTst;	count = CountResources (type);	for (i = 1; i <= count; i++) {		SetResLoad (false);		resHandle = GetIndResource (type, i);		SetResLoad (true);		GetResInfo (resHandle, &resID, &resType, name);		j = 1;		mcount = CountMItems (menu);		while (j <= mcount) {			GetMenuItemText (menu, j, nameTst);			if (IUCompString (name, nameTst) <= 0) 				break;			j++; 		}		InsertMenuItem (menu, name, j-1);	}}void DrawOnlyGrowIcon (WindowPtr window){	Rect growRect, portRect;	RgnHandle rgnGrow, rgnPort, rgntemp, rgnunion, rgnxor;		portRect = window->portRect;	growRect.bottom = portRect.bottom;	growRect.right = portRect.right;	growRect.top = growRect.bottom - 15;	growRect.left = growRect.right - 15;	rgntemp = NewRgn();	rgnunion = NewRgn();	rgnxor = NewRgn();	rgnPort = NewRgn ();	rgnGrow = NewRgn();		RectRgn (rgnGrow, &growRect);	RectRgn (rgnPort, &portRect);		DisposeRgn (window->visRgn);	window->visRgn = rgnPort;	CalcVis (window);	rgnPort = window->visRgn; 	UnionRgn (rgnGrow, rgnPort, rgnunion);	XorRgn (rgnGrow, rgnPort, rgnxor);	DiffRgn (rgnunion, rgnxor, rgntemp);	(*window).visRgn = rgntemp;	DrawGrowIcon (window);	(*window).visRgn = rgnxor;	CalcVis (window);	DisposeRgn(rgntemp);	DisposeRgn(rgnunion);	DisposeRgn(rgnPort);	DisposeRgn(rgnGrow);}