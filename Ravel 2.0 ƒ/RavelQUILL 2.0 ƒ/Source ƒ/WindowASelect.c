#include <Sound.h>#include <stdio.h>#include <string.h>#include "TE32K.h"#include "DialogLib.h"#include "PopUpLib.h"#include "myTEdit.h"/*ееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееее*///#include "Ravel_FTN.h"#include "ravel_msg_base.h"#include "Ravel_Prefs.h"#include "Preferences.h"//#include "BaseManager.h"#include "CommonData.h"#include "WindowsList.h"#include "WSubjects.h"#include "WASelect.h"#include "WView.h"#include "SoundLib.h"#include "Templates.h"/*ееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееее*/#include "rMenus.h"/*ееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееее*/typedef struct _wloc {	Point	topleft;	short	bottom;	} wloc;static	Rect	originalView = {0,0,0,0};pascal void LDEFASelect (short lMessage, Boolean lSelect, Rect *lRect, Cell lCell,				short lDataOffset, short lDataLen, ListHandle lHandle);//	#define cLeftOffset		5pascal void LDEFASelect (short lMessage, Boolean lSelect, Rect *lRect, Cell lCell,				short lDataOffset, short lDataLen, ListHandle lHandle){	short 		leftDraw, topDraw, k, locked;	FontInfo 	fi;	long		i, j;	pktmsg		*m;	Point		drawpt;	char		tmp[128];	long		lr, nm;	Boolean		yeah;		if ((lMessage == lInitMsg) || (lMessage == lCloseMsg))		return;		leftDraw = lRect->left+(*lHandle)->indent.h;	topDraw = lRect->top+(*lHandle)->indent.v;		switch (lMessage)	{	case lDrawMsg:			SetPort ((*lHandle)->port);			if (lDataLen == 4)		{			TextFont (viewFont);			TextSize (viewSize);			GetFontInfo (&fi);			SetPt ( &drawpt, leftDraw, topDraw+fi.leading+fi.ascent );			memcpy ( (Ptr) &i, *((*lHandle)->cells)+lDataOffset, 4 );			yeah = (i & 0x80000000L) != 0L;						i &= 0x7FFFFFFFL;						EraseRect (lRect);//е	marked dot//е area name			MoveTo ( drawpt.h + 1, drawpt.v );			if (i != 0 && i != AreasNumber+1)				(*areasHndls[i-1])->areaName[(*areasHndls[i-1])->areaName[0]+1] = 0;			sprintf (tmp, "%c %-48s",							(yeah) ? 0xA5 : 0x20,				(i == 0) ? "NETMAIL" :					(i == AreasNumber+1) ? "BADMAIL" :						(char *) &(*areasHndls[i-1])->areaName[1]);			DrawText ( tmp, 0, strlen (tmp) );		}		else			EraseRect (lRect);		if (!lSelect)			break;			case lHiliteMsg:			BitClr ( (Ptr) 0x0938, pHiliteBit);		InvertRect (lRect);		break;	}}static void AdjustWinSize (DialogPtr dialog, ListHandle list, short max){	short		iType, ii, dummy, neww, newh, newc;	Handle		iHandle;	Rect		iRect, rView, rDataBnds;	Point		cellSize;	FontInfo	fInfo;		TextFont (viewFont);	TextSize (viewSize);	GetFontInfo (&fInfo);	GetDialogItem ( dialog, 1, &iType, &iHandle, &rView );	newc = (*list)->cellSize.v;	neww = 1 + fInfo.widMax + fInfo.widMax * 48 + fInfo.widMax + fInfo.widMax * 6 + fInfo.widMax * 2 + fInfo.widMax * 6 + fInfo.widMax + 15;	//	rView.right;	newh = rView.top + (((max - rView.top) / newc) * newc);		SizeWindow ( dialog, neww, newh, true);	originalView.bottom = newh;	LSetDrawingMode ( false, list );		LSize ( neww - 15, ((newh - rView.top) / newc) * newc, list);		SetPt (&cellSize, neww - 15, newc);	LCellSize (cellSize, list);		(*((*list)->vScroll))->contrlRect.bottom -= 15;		LSetDrawingMode ( true, list );}void WASelectEventProcessor (EventRecord *event, windowsQElPtr dialogInfo, long info){	DialogPtr	dialog;	ListHandle	list;	short		iType, ii, dummy, neww, newh, newc, menuItem;	Handle		iHandle;	Rect		iRect, rView, rDataBnds;	Point		cellSize, theCell;	Point		where;			long		lSizeVH, nm, jj;		Str255		stemp;		char		key;		WStateData	*WStDat;	MenuHandle	hMenu;		WindowPtr	window;	windowsQElPtr	dInfo;	commonDataPtr	pcommon;	GrafPtr			oldPort;	switch (info & 0xFFFF)	{	case actionSetSize:				originalView.left = ((wloc *) event)->topleft.h;		originalView.top = ((wloc *) event)->topleft.v;		originalView.bottom = ((wloc *) event)->bottom;				break;		case actionGetSize:				((wloc *) event)->topleft.h = originalView.left;		((wloc *) event)->topleft.v = originalView.top;		((wloc *) event)->bottom = originalView.bottom;				break;		case actionCreate:		if (dInfo = windowsOpened (wtAreasSelect, 0, 0))		{			SelectWindow (dInfo->dialog);			break;		}				dialog = GetNewDialog (128 + wtAreasList, NULL, (WindowPtr) -1);		((WindowPeek)dialog)->windowKind = myKind_top;		((WindowPeek)dialog)->goAwayFlag = true;				SetWTitle (dialog, "\pSelect Area(s)");				SetPort ( dialog );		if (originalView.bottom)		{			if (!SuchWindow (wtAreasSelect) || qd.screenBits.bounds.bottom - originalView.top < originalView.bottom)			{				if (!originalView.top)				{					originalView.top = (*(((WindowPeek)dialog)->contRgn))->rgnBBox.top;					originalView.left = (*(((WindowPeek)dialog)->contRgn))->rgnBBox.left;	//				originalView.bottom = dialog->portRect.bottom;					originalView.top = LMGetMBarHeight () * 2;				}			}			else			{				originalView.left += 20;				originalView.top += 20;			}		}		else		{			originalView = (*(((WindowPeek)dialog)->contRgn))->rgnBBox;			originalView.bottom = dialog->portRect.bottom;			originalView.top = LMGetMBarHeight () * 2;		}				MoveWindow (dialog, originalView.left, originalView.top, false);		SizeWindow (dialog, dialog->portRect.right, originalView.bottom, false);//		TextFont ( 4 );//		TextSize ( 9 );		TextFont (viewFont);		TextSize (viewSize);		GetDialogItem ( dialog, 1, &iType, &iHandle, &rView );		SetRect ( &rDataBnds, 0, 0, 1, 0 );		rView.right -= 15;		SetPt ( &cellSize, 0, 0 );		list = LNew (						&rView,						&rDataBnds,						cellSize,						131,						dialog,						true,						false,						false,						true					);		(*list)->selFlags = 0x82;		(*list)->port->txFont = 4;		(*list)->port->txSize = 9;		(*(*list)->vScroll)->contrlRect.bottom -= 15;//		MoveTo (0, rView.top - 1);//		LineTo (rView.right + 15, rView.top - 1);				LActivate ( true, list );		LSetDrawingMode ( false, list );/*		Init areas here		*/		{			long	i;			dummy = LAddRow ( AreasNumber + ((((long) dialogInfo) == mSendto) ? 0 : 1), 0, list );			for ( i = 0; i <= AreasNumber - ((((long) dialogInfo) == mSendto) ? 1 : 0); i++ )			{				SetPt ( &theCell, 0, i);								jj = i + ((((long) dialogInfo) == mSendto) ? 1 : 0);				LSetCell (&jj, sizeof (long), theCell, list);			}		}				SetPt (&theCell, 0, 0);		LSetSelect (true, theCell,list);				AdjustWinSize (dialog, list, dialog->portRect.bottom);		WStDat = (WStateData *) *((WindowPeek) dialog)->dataHandle;				newc = (*list)->cellSize.v;		dummy = rView.top + newc * (*list)->dataBounds.bottom;				SetRect (&(WStDat->stdState),			WStDat->stdState.left + dialog->portRect.left,			WStDat->stdState.top + dialog->portRect.top,			WStDat->stdState.left + dialog->portRect.right,			(qd.screenBits.bounds.bottom < WStDat->stdState.top + dummy) ?				qd.screenBits.bounds.bottom :				((*list)->dataBounds.bottom > 5) ? WStDat->stdState.top + dummy :					WStDat->stdState.top + dialog->portRect.bottom);		LSetDrawingMode ( true, list );		ShowWindow ( dialog );		pcommon = (commonDataPtr) NewPtrClear (sizeof (commonASelect));				pcommon->cASelect.dialog = dialog;		pcommon->cASelect.list = list;		pcommon->cASelect.area_number = (long) event;		pcommon->cASelect.mode = (long) dialogInfo;		windowsAdd (dialog, wtAreasSelect, pcommon, WASelectEventProcessor, WASelectDialogProcessor);				dInfo = windowsLookUp (dialog);				SetWRefCon (dialog, (long) dInfo);		dInfo->inFront = true;		WASelectEventProcessor (NULL, dInfo, ((long) inMenuBar << 16) | mouseDown);		break;	case actionClose:		originalView = (*(((WindowPeek)(dialogInfo->dialog))->contRgn))->rgnBBox;		originalView.bottom = (dialogInfo->dialog)->portRect.bottom;		LDispose ((dialogInfo->common)->cASelect.list);				DisposePtr ((Ptr) dialogInfo->common);				DisposeDialog (dialogInfo->dialog);		windowsKill (dialogInfo->dialog);		break;			case actionActive:		DrawOnlyGrowIcon (dialogInfo->dialog);		MoveControl ((*(dialogInfo->common)->cASelect.list)->vScroll,			(*(dialogInfo->common)->cASelect.list)->rView.right + ((dialogInfo->inFront) ? 0 : 15),			(*(dialogInfo->common)->cASelect.list)->rView.top - 1);				break;	case actionBroadcast:			break;		case actionMenu:		SetPort (dialogInfo->dialog);		menuItem = (info >> 16) & 0xFF;				switch ((info >> 24) & 0xFF)		{		case msgM:					switch (menuItem)			{			case mSend:								iHandle = NewHandle (AreasNumber);				nm = 0;								for (ii = 0; ii < AreasNumber; ii++)				{					SetPt (&theCell, 0, ii);										dummy = 4;					LGetCell (&jj, &dummy, theCell, (dialogInfo->common)->cASelect.list);										if ((jj & 0x80000000L) != 0)					{						nm++;						(*iHandle)[ii] = true;					}					else						(*iHandle)[ii] = false;				}				if (nm)				{					Broadcast (wtMsgEdit, editSendto, (dialogInfo->common)->cASelect.area_number, (long) iHandle);					WASelectEventProcessor (event, dialogInfo, actionClose);				}				else					CallASndPlay (132);								DisposeHandle (iHandle);								break;			}		}		break;		case actionOpen:			break;		case mouseDown:		if ((info >> 16) != inMenuBar)			where = event->where;		switch (info >> 16)		{		case inMenuBar:					recalcWindowMenu ();			hMenu = GetMenuHandle (fileM + 256);			(*hMenu)->enableFlags = 0;						hMenu = GetMenuHandle (editM + 256);			(*hMenu)->enableFlags = 0;			hMenu = GetMenuHandle (msgM + 256);			(*hMenu)->enableFlags = ((dialogInfo->common)->cASelect.mode == mSendto) ?				(1L | (1L << mSend)) : 0;			hMenu = GetMenuHandle (nodeM + 256);			(*hMenu)->enableFlags = 0;			hMenu = GetMenuHandle (shuffleM + 256);			(*hMenu)->enableFlags = 0;			hMenu = GetMenuHandle (windowM + 256);			(*hMenu)->enableFlags = 0;			DrawMenuBar ();			break;		case inContent:					FindWindow (event->where, &window);						if (window != FrontWindow ())			{				if (((WindowPeek)FrontWindow ())->windowKind == myKind_top)					SysBeep (10);				else					SelectWindow (window);			}			else			{				SetPort (dialogInfo->dialog);				GlobalToLocal (&where);				if (LClick (where, event->modifiers, (dialogInfo->common)->cASelect.list) &&					(dialogInfo->common)->cASelect.mode != mSendto)				{					SetPt (&theCell, 0, 0);									if ( LGetSelect (true, &theCell, (dialogInfo->common)->cASelect.list) )					{						if (!theCell.v &&							((dialogInfo->common)->cASelect.mode == mCommentto ||							(dialogInfo->common)->cASelect.mode == mCommentQto))						{							CallASndPlay (132);							break;						}												switch ((dialogInfo->common)->cASelect.mode)						{						case mForward:		jj = editForward;	break;						case mReplyto:		jj = editReplyto;	break;						case mReplyQto:		jj = editReplyQto;	break;						case mCommentto:	jj = editCommentto;	break;						case mCommentQto:	jj = editCommentQto;break;						}						Broadcast (wtMsgEdit, jj,								(dialogInfo->common)->cASelect.area_number, theCell.v);						WASelectEventProcessor (event, dialogInfo, actionClose);					}				}			}			break;		case inZoomIn:		case inZoomOut:			if (TrackBox (dialogInfo->dialog, event->where, info >> 16))			{				ZoomWindow (dialogInfo->dialog, info >> 16, true);				AdjustWinSize (dialogInfo->dialog,						(dialogInfo->common)->cASelect.list,						(dialogInfo->dialog)->portRect.bottom);								originalView = (*(((WindowPeek)(dialogInfo->dialog))->contRgn))->rgnBBox;				originalView.bottom = (dialogInfo->dialog)->portRect.bottom;//				EraseRect (&(dialogInfo->dialog)->portRect);				InvalRect (&(dialogInfo->dialog)->portRect);			}			break;		case inDrag:			FindWindow (event->where, &window);						if (window != FrontWindow ())			{				if (((WindowPeek)FrontWindow ())->windowKind == myKind_top)					SysBeep (10);				else					SelectWindow (window);			}			else			{				DragWindow ( dialogInfo->dialog, event->where, &qd.screenBits.bounds );				originalView = (*(((WindowPeek)(dialogInfo->dialog))->contRgn))->rgnBBox;				originalView.bottom = (dialogInfo->dialog)->portRect.bottom;			}						break;		case inGoAway:					if (TrackGoAway (dialogInfo->dialog, event->where))			{				switch ((dialogInfo->common)->cASelect.mode)				{				case mForward:				case mReplyto:				case mReplyQto:				case mCommentto:				case mCommentQto:					Broadcast (wtMsgEdit, broadClose,							(dialogInfo->common)->cASelect.area_number, 0);				case mSendto:					WASelectEventProcessor (event, dialogInfo, actionClose);										break;				}			}						break;		case inGrow:					SetPort (dialogInfo->dialog);						GetDialogItem ( dialogInfo->dialog, 1, &iType, &iHandle, &rView );						newc = (*((dialogInfo->common)->cASelect.list))->cellSize.v;			rDataBnds.top = rView.top + newc * 8;			rDataBnds.bottom = qd.screenBits.bounds.bottom;			rDataBnds.left = (dialogInfo->dialog)->portRect.right;			rDataBnds.right = (dialogInfo->dialog)->portRect.right;			lSizeVH = GrowWindow ( dialogInfo->dialog, event->where, &rDataBnds );						if (lSizeVH)			{				AdjustWinSize (dialogInfo->dialog, (dialogInfo->common)->cASelect.list, HiWord (lSizeVH));				InvalRect (&(dialogInfo->dialog)->portRect);			}						break;		}			break;		case keyDown:	case autoKey:				SetPort (dialogInfo->dialog);		key = event->message & 0xFF;				switch (key)		{		case 0x1B:					switch ((dialogInfo->common)->cASelect.mode)			{			case mForward:			case mReplyto:			case mReplyQto:			case mCommentto:			case mCommentQto:				Broadcast (wtMsgEdit, broadClose,						(dialogInfo->common)->cASelect.area_number, 0);			case mSendto:				WASelectEventProcessor (event, dialogInfo, actionClose);								break;			}			break;						case EnterKey:		case ReturnKey:					if ((dialogInfo->common)->cASelect.mode == mSendto)				break;						SetPt (&theCell, 0, 0);					if ( LGetSelect (true, &theCell, (dialogInfo->common)->cASelect.list) )			{				if (!theCell.v &&					((dialogInfo->common)->cASelect.mode == mCommentto ||					(dialogInfo->common)->cASelect.mode == mCommentQto))				{					CallASndPlay (132);					break;				}								switch ((dialogInfo->common)->cASelect.mode)				{				case mForward:		jj = editForward;	break;				case mReplyto:		jj = editReplyto;	break;				case mReplyQto:		jj = editReplyQto;	break;				case mCommentto:	jj = editCommentto;	break;				case mCommentQto:	jj = editCommentQto;break;				}				Broadcast (wtMsgEdit, jj,						(dialogInfo->common)->cASelect.area_number, theCell.v);				WASelectEventProcessor (event, dialogInfo, actionClose);			}						break;					case 0x20:						if ((dialogInfo->common)->cASelect.mode == mSendto)			{				SetPt (&theCell, 0, 0);							if ( LGetSelect (true, &theCell, (dialogInfo->common)->cASelect.list) )				{					ii = 4;					LGetCell (&jj, &ii, theCell, (dialogInfo->common)->cASelect.list);									jj ^= 0x80000000L;										LSetCell (&jj, ii, theCell, (dialogInfo->common)->cASelect.list);				}			}						break;				case UpArrowKey:		//	Up		case DownArrowKey:		//	Down					newh = (*((dialogInfo->common)->cASelect.list))->dataBounds.bottom;					SetPt (&theCell, 0, 0);					if ( LGetSelect (true, &theCell, (dialogInfo->common)->cASelect.list) )				newc = theCell.v;			else				newc = (key == UpArrowKey) ? newh : -1;						neww = (key == UpArrowKey) ? newc - 1 : newc + 1;						if (neww >= newh)				neww = 0;			else				if (neww < 0)					neww = newh - 1;						SetPt (&theCell, 0, newc);			LSetSelect (false, theCell, (dialogInfo->common)->cASelect.list);						SetPt (&theCell, 0, neww);			LSetSelect (true, theCell, (dialogInfo->common)->cASelect.list);						LAutoScroll ((dialogInfo->common)->cASelect.list);			break;		case PageUpKey:			//	Up		case PageDownKey:		//	Down					GetDialogItem ( dialogInfo->dialog, 1, &iType, &iHandle, &rView );			dummy = ((dialogInfo->dialog)->portRect.bottom - rView.top) / (*((dialogInfo->common)->cASelect.list))->cellSize.v;			newh = (*((dialogInfo->common)->cASelect.list))->dataBounds.bottom;			if (dummy < newh)			{				SetPt (&theCell, 0, 0);							if ( LGetSelect (true, &theCell, (dialogInfo->common)->cASelect.list) )				{					newc = theCell.v;										neww = (key == PageUpKey) ? newc - dummy : newc + dummy;										if (neww >= newh)						neww = newh - 1;					else						if (neww < 0)							neww = 0;										SetPt (&theCell, 0, newc);					LSetSelect (false, theCell, (dialogInfo->common)->cASelect.list);										SetPt (&theCell, 0, neww);					LSetSelect (true, theCell, (dialogInfo->common)->cASelect.list);					LAutoScroll ((dialogInfo->common)->cASelect.list);				}			}			else			{				SetPt (&theCell, 0, 0);							if ( LGetSelect (true, &theCell, (dialogInfo->common)->cASelect.list) )				{					newc = theCell.v;										neww = (key == PageUpKey) ? 0 : newh - 1;										SetPt (&theCell, 0, newc);					LSetSelect (false, theCell, (dialogInfo->common)->cASelect.list);										SetPt (&theCell, 0, neww);					LSetSelect (true, theCell, (dialogInfo->common)->cASelect.list);					LAutoScroll ((dialogInfo->common)->cASelect.list);				}			}						break;		case HomeKey:					SetPt (&theCell, 0, 0);					if ( LGetSelect (true, &theCell, (dialogInfo->common)->cASelect.list) )			{				newc = theCell.v;				SetPt (&theCell, 0, newc);				LSetSelect (false, theCell, (dialogInfo->common)->cASelect.list);			}			SetPt (&theCell, 0, 0);			LSetSelect (true, theCell, (dialogInfo->common)->cASelect.list);			LAutoScroll ((dialogInfo->common)->cASelect.list);			break;		case EndKey:					newh = (*((dialogInfo->common)->cASelect.list))->dataBounds.bottom;			SetPt (&theCell, 0, 0);					if ( LGetSelect (true, &theCell, (dialogInfo->common)->cASelect.list) )			{				newc = theCell.v;				SetPt (&theCell, 0, newc);				LSetSelect (false, theCell, (dialogInfo->common)->cASelect.list);			}			SetPt (&theCell, 0, newh-1);			LSetSelect (true, theCell, (dialogInfo->common)->cASelect.list);			LAutoScroll ((dialogInfo->common)->cASelect.list);			break;		}		break;			case updateEvt:		SetPort (dialogInfo->dialog);		iRect = (*(((WindowPeek)(dialogInfo->dialog))->updateRgn))->rgnBBox;				GlobalToLocal (&topLeft(iRect));		GlobalToLocal (&botRight(iRect));		if (iRect.right > (*(dialogInfo->common)->cASelect.list)->rView.right)			iRect.right = (*(dialogInfo->common)->cASelect.list)->rView.right;		EraseRect (&iRect);		GetDialogItem (dialogInfo->dialog, 1, &iType, &iHandle, &rView );				SetRect (&rDataBnds, 0, 0, (dialogInfo->dialog)->portRect.right, rView.top - 1);		EraseRect (&rDataBnds);				MoveTo (0, rView.top - 1);		LineTo ((dialogInfo->dialog)->portRect.right, rView.top - 1);		BeginUpdate (dialogInfo->dialog);		DrawOnlyGrowIcon (dialogInfo->dialog);		EndUpdate (dialogInfo->dialog);		{			RgnHandle	mRgn;						mRgn = NewRgn ();			RectRgn (mRgn, &iRect);			LUpdate ( mRgn, (dialogInfo->common)->cASelect.list );			if (!(dialogInfo->inFront))			{				iRect = (*(dialogInfo->common)->cASelect.list)->rView;				iRect.left = iRect.right;				iRect.right += 15;				iRect.bottom -= 15;				EraseRect (&iRect);				MoveTo ((*(dialogInfo->common)->cASelect.list)->rView.right,						(*(dialogInfo->common)->cASelect.list)->rView.top);				LineTo ((*(dialogInfo->common)->cASelect.list)->rView.right,						(*(dialogInfo->common)->cASelect.list)->rView.bottom);			}			DisposeRgn (mRgn);		}		break;	}}void WASelectDialogProcessor (EventRecord *event, windowsQElPtr dialogInfo, long info){	DialogPtr	dialog;	short		iHit;	Point		where;	}