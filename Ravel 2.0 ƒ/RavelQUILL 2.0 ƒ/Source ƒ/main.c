/*ееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееее*////////*ееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееее*/#include <string.h>#include <Sound.h>#include "log.h"#include "PascalStr.h"#include "TE32K.h"//#include "Ravel_FTN.h"#include "ravel_msg_base.h"#include "ravel_tmp_base.h"#include "Ravel_Prefs.h"#include "Preferences.h"#include "key.h"#include "rPrinting.h"#include "nodelist.h"//#include "BaseManager.h"#include "Sublauncher.h"/*ееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееее*/#include "busy.h"#include "Filter.h"#include "DialogLib.h"#include "PopUpLib.h"#include "myTEdit.h"#include "CommonData.h"#include "WindowsList.h"#include "WAreas.h"#include "WSubjects.h"#include "WView.h"#include "WEdit.h"#include "WASelect.h"#include "WNodes.h"#include "WAddressee.h"#include "WFind.h"/*ееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееее*/#include "Plug-Ins.h"#include "myEnv.h"#include "Templates.h"//#include "Cookies.h"#include "multisaver.h"#include "rMenus.h"#include "do_about.h"/*ееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееее*/extern	long	printfontsize;extern	Str255	printfontname;extern	short	printfont;extern	Str63	fontname;short			viewFont;short			viewSize = 9;Boolean			needpgf = false;MenuHandle		myMenus [CntMenus];MenuHandle		NamesMenu;MenuHandle		OriginsMenu;Cursor			crs[3];short			crsI;Boolean			gQuit;Boolean			gNotified, ScanComplete;DialogPtr		dSplash;extern homeHndl	homesystem;			//	е	Home system structextern Str255	ShufflerPathName;typedef struct _wloc {	Point	topleft;	short	bottom;	} wloc;static	wloc	**locator;static	short	inSublaunch;/******************************************************************/static void AdjustMenus (void);static void DoCommand (long mResult);static void ToolBoxInit (void);void		DeleteMark (long area, long message);void		AppendMark (long area);void		DoEvent (EventRecord *event);void		DoSlice (void);short		LookForAreaNumber ( char *AreaName );void		putProgressName (Str255 name);void		InitProgress ( float );void		DrawProgress ( long );Boolean		PrepareUnlock();void		PerformUnlock();void		SimulateScanComplete();pascal void LDEFAreas (short lMessage, Boolean lSelect, Rect *lRect, Cell lCell,				short lDataOffset, short lDataLen, ListHandle lHandle);pascal void LDEFSubj (short lMessage, Boolean lSelect, Rect *lRect, Cell lCell,				short lDataOffset, short lDataLen, ListHandle lHandle);pascal void LDEFASelect (short lMessage, Boolean lSelect, Rect *lRect, Cell lCell,				short lDataOffset, short lDataLen, ListHandle lHandle);pascal void LDEFNodes (short lMessage, Boolean lSelect, Rect *lRect, Cell lCell,				short lDataOffset, short lDataLen, ListHandle lHandle);pascal void LDEFAddressee (short lMessage, Boolean lSelect, Rect *lRect, Cell lCell,				short lDataOffset, short lDataLen, ListHandle lHandle);/******************************************************************/enum {	uppAEHandlerProcInfo = kPascalStackBased		 | RESULT_SIZE(SIZE_CODE(sizeof(OSErr)))		 | STACK_ROUTINE_PARAMETER(1, SIZE_CODE(sizeof(Ptr)))		 | STACK_ROUTINE_PARAMETER(2, SIZE_CODE(sizeof(Ptr)))		 | STACK_ROUTINE_PARAMETER(3, SIZE_CODE(sizeof(long))),//	pascal Boolean myAlertProc (DialogPtr theDialog, EventRecord *theEvent, short *itemHit)	uppModalProcInfo = kPascalStackBased		 | RESULT_SIZE(SIZE_CODE(sizeof(Boolean)))		 | STACK_ROUTINE_PARAMETER(1, SIZE_CODE(sizeof(Ptr)))		 | STACK_ROUTINE_PARAMETER(2, SIZE_CODE(sizeof(Ptr)))		 | STACK_ROUTINE_PARAMETER(3, SIZE_CODE(sizeof(Ptr))),};Handle		*markArray;#define	kRavelEventClass	'R&vl'#define	kAEEnqueueCmd		'enQu'#define	kAENorifyQuill		'ntQu'#define	kAEScanComplete		'scQu'#define SuspendResume	1#define ResumeMask		1#if defined(powerc) || defined(__powerc)	UniversalProcPtr	uupMyAlertProc;#endifpascal Boolean myAlertProc ( DialogPtr theDialog, EventRecord *theEvent, short *itemHit );pascal Boolean myAlertProc (DialogPtr theDialog, EventRecord *theEvent, short *itemHit){	Boolean 	result = false;	char		key;	switch (theEvent->what)	{	case mouseDown:				result = false;		break;		case keyDown:	case autoKey:			key = theEvent->message & 0xFF;		result = true;		if (key == 0x03 || key == 0x0D)			*itemHit = 1;		else			if (key == 0x1B)				*itemHit = 2;			else				result = false;				break;	}	return result;}static void InitMarks (void){	short	i;		if (!(markArray = (Handle *) NewPtr ( (AreasNumber + 2) * sizeof (Handle) )))	{		putlog (lgALRT, "Can't create marks (not enough memory?) for entire base╔");		ParamText ("\pCan't create marks (not enough memory?) for base. See log for more details.\rUnable to proceed.", "\p", "\p", "\p");		Alert (500, NULL);		ExitToShell ();	}	for (i=0; i <= AreasNumber; i++)	{		if (msgbase_open (i, false) == -1)		{			putlog (lgALRT, "Base #%d corrupted! Can't proceed╔", i);			ParamText ("\pMessage base corrupted. See log for more details.\rUnable to proceed.", "\p", "\p", "\p");			Alert (500, NULL);			ExitToShell ();		}		if (!(markArray[i] = NewHandleClear (msgbase_getnummsg ())))		{			putlog (lgALRT, "Can't create marks (not enough memory?) for base #%d╔", i);			ParamText ("\pCan't create marks (not enough memory?) for base. See log for more details.\rUnable to proceed.", "\p", "\p", "\p");			Alert (500, NULL);			ExitToShell ();		}		msgbase_close (CLOSE_ONLY);	}	if (msgbase_open (BADAREA, false) == -1)	{		putlog (lgALRT, "Base BADAREA corrupted! Can't proceed╔", i);		ParamText ("\pMessage base corrupted. See log for more details.\rUnable to proceed.", "\p", "\p", "\p");		Alert (500, NULL);		ExitToShell ();	}		if (!(markArray[AreasNumber+1] = NewHandleClear (msgbase_getnummsg ())))	{		putlog (lgALRT, "Can't create marks (not enough memory?) for base BADAREA╔", i);		ParamText ("\pCan't create marks (not enough memory?) for base. See log for more details.\rUnable to proceed.", "\p", "\p", "\p");		Alert (500, NULL);		ExitToShell ();	}	msgbase_close (CLOSE_ONLY);}void DeleteMark (long area, long message){	long	nm = msgbase_getnummsg ();	long	i;			if (nm)	{		for (i = message; i < nm-1; i++)			(*markArray[area])[i] = (*markArray[area])[i+1];				SetHandleSize (markArray[area], nm - 1);	}}void AppendMark (long area){	long	nm = msgbase_getnummsg ();	long	i;			SetHandleSize (markArray[area], nm + 1);	(*markArray[area])[nm] = 0;}static void KillMarks (void){	short	i;		for (i=0; i <= AreasNumber+1; i++)		DisposeHandle (markArray[i]);		DisposePtr ((Ptr) markArray);}/******************************************************************//******************************************************************/static void ToolBoxInit (void){	short		i;	CursHandle	cursH;	Handle		htmp;		InitGraf (&qd.thePort);	InitFonts ();	FlushEvents (everyEvent, 0);	InitWindows ();	InitMenus ();	TEInit ();	TE32KInit ();	InitDialogs (NULL);	InitCursor ();	MaxApplZone ();	for (i=0; i<20; i++)		MoreMasters ();	SetEventMask (everyEvent);	cursH = GetCursor (iBeamCursor);	HLock ((Handle) cursH);	crs[0] = **cursH;	cursH = GetCursor (watchCursor);	HLock ((Handle) cursH);	crs[1] = **cursH;	crsI = -1;	printRecordH = (THPrint)NewHandle( sizeof( TPrint ) );	PrOpen ();	PrintDefault (printRecordH);	PrClose ();	}static short myOpenPrefFile (void){	short	wdRefNum, RefNum;	long	dirID;		if (OpenAnyDir ( kPreferencesFolderType, &wdRefNum, &dirID ) != noErr)		return -1;		RefNum = HOpenResFile (wdRefNum, dirID, "\pRavelQUILL Prefs", fsRdWrPerm);	if (RefNum == -1)	{		HCreate (wdRefNum, dirID, "\pRavelQUILL Prefs", 'RvlQ', 'pref');		HCreateResFile (wdRefNum, dirID, "\pRavelQUILL Prefs");		RefNum = HOpenResFile (wdRefNum, dirID, "\pRavelQUILL Prefs", fsRdWrPerm);	}	return RefNum;}static void Loop (void){	EventRecord		event;	WaitNextEvent (everyEvent, &event, 60, NULL);	DoEvent (&event);}static pascal OSErr MyHandleQuit (const AppleEvent *theAppleEvent, AppleEvent *reply, long handlerRefcon){	gQuit = true;	Broadcast (wtMsgEdit, broadClose, -1, 0);	if (SuchWindow (wtMsgEdit))		gQuit = false;	else	{		Broadcast (wtNodelist, broadClose, 0, 0);		Broadcast (wtSubjects, broadClose, 0, 0);		Broadcast (wtMsgView, broadClose, 0, 0);		Broadcast (wtAreasList, broadClose, 0, 0);		Broadcast (wtFindDlg, broadClose, 0, 0);		Broadcast (wtAddressee, broadClose, 0, 0);	}	return (gQuit) ? noErr : userCanceledErr;}static pascal OSErr MyHandleOAPP (const AppleEvent *theAppleEvent, AppleEvent *reply, long handlerRefcon){	WAreasEventProcessor (NULL, NULL, actionCreate);	return	noErr;}static pascal OSErr MyHandleRemind (const AppleEvent *theAppleEvent, AppleEvent *reply, long handlerRefcon){#if defined(powerc) || defined(__powerc)#else#endif	gNotified = true;	return	noErr;}static pascal OSErr MyHandleScanComplete (const AppleEvent *theAppleEvent, AppleEvent *reply, long handlerRefcon){#if defined(powerc) || defined(__powerc)#else#endif	SimulateScanComplete();	return	noErr;}void SimulateScanComplete(){	ScanComplete = true;}Boolean PrepareUnlock(){	if (inSublaunch)		return false;	else	{		Broadcast (wtMsgEdit, broadClose, -1, 0);		if (SuchWindow (wtMsgEdit))			return false;		else		{			Broadcast (wtNodelist, broadClose, 0, 0);			Broadcast (wtSubjects, broadClose, 0, 0);			Broadcast (wtMsgView, broadClose, 0, 0);			Broadcast (wtAreasList, broadClose, 0, 0);			Broadcast (wtFindDlg, broadClose, 0, 0);			Broadcast (wtAddressee, broadClose, 0, 0);		}	}	inSublaunch = true;	ScanComplete = false;		return true;}void PerformUnlock(){	KillMarks ();	msgbase_close (CLOSE_ONLY);	msgbase_dispose ();	KillPreference ();	base_bsy_clear ();}static void DoMenu (register long menuResult, short options){	short			menuItem, menu, i;	WindowPtr		window;	windowsQElPtr	dialogInfo;	MenuHandle		theMenu;	Str255			daName;		register void (*EventProcessor) (EventRecord *event, struct _window *dialogInfo, long info);	menuItem = LoWord (menuResult);	menu = HiWord (menuResult);	if (menu == namesID)	{		if (cuser != menuItem - 1)		{			CheckMenuItem (NamesMenu, cuser + 1, false);			CheckMenuItem (NamesMenu, menuItem, true);			cuser = menuItem - 1;		}	}	else		if (menu == originsID)		{			if (corigin != menuItem - 1)			{				CheckMenuItem (OriginsMenu, corigin + 1, false);				CheckMenuItem (OriginsMenu, menuItem, true);				corigin = menuItem - 1;			}		}		else		{			menu -= 256;			switch (menu)			{			case appleM:							switch(menuItem)				{				case aAbout:					HiliteMenu (0);					do_about (options);										break;				default:		//	еее	Others╔										GetMenuItemText (GetMenuHandle (256), menuItem, daName);					OpenDeskAcc(daName);										break;				}								break;						case fileM:						//	еее	File menu							switch (menuItem)				{				case fOpen:									if (windowsLookUp(window = FrontWindow ()) && (dialogInfo = (windowsQElPtr) GetWRefCon (window)))					{						EventProcessor = dialogInfo->EventProcessor;						if (EventProcessor)							EventProcessor (NULL, dialogInfo, actionOpen);					}					break;				case fClose:									if (windowsLookUp(window = FrontWindow ()) && (dialogInfo = (windowsQElPtr) GetWRefCon (window)))					{						if (options & optionKey)							Broadcast (dialogInfo->dialogType, broadClose, -1, 0);						else						{							EventProcessor = dialogInfo->EventProcessor;							if (EventProcessor)								EventProcessor (NULL, dialogInfo, actionClose);						}					}					break;								case fPageSetup:					PrOpen ();					PrStlDialog (printRecordH);					PrClose ();					break;								case fQuit:									gQuit = true;					Broadcast (wtMsgEdit, broadClose, -1, 0);					if (SuchWindow (wtMsgEdit))						gQuit = false;					else					{						Broadcast (wtNodelist, broadClose, 0, 0);						Broadcast (wtSubjects, broadClose, 0, 0);						Broadcast (wtMsgView, broadClose, 0, 0);						Broadcast (wtAreasList, broadClose, 0, 0);						Broadcast (wtFindDlg, broadClose, 0, 0);						Broadcast (wtAddressee, broadClose, 0, 0);					}					break;				default:									if (windowsLookUp (window = FrontWindow ()) && (dialogInfo = (windowsQElPtr) GetWRefCon (window)))					{						EventProcessor = dialogInfo->EventProcessor;						if (EventProcessor)							EventProcessor (NULL, dialogInfo, ((long) menu << 24) | ((long) menuItem << 16) | actionMenu);					}										break;				}				break;						case editM:						//	еее	Edit menu								switch (menuItem)				{				case iShowKludges:										needfilter = !needfilter;					theMenu = GetMenu (editM + 256);					CheckMenuItem (theMenu, iShowKludges, needfilter);										for (i = 0; i <= AreasNumber+1; i++)						Broadcast (wtMsgView, broadRedrawCell, i, 0);										break;								case iShowPgf:										needpgf = !needpgf;					theMenu = GetMenu (editM + 256);					CheckMenuItem (theMenu, iShowPgf, needpgf);										for (i = 0; i <= AreasNumber+1; i++)						Broadcast (wtMsgView, broadRedrawCell, i, 0);										break;								default:									if (windowsLookUp (window = FrontWindow ()) && (dialogInfo = (windowsQElPtr) GetWRefCon (window)))					{						EventProcessor = dialogInfo->EventProcessor;						if (EventProcessor)							EventProcessor (NULL, dialogInfo, ((long) menu << 24) | ((long) menuItem << 16) | actionMenu);					}										break;				}								break;			case windowM:					//	еее	Windows menu				switch (menuItem)				{				case wSubjects:									if (windowsLookUp (window = FrontWindow ()) && (dialogInfo = (windowsQElPtr) GetWRefCon (window)))					{						EventProcessor = dialogInfo->EventProcessor;						if (EventProcessor)							EventProcessor (NULL, dialogInfo, ((long) menu << 24) | ((long) menuItem << 16) | actionMenu);					}										break;				case wAreas:										if (dialogInfo = windowsOpened (wtAreasList, 0, 0))						SelectWindow (dialogInfo->dialog);					break;									default:										selectWindow (menuItem);					break;				}				break;/*						case nodeM:				switch (menuItem)				{				case nBrowse:										WNodeEventProcessor (NULL, NULL, actionCreate);					break;				}								break;*/			case shuffleM:								if (!PrepareUnlock())					break;				switch (menuItem)				{				case sLink:										doCommandForSHUFFLER ("LINK");					break;								case sScan:										doCommandForSHUFFLER ("SCAN");					break;								case sToss:										doCommandForSHUFFLER ("TOSS");					break;								case sPurge:										doCommandForSHUFFLER ("PURGE");					break;								case sPack:										doCommandForSHUFFLER ("PACK");					break;				case sUndelete:										doCommandForSHUFFLER ("UNDEL");					break;								case sImport:					//					doCommandForSHUFFLER ("IMPORT");					if (!ReadPreference ())					{						ParamText ("\pRavel's preferences file Ravel.PREF not found or corrupted.\rUnable to proceed.", "\p", "\p", "\p");						Alert (500, NULL);						ExitToShell ();					}										KillMarks ();					base_bsy_clear ();					tmpbase_open ();					tmpbase_close ();					base_bsy_raise ();					inSublaunch = false;					ScanComplete = false;					InitMarks ();					WAreasEventProcessor (NULL, NULL, actionCreate);					break;								default:				//					menuItem -= sFirstCustom;					theMenu = GetMenu (shuffleM + 256);					GetMenuItemText (theMenu, menuItem, daName);					daName[daName[0]+1] = 0;					doCommandForSHUFFLER ((char *) &daName[1]);										break;				}								if (menuItem == sImport)					break;								if (inSublaunch && ApplicationLaunch (ShufflerPathName))				{					PerformUnlock();				}				else					inSublaunch = false;								if (!inSublaunch)				{//					if (!ReadPreference ())//					{//						ParamText ("\pRavel's preferences file Ravel.PREF not found or corrupted.\rUnable to proceed.", "\p", "\p", "\p");//						Alert (500, NULL);//						ExitToShell ();//					}//					base_bsy_raise ();//					InitMarks ();					WAreasEventProcessor (NULL, NULL, actionCreate);				}								break;						case plugsM:								theMenu = GetMenu (plugsM + 256);				GetMenuItemText (theMenu, menuItem, daName);				daName[daName[0]+1] = 0;				CallNamedPlugIns (daName);				break;						default:							if (windowsLookUp (window = FrontWindow ()) && (dialogInfo = (windowsQElPtr) GetWRefCon (window)))				{					EventProcessor = dialogInfo->EventProcessor;					if (EventProcessor)						EventProcessor (NULL, dialogInfo, ((long) menu << 24) | ((long) menuItem << 16) | actionMenu);				}								break;			}		}	HiliteMenu (0);}void main (void){	short 	i, j, oldRes, prefRes;	unsigned long	checksum = 0;	Handle	htmp;	Str63	stemp;	ProcessSerialNumber	processSN;		AEEventHandlerUPP	uupMyHandleOAPP,						uupMyHandleQuit,						uupMyHandleRemind,						uupMyHandleScanComplete;	ListDefUPP			uupLDEFAreasProc,						uupLDEFSubjProc,						uupLDEFNodesProc,						uupLDEFASelectProc,						uupLDEFAddresseeProc;		ToolBoxInit ();		GetDateTime ( (unsigned long *) &qd.randSeed );		corigin = 0;	origins = 1;	cuser = 0;	users = 1;		prefRes = myOpenPrefFile ();		if (prefRes == -1)	{		ParamText ("\pCan't create/open RavelQUILL's preferences.\rUnable to proceed.", "\p", "\p", "\p");		Alert (500, NULL);		ExitToShell ();	}		oldRes = CurResFile ();	UseResFile (prefRes);		locator = (wloc **) Get1Resource ('WLOC', 0);		if (!locator)		locator = (wloc **) NewHandleClear (sizeof (wloc) * 10);	else		DetachResource ((Handle) locator);	MoveHHi ((Handle) locator);	HLock ((Handle) locator);		htmp = Get1Resource ('Pref', 0);		if (htmp)	{		corigin = (*htmp)[0];		cuser = (*htmp)[1];			ReleaseResource (htmp);	}	UseResFile (oldRes);	CloseResFile (prefRes);		if (!ReadPreference ())	{		ParamText ("\pRavel's preferences file Ravel.PREF not found or corrupted.\rUnable to proceed.", "\p", "\p", "\p");		Alert (500, NULL);		ExitToShell ();	}		openlog ();#ifndef LITE	putlog ( lgNOPE, "Begin, " QUILLNAME " " RAVELVERS " " RAVELISA " " RAVELBUILD );#else	putlog ( lgNOPE, "Begin, " QUILLNAME " " RAVELVERS " " RAVELBUILD );#endif	if (base_bsy_check ())	{		if (FindAProcess ('APPL', 'RvlS', &processSN) == noErr)		{			putlog ( lgALRT, "Base is busy." );			ParamText ("\pBase is busy.\rTry later.", "\p", "\p", "\p");			Alert (500, NULL);			ExitToShell ();		}	}		if (msgbase_init () != noErr)	{		putlog ( lgALRT, "Cannot open message base." );		ParamText ("\pCannot open message base.\rUnable to proceed.", "\p", "\p", "\p");		Alert (500, NULL);		ExitToShell ();	}	#ifndef LITE#ifdef PROTECTED	if (!CheckKey())	{		ExitToShell ();	}		j = GetHandleSize (keys.Invalidater)/4;	for (i=0;i<j-1;i++)	{		if (((unsigned long *)*keys.Invalidater)[i] == keys.crc)			checksum++;		checksum += ((unsigned long *)*keys.Invalidater)[i];	}		if (checksum != ((unsigned long *)*keys.Invalidater)[i] || j<0x200/4)	{		Alert (127, NULL);		ExitToShell ();	}	if (keys.crc != keys.oldcrc)		ExitToShell ();	if ((keys.oldcs+1+keys.cs)&0xFFFF)		ExitToShell ();		pStrCopy (keys.regName, (*homesystem)->sysop);	(*homesystem)->mainAddr.ad = keys.regAddr;#endif#endif	tmpbase_init ();		base_bsy_raise ();		do_splash (&dSplash);//	dSplash = GetNewDialog (200, NULL, (WindowPtr) -1);//	DrawDialog (dSplash);#if defined(powerc) || defined(__powerc)	uupMyAlertProc = NewRoutineDescriptor ((ProcPtr) myAlertProc, uppModalProcInfo, GetCurrentISA ());#endif	ReadNodeList ();	(*homesystem)->system[(*homesystem)->system[0]+1] = 0;	origin[0] = NewPtr ((*homesystem)->system[0]+1);	strcpy ( origin[0], (char *) &(*homesystem)->system[1]);	notepad = NULL;	custom = NULL;		fontname[0] = 0;	padname[0] = 0;	cookname[0] = 0;		(*homesystem)->sysop[(*homesystem)->sysop[0]+1] = 0;	username[0] = NewPtr ((*homesystem)->sysop[0]+1);	strcpy ( username[0], (char *) &(*homesystem)->sysop[1]);		ReadTemplates ();//	ReadCookies ();	corigin = (corigin < origins) ? corigin : 0;		cuser = (cuser < users) ? cuser : 0;		InitMarks ();	htmp = Get1Resource ( 'LDEF', 128 );#if defined(powerc) || defined(__powerc)	uupLDEFAreasProc = NewRoutineDescriptor ((ProcPtr) LDEFAreas, uppListDefProcInfo, GetCurrentISA ());	*((long *)((*htmp)+2)) = (long) uupLDEFAreasProc;#else	*((long *)((*htmp)+2)) = (long) LDEFAreas;#endif	htmp = Get1Resource ( 'LDEF', 129 );#if defined(powerc) || defined(__powerc)	uupLDEFSubjProc = NewRoutineDescriptor ((ProcPtr) LDEFSubj, uppListDefProcInfo, GetCurrentISA ());	*((long *)((*htmp)+2)) = (long) uupLDEFSubjProc;#else	*((long *)((*htmp)+2)) = (long) LDEFSubj;#endif		htmp = Get1Resource ( 'LDEF', 130 );#if defined(powerc) || defined(__powerc)	uupLDEFNodesProc = NewRoutineDescriptor ((ProcPtr) LDEFNodes, uppListDefProcInfo, GetCurrentISA ());	*((long *)((*htmp)+2)) = (long) uupLDEFNodesProc;#else	*((long *)((*htmp)+2)) = (long) LDEFNodes;#endif		htmp = Get1Resource ( 'LDEF', 131 );#if defined(powerc) || defined(__powerc)	uupLDEFASelectProc = NewRoutineDescriptor ((ProcPtr) LDEFASelect, uppListDefProcInfo, GetCurrentISA ());	*((long *)((*htmp)+2)) = (long) uupLDEFASelectProc;#else	*((long *)((*htmp)+2)) = (long) LDEFASelect;#endif		htmp = Get1Resource ( 'LDEF', 132 );#if defined(powerc) || defined(__powerc)	uupLDEFAddresseeProc = NewRoutineDescriptor ((ProcPtr) LDEFAddressee, uppListDefProcInfo, GetCurrentISA ());	*((long *)((*htmp)+2)) = (long) uupLDEFAddresseeProc;#else	*((long *)((*htmp)+2)) = (long) LDEFAddressee;#endif		windowsInit ();		// prefs handling		WAreasEventProcessor	((EventRecord *) &((*locator)[wtAreasList]), NULL, actionSetSize);	WSubjectsEventProcessor	((EventRecord *) &((*locator)[wtSubjects]), NULL, actionSetSize);	WViewEventProcessor		((EventRecord *) &((*locator)[wtMsgView]), NULL, actionSetSize);	WEditEventProcessor		((EventRecord *) &((*locator)[wtMsgEdit]), NULL, actionSetSize);	WASelectEventProcessor	((EventRecord *) &((*locator)[wtAreasSelect]), NULL, actionSetSize);	WNodeEventProcessor		((EventRecord *) &((*locator)[wtNodelist]), NULL, actionSetSize);	WFindEventProcessor		((EventRecord *) &((*locator)[wtFindDlg]), NULL, actionSetSize);	WProgressEventProcessor	((EventRecord *) &((*locator)[9]), NULL, actionSetSize);	WAddresseeEventProcessor((EventRecord *) &((*locator)[wtAddressee]), NULL, actionSetSize);		for (i=appleM; i<CntMenus; i++)		myMenus[i] = GetMenu (i+256);	NamesMenu = GetMenu (namesID);	OriginsMenu = GetMenu (originsID);	AppendResMenu (myMenus [appleM], 'DRVR');	InsertMenu (myMenus [appleM], 0);	InsertMenu (myMenus [fileM], 0);	InsertMenu (myMenus [editM], 0);	InsertMenu (myMenus [msgM], 0);	InsertMenu (myMenus [nodeM], 0);	InsertMenu (myMenus [shuffleM], 0);	InsertMenu (myMenus [windowM], 0);	InsertMenu (myMenus [plugsM], 0);//	pluginscontrol = NULL;//	pluginscontrolppc = NULL;	PreparePlugsStructure ();	LookForPlugIns ();	if (custom)	{		customRecordPtr		customCall;				AppendMenu ( myMenus [shuffleM], "\p(-" );			customCall = custom;				while (customCall)		{			AppendMenu ( myMenus [shuffleM], customCall->name );			customCall = customCall->next_custom;		}	}	if (notepad)	{		Str255		s_temp;		notePtr		tempNote;				AppendMenu ( myMenus [nodeM], "\p(-" );			tempNote = notepad;				while (tempNote)		{			if (tempNote->pad_name[0])				pStrCopy ( tempNote->pad_name, s_temp );			else				pStrCopy ( "\pUnnamed╔", s_temp );						AppendMenu ( myMenus [nodeM], s_temp );			tempNote = tempNote->next_note;		}	}	#ifndef LITE	for (i = 0; i < users; i++)#else	i = 0;#endif	{		strcpy ((char *) &stemp[1], username[i]);		stemp[0] = strlen (username[i]);		AppendMenu (NamesMenu, stemp);	}	#ifndef LITE	CheckMenuItem (NamesMenu, cuser + 1, true);#else	CheckMenuItem (NamesMenu, 1, true);#endif	InsertMenu (NamesMenu, -1);#ifndef LITE	for (i = 0; i < origins; i++)#else	i = 0;#endif	{		strcpy ((char *) &stemp[1], origin[i]);		stemp[0] = strlen (origin[i]);		AppendMenu (OriginsMenu, "\pDum");		SetMenuItemText (OriginsMenu, i+1, stemp); 	}	#ifndef LITE	CheckMenuItem (OriginsMenu, corigin + 1, true);#else	CheckMenuItem (OriginsMenu, 1, true);#endif	InsertMenu (OriginsMenu, -1);	needfilter = false;	inSublaunch = false;		DrawMenuBar ();		GetFNum ((fontname[0] != 0) ? fontname : "\p.q_Ravel_866", &viewFont);	if (printfontname[0] != 0)		GetFNum (printfontname, &printfont);	else		if (fontname[0] != 0)		{//			printfontsize = 12;			printfont = viewFont;		}		else		{			printfontsize = 0;			printfont = 0;		}	gQuit = false;	gNotified = false;	ScanComplete = false;#if defined(powerc) || defined(__powerc)	uupMyHandleOAPP = NewRoutineDescriptor ((ProcPtr) MyHandleOAPP, uppAEHandlerProcInfo, GetCurrentISA ());	uupMyHandleQuit = NewRoutineDescriptor ((ProcPtr) MyHandleQuit, uppAEHandlerProcInfo, GetCurrentISA ());	uupMyHandleRemind = NewRoutineDescriptor ((ProcPtr) MyHandleRemind, uppAEHandlerProcInfo, GetCurrentISA ());	uupMyHandleScanComplete = NewRoutineDescriptor ((ProcPtr) MyHandleScanComplete, uppAEHandlerProcInfo, GetCurrentISA ());		if (AEInstallEventHandler (kCoreEventClass, kAEQuitApplication, uupMyHandleQuit, 0, false))		DebugStr ("\pAE Installation failed!");	if (AEInstallEventHandler(kCoreEventClass, kAEOpenApplication, uupMyHandleOAPP, 0, false))		DebugStr ("\pAE Installation failed!");	if (AEInstallEventHandler(kCoreEventClass, kAEOpenDocuments, uupMyHandleOAPP, 0, false))		DebugStr ("\pAE Installation failed!");	if (AEInstallEventHandler(kRavelEventClass, kAENorifyQuill, uupMyHandleRemind, 0, false))		DebugStr ("\pAE Installation failed!");	if (AEInstallEventHandler(kRavelEventClass, kAEScanComplete, uupMyHandleScanComplete, 0, false))		DebugStr ("\pAE Installation failed!");#else	if (AEInstallEventHandler (kCoreEventClass, kAEQuitApplication, &MyHandleQuit, 0, false))		DebugStr ("\pAE Installation failed!");	if (AEInstallEventHandler(kCoreEventClass, kAEOpenApplication, &MyHandleOAPP, 0, false))		DebugStr ("\pAE Installation failed!");	if (AEInstallEventHandler(kCoreEventClass, kAEOpenDocuments, &MyHandleOAPP, 0, false))		DebugStr ("\pAE Installation failed!");	if (AEInstallEventHandler(kRavelEventClass, kAENorifyQuill, &MyHandleRemind, 0, false))		DebugStr ("\pAE Installation failed!");	if (AEInstallEventHandler(kRavelEventClass, kAEScanComplete, &MyHandleScanComplete, 0, false))		DebugStr ("\pAE Installation failed!");#endif	//	TE32KFromScrap ();		while (!gQuit)		Loop ();	prefRes = myOpenPrefFile ();		if (prefRes == -1)	{		putlog ( lgALRT, "Can't create/open RavelQUILL's preferences." );		ParamText ("\pCan't create/open RavelQUILL's preferences.\rUnable to proceed.", "\p", "\p", "\p");		Alert (500, NULL);		ExitToShell ();	}		oldRes = CurResFile ();	UseResFile (prefRes);	htmp = Get1Resource ('WLOC', 0);	if (htmp)	{		RemoveResource (htmp);		DisposeHandle (htmp);	}		WAreasEventProcessor	((EventRecord *) &((*locator)[wtAreasList]), NULL, actionGetSize);	WSubjectsEventProcessor	((EventRecord *) &((*locator)[wtSubjects]), NULL, actionGetSize);	WViewEventProcessor		((EventRecord *) &((*locator)[wtMsgView]), NULL, actionGetSize);	WEditEventProcessor		((EventRecord *) &((*locator)[wtMsgEdit]), NULL, actionGetSize);	WASelectEventProcessor	((EventRecord *) &((*locator)[wtAreasSelect]), NULL, actionGetSize);	WNodeEventProcessor		((EventRecord *) &((*locator)[wtNodelist]), NULL, actionGetSize);	WFindEventProcessor		((EventRecord *) &((*locator)[wtFindDlg]), NULL, actionGetSize);	WProgressEventProcessor	((EventRecord *) &((*locator)[9]), NULL, actionGetSize);	WAddresseeEventProcessor((EventRecord *) &((*locator)[wtAddressee]), NULL, actionGetSize);	AddResource ((Handle) locator, 'WLOC', 0, "\p");		htmp = Get1Resource ('Pref', 0);	if (htmp)	{		RemoveResource (htmp);		DisposeHandle (htmp);	}		htmp = NewHandle (sizeof (short));	(*htmp)[0] = corigin;		(*htmp)[1] = cuser;	AddResource (htmp, 'Pref', 0, "\p");	UseResFile (oldRes);	CloseResFile (prefRes);//	ZeroScrap ();//	TE32KToScrap ();	CloseNodeList ();	if (!inSublaunch)	{		KillMarks ();		base_bsy_clear ();	}		msgbase_close (0);	msgbase_dispose ();#if defined(powerc) || defined(__powerc)	DisposeRoutineDescriptor (uupMyAlertProc);	AERemoveEventHandler (kCoreEventClass, kAEQuitApplication, uupMyHandleQuit, false);	AERemoveEventHandler (kCoreEventClass, kAEOpenApplication, uupMyHandleOAPP, false);	AERemoveEventHandler (kCoreEventClass, kAEOpenDocuments, uupMyHandleOAPP, false);	AERemoveEventHandler (kRavelEventClass, kAENorifyQuill, uupMyHandleRemind, false);	AERemoveEventHandler (kRavelEventClass, kAEScanComplete, uupMyHandleScanComplete, false);	DisposeRoutineDescriptor (uupMyHandleQuit);	DisposeRoutineDescriptor (uupMyHandleOAPP);	DisposeRoutineDescriptor (uupMyHandleRemind);	DisposeRoutineDescriptor (uupMyHandleScanComplete);	DisposeRoutineDescriptor (uupLDEFAreasProc);	DisposeRoutineDescriptor (uupLDEFSubjProc);	DisposeRoutineDescriptor (uupLDEFNodesProc);	DisposeRoutineDescriptor (uupLDEFASelectProc);	DisposeRoutineDescriptor (uupLDEFAddresseeProc);#else	AERemoveEventHandler (kCoreEventClass, kAEQuitApplication, &MyHandleQuit, false);	AERemoveEventHandler (kCoreEventClass, kAEOpenApplication, &MyHandleOAPP, false);	AERemoveEventHandler (kCoreEventClass, kAEOpenDocuments, &MyHandleOAPP, false);	AERemoveEventHandler (kRavelEventClass, kAENorifyQuill, &MyHandleRemind, false);	AERemoveEventHandler (kRavelEventClass, kAEScanComplete, &MyHandleScanComplete, false);#endif	putlog ( lgNOPE, "End." );}void DoEvent (EventRecord *event){	windowsQElPtr	dialogInfo;	DialogPtr		currentWindow;	WindowPtr		window;	Handle			htmp;		long			growBytes;		short			part, oldKind;		register void (*EventProcessor) (EventRecord *event, struct _window *dialogInfo, long info);	register void (*DialogProcessor) (EventRecord *event, struct _window *dialogInfo, long info);	currentWindow = FrontWindow ();	//	е	Dialogs Event Processing╔	if (windowsLookUp (currentWindow))	{		if (dialogInfo = (windowsQElPtr) GetWRefCon (currentWindow))		{			oldKind = ((WindowPeek)currentWindow)->windowKind;			((WindowPeek)currentWindow)->windowKind = dialogKind;			DialogProcessor = dialogInfo->DialogProcessor;			if (DialogProcessor)				DialogProcessor (event, dialogInfo, -1);			((WindowPeek)currentWindow)->windowKind = oldKind;		}	}	//	е	Event Processing╔	switch (event->what)	{	case mouseDown:			part = FindWindow (event->where, &window);				if (part == inMenuBar)		{			if (windowsLookUp (currentWindow) && (dialogInfo = (windowsQElPtr) GetWRefCon (currentWindow)))			{				EventProcessor = dialogInfo->EventProcessor;				if (EventProcessor)					EventProcessor (NULL, dialogInfo, ((long) inMenuBar << 16) | mouseDown);			}			DoMenu ( MenuSelect (event->where), event->modifiers );		}		else			if (windowsLookUp (window) && (dialogInfo = (windowsQElPtr) GetWRefCon (window)))			{				EventProcessor = dialogInfo->EventProcessor;				if (EventProcessor)					EventProcessor (event, dialogInfo, ((long) part << 16) | mouseDown);			}			switch (part)			{			case inSysWindow:							SystemClick(event, window);				break;			case inContent:			//				if (window != FrontWindow())//				{//					SelectWindow(window);//				}				break;			}			break;		case keyDown:	case autoKey:		if (event->modifiers & cmdKey)		{			if (windowsLookUp (currentWindow) && (dialogInfo = (windowsQElPtr) GetWRefCon (currentWindow)))			{				EventProcessor = dialogInfo->EventProcessor;				if (EventProcessor)					EventProcessor (NULL, dialogInfo, ((long) inMenuBar << 16) | mouseDown);			}			DoMenu ( MenuKey (event->message & charCodeMask), event->modifiers );			break;		}		if (windowsLookUp (currentWindow) && (dialogInfo = (windowsQElPtr) GetWRefCon (currentWindow)))		{			EventProcessor = dialogInfo->EventProcessor;			if (EventProcessor)				EventProcessor (event, dialogInfo, keyDown);		}				break;	case kHighLevelEvent:		AEProcessAppleEvent (event);		break;	case osEvt:		if ( ((unsigned long) event->message >> 24) == SuspendResume )		{			InitCursor ();			crsI = -1;			if ( event->message & ResumeMask )			{//				TE32KFromScrap ();				if (windowsLookUp (currentWindow) && (dialogInfo = (windowsQElPtr) GetWRefCon (currentWindow)))				{					dialogInfo->inFront = 1;					EventProcessor = dialogInfo->EventProcessor;					if (EventProcessor)						EventProcessor (event, dialogInfo, actionActive);				}			}			else			{//				ZeroScrap ();//				TE32KToScrap ();				if (windowsLookUp (currentWindow) && (dialogInfo = (windowsQElPtr) GetWRefCon (currentWindow)))				{					dialogInfo->inFront = 0;					EventProcessor = dialogInfo->EventProcessor;					if (EventProcessor)						EventProcessor (event, dialogInfo, actionActive);				}			}		}		break;	case activateEvt:			if (windowsLookUp ((WindowPtr)event->message) &&			(dialogInfo = (windowsQElPtr) GetWRefCon ((WindowPtr)event->message)))			{				InitCursor ();				crsI = -1;								EventProcessor = dialogInfo->EventProcessor;							dialogInfo->inFront = (event->modifiers & activeFlag) != 0;				if (EventProcessor)				{					EventProcessor (NULL, dialogInfo, ((long) inMenuBar << 16) | mouseDown);					EventProcessor (NULL, dialogInfo, actionActive);				}			}		break;		case updateEvt:		if ((((WindowPeek)(event->message))->windowKind & 0xFFFE) == myKind)		{			if (windowsLookUp ((WindowPtr)event->message) && (dialogInfo = (windowsQElPtr) GetWRefCon ((WindowPtr)event->message)))			{				EventProcessor = dialogInfo->EventProcessor;				if (EventProcessor)				{					oldKind = ((WindowPeek)currentWindow)->windowKind;					((WindowPeek)currentWindow)->windowKind = dialogKind;					EventProcessor (event, dialogInfo, updateEvt);					((WindowPeek)currentWindow)->windowKind = oldKind;				}			}		}		else		{			BeginUpdate((WindowPtr)event->message);			if (((WindowPeek)(event->message))->windowKind == dialogKind)				UpdateDialog ( (WindowPtr)event->message, ((WindowPeek)(event->message))->port.visRgn );			EndUpdate((WindowPtr)event->message);		}				break;			case nullEvent:				if ((LMGetTime () & 0x00000030L) == 0)		{			MaxMem (&growBytes);#ifndef LITE#ifdef PROTECTED			if (!inSublaunch)			{				pStrCopy (keys.regName, (*homesystem)->sysop);				(*homesystem)->mainAddr.ad = keys.regAddr;			}#endif#endif		}		#ifndef LITE#ifdef PROTECTED		if (keys.crc != keys.oldcrc)			ExitToShell ();		if ((keys.oldcs+1+keys.cs)&0xFFFF)			ExitToShell ();					if (!inSublaunch)			(*homesystem)->mainAddr.ad = keys.regAddr;#endif#endif		if (inSublaunch)		{			if (ScanComplete)			{				if (!ReadPreference ())				{					ParamText ("\pRavel's preferences file Ravel.PREF not found or corrupted.\rUnable to proceed.", "\p", "\p", "\p");					Alert (500, NULL);					ExitToShell ();				}				tmpbase_open ();				tmpbase_close ();				base_bsy_raise ();				InitMarks ();				WAreasEventProcessor (NULL, NULL, actionCreate);								inSublaunch = false;				ScanComplete = false;			}		}		else		{			if (gNotified)			{				gNotified = false;				if (Alert (506, NULL) == 2)				{					Broadcast (wtMsgEdit, broadClose, -1, 0);					if (!SuchWindow (wtMsgEdit))					{						Broadcast (wtNodelist, broadClose, 0, 0);						Broadcast (wtSubjects, broadClose, 0, 0);						Broadcast (wtMsgView, broadClose, 0, 0);						Broadcast (wtAreasList, broadClose, 0, 0);						Broadcast (wtFindDlg, broadClose, 0, 0);						Broadcast (wtAddressee, broadClose, 0, 0);						KillMarks ();						msgbase_close (CLOSE_ONLY);						msgbase_dispose ();						KillPreference ();						if (!ReadPreference ())						{							ParamText ("\pRavel's preferences file Ravel.PREF not found or corrupted.\rUnable to proceed.", "\p", "\p", "\p");							Alert (500, NULL);							ExitToShell ();						}												base_bsy_clear ();						tmpbase_open ();						tmpbase_close ();						base_bsy_raise ();						InitMarks ();						WAreasEventProcessor (NULL, NULL, actionCreate);					}				}			}					if (windowsLookUp (currentWindow) && (dialogInfo = (windowsQElPtr) GetWRefCon (currentWindow)))			{				EventProcessor = dialogInfo->EventProcessor;				if (EventProcessor)					EventProcessor (event, dialogInfo, nullEvent);			}		}				break;	}}void DoSlice (void){}void putProgressName (Str255 name){}void InitProgress (float a){}void DrawProgress (long b){}short LookForAreaNumber ( char *AreaName ){	short		i;	for ( i = 0; i < AreasNumber; i++ )		if ( pcStrEqu ( (*areasHndls[i])->areaName, AreaName ) )			break;	return ( i == AreasNumber ) ? -1 : i+1;}