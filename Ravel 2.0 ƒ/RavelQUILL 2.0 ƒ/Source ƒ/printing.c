#include <Sound.h>#include <string.h>#include <stdio.h>#include "version.h"#include "ravel_msg_base.h"#include "rPrinting.h"#include "stringutl.h"		THPrint	printRecordH;extern	long	printfontsize;extern	Str255	printfontname;extern	short	viewFont;		short		printfont;#ifndef LITEstatic	FontInfo	fInfo;static	short		lines;static Boolean PrintOnePage (long *pos, short pn, pktmsg *m){	long	line_start, last_delimiter;	char	*p = *(m->text), tmp[128], tmp1[128];		short	i, j, iWidth, hlf;			hlf = (fInfo.ascent + fInfo.descent + fInfo.leading) / 2;		TextFace (bold);	MoveTo (0, (fInfo.ascent + fInfo.descent + fInfo.leading) * 2 + hlf);	if (m->area[0])		strcpy ( tmp1, m->area );	else		strcpy ( tmp1, "NetMail" );	sprintf ( tmp, "Area: %s\xD", tmp1 );	DrawText (tmp, 0, strlen (tmp));	MoveTo (0, (fInfo.ascent + fInfo.descent + fInfo.leading) * 3 + hlf);	sprintf ( tmp, "From: %s (%s) %s\xD", m->fromname, printaddr ( &m->from, tmp1 ), m->date );	DrawText (tmp, 0, strlen (tmp));	MoveTo (0, (fInfo.ascent + fInfo.descent + fInfo.leading) * 4 + hlf);	if (m->area[0])		sprintf ( tmp, "To:   %s\xD", m->toname );	else		sprintf ( tmp, "To:   %s (%s)\xD", m->toname, printaddr ( &m->to, tmp1 ) );		DrawText (tmp, 0, strlen (tmp));	MoveTo (0, (fInfo.ascent + fInfo.descent + fInfo.leading) * 5 + hlf);	sprintf ( tmp, "Subj: %s\xD", m->subj );	DrawText (tmp, 0, strlen (tmp));	TextFace (0);	for (j = 0; j < lines; j++)	{		MoveTo (0, (fInfo.ascent + fInfo.descent + fInfo.leading) * (j + 7) + hlf);			last_delimiter = -1;		line_start = *pos;				while (1)		{			if (!p[*pos])			{				DrawText (&p[line_start], 0, *pos - line_start);				return false;						//	end of text			}			else				if (p[*pos] == 13)				//	hard end of line				{					DrawText (&p[line_start], 0, *pos - line_start);					(*pos)++;					break;						//	exit this line				}				else					if (p[*pos] == ' ')			//	delimiter					{						iWidth = TextWidth (&p[line_start], 0, *pos - line_start);						if (iWidth > ((*printRecordH)->prInfo.rPage.right - (*printRecordH)->prInfo.rPage.left))						{							if (last_delimiter > 0)								*pos = last_delimiter;				//			else				//				very long line							DrawText (&p[line_start], 0, *pos - line_start);							(*pos)++;							break;				//	exit this line						}						else						{							last_delimiter = *pos;	//	process next							(*pos)++;						}					}					else						(*pos)++;		}	}	return true;}static long BypassToMsgPosition (short pn, pktmsg *m){	long	line_start, last_delimiter, pos = 0;	char	*p = *(m->text);		short	i, j, iWidth;				for (i = 1; i < pn; i++)	{		for (j = 0; j < lines; j++)		{			last_delimiter = -1;			line_start = pos;						while (1)			{				if (!p[pos])					return -1;						//	end of text				else					if (p[pos] == 13)				//	hard end of line					{						pos++;						break;						//	exit this line					}					else						if (p[pos] == ' ')			//	delimiter						{							iWidth = TextWidth (&p[line_start], 0, last_delimiter - line_start);							if (iWidth > ((*printRecordH)->prInfo.rPage.right - (*printRecordH)->prInfo.rPage.left))							{								if (last_delimiter > 0)									pos = last_delimiter;					//			else					//				very long line								pos++;								break;				//	exit this line							}							else							{								last_delimiter = pos;	//	process next								pos++;							}						}						else							pos++;			}		}	}	return pos;}static void DoPrintPageFrame (short pn){	Rect	r = (*printRecordH)->prInfo.rPage;	Str255	nn;		TextFont (0);	TextSize (0);	MoveTo (0, (fInfo.ascent + fInfo.descent + fInfo.leading) * 1);	DrawString ("\pRavelQUILL");		MoveTo (r.right - 30, (fInfo.ascent + fInfo.descent + fInfo.leading) * 1);	NumToString (pn, nn);	DrawString (nn);		PenSize (3, 3);		MoveTo (0, 1);	LineTo (r.right, 1);	MoveTo (0, 2 + (fInfo.ascent + fInfo.descent + fInfo.leading) * 1);	LineTo (r.right, 2 + (fInfo.ascent + fInfo.descent + fInfo.leading) * 1);	MoveTo (0, r.bottom - 10);	LineTo (r.right, r.bottom - 10);	PenSize (1, 1);	MoveTo (0, (fInfo.ascent + fInfo.descent + fInfo.leading) * 6);	LineTo (r.right, (fInfo.ascent + fInfo.descent + fInfo.leading) * 6);	MoveTo (0, 2 + (fInfo.ascent + fInfo.descent + fInfo.leading) * 6);	LineTo (r.right, 2 + (fInfo.ascent + fInfo.descent + fInfo.leading) * 6);}void DoPrintOneMessage (pktmsg *m){	GrafPtr		savedPort;	TPrStatus	prStatus;	TPPrPort	printPort;		short		i;	long		pos;		HLock (m->text);	GetPort(&savedPort);	PrOpen();	if (PrJobDialog (printRecordH))	{		printPort = PrOpenDoc(printRecordH, nil, nil);		SetPort (&printPort->gPort);				TextFont (printfont);		TextSize (printfontsize);				GetFontInfo (&fInfo);		lines = ((*printRecordH)->prInfo.rPage.bottom - (*printRecordH)->prInfo.rPage.top - 40) /					(fInfo.ascent + fInfo.descent + fInfo.leading);		lines -= 6;		//	w/o header		pos = BypassToMsgPosition ((*printRecordH)->prJob.iFstPage, m);		if (pos >= 0)		{			PrOpenPage (printPort, nil);			i = 0;						DoPrintPageFrame ((*printRecordH)->prJob.iFstPage);			TextFont (printfont);			TextSize (printfontsize);						while (((*printRecordH)->prJob.iFstPage + i) <= (*printRecordH)->prJob.iLstPage && PrintOnePage (&pos, i, m))			{				PrClosePage(printPort);	/* Close the currently open page. */				PrOpenPage(printPort, nil);	/* and open a new one. */								i++;				DoPrintPageFrame ((*printRecordH)->prJob.iFstPage + i);				TextFont (printfont);				TextSize (printfontsize);			}			PrClosePage (printPort);		}		else			SysBeep (10);		PrCloseDoc (printPort);				/* Print spooled document, if any. */		if ((**printRecordH).prJob.bJDocLoop == bSpoolLoop && PrError() == noErr)			PrPicFile (printRecordH, nil, nil, nil, &prStatus);	}	PrClose();	SetPort(savedPort);	HUnlock (m->text);}static	TPPrPort	printPort;static	TPPrDlg		PrtJobDialog;static	short	my_first;static	short	BoxValue;#if defined(powerc) || defined(__powerc)static	PDlgInitUPP		uupMyJobDlgInit;static	PItemUPP		uupMyJobItems, uupOldJobItems;#elsestatic pascal void (*prPItemProc) (TPPrDlg theDialog, short itemNo);#endifstatic pascal void MyJobItems (TPPrDlg theDialog, short itemNo){	Handle		h;	short		iType;	Rect		iBox;	if (itemNo > 0 && (itemNo == my_first || itemNo == (my_first + 1)))	{		BoxValue = itemNo - my_first;		GetDialogItem ((DialogPtr)theDialog, my_first, &iType, &h, &iBox);		SetControlValue ((ControlHandle)h, 1 - BoxValue);		GetDialogItem ((DialogPtr)theDialog, my_first + 1, &iType, &h, &iBox);		SetControlValue ((ControlHandle)h, BoxValue);	}	else#if defined(powerc) || defined(__powerc)		CallPItemProc (uupOldJobItems, theDialog, itemNo);#else		prPItemProc (theDialog, itemNo);#endif}static pascal TPPrDlg MyJobDlgInit (THPrint hPrint){	Handle		h;	short		iType;	Rect		iBox;		/* 	this routine appends items to the standard job dialog and		sets up user fields of the printing dialog record TPRDlg	*/#if defined(powerc) || defined(__powerc)	uupMyJobItems = NewPItemProc (MyJobItems);//	uupMyJobItems = NewRoutineDescriptor ((ProcPtr) MyJobItems, uppPItemProcInfo, GetCurrentISA ());#endif	h = GetResource ('DITL', 1234);	AppendDITL ((DialogPtr)PrtJobDialog, h, appendDITLBottom);	ReleaseResource (h);	my_first = CountDITL ((DialogPtr)PrtJobDialog) - 1;		/* save so MyJobItems can find it */	GetDialogItem ((DialogPtr)PrtJobDialog, my_first, &iType, &h, &iBox);	SetControlValue ((ControlHandle)h, 1 - BoxValue);	GetDialogItem ((DialogPtr)PrtJobDialog, my_first + 1, &iType, &h, &iBox);	SetControlValue ((ControlHandle)h, BoxValue);#if defined(powerc) || defined(__powerc)	uupOldJobItems = PrtJobDialog->pItemProc;#else	(PItemUPP)prPItemProc = PrtJobDialog->pItemProc;#endif#if defined(powerc) || defined(__powerc)	PrtJobDialog->pItemProc = uupMyJobItems;#else	PrtJobDialog->pItemProc = (PItemUPP)MyJobItems;#endif	return PrtJobDialog;}short DoPrintMessages_Init (void){	GrafPtr		savedPort;	short		res = 0;	GetPort(&savedPort);	PrOpen();	PrtJobDialog = PrJobInit(printRecordH);	if(PrError() != noErr)		return res;	BoxValue = 0;#if defined(powerc) || defined(__powerc)	uupMyJobDlgInit = NewPDlgInitProc (MyJobDlgInit);//	uupMyJobDlgInit = NewRoutineDescriptor ((ProcPtr) MyJobDlgInit, uppPDlgInitProcInfo, GetCurrentISA ());#endif#if defined(powerc) || defined(__powerc)	if(!PrDlgMain (printRecordH, uupMyJobDlgInit))#else	if(!PrDlgMain (printRecordH, MyJobDlgInit))#endif	{		PrClose();#if defined(powerc) || defined(__powerc)		DisposeRoutineDescriptor (uupMyJobDlgInit);		DisposeRoutineDescriptor (uupMyJobItems);#endif		return res;	}		printPort = PrOpenDoc(printRecordH, nil, nil);	SetPort (&printPort->gPort);		TextFont (printfont);	TextSize (printfontsize);		GetFontInfo (&fInfo);	lines = ((*printRecordH)->prInfo.rPage.bottom - (*printRecordH)->prInfo.rPage.top - 40) /				(fInfo.ascent + fInfo.descent + fInfo.leading);	lines -= 6;		//	w/o header	res = BoxValue + 1;	SetPort (savedPort);	return res;}void DoPrintMessages_Print (pktmsg *m){	short		i = 0;	long		pos = 0;	GrafPtr		savedPort;	GetPort (&savedPort);	SetPort (&printPort->gPort);		HLock (m->text);	PrOpenPage (printPort, nil);	DoPrintPageFrame ((*printRecordH)->prJob.iFstPage);	TextFont (printfont);	TextSize (printfontsize);		while (PrintOnePage (&pos, i, m))	{		PrClosePage(printPort);	/* Close the currently open page. */		PrOpenPage(printPort, nil);	/* and open a new one. */				i++;		DoPrintPageFrame ((*printRecordH)->prJob.iFstPage + i);		TextFont (printfont);		TextSize (printfontsize);	}	PrClosePage (printPort);	HUnlock (m->text);	SetPort (savedPort);}void DoPrintMessages_Close (void){	TPrStatus	prStatus;	PrCloseDoc (printPort);			/* Print spooled document, if any. */	if ((**printRecordH).prJob.bJDocLoop == bSpoolLoop && PrError() == noErr)			PrPicFile (printRecordH, nil, nil, nil, &prStatus);#if defined(powerc) || defined(__powerc)	DisposeRoutineDescriptor (uupMyJobDlgInit);	DisposeRoutineDescriptor (uupMyJobItems);#endif	PrClose();}#endif