#include <stdio.h>#include <string.h>//#include "Ravel_FTN.h"#include "ravel_msg_base.h"#include "Ravel_Prefs.h"#include "stringutl.h"#include "PascalStr.h"#include "nodelist.h"typedef struct _nodelistheader {	char			sign[16];	long			ofs_zones;	long			ofs_nets;	long			ofs_nodes;	long			ofs_points;	} nodelistheader;typedef struct _filerec {		Str15			fname;	unsigned long	modifdate;	long			flength;	short			points;} filerec, *p_files;typedef struct _zonerec  {		unsigned short	zone;	short			fnum;	long			foffset;	long			netoffset;	} zonerec, *p_zones;typedef struct _netrec  {		unsigned short	net;	short			fnum;	long			foffset;	long			nodeoffset;	} netrec, *p_nets;typedef struct _noderec  {		unsigned short	node;	short			flags;	long			foffset;	long			pointoffset;} noderec, *p_nodes;typedef struct _pointrec  {		unsigned short	point;	short			fnum;	long			foffset;	} pointrec, *p_points;#define	f_zone		0x0001	//	zone coordinator#define	f_region	0x0002	//	region coordinator#define	f_host		0x0004	//	net host#define	f_hub		0x0008	//	net hub#define	f_down		0x0010	//	down node#define	f_hold		0x0020	//	hold node#define	f_pvt		0x0040	//	private node#define	f_point		0x8000	//	it's pointextern	Str255			nodePath;static	long			ofs_zones;static	long			ofs_nets;static	long			ofs_nodes;static	long			ofs_points;	static	Str255			ravelnodesindex;static	short			indexref;static	p_files			pfiles;static	p_zones			pzones;static	p_nets			pnets;static	p_nodes			pnodes;static	p_points		ppoints;static	short			FLAG;void ReadNodeList (void){	nodelistheader	header;	long			ioCount;	Handle			h;			pStrConc ( nodePath, "\pRavel.NODELIST.INDEX", ravelnodesindex );	if ( FSOpen ( ravelnodesindex, 0, &indexref ) )	{		indexref = 0;		return;	}		ioCount = sizeof (nodelistheader);	FSRead ( indexref, &ioCount, &header );	ofs_zones = header.ofs_zones;	ofs_nets = header.ofs_nets;	ofs_nodes = header.ofs_nodes;	ofs_points = header.ofs_points;//е	h = NewHandle ( ofs_zones - sizeof (nodelistheader) );	MoveHHi (h);	HLock (h);		pfiles = (p_files) *h;	ioCount = ofs_zones - sizeof (nodelistheader);	FSRead ( indexref, &ioCount, pfiles );//е	h = NewHandle ( ofs_nets - ofs_zones );	MoveHHi (h);	HLock (h);	pzones = (p_zones) *h;	ioCount = ofs_nets - ofs_zones;	FSRead ( indexref, &ioCount, pzones );//е	h = NewHandle ( ofs_nodes - ofs_nets );	MoveHHi (h);	HLock (h);	pnets = (p_nets) *h;	ioCount = ofs_nodes - ofs_nets;	FSRead ( indexref, &ioCount, pnets );//е	h = NewHandle ( ofs_points - ofs_nodes );	MoveHHi (h);	HLock (h);	pnodes = (p_nodes) *h;	ioCount = ofs_points - ofs_nodes;	FSRead ( indexref, &ioCount, pnodes );//е	h = NewHandle ( 2048 );	MoveHHi (h);	HLock (h);	ppoints = (p_points) *h;//ее	FSClose (indexref);}void CloseNodeList (){//	if (indexref)//		FSClose (indexref);}long lookupZoneIndex (short zone){	register long	i = 0;	while (pzones[i].zone != -1)		if (pzones[i].zone == zone)			return i;		else			if (pzones[i].zone < zone)				i++;			else				break;	return -1;}long lookupNetIndex (long netoffset, short net){	register long	i = netoffset / sizeof (netrec);	while (pnets[i].net != -1)		if (pnets[i].net == net)			return i;		else			if (pnets[i].net < net)				i++;			else				break;	return -1;}static long lookupNetIndex1 (long netoffset, short net){	register long	i = netoffset / sizeof (netrec);	long			j = 0;	while (pnets[i].net != -1)		if (pnets[i].net == net)			return j;		else			if (pnets[i].net < net)				i++, j++;			else				break;	return -1;}long lookupNodeIndex (long nodeoffset, short node){	register long	i = nodeoffset / sizeof (noderec);	while (pnodes[i].node != -1)		if (pnodes[i].node == node)			return i;		else			if (pnodes[i].node < node)				i++;			else				break;	return -1;}static long lookupNodeIndex1 (long nodeoffset, short node){	register long	i = nodeoffset / sizeof (noderec);	long			j = 0;	while (pnodes[i].node != -1)		if (pnodes[i].node == node)			return j;		else			if (pnodes[i].node < node)				i++, j++;			else				break;	return -1;}static long lookupPoint (pointrec *pt, long pointoffset, short point){	short		i, j;	long		ioCount;		if (pointoffset >= 0)	{		SetFPos ( indexref, fsFromStart, ofs_points + pointoffset );				ioCount = sizeof (pointrec) * 128;		FSRead ( indexref, &ioCount, ppoints );				i = 0;				do {					if (ppoints[i].point == point)			{				*pt = ppoints[i];				return 0;			}			else				if (ppoints[i].point > point)					return -1;						i++;			if (i > 127)			{				ioCount = sizeof (pointrec) * 128;				FSRead ( indexref, &ioCount, ppoints );								i = 0;			}				} while (ppoints[i].point != -1);	}	return -1;}static long lookupPointIndex (long pointoffset, short point){	long		i, j;	long		ioCount;		if (pointoffset >= 0)	{		SetFPos ( indexref, fsFromStart, ofs_points + pointoffset );				ioCount = sizeof (pointrec) * 128;		FSRead ( indexref, &ioCount, ppoints );				i = 0;				do {					if (ppoints[i].point == point)			{				return i;			}			else				if (ppoints[i].point > point)					return -1;						i++;			if (i > 127)			{				ioCount = sizeof (pointrec) * 128;				FSRead ( indexref, &ioCount, ppoints );								i = 0;			}				} while (ppoints[i].point != -1);	}	return -1;}short adjust (addr *tempaddr){	short	nl_level = 0;	if (tempaddr->zone && (lookupZoneIndex (tempaddr->zone) != -1))		if (tempaddr->net && (lookupNetIndex (pzones[lookupZoneIndex (tempaddr->zone)].netoffset, tempaddr->net) != -1))		{			if (hasSequence (1, tempaddr))				nl_level = 2;			else				nl_level = 1;		}	return nl_level;}short ZoneByIndex (short inx){	return pzones[inx].zone;}short NetByIndex (short inx, addr *address){	long inx1;		inx1 = lookupZoneIndex (address->zone);	inx1 = pzones[inx1].netoffset / sizeof (netrec);	return pnets[inx1+inx].net;}short NodeByIndex (short inx, addr *address){	long inx1;	inx1 = lookupZoneIndex (address->zone);	inx1 = lookupNetIndex (pzones[inx1].netoffset, address->net);	inx1 = pnets[inx1].nodeoffset / sizeof (noderec);	return pnodes[inx1+inx].node;}short PointByIndex (short inx, addr *address){	long inx1, ioCount;	inx1 = lookupZoneIndex (address->zone);	inx1 = lookupNetIndex (pzones[inx1].netoffset, address->net);	inx1 = lookupNodeIndex (pnets[inx1].nodeoffset, address->node );	if (pnodes[inx1].pointoffset >= 0)	{		FSOpen ( ravelnodesindex, 0, &indexref );		SetFPos ( indexref, fsFromStart, ofs_points + pnodes[inx1].pointoffset + sizeof (pointrec)*inx );				ioCount = sizeof (pointrec);		FSRead ( indexref, &ioCount, ppoints );				FSClose (indexref);				return ppoints[0].point;	}	return -1;}short gotline (short nl_level, addr *nl_addr){	long	inx;	switch (nl_level)	{	case 0:				return lookupZoneIndex (nl_addr->zone);		case 1:			inx = lookupZoneIndex (nl_addr->zone);				if (inx < 0)			break;				return lookupNetIndex1 (pzones[inx].netoffset, nl_addr->net);		case 2:		inx = lookupZoneIndex (nl_addr->zone);		if (inx < 0)			break;				inx = lookupNetIndex (pzones[inx].netoffset, nl_addr->net);		if (inx < 0)			break;				return lookupNodeIndex1 (pnets[inx].nodeoffset, nl_addr->node);	case 3:		if (!indexref)			break;				if ( FSOpen ( ravelnodesindex, 0, &indexref ) )		{			break;		}		inx = lookupZoneIndex (nl_addr->zone);		if (inx < 0)			break;				inx = lookupNetIndex (pzones[inx].netoffset, nl_addr->net);		if (inx < 0)			break;				inx = lookupNodeIndex (pnets[inx].nodeoffset, nl_addr->node);		if (inx < 0)			break;				inx = lookupPointIndex (pnodes[inx].pointoffset, nl_addr->point);				FSClose (indexref);				return inx;	}		return -1;}/*Hold,352,GR_44_Station,St.Petersburg,Alexander_Mironov,7-812-314-0518,9600,XA,MO,H16,V32T,U,TVF*/static void FilterNodeString (addr *address, StringPtr str){	short	i, j, k;	Str255	temp;		i = 1;		while (str[i] != ',' && i <= str[0])		i++;		i++;		while (str[i] != ',' && i <= str[0])		i++;		if (i < str[0])	{		i++;		k = 0;		j = 1;				while (str[i] != 0x0D && i <= str[0])		{			switch (str[i])			{			case ',':								if (k > 4)					temp[j++] = str[i];				else				{					k++;					temp[j++] = 0x0D;				}								break;							case '_':							temp[j++] = ' ';				break;						default:				temp[j++] = str[i];				break;			}						i++;		}				temp[j] = 0;		temp[0] = strlen ( (char *) &temp[1] );			printaddr ( address, (char *) &str[1] );		str[0] = strlen ( (char *) &str[1] );				pStrConc ( str, "\p, ", str );		pStrConc ( str, temp, str );	}}Boolean hasSequence (short level, addr *address){	long		inx;		if (level == 0)	{		inx = lookupZoneIndex (address->zone);		if (inx >= 0)		{			if (pzones[inx].netoffset != -1)				return true;		}				return false;	}	else		if (level == 1)		{			inx = lookupZoneIndex (address->zone);			inx = lookupNetIndex ( pzones[inx].netoffset, address->net );			if (inx >= 0)			{				if (pnets[inx].nodeoffset != -1)					return true;			}						return false;		}		else			if (level == 2)			{				inx = lookupZoneIndex (address->zone);				inx = lookupNetIndex ( pzones[inx].netoffset, address->net );				inx = lookupNodeIndex ( pnets[inx].nodeoffset, address->node );				if (inx >= 0)				{					if (pnodes[inx].pointoffset != -1)						return true;				}								return false;			}				return false;}Boolean GetNodeInfo (addr *address, StringPtr result){	long		inx_z, inx_nt, inx_nd, ioCount;	short		a;	pointrec	pt;	Boolean		res = false;	Str255		ttt;				if (!indexref)		return false;		if ( FSOpen ( ravelnodesindex, 0, &indexref ) )	{		return false;	}	FLAG = 0;	inx_z = lookupZoneIndex ( address->zone );	if (inx_z >= 0)	{		if (address->net)		{			inx_nt = lookupNetIndex ( pzones[inx_z].netoffset, address->net );			if (inx_nt >= 0)			{				if (address->node)				{					inx_nd = lookupNodeIndex ( pnets[inx_nt].nodeoffset, address->node );									if (inx_nd >= 0)					{						if (address->point)						{	//	full 4D - zone:net/node.point																		if ( lookupPoint ( &pt, pnodes[inx_nd].pointoffset, address->point ) == 0 )							{								pStrConc ( nodePath, pfiles[pt.fnum].fname, ttt );								FSOpen ( ttt, 0, &a );								SetFPos ( a, fsFromStart, pt.foffset );								ioCount = 255;								FSRead ( a, &ioCount, &result[1] );								result[0] = 255;								FilterNodeString (address, result);								FSClose ( a );								res = true;							}						}						else						{	//	node only - zone:net/node								pStrConc ( nodePath, pfiles[pnets[inx_nt].fnum].fname, ttt );							FSOpen ( ttt, 0, &a );							SetFPos ( a, fsFromStart, pnodes[inx_nd].foffset );							ioCount = 255;							FSRead ( a, &ioCount, &result[1] );							result[0] = 255;							FilterNodeString (address, result);							FSClose ( a );							FLAG = pnodes[inx_nd].flags;							res = true;						}					}				}				else				{	//	net only - zone:net/0									pStrConc ( nodePath, pfiles[pnets[inx_nt].fnum].fname, ttt );					FSOpen ( ttt, 0, &a );					SetFPos ( a, fsFromStart, pnets[inx_nt].foffset );					ioCount = 255;					FSRead ( a, &ioCount, &result[1] );					result[0] = 255;					FilterNodeString (address, result);					FSClose ( a );					FLAG = f_host;					res = true;				}			}		}		else		{	//	zone only - zone:0/0					pStrConc ( nodePath, pfiles[pzones[inx_z].fnum].fname, ttt );			FSOpen ( ttt, 0, &a );			SetFPos ( a, fsFromStart, pzones[inx_z].foffset );			ioCount = 255;			FSRead ( a, &ioCount, &result[1] );			result[0] = 255;			FilterNodeString (address, result);			FSClose ( a );			FLAG = f_zone;			res = true;		}	}		FSClose (indexref);	if (res && FLAG)	{		pStrConc ( result, "\p\xD", result );		if (FLAG & f_zone)			pStrConc ( result, "\pZone", result );		else			if (FLAG & f_host)			{				if (address->net < 100)					pStrConc ( result, "\pRegion", result );				else					pStrConc ( result, "\pHost", result );			}			else				if (FLAG & f_hub)					pStrConc ( result, "\pHub", result );				else					if (FLAG & f_down)						pStrConc ( result, "\pDown", result );					else						if (FLAG & f_hold)							pStrConc ( result, "\pHold", result );						else							if (FLAG & f_pvt)								pStrConc ( result, "\pPrivate", result );	}	return res;}Boolean GetNameFromAddr (addr *address, StringPtr result){	Str255		sTemp;	short		i, j;		if (GetNodeInfo (address, sTemp))	{		i = 1;		for (j = 0; j < 2 && i <= sTemp[0]; j++)		{			while (sTemp[i] != 0x0D && i <= sTemp[0])				i++;			i++;		}		j = 1;		while (sTemp[i] != 0x0D && i <= sTemp[0])			result[j++] = sTemp[i++];				result[0] = j-1;	}	else		return false;}Boolean GetInfoFromAddr (addr *address, StringPtr result){	Str255		sTemp;	short		i, j, k;		if (GetNodeInfo (address, sTemp))	{		i = 1;		for (j = 0; j < 1 && i <= sTemp[0]; j++)		{			while (sTemp[i] != ',' && i <= sTemp[0])				i++;			i++;		}		j = 1;		k = 0;				while (k < 3 && i <= sTemp[0])		{			if (sTemp[i] == ',' || sTemp[i] == 0xD)			{				sTemp[i] = ',';				k++;			}						result[j++] = sTemp[i++];		}				result[0] = j-1;	}	else		return false;}Boolean yep (void){	if (!indexref)		return false;	else		return true;}