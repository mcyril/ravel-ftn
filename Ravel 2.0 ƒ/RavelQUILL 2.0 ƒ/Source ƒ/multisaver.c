/*본본본본본본본본본본본본본본본본본본본본본본본본본본본본본본본본본본본본본본*/#include <Sound.h>#include <string.h>#include <stdio.h>#include "TE32K.h"#include "PopUpLib.h"#include "myTEdit.h"#include "PascalStr.h"//#include "Ravel_FTN.h"#include "ravel_msg_base.h"#include "Ravel_Prefs.h"#include "Preferences.h"#include "pktparse.h"#include "stringutl.h"//#include "BaseManager.h"#include "CommonData.h"#include "WindowsList.h"#include "multisaver.h"#include "DialogLib.h"#include "WFind.h"#include "Filter.h"/*본본본본본본본본본본본본본본본본본본본본본본본본본본본본본본본본본본본본본본*/#include "rMenus.h"/*본본본본본본본본본본본본본본본본본본본본본본본본본본본본본본본본본본본본본본*/extern	Handle		*markArray;#if defined(powerc) || defined(__powerc)	extern	UniversalProcPtr	uupMyAlertProc;#else	pascal Boolean myAlertProc ( DialogPtr theDialog, EventRecord *theEvent, short *itemHit );#endif/*enum {//	static pascal short saveDlgHook (short item, DialogPtr dialog)	uppDlgHookProcInfo = kPascalStackBased		 | RESULT_SIZE(SIZE_CODE(sizeof(short)))		 | STACK_ROUTINE_PARAMETER(1, SIZE_CODE(sizeof(short)))		 | STACK_ROUTINE_PARAMETER(2, SIZE_CODE(sizeof(Ptr)))};*/static	Str255	origName = "\p";static	short	d_state;static	short	d_safe;static	FSSpec	spec;static	short	isatrue;static char *delimiter = "=============================================================================\xD";//	d_state//			xxxx//			||||//			|||+-	can current		9//			||+--	can selected	10//			|+---	can all			11//			+----	reservedvoid	DoEvent (EventRecord *event);static short MyReplacer (StringPtr fileName){	DialogPtr	myDlg;	short		iHit;	GrafPtr		oldGraf;			GetPort (&oldGraf);		myDlg = GetNewDialog (3998, NULL, (WindowPtr) -1L);	SetPort (myDlg);	ParamText (fileName, "\p", "\p", "\p");	ShowWindow (myDlg);	DrawDialog (myDlg);	DefaultButton (myDlg, 1);	do {#if defined(powerc) || defined(__powerc)		ModalDialog (uupMyAlertProc, &iHit);#else		ModalDialog (myAlertProc, &iHit);#endif	} while (iHit != 1 && iHit != 2 && iHit != 3);	SetPort (oldGraf);	DisposeDialog (myDlg);		return iHit;}static pascal short saveDlgHook (short item, DialogPtr dialog){	short			res = item;	short			i;	short			iType;	Handle			iHandle;	Rect			iRect;	Str255			fileName;			switch (item)	{	case -1:			d_safe = 0;		isatrue = false;				i = 9;			if (!(d_state & 0x0001))		{			GetDialogItem (dialog, 9, &iType, &iHandle, &iRect);			HiliteControl ((ControlHandle) iHandle, 255);			i = 11;		}		if (!(d_state & 0x0002))		{			GetDialogItem (dialog, 10, &iType, &iHandle, &iRect);			HiliteControl ((ControlHandle) iHandle, 255);		}		if (!(d_state & 0x0004))		{			GetDialogItem (dialog, 11, &iType, &iHandle, &iRect);			HiliteControl ((ControlHandle) iHandle, 255);		}				if (i)		{			GetDialogItem (dialog, i, &iType, &iHandle, &iRect);			SetControlValue ((ControlHandle) iHandle, 1);		}		break;		case 1:		isatrue = true;		GetDialogItem (dialog, 7, &iType, &iHandle, &iRect);		GetDialogItemText (iHandle, fileName);		if (FSMakeFSSpec (-LMGetSFSaveDisk (), LMGetCurDirStore (), fileName, &spec) == noErr)		{			i = MyReplacer (fileName);					switch (i)			{			case 1:	//	append			case 3:	//	rewrite								res = 2;								GetDialogItem (dialog, 9, &iType, &iHandle, &iRect);				if (GetControlValue ((ControlHandle) iHandle))					d_safe = 1;				else				{					GetDialogItem (dialog, 10, &iType, &iHandle, &iRect);					if (GetControlValue ((ControlHandle) iHandle))						d_safe = 2;					else					{						GetDialogItem (dialog, 11, &iType, &iHandle, &iRect);						if (GetControlValue ((ControlHandle) iHandle))							d_safe = 3;					}				}				d_safe |= i << 8;								break;							case 2:	//	cancel							res = 0;				break;			}		}		else		{			GetDialogItem (dialog, 9, &iType, &iHandle, &iRect);			if (GetControlValue ((ControlHandle) iHandle))				d_safe = 1;			else			{				GetDialogItem (dialog, 10, &iType, &iHandle, &iRect);				if (GetControlValue ((ControlHandle) iHandle))					d_safe = 2;				else				{					GetDialogItem (dialog, 11, &iType, &iHandle, &iRect);					if (GetControlValue ((ControlHandle) iHandle))						d_safe = 3;				}			}			d_safe |= 0x0300;		}				break;		case 2:		d_safe = -1;		break;	case 9:	case 10:	case 11:			if (d_state & 0x0004)		{			GetDialogItem (dialog, 11, &iType, &iHandle, &iRect);			SetControlValue ((ControlHandle) iHandle, 0);		}				if (d_state & 0x0002)		{			GetDialogItem (dialog, 10, &iType, &iHandle, &iRect);			SetControlValue ((ControlHandle) iHandle, 0);		}		if (d_state & 0x0001)		{			GetDialogItem (dialog, 9, &iType, &iHandle, &iRect);			SetControlValue ((ControlHandle) iHandle, 0);		}			GetDialogItem (dialog, item, &iType, &iHandle, &iRect);		SetControlValue ((ControlHandle) iHandle, 1);		res = 0;				break;	}		return res;}static void flushOneMsg (short outaFile, pktmsg *m){	char		tmp[128], tmp1[128];	long		counter;		counter = strlen (delimiter);	FSWrite (outaFile, &counter, delimiter);		if (m->area[0])		strcpy ( tmp1, m->area );	else		strcpy ( tmp1, "NetMail" );	sprintf ( tmp, "Area: %s\xD", tmp1 );	counter = strlen (tmp);	FSWrite (outaFile, &counter, tmp);	sprintf ( tmp, "From: %s (%s) %s\xD", m->fromname, printaddr ( &m->from, tmp1 ), m->date );	counter = strlen (tmp);	FSWrite (outaFile, &counter, tmp);	if (m->area[0])		sprintf ( tmp, "To:   %s\xD", m->toname );	else		sprintf ( tmp, "To:   %s (%s)\xD", m->toname, printaddr ( &m->to, tmp1 ) );		counter = strlen (tmp);	FSWrite (outaFile, &counter, tmp);	sprintf ( tmp, "Subj: %s\xD", m->subj );	counter = strlen (tmp);	FSWrite (outaFile, &counter, tmp);	counter = strlen (delimiter);	FSWrite (outaFile, &counter, delimiter);	HLock (m->text);	callFilter (m->text);	forwardFilter (m->text);	counter = strlen (*(m->text));	FSWrite (outaFile, &counter, *(m->text));	HUnlock (m->text);	counter = strlen (delimiter);	FSWrite (outaFile, &counter, delimiter);		counter = 1L;	tmp[0] = 0x0D;	FSWrite (outaFile, &counter, tmp);}//	mode//			0 - normal//			1 - from arealistvoid SaveMessagesToFile (long area, long current_message, short mode){	Point		where = {0,0};	SFReply		reply;	long		jj, nm;	pktmsg		*m;	EventRecord		event;		short		outaFile;	#if defined(powerc) || defined(__powerc)	UniversalProcPtr	uupSaveDlgHook;		uupSaveDlgHook = NewRoutineDescriptor ((ProcPtr) saveDlgHook, uppDlgHookProcInfo, GetCurrentISA ());#endif	//	if (area == AreasNumber+1)//		OpenBase ( BADAREA, true );//	else//		OpenBase (area, true);	msgbase_open_idx (area, true);	nm = msgbase_getnummsg ();	if (nm)	{		d_state = 0x0004;		if (!mode)			d_state |= 0x0001;		for (jj=0; jj < nm; jj++)			if ((*markArray[area])[jj])				break;			if (jj != nm)			d_state |= 0x0002;		#if defined(powerc) || defined(__powerc)		SFPPutFile (where, "\p", origName, uupSaveDlgHook, &reply, 3999, NULL);#else		SFPPutFile (where, "\p", origName, saveDlgHook, &reply, 3999, NULL);#endif		while (d_safe != -1)		{			pStrCopy (reply.fName, origName);					if (!isatrue)			{				if (FSOpen (reply.fName, reply.vRefNum, &outaFile) == fnfErr)				{					Create (reply.fName, reply.vRefNum, 'ALFA', 'TEXT');					if (FSOpen (reply.fName, reply.vRefNum, &outaFile))						break;				}				else				{					if ((d_safe & 0xFF00) == 0x0300)						SetEOF (outaFile, 0L);					else						SetFPos (outaFile, fsFromLEOF, 0L);				}			}			else			{				if (FSpOpenDF (&spec, fsRdWrPerm, &outaFile) == fnfErr)				{					FSpCreate (&spec, 'ALFA', 'TEXT', 0);					if (FSpOpenDF (&spec, fsRdWrPerm, &outaFile))						break;				}				else				{					if ((d_safe & 0xFF00) == 0x0300)						SetEOF (outaFile, 0L);					else						SetFPos (outaFile, fsFromLEOF, 0L);				}			}			switch (d_safe & 0x00FF)			{			case 1:		//	current								if (msgbase_read_message (current_message, &m, READMODE_TEXT))				{					flushOneMsg (outaFile, m);					FreePktMsg (m);				}								break;			case 2:		//	marked								WProgressEventProcessor ((EventRecord *) nm, (windowsQElPtr) 1, actionCreate);								for (jj=0; jj < nm; jj++)				{					Broadcast (wtFindDlg, broadSyncCellLR, jj, 0);					if ((*markArray[area])[jj])					{						if (msgbase_read_message (jj, &m, READMODE_TEXT))						{							flushOneMsg (outaFile, m);							FreePktMsg (m);							if (WaitNextEvent (everyEvent, &event, 0, NULL))							{								if (!event.what)									goto nulled;																msgbase_close (CLOSE_ONLY);																DoEvent (&event);							//								if (area == AreasNumber+1)//									OpenBase ( BADAREA, true );//								else//									OpenBase (area, true);															msgbase_open_idx (area, true);							}							else							{							nulled:															DoEvent (&event);							}						}					}				}								Broadcast (wtFindDlg, broadClose, -1, 0);				break;			case 3:		//	all								WProgressEventProcessor ((EventRecord *) nm, (windowsQElPtr) 1, actionCreate);								for (jj=0; jj < nm; jj++)				{					Broadcast (wtFindDlg, broadSyncCellLR, jj, 0);					if (msgbase_read_message (jj, &m, READMODE_TEXT))					{						flushOneMsg (outaFile, m);						FreePktMsg (m);						if (WaitNextEvent (everyEvent, &event, 0, NULL))						{							if (!event.what)								goto nulled1;														msgbase_close (CLOSE_ONLY);							DoEvent (&event);						//							if (area == AreasNumber+1)//								OpenBase ( BADAREA, true );//							else//								OpenBase (area, true);							msgbase_open_idx (area, true);						}						else						{						nulled1:													DoEvent (&event);						}					}				}				Broadcast (wtFindDlg, broadClose, -1, 0);				break;			}					FSClose (outaFile);						break;		}	}	else		SysBeep (10);	msgbase_close (CLOSE_ONLY);#if defined(powerc) || defined(__powerc)	DisposeRoutineDescriptor (uupSaveDlgHook);#endif}