#include <stdio.h>#include <string.h>//#include "Ravel_FTN.h"#include "ravel_msg_base.h"#include "Ravel_Prefs.h"#include "log.h"#include "Sublauncher.h"#define	kRavelEventClass	'R&vl'#define	kAEEnqueueCmd		'enQu'#define	kAENorifyQuill		'ntQu'#define	kAEScanComplete		'scQu'static	ProcessSerialNumber	launchedProcessSN;extern Str255	ShufflerPathName;OSErr FindAProcess (OSType typeToFind, OSType creatorToFind,			ProcessSerialNumberPtr processSN){	ProcessInfoRec	tempInfo;	FSSpec	procSpec;	Str31		processName;	OSErr		myErr = noErr;	// start at the beginning of the process list	processSN->lowLongOfPSN = kNoProcess;	processSN->highLongOfPSN = 0;	// initialize the process information record	tempInfo.processInfoLength = sizeof(ProcessInfoRec);	tempInfo.processName = (StringPtr)&processName;	tempInfo.processAppSpec = &procSpec;//	while((tempInfo.processSignature != creatorToFind ||//			tempInfo.processType != typeToFind) ||//			myErr != noErr)		do {		myErr = GetNextProcess (processSN);		if (myErr == noErr)		{			GetProcessInformation(processSN, &tempInfo);			if (tempInfo.processSignature == creatorToFind &&				tempInfo.processType == typeToFind)				break;		}			} while (myErr == noErr);	return(myErr);}void doCommandForSHUFFLER (char *cmd){	FILE	*c_file;	char	fi[256];	short	i;		memcpy (fi, &ShufflerPathName[1], ShufflerPathName[0]);	fi[ShufflerPathName[0]] = 0;		for (i = strlen (fi) - 1; i >= 0; i--)		if (fi[i] == ':')			break;		else			fi[i] = 0;	strcat (fi, "Ravel.What");	if (c_file = fopen (fi, "w"))	{		fprintf (c_file, "%s\n", cmd);		fclose (c_file);	}}Boolean doCheckOperating (){	ProcessInfoRecPtr	ProcessInfo;	Boolean				res;	register short		iErr;	//	make here background working about sublaunching, bbs, etc.	//	putlog ( lgATTN, "+ MISBEHAVE" );	ProcessInfo = (ProcessInfoRecPtr) NewPtr (sizeof(ProcessInfoRec));	ProcessInfo->processInfoLength = sizeof(ProcessInfoRec);	ProcessInfo->processName = NULL;	ProcessInfo->processAppSpec = NULL;		iErr = GetProcessInformation ( &launchedProcessSN, ProcessInfo );		res = ( iErr != noErr );		DisposePtr ( (Ptr) ProcessInfo );	return res;		//	TRUE - mean rise EventsPossible when done					//	FALSE - not done yet}//		doCommandForSHUFFLER ( "TOSS" );	//		if ( ApplicationLaunch ("\pRavelSHUFFLER") )//			res = FALSE;		Boolean ApplicationLaunch ( StringPtr ApplPathName ){	short				iErr;	LaunchParamBlockRec	myLaunchParams;	FSSpec				spec;	AppleEvent		event, reply;	AEAddressDesc	address;//	putlog ( lgATTN, "Try sublaunch %#s.", ApplPathName );	if ( iErr = FSMakeFSSpec ( 0, 0, ApplPathName, &spec ) )	{		putlog ( lgALRT, "Application %#s not found (err = %d).", ApplPathName, iErr );			return false;	}//	if ( !FindAProcess ( 'APPL', 'RvlQ', &launchedProcessSN ) )//	{//		putlog ( lgALRT, "RavelQUILL running. Try launch %#s later.", ApplPathName );	//		return false;//	}	if ( !FindAProcess ( 'APPL', 'RvlS', &launchedProcessSN ) )	{		iErr = AECreateDesc (typeProcessSerialNumber, &launchedProcessSN, sizeof(launchedProcessSN), &address);		if (iErr)		{			putlog ( lgALRT, "AECreateDesc (err = %d).", iErr );				return false;		}				iErr = AECreateAppleEvent (kRavelEventClass, kAEEnqueueCmd, &address, kAutoGenerateReturnID, kAnyTransactionID, &event);		if (iErr)		{			putlog ( lgALRT, "AECreateAppleEvent (err = %d).", iErr );				return false;		}		iErr = AESend (&event, &reply, kAENeverInteract + kAENoReply, kAENormalPriority, kAEDefaultTimeout, NULL, NULL);		if (iErr)		{			putlog ( lgALRT, "AESend (err = %d).", iErr );				return false;		}				AEDisposeDesc(&event);		AEDisposeDesc(&address);//		AEDisposeDesc(&reply);		putlog ( lgATTN, "Sending command for %#s.", ApplPathName );//		return false;	}	else	{		myLaunchParams.launchBlockID = extendedBlock;		myLaunchParams.launchEPBLength = extendedBlockLen;		myLaunchParams.launchFileFlags = 0;		myLaunchParams.launchControlFlags = launchContinue + launchNoFileFlags + launchDontSwitch;		myLaunchParams.launchAppSpec = &spec;		myLaunchParams.launchAppParameters = NULL;		iErr = LaunchApplication ( &myLaunchParams );		if (!iErr)		{			putlog ( lgATTN, "Sublaunching %#s.", ApplPathName );			launchedProcessSN = myLaunchParams.launchProcessSN;		}		else		{			putlog ( lgALRT, "Launch failed with errCode=%d.", iErr );				return FALSE;		}	}		return true;}