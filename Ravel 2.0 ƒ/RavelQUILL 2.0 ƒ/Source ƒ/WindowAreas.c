#include <Sound.h>#include <stdio.h>#include <string.h>#include "TE32K.h"#include "DialogLib.h"#include "PopUpLib.h"#include "myTEdit.h"/*ееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееее*///#include "Ravel_FTN.h"#include "ravel_msg_base.h"#include "Ravel_Prefs.h"#include "Preferences.h"//#include "BaseManager.h"#include "nodelist.h"#include "CommonData.h"#include "WindowsList.h"#include "WSubjects.h"#include "WAreas.h"#include "WView.h"#include "WNodes.h"#include "WAddressee.h"#include "multisaver.h"#include "Templates.h"/*ееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееее*/#include "rMenus.h"/*ееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееее*/extern	DialogPtr	dSplash;extern	Handle		*markArray;extern	Boolean		tracktome;typedef struct _wloc {	Point	topleft;	short	bottom;	} wloc;static	char	*hpbdCyril = "╥╔all alone isn╒t ill. It╒s all alone only╔╙\rHappy birthday Cyril";static	Rect	originalView = {0,0,0,0};pascal void LDEFAreas (short lMessage, Boolean lSelect, Rect *lRect, Cell lCell,				short lDataOffset, short lDataLen, ListHandle lHandle);//	#define cLeftOffset		5Boolean trackUnread (long i, long *lr, long *nm){	long		lr2;	Boolean		yeah;	msgbase_atom	Atom;//	if (i == AreasNumber+1)//		OpenBase ( BADAREA, true );//	else//		OpenBase (i, true);		msgbase_open_idx (i, true);		lr2 = msgbase_getlastread ();	*lr = msgbase_scanunread (0,0);	*nm = msgbase_getnummsg ();	if (*lr < 0)		*lr = 0;		msgbase_setlastread (*lr);	if (*nm != 0 && *nm - 1 == *lr)	{		msgbase_read_atom (*lr, &Atom);			yeah = (Atom.base_flags & ATOM_WASREAD) == 0;	}	else		yeah = (*nm != 0 && *nm - 1 != *lr);		msgbase_close ((*lr != lr2) ? 2 : 0);		return yeah;}pascal void LDEFAreas (short lMessage, Boolean lSelect, Rect *lRect, Cell lCell,				short lDataOffset, short lDataLen, ListHandle lHandle){	short 		leftDraw, topDraw, k, locked;	FontInfo 	fi;	long		i, j;	pktmsg		*m;	Point		drawpt;	char		tmp[128];//	long		lr, nm;//	Boolean		yeah;	unsigned char	oldMode;	PenState	penState;	areas_s		a_rec;	if ((lMessage == lInitMsg) || (lMessage == lCloseMsg))		return ;		leftDraw = lRect->left+(*lHandle)->indent.h;	topDraw = lRect->top+(*lHandle)->indent.v;		switch (lMessage)	{	case lDrawMsg:			SetPort ((*lHandle)->port);			if (lDataLen == 4)		{//			TextFont (viewFont);			TextFont (4);			TextSize (viewSize);			GetFontInfo (&fi);			SetPt ( &drawpt, leftDraw, topDraw+fi.leading+fi.ascent );			memcpy ( (Ptr) &i, *((*lHandle)->cells)+lDataOffset, 4 );#if !TARGET_API_MAC_CARBON			a_rec = (((windowsQElPtr)(((WindowPeek)(*lHandle)->port)->refCon))->common)->cAreasList.areasList[i];#else			a_rec = (((windowsQElPtr)GetWRefCon(GetWindowFromPort(GetListPort(lHandle))))->common)->cAreasList.areasList[i];#endif						if (a_rec.a_resync)			{				a_rec.a_mio = false;				a_rec.a_resync = false;				a_rec.a_unread = trackUnread (i, &a_rec.a_last, &a_rec.a_total);								if (a_rec.a_unread && tracktome)				{					msgbase_open_idx (i, true);					a_rec.a_mio = msgbase_scanforme (a_rec.a_last, myname);										msgbase_close (CLOSE_ONLY);				}				else					a_rec.a_mio = false;				#if !TARGET_API_MAC_CARBON				(((windowsQElPtr)(((WindowPeek)(*lHandle)->port)->refCon))->common)->cAreasList.areasList[i] = a_rec;#else				(((windowsQElPtr)GetWRefCon(GetWindowFromPort(GetListPort(lHandle))))->common)->cAreasList.areasList[i] = a_rec;#endif			}						EraseRect (lRect);			MoveTo ( drawpt.h + 1, drawpt.v );			if (a_rec.a_mio)			{				if (*((short *) 0x0D60) == 1)					TextFace (underline);				else					ForeColor (redColor);			}						DrawChar ((a_rec.a_unread) ? 0xA5 : 0x20);			if (*((short *) 0x0D60) == 1)				TextFace (0);			else				ForeColor (blackColor);			MoveTo ( drawpt.h + 7, drawpt.v );			sprintf (tmp, "%-48s %6ld  %6ld",				a_rec.a_name,				(a_rec.a_total) ? a_rec.a_last + 1 : a_rec.a_last,				a_rec.a_total);			DrawText ( tmp, 0, strlen (tmp) );		}		else			EraseRect (lRect);		if (!lSelect)			break;			case lHiliteMsg:			oldMode = LMGetHiliteMode();		LMSetHiliteMode(1);#if !TARGET_API_MAC_CARBON		if (((WindowPeek)(*lHandle)->port)->hilited)#else		if (IsWindowHilited(GetWindowFromPort(GetListPort(lHandle))))#endif			InvertRect(lRect);		else		{			GetPenState (&penState);			PenMode (srcXor);			FrameRect (lRect);			SetPenState (&penState);		}		LMSetHiliteMode(oldMode);				break;	}}static void AdjustWinSize (WindowPtr dialog, ListHandle list, short max){	short		iType, ii, dummy, neww, newh, newc;	Handle		iHandle;	Rect		iRect, rView, rDataBnds;	Point		cellSize;//	FontInfo	fInfo;	//	TextFont (viewFont);	TextFont (4);	TextSize (viewSize);//	GetFontInfo (&fInfo);	ii = CharWidth (' ');		GetDialogItem (GetDialogFromWindow(dialog), 1, &iType, &iHandle, &rView);	newc = (*list)->cellSize.v;//	neww = 1 + fInfo.widMax + fInfo.widMax * 48 + fInfo.widMax + fInfo.widMax * 6 + fInfo.widMax * 2 + fInfo.widMax * 6 + fInfo.widMax + 15;	//	rView.right;	neww = 1 + ii + ii * 48 + ii + ii * 6 + ii * 2 + ii * 6 + ii + 15;	//	rView.right;	newh = rView.top + (((max - rView.top) / newc) * newc);		SizeWindow (dialog, neww, newh, true);	originalView.bottom = newh;	LSetDrawingMode ( false, list );		LSize ( neww - 15, ((newh - rView.top) / newc) * newc, list);		SetPt (&cellSize, neww - 15, newc);	LCellSize (cellSize, list);#if !TARGET_API_MAC_CARBON	(*((*list)->vScroll))->contrlRect.bottom -= 15;#else	#warning !!!@@@!!!#endif		LSetDrawingMode ( true, list );}static void CalcLR (void){//	indexAtomType	Atom;//	long			i, j;	/*		j = GetNumOfMessages ();	for (i = 0; i < j; i++)	{		if (ReadMessageAtom (i, &Atom))		{			if (!(Atom.deleted & 0x4000))			{				SetLastRead (i);				return;			}		}	}*/	if (msgbase_getnummsg ())		msgbase_setlastread (msgbase_scanunread (0, 1));}void WAreasEventProcessor (EventRecord *event, windowsQElPtr dialogInfo, long info){	DateTimeRec	dtr;		DialogPtr	dialog;	ListHandle	list;	short		iType, ii, dummy, neww, newh, newc, menuItem;	Handle		iHandle;	Rect		iRect, rView, rDataBnds;	Point		cellSize, theCell;	Point		where;			long		lSizeVH, nm, jj;	long		i;		Str255		stemp;		char		key;		WStateData	*WStDat;	MenuHandle	hMenu;		WindowPtr	window;	windowsQElPtr	dInfo;	commonDataPtr	pcommon;	GrafPtr			oldPort;	switch (info & 0xFFFF)	{	case actionSetSize:				originalView.left = ((wloc *) event)->topleft.h;		originalView.top = ((wloc *) event)->topleft.v;		originalView.bottom = ((wloc *) event)->bottom;				break;		case actionGetSize:				((wloc *) event)->topleft.h = originalView.left;		((wloc *) event)->topleft.v = originalView.top;		((wloc *) event)->bottom = originalView.bottom;				break;		case actionCreate:		if (dInfo = windowsOpened (wtAreasList, 0, 0))		{			SelectWindow(dInfo->dialog);			break;		}				dialog = GetNewDialog(128 + wtAreasList, NULL, (dSplash)? GetDialogWindow(dSplash) : (WindowPtr) -1);		SetWindowKind(dialog, myKind);		SetPort (dialog);		if (originalView.bottom)		{			if (!SuchWindow (wtAreasList) || qd.screenBits.bounds.bottom - originalView.top < originalView.bottom)			{				if (!originalView.top)				{					originalView.top = (*(((WindowPeek)dialog)->contRgn))->rgnBBox.top;					originalView.left = (*(((WindowPeek)dialog)->contRgn))->rgnBBox.left;	//				originalView.bottom = dialog->portRect.bottom;					originalView.top = LMGetMBarHeight () * 2;				}			}			else			{				originalView.left += 20;				originalView.top += 20;			}		}		else		{			originalView = (*(((WindowPeek)dialog)->contRgn))->rgnBBox;			originalView.bottom = dialog->portRect.bottom;			originalView.top = LMGetMBarHeight () * 2;		}				MoveWindow (dialog, originalView.left, originalView.top, false);		SizeWindow (dialog, dialog->portRect.right, originalView.bottom, false);//		TextFont ( 4 );//		TextSize ( 9 );//		TextFont (viewFont);		TextFont (4);		TextSize (viewSize);		GetDialogItem ( dialog, 1, &iType, &iHandle, &rView );		SetRect ( &rDataBnds, 0, 0, 1, 0 );		rView.right -= 15;		SetPt ( &cellSize, 0, 0 );		list = LNew (						&rView,						&rDataBnds,						cellSize,						128,						dialog,						true,						false,						false,						true					);		(*list)->selFlags = 0x82;		(*list)->port->txFont = 4;		(*list)->port->txSize = 9;		(*(*list)->vScroll)->contrlRect.bottom -= 15;//		MoveTo (0, rView.top - 1);//		LineTo (rView.right + 15, rView.top - 1);				LActivate ( true, list );		AdjustWinSize (dialog, list, dialog->portRect.bottom);		ShowWindow ( dialog );		pcommon = (commonDataPtr) NewPtrClear (sizeof (commonAreasList));				pcommon->cAreasList.dialog = dialog;		pcommon->cAreasList.list = list;		pcommon->cAreasList.area_number = 0;		pcommon->cAreasList.areasList = (areas_s_ptr) NewPtrClear (sizeof (areas_s) * (AreasNumber + 2));				strcpy (pcommon->cAreasList.areasList[0].a_name, "NETMAIL");		pcommon->cAreasList.areasList[0].a_resync = true;				for ( i = 0; i < AreasNumber; i++ )		{			(*areasHndls[i])->areaName[(*areasHndls[i])->areaName[0]+1] = 0;			strcpy (pcommon->cAreasList.areasList[i+1].a_name,						(char *) &(*areasHndls[i])->areaName[1]);			pcommon->cAreasList.areasList[i+1].a_resync = true;		}		strcpy (pcommon->cAreasList.areasList[AreasNumber+1].a_name, "BADMAIL");		pcommon->cAreasList.areasList[AreasNumber+1].a_resync = true;				windowsAdd (dialog, wtAreasList, pcommon, WAreasEventProcessor, WAreasDialogProcessor);				dInfo = windowsLookUp (dialog);				SetWRefCon (dialog, (long) dInfo);		dInfo->inFront = true;		LSetDrawingMode ( false, list );/*		Init areas here		*/		dummy = LAddRow ( AreasNumber + 2, 0, list );		for ( i = 0; i <= AreasNumber; i++ )		{			SetPt ( &theCell, 0, i );			LSetCell (&i, sizeof (long), theCell, list);		}		SetPt ( &theCell, 0, i = AreasNumber+1 );		LSetCell (&i, sizeof (long), theCell, list);				SetPt (&theCell, 0, 0);		LSetSelect (true, theCell,list);				LSetDrawingMode ( true, list );		WStDat = (WStateData *) *((WindowPeek) dialog)->dataHandle;				newc = (*list)->cellSize.v;		dummy = rView.top + newc * (*list)->dataBounds.bottom;				SetRect (&(WStDat->stdState),			WStDat->stdState.left + dialog->portRect.left,			WStDat->stdState.top + dialog->portRect.top,			WStDat->stdState.left + dialog->portRect.right,			(qd.screenBits.bounds.bottom < WStDat->stdState.top + dummy) ?				qd.screenBits.bounds.bottom :				((*list)->dataBounds.bottom > 5) ? WStDat->stdState.top + dummy :					WStDat->stdState.top + dialog->portRect.bottom);		WAreasEventProcessor (NULL, dInfo, ((long) inMenuBar << 16) | mouseDown);		if (dSplash)		{			WAreasEventProcessor (NULL, dInfo, updateEvt);			Delay (60, (unsigned long *) &jj);			DisposeDialog (dSplash);			dSplash = NULL;		}		break;	case actionClose:		originalView = (*(((WindowPeek)(dialogInfo->dialog))->contRgn))->rgnBBox;		originalView.bottom = (dialogInfo->dialog)->portRect.bottom;		LDispose ((dialogInfo->common)->cAreasList.list);				DisposePtr ((Ptr) (dialogInfo->common)->cAreasList.areasList);		DisposePtr ((Ptr) dialogInfo->common);				DisposeDialog (dialogInfo->dialog);		windowsKill (dialogInfo->dialog);		break;			case actionActive:		DrawOnlyGrowIcon (dialogInfo->dialog);		MoveControl ((*(dialogInfo->common)->cAreasList.list)->vScroll,			(*(dialogInfo->common)->cAreasList.list)->rView.right + ((dialogInfo->inFront) ? 0 : 15),			(*(dialogInfo->common)->cAreasList.list)->rView.top - 1);				SetPt (&theCell, 0, 0);			if ( LGetSelect (true, &theCell, (dialogInfo->common)->cAreasList.list) )		{			LDraw (theCell, (dialogInfo->common)->cAreasList.list);		}				break;	case actionBroadcast:			GetPort (&oldPort);		SetPort (dialogInfo->dialog);				switch (((BroadcastRecPtr) event)->synctype)		{		case broadClose:					WAreasEventProcessor (NULL, dialogInfo, actionClose);			break;					case broadRedrawCell:						(dialogInfo->common)->cAreasList.areasList[((BroadcastRecPtr) event)->area].a_resync = true;						SetPt (&theCell, 0, ((BroadcastRecPtr) event)->area);			LDraw (theCell, (dialogInfo->common)->cAreasList.list);			break;		}				SetPort (oldPort);				break;		case actionMenu:		menuItem = (info >> 16) & 0xFF;				switch ((info >> 24) & 0xFF)		{		case fileM:					switch (menuItem)			{			case fExport:								SetPt (&theCell, 0, 0);							if ( LGetSelect (true, &theCell, (dialogInfo->common)->cAreasList.list) )					SaveMessagesToFile (theCell.v, 0, 1);								break;			}						break;				case windowM:					switch (menuItem)			{			case wSubjects:								SetPt (&theCell, 0, 0);							if ( LGetSelect (true, &theCell, (dialogInfo->common)->cAreasList.list) )				{					WSubjectsEventProcessor ((EventRecord *) theCell.v, (windowsQElPtr) -1L, actionCreate);				}								break;			}						break;		case nodeM:			switch (menuItem)			{			case nBrowse:								WNodeEventProcessor ((EventRecord *) 2L, (windowsQElPtr) &(*homesystem)->mainAddr.ad, actionCreate);				break;						case nNotepad:							WAddresseeEventProcessor ((EventRecord *) 1L, NULL, actionCreate);				break;			}						break;		}		break;		case actionOpen:			SetPt (&theCell, 0, 0);			if ( LGetSelect (true, &theCell, (dialogInfo->common)->cAreasList.list) )		{			WViewEventProcessor ((EventRecord *) theCell.v, (windowsQElPtr) -1L, actionCreate);		}		break;		case mouseDown:		if ((info >> 16) != inMenuBar)			where = event->where;		switch (info >> 16)		{		case inMenuBar:					recalcWindowMenu ();			SetPt (&theCell, 0, 0);					dummy = LGetSelect (true, &theCell, (dialogInfo->common)->cAreasList.list);			hMenu = GetMenuHandle (fileM + 256);			(*hMenu)->enableFlags = 1L | (1L << fQuit) | (1L << fPageSetup);						if (dummy)				(*hMenu)->enableFlags |= (1L << fOpen) | (1L << fExport);			hMenu = GetMenuHandle (editM + 256);			(*hMenu)->enableFlags = 1L | (1L << iUserName) | (1L << iOrigin) | (1L << iShowKludges) | (1L << iShowPgf);			hMenu = GetMenuHandle (msgM + 256);			(*hMenu)->enableFlags = 0;			hMenu = GetMenuHandle (nodeM + 256);						(*hMenu)->enableFlags = 0;						if (padname[0])				(*hMenu)->enableFlags |= (1L | (1L << nNotepad));						if (yep ())				(*hMenu)->enableFlags |= (1L | (1L << nBrowse));			hMenu = GetMenuHandle (shuffleM + 256);			(*hMenu)->enableFlags = -1L;			hMenu = GetMenuHandle (windowM + 256);			if (((WindowPeek)(dialogInfo->dialog))->windowKind != myKind_top)			{				(*hMenu)->enableFlags = -1L;			}			else				(*hMenu)->enableFlags = 0;			if (!dummy)				(*hMenu)->enableFlags &= ~(1L << wSubjects);			DrawMenuBar ();			break;		case inContent:					FindWindow (event->where, &window);						if (window != FrontWindow ())			{				if (((WindowPeek)FrontWindow ())->windowKind == myKind_top)					SysBeep (10);				else					SelectWindow (window);			}			else			{				SetPort (dialogInfo->dialog);				GlobalToLocal (&where);				if (LClick (where, event->modifiers, (dialogInfo->common)->cAreasList.list))				{					WAreasEventProcessor (NULL, dialogInfo, actionOpen);				}			}			break;		case inZoomIn:		case inZoomOut:			SetPort (dialogInfo->dialog);			if (TrackBox (dialogInfo->dialog, event->where, info >> 16))			{				ZoomWindow (dialogInfo->dialog, info >> 16, true);				AdjustWinSize (dialogInfo->dialog,						(dialogInfo->common)->cAreasList.list,						(dialogInfo->dialog)->portRect.bottom);								originalView = (*(((WindowPeek)(dialogInfo->dialog))->contRgn))->rgnBBox;				originalView.bottom = (dialogInfo->dialog)->portRect.bottom;				EraseRect (&(dialogInfo->dialog)->portRect);				InvalRect (&(dialogInfo->dialog)->portRect);			}			break;		case inDrag:			FindWindow (event->where, &window);						if (window != FrontWindow ())			{				if (((WindowPeek)FrontWindow ())->windowKind == myKind_top)					SysBeep (10);				else					SelectWindow (window);			}			else			{				DragWindow ( dialogInfo->dialog, event->where, &qd.screenBits.bounds );				originalView = (*(((WindowPeek)(dialogInfo->dialog))->contRgn))->rgnBBox;				originalView.bottom = (dialogInfo->dialog)->portRect.bottom;			}						break;		case inGrow:					SetPort (dialogInfo->dialog);						GetDialogItem ( dialogInfo->dialog, 1, &iType, &iHandle, &rView );						newc = (*((dialogInfo->common)->cAreasList.list))->cellSize.v;			rDataBnds.top = rView.top + newc * 8;			rDataBnds.bottom = qd.screenBits.bounds.bottom;			rDataBnds.left = (dialogInfo->dialog)->portRect.right;			rDataBnds.right = (dialogInfo->dialog)->portRect.right;			lSizeVH = GrowWindow ( dialogInfo->dialog, event->where, &rDataBnds );						if (lSizeVH)			{				AdjustWinSize (dialogInfo->dialog, (dialogInfo->common)->cAreasList.list, HiWord (lSizeVH));				EraseRect (&(dialogInfo->dialog)->portRect);				InvalRect (&(dialogInfo->dialog)->portRect);			}						break;		}			break;		case keyDown:	case autoKey:				SetPort (dialogInfo->dialog);		key = event->message & 0xFF;				SetPort (dialogInfo->dialog);		switch (key)		{		case '/':					SetPt (&theCell, 0, 0);					if ( LGetSelect (true, &theCell, (dialogInfo->common)->cAreasList.list) )			{//				if (theCell.v == AreasNumber+1)//					OpenBase ( BADAREA, true );//				else//					OpenBase (theCell.v, true);								msgbase_open_idx (theCell.v, true);					msgbase_allread ();								msgbase_close (CLOSE_UPDATE);				Broadcast (wtAreasList, broadRedrawCell, theCell.v, 0);				Broadcast (wtSubjects, broadRedrawCells, theCell.v, 0);				Broadcast (wtMsgView, broadRedrawCell, theCell.v, 0);			}						break;				case '*':					SetPt (&theCell, 0, 0);					if ( LGetSelect (true, &theCell, (dialogInfo->common)->cAreasList.list) )			{//				if (theCell.v == AreasNumber+1)//					OpenBase ( BADAREA, false );//				else//					OpenBase (theCell.v, false);				msgbase_open_idx (theCell.v, false);				nm = msgbase_getnummsg ();				msgbase_close (CLOSE_ONLY);		//		SetCursor (&watchCursor);								for (jj=0; jj < nm; jj++)				{					(*markArray[theCell.v])[jj] = 0xFF;				}								Broadcast (wtSubjects, broadRedrawCells, theCell.v, 0);				Broadcast (wtMsgView, broadRedrawCell, theCell.v, 0);		//		SetCursor (&arrow);			}					break;						case 0x1B:					if ((event->message & 0xFF00) != 0x4700)				break;					SetPt (&theCell, 0, 0);					if ( LGetSelect (true, &theCell, (dialogInfo->common)->cAreasList.list) )			{//				if (theCell.v == AreasNumber+1)//					OpenBase ( BADAREA, false );//				else//					OpenBase (theCell.v, false);				msgbase_open_idx (theCell.v, false);				nm = msgbase_getnummsg ();				msgbase_close (CLOSE_ONLY);				for (jj=0; jj < nm; jj++)				{					(*markArray[theCell.v])[jj] = 0;				}								Broadcast (wtSubjects, broadRedrawCells, theCell.v, 0);				Broadcast (wtMsgView, broadRedrawCell, theCell.v, 0);			}					break;				case EnterKey:		case ReturnKey://		case 0x20:					WAreasEventProcessor (NULL, dialogInfo, actionOpen);			break;				case UpArrowKey:		//	Up		case DownArrowKey:		//	Down					newh = (*((dialogInfo->common)->cAreasList.list))->dataBounds.bottom;					SetPt (&theCell, 0, 0);					if ( LGetSelect (true, &theCell, (dialogInfo->common)->cAreasList.list) )				newc = theCell.v;			else				newc = (key == UpArrowKey) ? newh : -1;						neww = (key == UpArrowKey) ? newc - 1 : newc + 1;						if (neww >= newh)				neww = 0;			else				if (neww < 0)					neww = newh - 1;						SetPt (&theCell, 0, newc);			LSetSelect (false, theCell, (dialogInfo->common)->cAreasList.list);						SetPt (&theCell, 0, neww);			LSetSelect (true, theCell, (dialogInfo->common)->cAreasList.list);						LAutoScroll ((dialogInfo->common)->cAreasList.list);			break;		case PageUpKey:			//	Up		case PageDownKey:		//	Down					GetDialogItem ( dialogInfo->dialog, 1, &iType, &iHandle, &rView );			dummy = ((dialogInfo->dialog)->portRect.bottom - rView.top) / (*((dialogInfo->common)->cAreasList.list))->cellSize.v;			newh = (*((dialogInfo->common)->cAreasList.list))->dataBounds.bottom;			if (dummy < newh)			{				SetPt (&theCell, 0, 0);							if ( LGetSelect (true, &theCell, (dialogInfo->common)->cAreasList.list) )				{					newc = theCell.v;										neww = (key == PageUpKey) ? newc - dummy : newc + dummy;										if (neww >= newh)						neww = newh - 1;					else						if (neww < 0)							neww = 0;										SetPt (&theCell, 0, newc);					LSetSelect (false, theCell, (dialogInfo->common)->cAreasList.list);										SetPt (&theCell, 0, neww);					LSetSelect (true, theCell, (dialogInfo->common)->cAreasList.list);					LAutoScroll ((dialogInfo->common)->cAreasList.list);				}			}			else			{				SetPt (&theCell, 0, 0);							if ( LGetSelect (true, &theCell, (dialogInfo->common)->cAreasList.list) )				{					newc = theCell.v;										neww = (key == PageUpKey) ? 0 : newh - 1;										SetPt (&theCell, 0, newc);					LSetSelect (false, theCell, (dialogInfo->common)->cAreasList.list);										SetPt (&theCell, 0, neww);					LSetSelect (true, theCell, (dialogInfo->common)->cAreasList.list);					LAutoScroll ((dialogInfo->common)->cAreasList.list);				}			}						break;		case HomeKey:					SetPt (&theCell, 0, 0);					if ( LGetSelect (true, &theCell, (dialogInfo->common)->cAreasList.list) )			{				newc = theCell.v;				SetPt (&theCell, 0, newc);				LSetSelect (false, theCell, (dialogInfo->common)->cAreasList.list);			}			SetPt (&theCell, 0, 0);			LSetSelect (true, theCell, (dialogInfo->common)->cAreasList.list);			LAutoScroll ((dialogInfo->common)->cAreasList.list);			break;		case EndKey:					newh = (*((dialogInfo->common)->cAreasList.list))->dataBounds.bottom;			SetPt (&theCell, 0, 0);					if ( LGetSelect (true, &theCell, (dialogInfo->common)->cAreasList.list) )			{				newc = theCell.v;				SetPt (&theCell, 0, newc);				LSetSelect (false, theCell, (dialogInfo->common)->cAreasList.list);			}			SetPt (&theCell, 0, newh-1);			LSetSelect (true, theCell, (dialogInfo->common)->cAreasList.list);			LAutoScroll ((dialogInfo->common)->cAreasList.list);			break;		}		break;			case updateEvt:		SetPort (dialogInfo->dialog);		BeginUpdate (dialogInfo->dialog);//		iRect = (*(((WindowPeek)(dialogInfo->dialog))->updateRgn))->rgnBBox;		//		GlobalToLocal (&topLeft(iRect));//		GlobalToLocal (&botRight(iRect));//		if (iRect.right > (*(dialogInfo->common)->cAreasList.list)->rView.right)//			iRect.right = (*(dialogInfo->common)->cAreasList.list)->rView.right;//		EraseRect (&iRect);		GetDialogItem (dialogInfo->dialog, 1, &iType, &iHandle, &rView );				SetRect (&rDataBnds, 0, 0, (dialogInfo->dialog)->portRect.right, rView.top - 1);		EraseRect (&rDataBnds);				GetTime (&dtr);				if (dtr.day == 3 && dtr.month == 10)		{			TextFace (bold);						TETextBox (hpbdCyril, strlen (hpbdCyril), &rDataBnds, teJustCenter);						TextFace (0);		}				MoveTo (0, rView.top - 1);		LineTo ((dialogInfo->dialog)->portRect.right, rView.top - 1);/*		{			RgnHandle	mRgn;						mRgn = NewRgn ();			RectRgn (mRgn, &iRect);			LUpdate ( mRgn, (dialogInfo->common)->cAreasList.list );			if (!(dialogInfo->inFront))			{				iRect = (*(dialogInfo->common)->cAreasList.list)->rView;				iRect.left = iRect.right;				iRect.right += 15;				iRect.bottom -= 15;				EraseRect (&iRect);				MoveTo ((*(dialogInfo->common)->cAreasList.list)->rView.right,						(*(dialogInfo->common)->cAreasList.list)->rView.top);				LineTo ((*(dialogInfo->common)->cAreasList.list)->rView.right,						(*(dialogInfo->common)->cAreasList.list)->rView.bottom);			}			DisposeRgn (mRgn);		}*/		LUpdate ((dialogInfo->dialog)->visRgn, (dialogInfo->common)->cAreasList.list);		if (!(dialogInfo->inFront))		{			iRect = (*(dialogInfo->common)->cAreasList.list)->rView;			iRect.left = iRect.right;			iRect.right += 15;			iRect.bottom -= 15;			EraseRect (&iRect);			MoveTo ((*(dialogInfo->common)->cAreasList.list)->rView.right,					(*(dialogInfo->common)->cAreasList.list)->rView.top);			LineTo ((*(dialogInfo->common)->cAreasList.list)->rView.right,					(*(dialogInfo->common)->cAreasList.list)->rView.bottom);		}		DrawOnlyGrowIcon (dialogInfo->dialog);		EndUpdate (dialogInfo->dialog);		break;	}}void WAreasDialogProcessor (EventRecord *event, windowsQElPtr dialogInfo, long info){	DialogPtr	dialog;	short		iHit;	Point		where;	}