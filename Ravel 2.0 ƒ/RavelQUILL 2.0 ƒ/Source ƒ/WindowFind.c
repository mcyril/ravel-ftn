#include <Sound.h>#include <stdio.h>#include <string.h>#include "TE32K.h"#include "DialogLib.h"#include "PopUpLib.h"#include "myTEdit.h"/*본본본본본본본본본본본본본본본본본본본본본본본본본본본본본본본본본본본본본본*///#include "Ravel_FTN.h"#include "ravel_msg_base.h"#include "Ravel_Prefs.h"#include "Preferences.h"#include "pktparse.h"#include "stringutl.h"//#include "BaseManager.h"#include "CommonData.h"#include "WindowsList.h"#include "WFind.h"#include "Filter.h"#include "Templates.h"#include "SoundLib.h"/*본본본본본본본본본본본본본본본본본본본본본본본본본본본본본본본본본본본본본본*/#include "rMenus.h"/*본본본본본본본본본본본본본본본본본본본본본본본본본본본본본본본본본본본본본본*/typedef struct _wloc {	Point	topleft;	short	bottom;	} wloc;extern	short	viewFont;static	Rect	originalView = {0,0,0,0};static	Rect	originalView1 = {0,0,0,0};static	windowsQElPtr	gParrent = 0;static	long			gBase = -1;static	long			gMessage;static	long			gMode = 0x0006;static	long			gOperation = 0;static	Str255			gWhat = "\p";static	Boolean			gCanceled;void	DoEvent (EventRecord *event);static	RGBColor	colorBlack = {17030, 17030, 17030};static	RGBColor	colorWhite = {53055, 53055, 65535};static	long	progressValue;static	float	limit;static	Rect	box;static void _InitProgress (DialogPtr RavelWindow, float howmuch){	Handle		iHandle;	short		iType;	RGBColor	oldFColor;	Rect		bbox;	GrafPtr		oldPort;			GetPort (&oldPort);	SetPort (RavelWindow);	GetDialogItem ( RavelWindow, 2, &iType, &iHandle, &box );	GetForeColor (&oldFColor);	RGBForeColor (&colorWhite);	FillRect ( &box, &qd.black );	RGBForeColor (&oldFColor);		bbox = box;	InsetRect ( &bbox, -1, -1 );	FrameRect ( &bbox );	progressValue = 0;	limit = ((float)(box.right - box.left))/howmuch;	/* use a float to get good*/	SetPort (oldPort);}static void _DrawProgress (long i, Boolean update){	RGBColor	oldFColor;	Rect		bbox;	GrafPtr		oldPort;			if (!update && progressValue == i)		return;		bbox = box;	bbox.right = box.left + (progressValue = i)*limit;	GetForeColor (&oldFColor);	RGBForeColor (&colorBlack);	FillRect ( &bbox, &qd.black );	bbox = box;	bbox.left = box.left + (progressValue = i)*limit;	RGBForeColor (&colorWhite);	FillRect ( &bbox, &qd.black );	RGBForeColor (&oldFColor);	bbox = box;	InsetRect ( &bbox, -1, -1 );	FrameRect ( &bbox );}static long subfind (char *what, char *text){	long		stlen = strlen (text);	short		whlen = strlen (what);	long		the_pos = 0;	long		res = -1;		if (stlen == 0)		return res;	while (the_pos + whlen <= stlen)	{		if ( ((gMode & 0x0001) == 0 && !strncasecmp (what, text+the_pos, whlen)) ||			 ((gMode & 0x0001) != 0 && !strncmp (what, text+the_pos, whlen)) )		{			res = the_pos;			break;		}			the_pos++;	}		return res;}void FindInit (windowsQElPtr parrent, long base, long message){	gParrent = parrent;	gBase = base;	gMessage = message;	gCanceled = false;		WFindEventProcessor ((EventRecord *) FindNext, (windowsQElPtr) FindCancel, actionCreate);}void FindNextNext (windowsQElPtr parrent, long base, long message){	gCanceled = false;		if (gParrent != parrent || gBase != base)		FindInit (parrent, base, message);	else	{		if (message == gMessage)			gMessage++;				FindNext ();	}}void FindNext (void){	EventRecord		event;	long			i, res;	pktmsg			*m;	BroadcastRec	bc;	short			ddum;	register void (*EventProcessor) (EventRecord *event, struct _window *dialogInfo, long info);	if ((gMode & 0x0006) != 0 && gWhat[0])	{		gWhat[gWhat[0]+1] = 0;	//		if (gBase == AreasNumber+1)//			OpenBase ( BADAREA, true );//		else//			OpenBase (gBase, true);		msgbase_open_idx (gBase, true);		WProgressEventProcessor ((EventRecord *) msgbase_getnummsg (), NULL, actionCreate);		for (i = gMessage; ; i++)		{			if (gCanceled)				break;						Broadcast (wtFindDlg, broadSyncCellLR, i, 0);						if ((gMode & 0x0004) != 0)			{				if (!msgbase_read_message (i, &m, READMODE_TEXT))					break;				callFilter (m->text);				HLock (m->text);			}			else			{				if (!msgbase_read_message (i, &m, READMODE_ONLY))					break;			}						res = -1;			if (((gMode & 0x0002) != 0 &&				(subfind ((char *) &gWhat[1], m->fromname) >= 0 ||				 subfind ((char *) &gWhat[1], m->toname) >= 0 ||				 subfind ((char *) &gWhat[1], m->subj) >= 0)))				 	res = -2;						if (res == -1 && (gMode & 0x0004) != 0)				res = subfind ((char *) &gWhat[1], *m->text);						if (res != -1)			{				FreePktMsg (m);				Broadcast (wtFindDlg, broadClose, -1, 0);				msgbase_close (CLOSE_ONLY);				EventProcessor = gParrent->EventProcessor;				bc.synctype = broadSyncCellLR;				bc.area = gBase;				bc.message = gMessage = i;				EventProcessor ((EventRecord *) &bc, gParrent, actionBroadcast);								if (res >= 0)				{					WinCom	WCP;					struct _TECommand	TEC;									WCP.arg.TEC = &TEC;					bc.param[0] = (long)&WCP;					WCP.arg.TEC->fieldnumber = 0;					WCP.arg.TEC->frompos = res;					WCP.arg.TEC->topos = res + gWhat[0];					bc.synctype = teCmdSelectText;					EventProcessor ((EventRecord *) &bc, gParrent, actionBroadcast);					bc.synctype = teCmdScrollToVisible;					EventProcessor ((EventRecord *) &bc, gParrent, actionBroadcast);				}				return;			}			FreePktMsg (m);						if (WaitNextEvent (everyEvent, &event, 0, NULL))			{				if (!event.what)					goto nulled;								msgbase_close (CLOSE_ONLY);				DoEvent (&event);						//				if (gBase == AreasNumber+1)//					OpenBase ( BADAREA, true );//				else//					OpenBase (gBase, true);				msgbase_open_idx (gBase, true);			}			else			{			nulled:							DoEvent (&event);			}		}				Broadcast (wtFindDlg, broadClose, -1, 0);		msgbase_close (CLOSE_ONLY);	}		gParrent = 0;	gBase = -1;		CallASndPlay (131);}void FindCancel (void){}void WFindEventProcessor (EventRecord *event, windowsQElPtr dialogInfo, long info){	DialogPtr	dialog;	RGBColor	color, color1;	LongRect	tlRect;	short		iType, ii, dummy, neww, newh, newc, menuItem;	Handle		iHandle;	Rect		iRect, rView, rDataBnds;	Point		cellSize, theCell;	Point		where;			long		lSizeVH, nm, jj;		Str255		stemp;		char		key;		WStateData	*WStDat;	MenuHandle	hMenu;		WindowPtr	window;	windowsQElPtr	dInfo;	commonDataPtr	pcommon;	GrafPtr			oldPort;	PScrapStuff		pScrpInf;	FontInfo		fi;	register void (*Action)(void);	switch (info & 0xFFFF)	{	case actionSetSize:				originalView.left = ((wloc *) event)->topleft.h;		originalView.top = ((wloc *) event)->topleft.v;		originalView.bottom = ((wloc *) event)->bottom;				break;		case actionGetSize:				((wloc *) event)->topleft.h = originalView.left;		((wloc *) event)->topleft.v = originalView.top;		((wloc *) event)->bottom = originalView.bottom;				break;		case actionCreate:		if (dInfo = windowsOpened (wtFindDlg, 0, 0))		{			SelectWindow (dInfo->dialog);			break;		}				dialog = FrontWindow ();		if (!dialog)			iRect = (*LMGetGrayRgn ())->rgnBBox;		else			iRect = (*(((WindowPeek)dialog)->contRgn))->rgnBBox;				dialog = GetNewDialog (132, NULL, (WindowPtr) -1);		((WindowPeek)dialog)->windowKind = myKind_top;				SetPort ( dialog );		if (!originalView.bottom)		{			originalView.left = iRect.right / 2 -				(dialog->portRect.right - dialog->portRect.left) / 2;			originalView.top = iRect.bottom / 2 -				(dialog->portRect.bottom - dialog->portRect.top) / 2;					originalView.bottom = 1;		}				MoveWindow (dialog, originalView.left, originalView.top, false);				GetDialogItem ( dialog, 5, &iType, &iHandle, &iRect );		SetControlValue ( (ControlHandle) iHandle, (gMode & 0x0001) != 0 );		GetDialogItem ( dialog, 6, &iType, &iHandle, &iRect );		SetControlValue ( (ControlHandle) iHandle, (gMode & 0x0002) != 0 );		GetDialogItem ( dialog, 7, &iType, &iHandle, &iRect );		SetControlValue ( (ControlHandle) iHandle, (gMode & 0x0004) != 0 );		ShowWindow ( dialog );		pcommon = (commonDataPtr) NewPtrClear (sizeof (commonGPurpose));				pcommon->cGeneral.dialog = dialog;				TextFont (viewFont);		TextSize (viewSize);		GetFontInfo (&fi);		GetDialogItem ( dialog, 3, &iType, &iHandle, &iRect );		iRect.bottom = iRect.top + fi.ascent + fi.descent;		SetDialogItem ( dialog, 3, iType, iHandle, &iRect );		pcommon->cGeneral.te = littleTENew (dialog, 3, false, true);		(*pcommon->cGeneral.te)->txFont = viewFont;		(*pcommon->cGeneral.te)->txSize = viewSize;		TextFont (0);		TextSize (0);				TE32KSetText ((char *) &gWhat[1], gWhat[0], pcommon->cGeneral.te);		(ProcPtr) pcommon->cGeneral.Action = (ProcPtr) event;		(ProcPtr) pcommon->cGeneral.ActionCancel = (ProcPtr) dialogInfo;		windowsAdd (dialog, wtFindDlg, pcommon, WFindEventProcessor, WFindDialogProcessor);				dInfo = windowsLookUp (dialog);				SetWRefCon (dialog, (long) dInfo);		dInfo->inFront = true;		WFindEventProcessor (NULL, dInfo, ((long) inMenuBar << 16) | mouseDown);		break;	case actionClose:		TE32KDispose ((dialogInfo->common)->cGeneral.te);		DisposePtr ((Ptr) dialogInfo->common);				DisposeDialog (dialogInfo->dialog);		windowsKill (dialogInfo->dialog);		break;			case actionActive:		break;	case actionBroadcast:			GetPort (&oldPort);		SetPort (dialogInfo->dialog);		switch (((BroadcastRecPtr) event)->synctype)		{		case broadClose:					WFindEventProcessor (NULL, dialogInfo, actionClose);			break;		}			SetPort (oldPort);		break;		case actionMenu:		SetPort (dialogInfo->dialog);		menuItem = (info >> 16) & 0xFF;				switch ((info >> 24) & 0xFF)		{		case editM:					GetBackColor (&color1);			color.red = color.green = color.blue = 0xFFFF;			RGBBackColor(&color);			switch (menuItem)			{			case iCut:								TE32KCutToScrap ((dialogInfo->common)->cGeneral.te);				break;			case iCopy:								TE32KCopyToScrap ((dialogInfo->common)->cGeneral.te);				break;			case iPaste:								TE32KPasteFromScrap ((dialogInfo->common)->cGeneral.te);				break;			case iClear:								TE32KDelete ((dialogInfo->common)->cGeneral.te);				break;			}//			color.red = color.green = color.blue = 50000;			RGBBackColor(&color1);			break;		}				break;		case actionOpen:			break;		case mouseDown:		if ((info >> 16) != inMenuBar)			where = event->where;		switch (info >> 16)		{		case inMenuBar:					recalcWindowMenu ();			hMenu = GetMenuHandle (fileM + 256);			(*hMenu)->enableFlags = 1L | (1L << fClose) | (1L << fQuit);						hMenu = GetMenuHandle (editM + 256);			(*hMenu)->enableFlags = 1L;			if ((*(dialogInfo->common)->cGeneral.te)->selStart != (*(dialogInfo->common)->cGeneral.te)->selEnd)				(*hMenu)->enableFlags |= (1L << iCopy) | (1L << iCut) | (1L << iClear);						pScrpInf = InfoScrap ();			if (pScrpInf->scrapSize != 0 && pScrpInf->scrapSize < 200)				(*hMenu)->enableFlags |= (1L << iPaste);			hMenu = GetMenuHandle (msgM + 256);			(*hMenu)->enableFlags = 0;			hMenu = GetMenuHandle (nodeM + 256);			(*hMenu)->enableFlags = 0;			hMenu = GetMenuHandle (shuffleM + 256);			(*hMenu)->enableFlags = 0;			hMenu = GetMenuHandle (windowM + 256);			(*hMenu)->enableFlags = 0;			DrawMenuBar ();			break;		case inContent:					FindWindow (event->where, &window);						if (window != FrontWindow ())			{				if (((WindowPeek)FrontWindow ())->windowKind == myKind_top)					SysBeep (10);				else					SelectWindow (window);			}			else			{				SetPort (dialogInfo->dialog);				GlobalToLocal (&where);								GetDialogItem (dialogInfo->dialog, 3, &iType, &iHandle, &iRect);								if (PtInRect (where, &iRect))				{					GetBackColor (&color1);					color.red = color.green = color.blue = 0xFFFF;					RGBBackColor(&color);					TE32KClick (where, (event->modifiers & shiftKey) != 0, (dialogInfo->common)->cGeneral.te);//					color.red = color.green = color.blue = 50000;					RGBBackColor(&color1);				}			}			break;		case inDrag:			FindWindow (event->where, &window);						if (window != FrontWindow ())			{				if (((WindowPeek)FrontWindow ())->windowKind == myKind_top)					SysBeep (10);				else					SelectWindow (window);			}			else			{				DragWindow ( dialogInfo->dialog, event->where, &qd.screenBits.bounds );				originalView = (*(((WindowPeek)(dialogInfo->dialog))->contRgn))->rgnBBox;			}						break;		case inGoAway:					if (TrackGoAway (dialogInfo->dialog, event->where))			{				gMode = 0;								GetDialogItem ( dialogInfo->dialog, 5, &iType, &iHandle, &iRect );				gMode |= (GetControlValue ( (ControlHandle) iHandle ) != 0) ? 0x0001 : 0;				GetDialogItem ( dialogInfo->dialog, 6, &iType, &iHandle, &iRect );				gMode |= (GetControlValue ( (ControlHandle) iHandle ) != 0) ? 0x0002 : 0;				GetDialogItem ( dialogInfo->dialog, 7, &iType, &iHandle, &iRect );				gMode |= (GetControlValue ( (ControlHandle) iHandle ) != 0) ? 0x0004 : 0;				if ((*(dialogInfo->common)->cGeneral.te)->teLength > 0 &&					(*(dialogInfo->common)->cGeneral.te)->teLength < 240)				{					memcpy (&gWhat[1], *(*(dialogInfo->common)->cGeneral.te)->hText, (*(dialogInfo->common)->cGeneral.te)->teLength);					gWhat[0] = (*(dialogInfo->common)->cGeneral.te)->teLength;				}								Action = (dialogInfo->common)->cGeneral.ActionCancel;				WFindEventProcessor (event, dialogInfo, actionClose);				Action ();			}						break;		}			break;		case keyDown:	case autoKey:				SetPort (dialogInfo->dialog);		key = event->message & 0xFF;				switch (key)		{		case 0x1B:			gMode = 0;						GetDialogItem ( dialogInfo->dialog, 5, &iType, &iHandle, &iRect );			gMode |= (GetControlValue ( (ControlHandle) iHandle ) != 0) ? 0x0001 : 0;			GetDialogItem ( dialogInfo->dialog, 6, &iType, &iHandle, &iRect );			gMode |= (GetControlValue ( (ControlHandle) iHandle ) != 0) ? 0x0002 : 0;			GetDialogItem ( dialogInfo->dialog, 7, &iType, &iHandle, &iRect );			gMode |= (GetControlValue ( (ControlHandle) iHandle ) != 0) ? 0x0004 : 0;			if ((*(dialogInfo->common)->cGeneral.te)->teLength > 0 &&				(*(dialogInfo->common)->cGeneral.te)->teLength < 240)			{				memcpy (&gWhat[1], *(*(dialogInfo->common)->cGeneral.te)->hText, (*(dialogInfo->common)->cGeneral.te)->teLength);				gWhat[0] = (*(dialogInfo->common)->cGeneral.te)->teLength;			}						Action = (dialogInfo->common)->cGeneral.ActionCancel;			WFindEventProcessor (event, dialogInfo, actionClose);			Action ();			break;						case EnterKey:		case ReturnKey:			if ((*(dialogInfo->common)->cGeneral.te)->teLength > 0 &&				(*(dialogInfo->common)->cGeneral.te)->teLength < 240)			{				gMode = 0;								GetDialogItem ( dialogInfo->dialog, 5, &iType, &iHandle, &iRect );				gMode |= (GetControlValue ( (ControlHandle) iHandle ) != 0) ? 0x0001 : 0;				GetDialogItem ( dialogInfo->dialog, 6, &iType, &iHandle, &iRect );				gMode |= (GetControlValue ( (ControlHandle) iHandle ) != 0) ? 0x0002 : 0;				GetDialogItem ( dialogInfo->dialog, 7, &iType, &iHandle, &iRect );				gMode |= (GetControlValue ( (ControlHandle) iHandle ) != 0) ? 0x0004 : 0;				memcpy (&gWhat[1], *(*(dialogInfo->common)->cGeneral.te)->hText, (*(dialogInfo->common)->cGeneral.te)->teLength);				gWhat[0] = (*(dialogInfo->common)->cGeneral.te)->teLength;								Action = (dialogInfo->common)->cGeneral.Action;				WFindEventProcessor (event, dialogInfo, actionClose);				Action ();			}			else			{				CallASndPlay (132);			}			break;				case DeleteFwdKey:						GetBackColor (&color1);			color.red = color.green = color.blue = 0xFFFF;			RGBBackColor(&color);			myTEDel ((dialogInfo->common)->cGeneral.te);//			color.red = color.green = color.blue = 50000;			RGBBackColor(&color1);			break;		default:					if (key < 0x20 && key > 0)				break;					case RightArrowKey:		//	Right		case LeftArrowKey:		//	Left		case BackSpaceKey:					GetBackColor (&color1);			color.red = color.green = color.blue = 0xFFFF;			RGBBackColor(&color);			TE32KKey (key, (dialogInfo->common)->cGeneral.te);//			color.red = color.green = color.blue = 50000;			RGBBackColor(&color1);						break;		}		break;			case updateEvt:		SetPort (dialogInfo->dialog);				BeginUpdate (dialogInfo->dialog);		DrawDialog (dialogInfo->dialog);		EndUpdate (dialogInfo->dialog);		GetBackColor (&color1);		color.red = color.green = color.blue = 0xFFFF;		RGBBackColor(&color);				GetDialogItem (dialogInfo->dialog, 3, &iType, &iHandle, &iRect);		EraseRect (&iRect);				RectToLongRect (&iRect, &tlRect);		InsetRect (&iRect, -2, -2);		FrameRect (&iRect);		//		RectToLongRect (&(dialogInfo->dialog)->portRect, &tlRect);		TE32KUpdate (&tlRect, (dialogInfo->common)->cGeneral.te);//		color.red = color.green = color.blue = 50000;		RGBBackColor(&color1);		DefaultButton (dialogInfo->dialog, 1);		break;	case nullEvent:				GetPort (&oldPort);		SetPort (dialogInfo->dialog);				TE32KIdle ((dialogInfo->common)->cGeneral.te);		break;	}}void WFindDialogProcessor (EventRecord *event, windowsQElPtr dialogInfo, long info){	DialogPtr	dialog;	short		iHit, dummy;	Point		where;	short		iType;	Handle		iHandle;	Rect		iRect;	register void (*Action)(void);	if (IsDialogEvent (event))	{		if (DialogSelect (event, &dialog, &iHit))		{			switch (iHit)			{			case 1:							if ((*(dialogInfo->common)->cGeneral.te)->teLength > 0 &&					(*(dialogInfo->common)->cGeneral.te)->teLength < 240)				{					gMode = 0;										GetDialogItem ( dialog, 5, &iType, &iHandle, &iRect );					gMode |= (GetControlValue ( (ControlHandle) iHandle ) != 0) ? 0x0001 : 0;					GetDialogItem ( dialog, 6, &iType, &iHandle, &iRect );					gMode |= (GetControlValue ( (ControlHandle) iHandle ) != 0) ? 0x0002 : 0;					GetDialogItem ( dialog, 7, &iType, &iHandle, &iRect );					gMode |= (GetControlValue ( (ControlHandle) iHandle ) != 0) ? 0x0004 : 0;					memcpy (&gWhat[1], *(*(dialogInfo->common)->cGeneral.te)->hText, (*(dialogInfo->common)->cGeneral.te)->teLength);					gWhat[0] = (*(dialogInfo->common)->cGeneral.te)->teLength;										Action = (dialogInfo->common)->cGeneral.Action;					WFindEventProcessor (event, dialogInfo, actionClose);					Action ();				}				else				{					CallASndPlay (132);				}								event->what = 0;				break;							case 2:							gMode = 0;								GetDialogItem ( dialog, 5, &iType, &iHandle, &iRect );				gMode |= (GetControlValue ( (ControlHandle) iHandle ) != 0) ? 0x0001 : 0;				GetDialogItem ( dialog, 6, &iType, &iHandle, &iRect );				gMode |= (GetControlValue ( (ControlHandle) iHandle ) != 0) ? 0x0002 : 0;				GetDialogItem ( dialog, 7, &iType, &iHandle, &iRect );				gMode |= (GetControlValue ( (ControlHandle) iHandle ) != 0) ? 0x0004 : 0;				if ((*(dialogInfo->common)->cGeneral.te)->teLength > 0 &&					(*(dialogInfo->common)->cGeneral.te)->teLength < 240)				{					memcpy (&gWhat[1], *(*(dialogInfo->common)->cGeneral.te)->hText, (*(dialogInfo->common)->cGeneral.te)->teLength);					gWhat[0] = (*(dialogInfo->common)->cGeneral.te)->teLength;				}								Action = (dialogInfo->common)->cGeneral.ActionCancel;				WFindEventProcessor (event, dialogInfo, actionClose);				Action ();				event->what = 0;				break;							case 5:			case 6: //	head			case 7:	//	text							GetDialogItem ( dialog, iHit, &iType, &iHandle, &iRect );				dummy = GetControlValue ( (ControlHandle) iHandle );				SetControlValue ( (ControlHandle) iHandle, !dummy );				event->what = 0;				break;			}		}	}}void WProgressEventProcessor (EventRecord *event, windowsQElPtr dialogInfo, long info){	DialogPtr	dialog;	RGBColor	color;	LongRect	tlRect;	short		iType, ii, dummy, neww, newh, newc, menuItem;	Handle		iHandle;	Rect		iRect, rView, rDataBnds;	Point		cellSize, theCell;	Point		where;			long		lSizeVH, nm, jj;		Str255		stemp;		char		key;		WStateData	*WStDat;	MenuHandle	hMenu;		WindowPtr	window;	windowsQElPtr	dInfo;	commonDataPtr	pcommon;	GrafPtr			oldPort;	PScrapStuff		pScrpInf;	register void (*Action)(void);	switch (info & 0xFFFF)	{	case actionSetSize:				originalView1.left = ((wloc *) event)->topleft.h;		originalView1.top = ((wloc *) event)->topleft.v;		originalView1.bottom = ((wloc *) event)->bottom;				break;		case actionGetSize:				((wloc *) event)->topleft.h = originalView1.left;		((wloc *) event)->topleft.v = originalView1.top;		((wloc *) event)->bottom = originalView1.bottom;				break;		case actionCreate:		if (dInfo = windowsOpened (wtFindDlg, 0, 0))		{			SelectWindow (dInfo->dialog);			break;		}				dialog = FrontWindow ();		if (!dialog)			iRect = (*LMGetGrayRgn ())->rgnBBox;		else			iRect = (*(((WindowPeek)dialog)->contRgn))->rgnBBox;				dialog = GetNewDialog (133, NULL, (WindowPtr) -1);		((WindowPeek)dialog)->windowKind = myKind_top;				SetPort ( dialog );				if (!originalView1.bottom)		{			originalView1.left = iRect.right / 2 -				(dialog->portRect.right - dialog->portRect.left) / 2;			originalView1.top = iRect.bottom / 2 -				(dialog->portRect.bottom - dialog->portRect.top) / 2;					originalView1.bottom = 1;		}				MoveWindow (dialog, originalView1.left, originalView1.top, false);				if (dialogInfo)		{			GetDialogItem ( dialog, 1, &iType, &iHandle, &iRect );			HiliteControl ((ControlHandle) iHandle, 255);		}		ShowWindow ( dialog );		pcommon = (commonDataPtr) NewPtrClear (sizeof (commonGPurpose));				pcommon->cGeneral.dialog = dialog;		pcommon->cGeneral.cpurp = 0;				jj = (long) event;		_InitProgress (dialog, (float) jj);				windowsAdd (dialog, wtFindDlg, pcommon, WProgressEventProcessor, WProgressDialogProcessor);				dInfo = windowsLookUp (dialog);				SetWRefCon (dialog, (long) dInfo);		dInfo->inFront = true;		WProgressEventProcessor (NULL, dInfo, ((long) inMenuBar << 16) | mouseDown);		break;	case actionClose:		DisposePtr ((Ptr) dialogInfo->common);				DisposeDialog (dialogInfo->dialog);		windowsKill (dialogInfo->dialog);		break;			case actionActive:		break;	case actionBroadcast:			GetPort (&oldPort);		SetPort (dialogInfo->dialog);		switch (((BroadcastRecPtr) event)->synctype)		{		case broadClose:					WProgressEventProcessor (NULL, dialogInfo, actionClose);			break;					case broadSyncCellLR:						_DrawProgress ((dialogInfo->common)->cGeneral.cpurp = ((BroadcastRecPtr) event)->area, false);			break;		}			SetPort (oldPort);		break;		case actionOpen:			break;		case mouseDown:		where = event->where;		switch (info >> 16)		{		case inMenuBar:					recalcWindowMenu ();			hMenu = GetMenuHandle (fileM + 256);			(*hMenu)->enableFlags = 0;						hMenu = GetMenuHandle (editM + 256);			(*hMenu)->enableFlags = 0;			hMenu = GetMenuHandle (msgM + 256);			(*hMenu)->enableFlags = 0;			hMenu = GetMenuHandle (nodeM + 256);			(*hMenu)->enableFlags = 0;			hMenu = GetMenuHandle (shuffleM + 256);			(*hMenu)->enableFlags = 0;			hMenu = GetMenuHandle (windowM + 256);			(*hMenu)->enableFlags = 0;			DrawMenuBar ();			break;		case inContent:					FindWindow (event->where, &window);						if (window != FrontWindow ())			{				if (((WindowPeek)FrontWindow ())->windowKind == myKind_top)					SysBeep (10);				else					SelectWindow (window);			}			break;		case inDrag:			FindWindow (event->where, &window);						if (window != FrontWindow ())			{				if (((WindowPeek)FrontWindow ())->windowKind == myKind_top)					SysBeep (10);				else					SelectWindow (window);			}			else			{				DragWindow ( dialogInfo->dialog, event->where, &qd.screenBits.bounds );				originalView1 = (*(((WindowPeek)(dialogInfo->dialog))->contRgn))->rgnBBox;			}			break;		}				break;			case keyDown:	case autoKey:				SetPort (dialogInfo->dialog);		key = event->message & 0xFF;				switch (key)		{		case 0x1B:			gCanceled = true;			break;					default:					break;		}		break;			case updateEvt:		SetPort (dialogInfo->dialog);				BeginUpdate (dialogInfo->dialog);		DrawDialog (dialogInfo->dialog);		EndUpdate (dialogInfo->dialog);		_DrawProgress ((dialogInfo->common)->cGeneral.cpurp, true);		break;	}}void WProgressDialogProcessor (EventRecord *event, windowsQElPtr dialogInfo, long info){	DialogPtr	dialog;	short		iHit, dummy;	Point		where;	if (IsDialogEvent (event))	{		if (DialogSelect (event, &dialog, &iHit))		{			switch (iHit)			{			case 1:							gCanceled = true;				event->what = 0;				break;			}		}	}}