#include <string.h>#include <stdio.h>#include "log.h"//#include "Ravel_FTN.h"#include "ravel_msg_base.h"#include "Ravel_Prefs.h"#include "stringutl.h"#include "PascalStr.h"#include "nodelist.h"#include "Templates.h"	Str255			padname;	Str255			cookname;	Str63			fontname;	templateRecordPtr	prevent = NULL;	templateRecordPtr	poster = NULL;	templateRecordPtr	replyText = NULL;	templateRecordPtr	commentText = NULL;	char				*prevent_def = NULL;	char				*poster_def = NULL;	char				*replyText_def = NULL;	char				*commentText_def = NULL;	char				*receiptText = NULL;	char				*tearLine = NULL;	short			users;	short			cuser;	char			*username[5];	short			origins;	short			corigin;	char			*origin[5];	long			hqxlines = 130;	long			printfontsize = 12;	Str255			printfontname = {"\p"};	notePtr			notepad;	customRecordPtr	custom;	Boolean			netmailorigin = false,						uucpaware = false,						tracktome = false,						respondcfm = false,						doSound = true,						coloredquotes = false;	char			q_wasfrom[MName+1];	char			q_wasto[MName+1];	char			q_nowfrom[MName+1];	char			q_nowto[MName+1];	char			q_date[MDate+1];	char			q_subj[MSubject+1];static char		*tokens[] = {								"hello",			//	0								"sign",				//	1								"reply",			//	2								"username",			//	3								"origin",			//	4								"netmailorigin",	//	5								"notepad",			//	6								"uucpaware",		//	7								"customcall",		//	8								"viewfont",			//	9								"comment",			//	10								"notefile",			//	11								"tracktome",		//	12								"seglines",			//	13								"respondcfm",		//	14								"sounds",			//	15								"iamusingfucking",	//	16								"iamfucking",		//	17								"coloredquoting",	//	18								"receipt",			//	19								"rgbquoteodd",		//	20								"rgbquoteeven",		//	21								"rgbkludge",		//	22								"printfont",		//	23								"printsize",		//	24								"cookies",			//	25								"tearline",			//	26								"viewsize",			//	27								""							};static char		*substs[] = {								"@1stfrom",								"@fullfrom",								"@1stto",								"@fullto",								"@1stwasfrom",								"@fullwasfrom",								"@1stwasto",								"@fullwasto",								"@date",								"@time",								"@subj",								""							};static short fndtoken (char **tt, char *from){	short	res = 0;		while (tt[res][0])		if (!strncasecmp ( from, tt[res], strlen (tt[res]) ))			return res;		else			res++;		return -1;}void performsubstitution (char **storage, char *templater){	char	tmp[1024];	short	i, j, k, t;		i=0;	while ( *templater && i < 1000 )	{		if ( *templater == '@' )		{					t = fndtoken ( substs, templater );			switch (t)			{			case 0:		//	1st name now from								k = strlen (q_nowfrom);				for ( j=0; j<k && q_nowfrom[j] != ' '; j++ )				{					tmp[i++] = q_nowfrom[j];				}								templater += strlen (substs[t]);				break;							case 1:		//	full name now from							k = strlen (q_nowfrom);				for ( j=0; j<k; j++ )				{					tmp[i++] = q_nowfrom[j];				}								templater += strlen (substs[t]);				break;							case 2:		//	1st name now to								k = strlen (q_nowto);				for ( j=0; j<k && q_nowto[j] != ' '; j++ )				{					tmp[i++] = q_nowto[j];				}								templater += strlen (substs[t]);				break;							case 3:		//	full name now to							k = strlen (q_nowto);				for ( j=0; j<k; j++ )				{					tmp[i++] = q_nowto[j];				}								templater += strlen (substs[t]);				break;							case 4:		//	1st name was from								k = strlen (q_wasfrom);				for ( j=0; j<k && q_wasfrom[j] != ' '; j++ )				{					tmp[i++] = q_wasfrom[j];				}								templater += strlen (substs[t]);				break;							case 5:		//	full name was from							k = strlen (q_wasfrom);				for ( j=0; j<k; j++ )				{					tmp[i++] = q_wasfrom[j];				}								templater += strlen (substs[t]);				break;							case 6:		//	1st name was to								k = strlen (q_wasto);				for ( j=0; j<k && q_wasto[j] != ' '; j++ )				{					tmp[i++] = q_wasto[j];				}								templater += strlen (substs[t]);				break;							case 7:		//	full name was to							k = strlen (q_wasto);				for ( j=0; j<k; j++ )				{					tmp[i++] = q_wasto[j];				}								templater += strlen (substs[t]);				break;						case 8:		//	date						//	k = strlen (q_date);				for ( j=0; j<9; j++ )				{					tmp[i++] = q_date[j];				}								templater += strlen (substs[t]);				break;						case 9:		//	time							k = strlen (q_date);				for ( j=11; j<k; j++ )				{					tmp[i++] = q_date[j];				}								templater += strlen (substs[t]);				break;						case 10:		//	subj				k = strlen (q_subj);				for ( j=0; j<k; j++ )				{					tmp[i++] = q_subj[j];				}								templater += strlen (substs[t]);				break;			default:							goto copier;			}				}		else		{		copier:			tmp[i++] = *templater;			templater++;		}	}	tmp[i] = 0;		*storage = NewPtr (i+1);	strcpy ( *storage, tmp );}static void pushtojail ( char **storage, char **from ){	char		tmp[512];	short		i;//	while ( **from && **from != 0x0D )//		(*from)++;	if (!**from)	{		*storage = NewPtrClear (1);		return;	}//	(*from)++;	i=0;	while ( **from && **from != '#' && i < 511 )	{		tmp[i++] = **from;		(*from)++;	}	if (**from == '#')	{		tmp[i] = 0;		*storage = NewPtr (i+1);		strcpy ( *storage, tmp );		(*from)++;	}	else		**from = 0;}static void pushtoeoln ( char **storage, char **from ){	char		tmp[512];	short		i;	while ( **from && **from == ' ' )		(*from)++;	if (!**from)	{		*storage = NewPtrClear (1);		return;	}		i=0;	while ( **from && **from != 0x0d && i < 511 )	{		tmp[i++] = **from;		(*from)++;	}	if (**from == 0x0d)	{		tmp[i] = 0;		*storage = NewPtr (i+1);		strcpy ( *storage, tmp );		(*from)++;	}	else		**from = 0;}static passtoeoln ( char **from ){	while ( **from && **from != 0xd )		(*from)++;	if (!**from)		return;	(*from)++;}void ReadTemplates (void){	short		fRefNum, t, tt;	long		len = 0, counter;	Handle		txt;	Ptr			p, ttt;	addr		tempaddr;	Str63		tempname;	notePtr		tempNote;		char		tmp[128];		customRecordPtr		customCall;	templateRecordPtr	template_p;		long		l_1, l_2, l_3, l_4, l_5, l_6;			fontname[0] = 0;	padname[0] = 0;	cookname[0] = 0;		if ( FSOpen ( "\pRavelQUILL.cfg", 0, &fRefNum ) )	{		putlog ( lgATTN, "RavelQUILL.cfg not found. Using default templates and settings." );		return;	}			GetEOF ( fRefNum, &len );		if (len > 0 && (txt = NewHandle ( len+1 )))	{		counter = len;				HLock (txt);		FSRead ( fRefNum, &counter, *txt );				p = *txt;		p[len] = 0;				while (*p)		{			if (*p == 0x0d)				p++;			else				if (*p != ';')				{					t = fndtoken (tokens, p);										switch (t)					{					case 0:		//	hello												p += strlen (tokens[t]);						pushtoeoln ( &ttt, &p );						#ifndef LITE						if (*ttt)						{							if (!prevent)							{								template_p = prevent = (templateRecordPtr) NewPtr (sizeof (templateRecord));							}							else							{								template_p = prevent;																while (template_p->next_template)									template_p = template_p->next_template;																template_p->next_template = (templateRecordPtr) NewPtr (sizeof (templateRecord));								template_p = template_p->next_template;							}														template_p->next_template = NULL;							pushtojail ( &template_p->template, &p );							template_p->areaname = ttt;						}						else#endif						{							pushtojail ( &prevent_def, &p );							DisposePtr (ttt);						}																		break;										case 1:		//	sign						p += strlen (tokens[t]);						pushtoeoln ( &ttt, &p );						#ifndef LITE						if (*ttt)						{							if (!poster)							{								template_p = poster = (templateRecordPtr) NewPtr (sizeof (templateRecord));							}							else							{								template_p = poster;																while (template_p->next_template)									template_p = template_p->next_template;																template_p->next_template = (templateRecordPtr) NewPtr (sizeof (templateRecord));								template_p = template_p->next_template;							}														template_p->next_template = NULL;							pushtojail ( &template_p->template, &p );							template_p->areaname = ttt;						}						else#endif						{							pushtojail ( &poster_def, &p );							DisposePtr (ttt);						}																		break;					case 2:		//	reply						p += strlen (tokens[t]);						pushtoeoln ( &ttt, &p );						#ifndef LITE						if (*ttt)						{							if (!replyText)							{								template_p = replyText = (templateRecordPtr) NewPtr (sizeof (templateRecord));							}							else							{								template_p = replyText;																while (template_p->next_template)									template_p = template_p->next_template;																template_p->next_template = (templateRecordPtr) NewPtr (sizeof (templateRecord));								template_p = template_p->next_template;							}														template_p->next_template = NULL;							pushtojail ( &template_p->template, &p );							template_p->areaname = ttt;						}						else#endif						{							pushtojail ( &replyText_def, &p );							DisposePtr (ttt);						}																		break;					case 3:		//	username#ifndef LITE						p += strlen (tokens[t]);						if (users > 5)#endif							passtoeoln (&p);#ifndef LITE						else						{							pushtoeoln ( &username[users], &p );							users++;						}#endif						break;										case 4:		//	origin					#ifndef LITE						p += strlen (tokens[t]);						if (origins > 5)#endif							passtoeoln (&p);#ifndef LITE						else						{							pushtoeoln ( &origin[origins], &p );							origins++;						}#endif						break;											case 5:												p += strlen (tokens[t]);						pushtoeoln ( &ttt, &p );												if ( !strcasecmp ( "yes", ttt ) )							netmailorigin = true;						else							netmailorigin = false;												DisposePtr (ttt);												break;					case 6:											p += strlen (tokens[t]);												pushtoeoln ( &ttt, &p );												tempaddr.zone = 0;						tempaddr.net = 0;						tempaddr.node = 0;						tempaddr.point = 0;												tt = parseaddr ( &tempaddr, ttt );												while (ttt[tt] == ' ' && ttt[tt] != 0)							tt++;												strcpy ( (char *)&tempname[1], &ttt[tt] );						tempname[0] = strlen (&ttt[tt]);												while (tempaddr.zone)						{							if (!notepad)							{								tempNote = notepad = (notePtr) NewPtr (sizeof (struct _note));							}							else							{								tempNote = notepad;																while (tempNote->next_note)									tempNote = tempNote->next_note;																	tempNote->next_note = (notePtr) NewPtr (sizeof (struct _note));								tempNote = tempNote->next_note;							}														tempNote->next_note = NULL;							tempNote->pad_address = tempaddr;														if (tempname[0])								pStrCopy ( tempname, tempNote->pad_name );							else							{								if ( !GetNameFromAddr ( &tempaddr, tempNote->pad_name ) )									tempNote->pad_name[0] = 0;							}														break;						}												DisposePtr (ttt);												break;					case 7:												p += strlen (tokens[t]);						pushtoeoln ( &ttt, &p );												if ( !strcasecmp ( "yes", ttt ) )							uucpaware = true;						else							uucpaware = false;												DisposePtr (ttt);												break;										case 8:											p += strlen (tokens[t]);												pushtoeoln ( &ttt, &p );												if (!custom)						{							customCall = custom = (customRecordPtr) NewPtr (sizeof (customRecord));						}						else						{							customCall = custom;														while (customCall->next_custom)								customCall = customCall->next_custom;														customCall->next_custom = (customRecordPtr) NewPtr (sizeof (customRecord));							customCall = customCall->next_custom;						}												customCall->next_custom = NULL;						strcpy ( (char *) &customCall->name[1], ttt );						customCall->name[0] = strlen (ttt);												DisposePtr (ttt);												break;										case 9:		//	viewfont											p += strlen (tokens[t]);												pushtoeoln ( &ttt, &p );												strcpy ( (char *) &fontname[1], ttt );						fontname[0] = strlen (ttt);												DisposePtr (ttt);												break;										case 10:	//	comment						p += strlen (tokens[t]);						pushtoeoln ( &ttt, &p );						#ifndef LITE						if (*ttt)						{							if (!commentText)							{								template_p = commentText = (templateRecordPtr) NewPtr (sizeof (templateRecord));							}							else							{								template_p = commentText;																while (template_p->next_template)									template_p = template_p->next_template;																template_p->next_template = (templateRecordPtr) NewPtr (sizeof (templateRecord));								template_p = template_p->next_template;							}														template_p->next_template = NULL;							pushtojail ( &template_p->template, &p );							template_p->areaname = ttt;						}						else#endif						{							pushtojail ( &commentText_def, &p );							DisposePtr (ttt);						}																		break;					case 11:	//	notefile											p += strlen (tokens[t]);												pushtoeoln ( &ttt, &p );												strcpy ( (char *) &padname[1], ttt );						padname[0] = strlen (ttt);												DisposePtr (ttt);												break;										case 12:	//	tracktome											p += strlen (tokens[t]);						pushtoeoln ( &ttt, &p );												if ( !strcasecmp ( "yes", ttt ) )							tracktome = true;						else							tracktome = false;												DisposePtr (ttt);												break;										case 13:	//	seglines											p += strlen (tokens[t]);						pushtoeoln ( &ttt, &p );												strncpy ((char *) &tempname[1], ttt, 32);						tempname[33] = 0;						tempname[0] = strlen ((char *) &tempname[1]);												StringToNum (tempname, &hqxlines);												if (hqxlines <= 20 || hqxlines > 256)							hqxlines = 130;												DisposePtr (ttt);												break;										case 14:	//	respondcfm											p += strlen (tokens[t]);						pushtoeoln ( &ttt, &p );												if ( !strcasecmp ( "yes", ttt ) )							respondcfm = true;						else							respondcfm = false;												DisposePtr (ttt);												break;										case 15:	//	sounds											p += strlen (tokens[t]);						pushtoeoln ( &ttt, &p );												if ( !strcasecmp ( "yes", ttt ) )							doSound = true;						else							doSound = false;												DisposePtr (ttt);												break;					#ifndef LITE					case 16:	//	d1											p += strlen (tokens[t]);						pushtoeoln ( &ttt, &p );												DisposePtr (ttt);												break;										case 17:	//	d2											p += strlen (tokens[t]);						pushtoeoln ( &ttt, &p );												DisposePtr (ttt);												break;#endif					case 18:	//	coloredquotes											p += strlen (tokens[t]);						pushtoeoln ( &ttt, &p );												if ( !strcasecmp ( "yes", ttt ) )							coloredquotes = true;						else							coloredquotes = false;												DisposePtr (ttt);											break;										case 19:	//	receipt						p += strlen (tokens[t]);						pushtoeoln ( &ttt, &p );						DisposePtr (ttt);						pushtojail ( &receiptText, &p );						break;										case 20:	//	rgbquoteodd						p += strlen (tokens[t]);						pushtoeoln ( &ttt, &p );												if (sscanf (ttt, "%lx.%lx.%lx %lx.%lx.%lx", &l_1, &l_2, &l_3, &l_4, &l_5, &l_6) == 6)						{							quoteGrayFg.red = l_1;							quoteGrayFg.green = l_2;							quoteGrayFg.blue = l_3;							quoteGray.red = l_4;							quoteGray.green = l_5;							quoteGray.blue = l_6;						}												DisposePtr (ttt);											break;					case 21:	//	rgbquoteeven						p += strlen (tokens[t]);						pushtoeoln ( &ttt, &p );												if (sscanf (ttt, "%lx.%lx.%lx %lx.%lx.%lx", &l_1, &l_2, &l_3, &l_4, &l_5, &l_6) == 6)						{							quote1GrayFg.red = l_1;							quote1GrayFg.green = l_2;							quote1GrayFg.blue = l_3;							quote1Gray.red = l_4;							quote1Gray.green = l_5;							quote1Gray.blue = l_6;						}												DisposePtr (ttt);											break;					case 22:	//	rgbkludge						p += strlen (tokens[t]);						pushtoeoln ( &ttt, &p );												if (sscanf (ttt, "%lx.%lx.%lx %lx.%lx.%lx", &l_1, &l_2, &l_3, &l_4, &l_5, &l_6) == 6)						{							kludgeColor.red = l_1;							kludgeColor.green = l_2;							kludgeColor.blue = l_3;							kludgeBack.red = l_4;							kludgeBack.green = l_5;							kludgeBack.blue = l_6;						}												DisposePtr (ttt);											break;										case 23:		//	printfont												p += strlen (tokens[t]);												pushtoeoln ( &ttt, &p );												strcpy ( (char *) &printfontname[1], ttt );						printfontname[0] = strlen (ttt);												DisposePtr (ttt);												break;											case 24:		//	printsize												p += strlen (tokens[t]);						pushtoeoln ( &ttt, &p );												strncpy ((char *) &tempname[1], ttt, 32);						tempname[33] = 0;						tempname[0] = strlen ((char *) &tempname[1]);												StringToNum (tempname, &printfontsize);												if (printfontsize <= 4 || printfontsize > 64)							printfontsize = 12;												DisposePtr (ttt);												break;										case 25:	//	cookies											p += strlen (tokens[t]);												pushtoeoln ( &ttt, &p );												strcpy ( (char *) &cookname[1], ttt );						cookname[0] = strlen (ttt);												DisposePtr (ttt);												break;					#ifndef LITE					case 26:	//	tearline											p += strlen (tokens[t]);						pushtoeoln ( &tearLine, &p );											break;#endif					case 27:		//	viewsize												p += strlen (tokens[t]);						pushtoeoln ( &ttt, &p );												strncpy ((char *) &tempname[1], ttt, 32);						tempname[33] = 0;						tempname[0] = strlen ((char *) &tempname[1]);												StringToNum (tempname, &l_1);												if (l_1 < 9 || l_1 > 64)							viewSize = 9;						else							viewSize = l_1;						DisposePtr (ttt);												break;										default:	//	all others												pushtoeoln ( &ttt, &p );						putlog ( lgATTN, "Unknown tag <%s> in RavelQUILL.cfg. Ignored.", ttt );						DisposePtr (ttt);//						SysBeep (10);//						passtoeoln (&p);												break;					}				}				else					passtoeoln (&p);		}				DisposeHandle (txt);	}	FSClose ( fRefNum );}Boolean myname (StringPtr tmp){	short	i;		for (i=0; i<users; i++)		if (!strcasecmp ((char *) &tmp[1], username[i]))			return true;		return false;}Ptr look_for_template (char *areaname, templateRecordPtr templates, char *default_template){	templateRecordPtr	template_p;	char				area[64];#ifndef LITE	if (!areaname[0])		strcpy (area, "NETMAIL");	else		strcpy (area, areaname);		if (templates)	{		template_p = templates;			do {					if (!strcasecmp (area, template_p->areaname))				break;						template_p = template_p->next_template;				} while (template_p);		if (template_p)		{			return template_p->template;		}	}#endif	return default_template;}