#include <TextEdit.h>#include "TE32K.h"#include "rMenus.h"#include "myTEdit.h"enum {//	pascal void VActionProc (ControlHandle control, short part)	uppVActionProcInfo = kPascalStackBased		 | STACK_ROUTINE_PARAMETER(1, SIZE_CODE(sizeof(Handle)))		 | STACK_ROUTINE_PARAMETER(2, SIZE_CODE(sizeof(short))),//	static pascal void VActionProcThumb (void)	uppVActionThumbProcInfo = kPascalStackBased};extern	Boolean	coloredquotes;static void MyClickLoop (TE32KHandle theTEH32K){	short		controlMax,controlMin,controlVal,lineHeight;	Rect		viewRect;	Point		mousePoshort;	RgnHandle	saveClip;	long		vDelta;	LongRectToRect(&((**theTEH32K).viewRect),&viewRect);	lineHeight = (**theTEH32K).lineHeight;	vDelta = 0L;		GetMouse(&mousePoshort);		if (!PtInRect(mousePoshort,&viewRect))	{		controlMax = GetControlMaximum((**theTEH32K).theVScroll);		controlMin = GetControlMinimum((**theTEH32K).theVScroll);		controlVal = GetControlValue((**theTEH32K).theVScroll);				if (mousePoshort.v>viewRect.bottom && controlVal<controlMax)		{			vDelta = -lineHeight;			SetControlValue((**theTEH32K).theVScroll,controlVal+1);		}				else if (mousePoshort.v<viewRect.top && controlVal>controlMin)		{			vDelta = lineHeight;			SetControlValue((**theTEH32K).theVScroll,controlVal-1);		}	}		if (vDelta)	{		saveClip = NewRgn();		GetClip(saveClip);		ClipRect(&((**theTEH32K).inPort->portRect));				TE32KScroll(0,vDelta,theTEH32K);				SetClip(saveClip);		DisposeRgn(saveClip);	}}void AdjustV (ControlHandle control, TE32KHandle docTE, Boolean canRedraw){	short	ctlVal,			screenLines,			numLines,			oldVal;	ctlVal = ((*docTE)->viewRect.top - (*docTE)->destRect.top)/(*docTE)->lineHeight;	screenLines = ((*docTE)->viewRect.bottom - (*docTE)->viewRect.top)/(**docTE).lineHeight;	numLines = (**docTE).nLines;		if (ctlVal > numLines-screenLines)		SetControlMaximum(control,ctlVal);	else		SetControlMaximum(control,(numLines-screenLines > 0) ? numLines-screenLines : 0);		oldVal = GetControlValue(control);		if (oldVal != ctlVal || canRedraw)		SetControlValue(control,ctlVal);	/*	short	value, lines, max;	short	oldValue, oldMax;	TE32KPtr	te;		oldValue = GetControlValue (control);	oldMax = GetCtlMax (control);	te = *docTE;	lines = te->nLines;	if (*(*te->hText+te->teLength-1) == 0x0D)		lines += 1;	max = lines-((te->viewRect.bottom-te->viewRect.top)/te->lineHeight);	if (max < 0) 		max = 0;	SetCtlMax (control, max);	te = *docTE;	value = (te->viewRect.top-te->destRect.top)/te->lineHeight;	if (value < 0) 		value = 0;	else 		if (value >  max) 			value = max;	SetControlValue(control, value);	if (canRedraw || (max != oldMax) || (value != oldValue))		ShowControl (control);	if (te->teLength)		TE32KScroll (0, (te->viewRect.top-te->destRect.top)-value*te->lineHeight, docTE);*//*	if (!max && !value && te->teLength)	{		if (te->viewRect.top != te->destRect.top)		{//			DebugStr ("\pHere we go!");					TE32KScroll (0,				(te->viewRect.top-te->destRect.top)-value*te->lineHeight),				((DocumentPeek)window)->docTE);//			TE32KScroll (0, te->viewRect.top - te->destRect.top, docTE);		}	}*/}void myTESize (myTE32KHandle myBody){	short		wide;	short		high;	RGBColor	color, color1;	LongRect	tlRect;	(*((*myBody)->bodytext))->destRect.right = ((*myBody)->dialog)->portRect.right-15 - 2;	(*((*myBody)->bodytext))->destRect.bottom = ((*myBody)->dialog)->portRect.bottom - 2;	(*((*myBody)->bodytext))->viewRect.right = ((*myBody)->dialog)->portRect.right-15 - 2;	(*((*myBody)->bodytext))->viewRect.bottom = ((*myBody)->dialog)->portRect.bottom - 2;	if ((*myBody)->scroll)	{		MoveControl ((*myBody)->scroll, ((*myBody)->dialog)->portRect.right-15, (*((*myBody)->bodytext))->viewRect.top-3);				wide = 16;		high = (*((*myBody)->bodytext))->viewRect.bottom - (*((*myBody)->bodytext))->viewRect.top + 5;		high -= ((*myBody)->needgrow) ? 14 : 0;		SizeControl ((*myBody)->scroll, wide, high );		UpdateControls ((*myBody)->dialog, ((*myBody)->dialog)->visRgn);		AdjustV ((*myBody)->scroll, (*myBody)->bodytext, true);	}	GetBackColor (&color1);	color.red = color.green = color.blue = 0xFFFF;	RGBBackColor(&color);//	EraseRect (&(*((*myBody)->bodytext))->viewRect);	RectToLongRect (&((*myBody)->dialog)->portRect, &tlRect);	TE32KUpdate (&tlRect, (*myBody)->bodytext);//	color.red = color.green = color.blue = 50000;	RGBBackColor(&color1);}static char		brk[256] = {	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,		//	+00	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,		//	+10	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,		//	+20	1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0,		//	+30	0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,		//	+40	1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0,		//	+50	0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,		//	+60	1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0,		//	+70	1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,		//	+80	1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,		//	+90	1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,		//	+A0	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,		//	+B0	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,		//	+C0	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,		//	+D0	1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,		//	+E0	1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0		//	+F0};/*		WordBreakProcPtr uses register based parameters on the 68k and cannot		be written in or called from a high-level language without the help of		mixed mode or assembly glue.			typedef pascal Boolean (*WordBreakProcPtr)(Ptr text, short charPos);		In:		 => text        	A0.L		 => charPos     	D0.W		Out:		 <= return value	D0.B*//*asm static void myWordBreak (void){	_Debugger	MOVE.W		D1, -(SP)	MOVE.L		A1, -(SP)	CLR.W		D1	MOVE.B		(A0, D0.W), D1	LEA			brk, A1	MOVE.B		(A1, D1.W), D0	MOVE.L		(SP)+, A1	MOVE.W		(SP)+, D1	OR.B		D0, D0	SEQ			D0	NEG			D0	RTS}*//*	typedef pascal Boolean (*EOLHookProcPtr)(char theChar, TEPtr pTE, TE32KHandle hTE);		In:			=> 	theChar					D0.B			=>	pTE						A3.L			=>	hTE						A4.L		Out:			<=	Boolean					Z bit of the CCR*//*asm static void myEOLHook (void){	_Debugger	MOVE.W		D1, -(SP)	MOVE.L		A1, -(SP)	CLR.W		D1	MOVE.B		D0, D1	LEA			brk, A1	MOVE.B		(A1, D1.W), D0	MOVE.L		(SP)+, A1	MOVE.W		(SP)+, D1	TST.B		D0	SEQ			D0	NEG			D0	RTS}*//*	typedef pascal void (*CaretHookProcPtr)(const Rect *r, TEPtr pTE);		In:			=> 	r						on stack			=>	pTE						A3.L		Out:			none*//*asm static void myCaretHook (void){//	ADDQ.L		#4, SP	_EraseRect	RTS}*/TE32KHandle littleTENew (DialogPtr dialog, short item, Boolean suppresscaret, Boolean active){	short		iType;	Handle		iHandle;	Rect		iRect;	TE32KHandle	res;	LongRect	tlRect;	GetDialogItem (dialog, item, &iType, &iHandle, &iRect);	RectToLongRect (&iRect, &tlRect);	res = TE32KNew (&tlRect, &tlRect);	//¥	if (suppresscaret)//¥		(*res)->caretHook = (CaretHookUPP) myCaretHook;	(*res)->suppressCaret = suppresscaret;	(*res)->crOnly = 1;	TE32KFeatureFlag (te32KFOutlineHilite, TE32KBitSet, res);	TE32KAutoView (false, res);	TE32KSetText ("", 0, res);		if (active)		TE32KActivate (res);	else		TE32KDeactivate (res);	return res;}void myTEDel (TE32KHandle te){	if ((*te)->selStart == (*te)->selEnd)	{		if ((*te)->selStart != (*te)->teLength)		{			TE32KSetSelect ((*te)->selStart, (*te)->selStart+1, te);			TE32KDelete (te);		}	}	else	{		TE32KDelete (te);	}}myTE32KHandle myTENew (WindowPtr window, Rect *rView, Boolean needscroll, Boolean needgrow, Boolean suppresscaret){	myTE32KHandle			myBody;	Rect				myView;	UniversalProcPtr	procAddr;	LongRect			tlRect;			myBody = (myTE32KHandle) NewHandleClear (sizeof (myTERec));		(*myBody)->dialog = window;	(*myBody)->needscroll = needscroll;	(*myBody)->needgrow = needgrow;	myView = *rView;		if (needscroll)		myView.right -= 15;		InsetRect (&myView, 2, 2);		RectToLongRect (&myView, &tlRect);	(*myBody)->bodytext = TE32KNew (&tlRect, &tlRect);	(**(*myBody)->bodytext).clikLoop = (TE32KProcPtr) MyClickLoop;		(*(*myBody)->bodytext)->suppressCaret = suppresscaret;	TE32KFeatureFlag (te32KFOutlineHilite, TE32KBitSet, (*myBody)->bodytext);		if (coloredquotes)		TE32KFeatureFlag (te32KFColorQuotes, TE32KBitSet, (*myBody)->bodytext);		if (needscroll)	{		myView = *rView;		myView.right++;		myView.left = myView.right - 16;			if (needgrow)			myView.bottom -= 15;		InsetRect (&myView, 0, -1);				(*myBody)->scroll = NewControl (											window,											&myView,											"\p",											true,											0,											0,											0,											scrollBarProc,											(long) (*myBody)->bodytext										);		(**(*myBody)->bodytext).theVScroll = (*myBody)->scroll;		AdjustV ((*myBody)->scroll, (*myBody)->bodytext, true);	}	else		(*myBody)->scroll = NULL;	TE32KAutoView (true, (*myBody)->bodytext);	TE32KSetText ("", 0, (*myBody)->bodytext);	TE32KActivate ((*myBody)->bodytext);	return myBody;}void myTEDispose (myTE32KHandle myBody){	if ((*myBody)->scroll)		DisposeControl ((*myBody)->scroll);	TE32KDispose ((*myBody)->bodytext);	DisposeHandle ((Handle) myBody);}void myTEUpdate (myTE32KHandle myBody){	RGBColor	color, color1;	LongRect	tlRect;	GetBackColor (&color1);	color.red = color.green = color.blue = 0xFFFF;	RGBBackColor(&color);	RectToLongRect (&((*myBody)->dialog)->portRect, &tlRect);	TE32KUpdate (&tlRect, (*myBody)->bodytext);//	color.red = color.green = color.blue = 50000;	RGBBackColor(&color1);	ShowControl ((*myBody)->scroll);}void myTEScrollRedraw (myTE32KHandle myBody){	AdjustV ((*myBody)->scroll, (*myBody)->bodytext, true);}static void CommonAction (ControlHandle control, short *amount){	short		value, max;		value = GetControlValue (control);	max = GetControlMaximum (control);	*amount = value - *amount;	if (*amount < 0)		*amount = 0;	else		if (*amount > max)			*amount = max;	SetControlValue (control, *amount);	*amount = value - *amount;}pascal void VActionProc (ControlHandle control, short part){	short		amount;	WindowPtr	window;	TE32KPtr		te;		if (part != 0)	{		window = (*control)->contrlOwner;		te = *((TE32KHandle) (*control)->contrlRfCon);		switch (part)		{			case kControlUpButtonPart:			case kControlDownButtonPart:								amount = 1;				break;			case kControlPageUpPart:			case kControlPageDownPart:								amount = (te->viewRect.bottom - te->viewRect.top) / te->lineHeight;				break;		}		if ((part == kControlDownButtonPart) || (part == kControlPageDownPart))			amount = -amount;		CommonAction (control, &amount);		if (amount != 0)			TE32KScroll (0, amount * te->lineHeight, (TE32KHandle) (*control)->contrlRfCon);	}}static	ControlHandle	gControl;static	long			gValue;static pascal void VActionProcThumb (void){	long		amount;	//	, value;	Point		where;	Rect		cRect = (*gControl)->contrlRect;	long		cHigh, max;			InsetRect (&cRect, 0, 15);	max = GetControlMaximum (gControl);//	amount = GetControlValue (gControl);//	value = amount;	//	while (StillDown ())//	{		GetMouse (&where);				if (PtInRect (where, &cRect))		{			amount = (max * (where.v - cRect.top)) / (cRect.bottom - cRect.top);//			value = GetControlValue (gControl);						if (amount != gValue)			{//				AdjustV (gControl, (TE32KHandle) (*gControl)->contrlRfCon, true);				TE32KScroll (0,					((*(TE32KHandle) (*gControl)->contrlRfCon)->viewRect.top -						(*(TE32KHandle) (*gControl)->contrlRfCon)->destRect.top) -							amount * (*(TE32KHandle) (*gControl)->contrlRfCon)->lineHeight,					(TE32KHandle) (*gControl)->contrlRfCon);//				TEScroll (0, (gValue - amount) * (*((TE32KHandle) (*gControl)->contrlRfCon))->lineHeight, (TE32KHandle) (*gControl)->contrlRfCon);				gValue = amount;			}		}//	}	//	SetControlValue (gControl, value);}void myTEIdle (TE32KHandle myBody, Boolean supprescaret){//	CaretHookUPP	oldCaretHook = (*myBody)->caretHook;	//¥	if (supprescaret)//¥		(*myBody)->caretHook = (CaretHookUPP) myCaretHook;	TE32KIdle (myBody);//	(*myBody)->caretHook = oldCaretHook;//¥	(*myBody)->caretHook = NULL;}Boolean myTEMouseDown (myTE32KHandle myBody, Point where, long modifiers){	ControlHandle 		control;	short				part, value;	UniversalProcPtr	pp;	short				iType;	Handle				iHandle;	Rect				rView, rDataBnds;	RGBColor			color, color1;	Rect				tRect;		LongRectToRect (&(*((*myBody)->bodytext))->viewRect, &tRect);	if (PtInRect (where, &tRect))	{		GetBackColor (&color1);		color.red = color.green = color.blue = 0xFFFF;		RGBBackColor(&color);		TE32KClick (where, (modifiers & shiftKey) != 0, (*myBody)->bodytext);			if ((*myBody)->scroll)			AdjustV ((*myBody)->scroll, (*myBody)->bodytext, true);	//		TEIdle ((*myBody)->bodytext);	//		color.red = color.green = color.blue = 50000;		RGBBackColor(&color1);		return true;	}	else	{		GetDialogItem ( (*myBody)->dialog, miBody, &iType, &iHandle, &rView );				rView.bottom = ((*myBody)->dialog)->portRect.bottom;		rView.right = ((*myBody)->dialog)->portRect.right;		rDataBnds = rView;		rDataBnds.left = rDataBnds.right - 15;		rDataBnds.bottom -= 15;				if (PtInRect (where, &rDataBnds))		{			GetBackColor (&color1);			color.red = color.green = color.blue = 0xFFFF;			RGBBackColor(&color);			part = FindControl (where, (*myBody)->dialog, &control);			switch (part)			{			case 0:								break;			case kControlIndicatorPart:								gControl = control;				gValue = GetControlValue (gControl);				#if defined(powerc) || defined(__powerc)				pp = NewRoutineDescriptor ((ProcPtr) VActionProcThumb, uppVActionThumbProcInfo, GetCurrentISA ());#else				pp = (UniversalProcPtr) VActionProcThumb;#endif				part = TrackControl (control, where, (ControlActionUPP) pp);#if defined(powerc) || defined(__powerc)				DisposeRoutineDescriptor (pp);#endif				SetControlValue (gControl, gValue);				AdjustV ((*myBody)->scroll, (*myBody)->bodytext, true);//				UpdtControl ((*myBody)->dialog, ((*myBody)->dialog)->visRgn);								break;			default:			#if defined(powerc) || defined(__powerc)				pp = NewRoutineDescriptor ((ProcPtr) VActionProc, uppVActionProcInfo, GetCurrentISA ());#else				pp = (UniversalProcPtr) VActionProc;#endif				value = TrackControl (control, where, (ControlActionUPP) pp);#if defined(powerc) || defined(__powerc)				DisposeRoutineDescriptor (pp);#endif				AdjustV ((*myBody)->scroll, (*myBody)->bodytext, true);				break;			}		//			color.red = color.green = color.blue = 50000;			RGBBackColor(&color1);			return true;		}	}		return false;}Boolean myTEMouseDown2 (myTE32KHandle myBody, Point where, long modifiers){	ControlHandle 		control;	short				part, value;	UniversalProcPtr	pp;	short				iType;	Handle				iHandle;	Rect				rView, rDataBnds;	RGBColor			color, color1;	Rect				tRect;	LongRectToRect (&(*((*myBody)->bodytext))->viewRect, &tRect);	if (PtInRect (where, &tRect))		return false;	GetDialogItem ( (*myBody)->dialog, miBody, &iType, &iHandle, &rView );		rView.bottom = ((*myBody)->dialog)->portRect.bottom;	rView.right = ((*myBody)->dialog)->portRect.right;	rDataBnds = rView;	rDataBnds.left = rDataBnds.right - 15;	rDataBnds.bottom -= 15;		if (PtInRect (where, &rDataBnds))	{		GetBackColor (&color1);		color.red = color.green = color.blue = 0xFFFF;		RGBBackColor(&color);		part = FindControl (where, (*myBody)->dialog, &control);		switch (part)		{		case 0:						break;		case kControlIndicatorPart:						gControl = control;			gValue = GetControlValue (gControl);#if defined(powerc) || defined(__powerc)			pp = NewRoutineDescriptor ((ProcPtr) VActionProcThumb, uppVActionThumbProcInfo, GetCurrentISA ());#else			pp = (UniversalProcPtr) VActionProcThumb;#endif			part = TrackControl (control, where, (ControlActionUPP) pp);#if defined(powerc) || defined(__powerc)			DisposeRoutineDescriptor (pp);#endif			SetControlValue (gControl, gValue);			AdjustV ((*myBody)->scroll, (*myBody)->bodytext, true);//				UpdtControl ((*myBody)->dialog, ((*myBody)->dialog)->visRgn);						break;		default:		#if defined(powerc) || defined(__powerc)			pp = NewRoutineDescriptor ((ProcPtr) VActionProc, uppVActionProcInfo, GetCurrentISA ());#else			pp = (UniversalProcPtr) VActionProc;#endif			value = TrackControl (control, where, (ControlActionUPP) pp);#if defined(powerc) || defined(__powerc)			DisposeRoutineDescriptor (pp);#endif			AdjustV ((*myBody)->scroll, (*myBody)->bodytext, true);			break;		}	//		color.red = color.green = color.blue = 50000;		RGBBackColor(&color1);		return true;	}		return false;}void littleTE32KUpdate (Rect *updateRect, TE32KHandle te){	LongRect	tlRect;	RGBColor	color, color1;	Rect		iRect;	GetBackColor (&color1);	color.red = color.green = color.blue = 0xFFFF;	RGBBackColor(&color);	RectToLongRect (updateRect, &tlRect);	TE32KUpdate (&tlRect, te);	LongRectToRect (&(*te)->viewRect, &iRect);	color.red = color.green = color.blue = 0;	RGBForeColor(&color);	InsetRect (&iRect, -2, -2);	FrameRect (&iRect);		if ((*te)->active)	{		color.red = color.green = 0;		color.blue = 0x4000;		RGBForeColor(&color);	}	else	{		color.red = color.green = color.blue = 50000;		RGBForeColor (&color);	}		InsetRect (&iRect, 1, 1);	FrameRect (&iRect);	color.red = color.green = color.blue = 0;	RGBForeColor(&color);//	color.red = color.green = color.blue = 50000;	RGBBackColor(&color1);}