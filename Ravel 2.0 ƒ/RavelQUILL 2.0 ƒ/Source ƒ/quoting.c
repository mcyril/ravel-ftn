#include <ctype.h>#include <string.h>#include "quoting.h"Boolean hasInitials ( char *t, short *qstart, short *qend ){	short		i;	Boolean		ppp = false, res = false;			for ( i = 0; i < 31; i ++ )		if (t[i] == ' ' || t[i] == '\t')		{										//	space or tab			if (ppp)				break;							//	was other than space or tab early			else				continue;						//	elseÉ		}		else		{										//	other symbols			if (!t[i] || !(isalpha(t[i]) || t[i] == '>'))				break;							//	EOtext or EOLN						if (!ppp)			{									//	no others symbols yet				ppp = true;				*qstart = i;					//	first initial position				*qend = i;						//	last initial position								if (t[i] == '>')				{					res = true;					//	initials?				}			}			else				if (t[i] == '>')				//	immed initial?				{					*qend = i;					//	last initial position					res = true;				}				else					if (res)						break;		}	return res;}static void createInitials ( char *txt, char *initial ){	short		i, j;	Boolean		ppp = false;			for ( i = 0, j = 0; txt[i] && j < 31; i++ )	{		if (!ppp && (txt[i] > '@' && txt[i] < '['))		{			initial[j++] = txt[i];			ppp = true;		}		else			if (ppp && (txt[i] == ' ' || txt[i] == '@' || txt[i] == '.'))				ppp = false;	}		initial[j] = 0;}static	char	last_initial[64];static	char	initial_initial[64];static	Handle	stringspooler;static	Handle	quotedspooler;static void flushSpooler (void){	char	initial[64];	char	string[128];	short	inline_pos, instring_pos, last_delimiter;	long	spool_len, i;	if (stringspooler)	{		HLock (stringspooler);		spool_len = GetHandleSize (stringspooler);				for (i = 0; i < spool_len; i++)			if ((*stringspooler)[i] == '\t')				(*stringspooler)[i] = ' ';				initial[0] = ' ';		initial[1] = 0;				if (last_initial[0] == 0xFF)			strcat (initial, initial_initial);		else			strcat (initial, last_initial);				strcat (initial, "> ");				inline_pos = 0;		last_delimiter = 0;				strcpy (string, initial);		instring_pos = strlen (initial);				while (inline_pos < spool_len)		{			if (instring_pos < 77)			{				if ((*stringspooler)[inline_pos] == ' ')					last_delimiter = instring_pos;								string[instring_pos++] = (*stringspooler)[inline_pos++];			}			else			{				if (last_delimiter)				{					string[last_delimiter] = 0x0D;					PtrAndHand (string, quotedspooler, last_delimiter+1);										while ( last_delimiter < instring_pos && string[last_delimiter++] == ' ' );//						last_delimiter++;					//					if (last_delimiter < instring_pos)//					{//						while (last_delimiter < instring_pos && string[last_delimiter] == ' ')//							last_delimiter++;												if (last_delimiter < instring_pos)							BlockMove (string+last_delimiter,								string+strlen (initial), instring_pos-last_delimiter);//					}										memcpy (string, initial, strlen (initial));										instring_pos = strlen (initial)+instring_pos-last_delimiter;					last_delimiter = 0;				}				else				{					string[77] = 0x0D;					PtrAndHand (string, quotedspooler, 78);					strcpy (string, initial);					instring_pos = strlen (initial);					last_delimiter = 0;				}			}		}				if (instring_pos != strlen (initial))		{			string[instring_pos] = 0x0D;			PtrAndHand (string, quotedspooler, instring_pos+1);		}				DisposeHandle (stringspooler);		stringspooler = NULL;	}}void prepareQuoting (char *body, Handle *quoted, char *fromname){	short	startpos, lastpos, pos;	char	current_initial[64];	char	spacer = ' ';		char	*p;		createInitials (fromname, initial_initial);//	current_initial[0] = 0;	last_initial[0] = 0xFF;	last_initial[1] = 0;		quotedspooler = *quoted = NewHandle (0);		stringspooler = NULL;		p = body;	while (*p)	{		if (*p == 0x01)				//	kludge		{			*p = '@';		}		else			if ( !strncmp ( p, "--- ", 4 ) || !strncmp ( p, "---\r", 4 ))	//	tearline				memcpy ( p, "-+", 2 );			else				if ( !strncmp ( p, " * Origin: ", 11 ) )	//	origin					memcpy ( p, " +", 2 );				else					if (!strncmp (p, "SEEN-BY: ", 9))		//	SEEN-BY:						memcpy ( p, "SEEN+", 5 );				if (*p == 0x0D)		{							//	empty string			flushSpooler ();									//		flush CR only			PtrAndHand (p, quotedspooler, 1);			p++;			last_initial[0] = 0xFF;			last_initial[1] = 0;		}		else		{							//	process filled string			if (hasInitials (p, &startpos, &lastpos))			{				if (lastpos != startpos)					memcpy (current_initial, p+startpos, lastpos-startpos+1);				else					current_initial[0] = '>';				current_initial[lastpos-startpos+1] = 0;								p += lastpos+1;								if (!strcmp (current_initial, last_initial))				{					//	the same initial - add paragraph to spooler					while (*p && *p == ' ')						p++;					pos = 0;					while (p[pos] && p[pos] != 0x0D)						pos++;										if (*p)					{						if (!stringspooler)							stringspooler = NewHandle (0);						else							PtrAndHand (&spacer, stringspooler, 1);						PtrAndHand (p, stringspooler, pos);						p += pos + 1;					}				}				else				{					//	flush spooler with last initial					flushSpooler ();										strcpy (last_initial, current_initial);													//	add paragraph to spooler					while (*p && *p == ' ')						p++;										pos = 0;					while (p[pos] && p[pos] != 0x0D)						pos++;										if (*p)					{						if (!stringspooler)							stringspooler = NewHandle (0);						else							PtrAndHand (&spacer, stringspooler, 1);						PtrAndHand (p, stringspooler, pos);						p += pos + 1;					}				}			}			else			{						//	no initial									//		flush spooler				flushSpooler ();									//		add paragraph to spooler				while (*p && *p == ' ')					p++;				pos = 0;				while (p[pos] && p[pos] != 0x0D)					pos++;								if (*p)				{					if (!stringspooler)						stringspooler = NewHandle (0);					else						PtrAndHand (&spacer, stringspooler, 1);					PtrAndHand (p, stringspooler, pos);					p += pos + 1;				}									//		mark -1 is initial initial			//				strcpy (last_initial, initial_initial);				last_initial[0] = 0xFF;				last_initial[1] = 0;			}		}	}	flushSpooler ();}short quotingnest (char *t, short qstart, short qend){	short	i;	short	res = 0;	for (i=qend; i>=qstart; i--)	{		if (t[i] != '>')			break;				res++;	}	return res;}