#include <string.h>#include <stdio.h>#include "PKT.h"#include "Prefs.h"#include "AreaUtils.h"#include "BaseManager.h"#include "Pathes.h"#include "Utils.h"#include "myEnv.h"#include "PascalStr.h"#include "stringutl.h"#include "PKTUtils.h"#include "Templates.h"#include "Preferences.h"/*extern	homeHndl		homesystem;			//	¥	Home system structextern	mailPrefHndl	mailHndl;			//	¥	Netmail structextern	short			AreasNumber;		//	¥	Areas structs listextern	areaPrefHndl	*areasHndls;extern	short			GroupsNumber;		//	¥	AreaGroups structs listextern	groupPrefHndl	*groupsHndls;extern	short			NodesNumber;		//	¥	Linked Nodes structs listextern	nodePrefHndl	*nodesHndls;*/static	short	CurrentBaseNumber;		Str255	CurrentArea;static	short	wdBaseVRef;static	short	CBIndexRef;static	short	CBHeadRef;static	short	CBTextRef;static	baseHndl			HBase;//static	baseIndexHeaderType	HeaderBase;//	¥ Prepare mesage basesBoolean InitBase (void){	CurrentBaseNumber = -1;		wdBaseVRef = myOpenWD ( basePath );	return ( wdBaseVRef != 0 );}//	¥ Dispose mesage basesBoolean DisposBase (void){	if ( CurrentBaseNumber != -1 )		return FALSE;		myCloseWD ( wdBaseVRef );	return TRUE;}Boolean BaseAjust (void){	short		i;		for ( i = 1; i <= AreasNumber; i++ )		if ( OpenBase ( i, true ) != i )			return false;		else			CloseBase (1);	if ( OpenBase ( BADAREA, true ) != BADAREA )		return false;	else		CloseBase (1);	if ( OpenBase ( NETMAIL, true ) != NETMAIL )		return false;	else		CloseBase (1);	return true;}/*Boolean ReadBaseHeader (void){	short	iErr;	long	counter;		SetFPos ( CBIndexRef, fsFromStart, 0 );	counter = sizeof (baseIndexHeaderType);	iErr = FSRead ( CBIndexRef, &counter, &HeaderBase );	return ( iErr == 0 ) ? sizeof (baseIndexHeaderType) == counter : FALSE;}Boolean WriteBaseHeader (void){	short	iErr;	long	counter;		SetFPos ( CBIndexRef, fsFromStart, 0 );	counter = sizeof (baseIndexHeaderType);	iErr = FSWrite ( CBIndexRef, &counter, &HeaderBase );	return ( iErr == 0 ) ? sizeof (baseIndexHeaderType) == counter : FALSE;}*///	¥ Open message base # AreaNumber//	¥ Return AreaNumber if success or number of opened base//	¥ Return -1 if error occured due opening baseshort OpenBase ( short AreaNumber, Boolean needfull ){	short		iErr, ii;	Str255		CBIndexName, CBHeadName, CBTextName, sss;	long		indexSize, ccc;				if ( CurrentBaseNumber != -1 )		return CurrentBaseNumber;		if ( AreaNumber > AreasNumber )		return -1;		switch ( AreaNumber )	{		case BADAREA:	pStrCopy ( "\pBADMAIL", CurrentArea );								break;		case NETMAIL:	pStrCopy ( "\pNETMAIL", CurrentArea );								break;		default:		pStrCopy ( (*areasHndls[AreaNumber-1])->areaName, CurrentArea );	break;	}		CurrentArea[CurrentArea[0]+1] = 0;		if (CurrentArea[0] > 16)	{		pStrCopy ( CurrentArea, CBIndexName );				ccc = 0L;		for (ii=0; ii < CBIndexName[0]; ii++)		{			ccc += CBIndexName[ii];			ccc = (ccc << 1) | (ccc >> 31);		}		sprintf ((char *) &CBIndexName[17], "%.8lX", ccc);		CBIndexName[0] = strlen ((char *) &CBIndexName[1]);				pStrConc ( CBIndexName, "\p.HEAD", CBHeadName );		pStrConc ( CBIndexName, "\p.TEXT", CBTextName );		pStrConc ( CBIndexName, "\p.INDEX", CBIndexName );	}	else	{		pStrConc ( CurrentArea, "\p.INDEX", CBIndexName );		pStrConc ( CurrentArea, "\p.HEAD", CBHeadName );		pStrConc ( CurrentArea, "\p.TEXT", CBTextName );	}		if ( (iErr = FSOpen ( CBIndexName, wdBaseVRef, &CBIndexRef )) != noErr )		if ( iErr == fnfErr )		{			baseIndexHeaderType	HeaderBase;			long				counter;								iErr = Create ( CBIndexName, wdBaseVRef, 'Ravl', 'BasI' );			if ( iErr )				return -1;							iErr = FSOpen ( CBIndexName, wdBaseVRef, &CBIndexRef );			if ( iErr )				return -1;							memset ( &HeaderBase, 0, sizeof (baseIndexHeaderType) );						HeaderBase.busy = 0;//			pStrCopy ( CurrentArea, HeaderBase.AreaName );//			HeaderBase.AreaName[HeaderBase.AreaName[0]+1] = 0;			HeaderBase.CRCIndex = 0;			HeaderBase.CRCText = 0;			HeaderBase.NumberOfMessages = 0;			HeaderBase.lastRead = 0;						counter = sizeof (baseIndexHeaderType);			if ( FSWrite (CBIndexRef, &counter, &HeaderBase) )			{				FSClose ( CBIndexRef );				return -1;			}		}		else			return -1;	GetEOF ( CBIndexRef, &indexSize );	if ( (iErr = FSOpen ( CBHeadName, wdBaseVRef, &CBHeadRef )) != noErr )		if ( iErr == fnfErr )		{			iErr = Create ( CBHeadName, wdBaseVRef, 'Ravl', 'BasT' );			if ( iErr )			{				FSClose ( CBIndexRef );				return -1;			}						iErr = FSOpen ( CBHeadName, wdBaseVRef, &CBHeadRef );			if ( iErr )			{				FSClose ( CBIndexRef );				return -1;			}		}		else		{			FSClose ( CBIndexRef );			return -1;		}		if ( (iErr = FSOpen ( CBTextName, wdBaseVRef, &CBTextRef )) != noErr )		if ( iErr == fnfErr )		{			iErr = Create ( CBTextName, wdBaseVRef, 'Ravl', 'BasT' );			if ( iErr )			{				FSClose ( CBHeadRef );				FSClose ( CBIndexRef );				return -1;			}						iErr = FSOpen ( CBTextName, wdBaseVRef, &CBTextRef );			if ( iErr )			{				FSClose ( CBHeadRef );				FSClose ( CBIndexRef );				return -1;			}		}		else		{			FSClose ( CBHeadRef );			FSClose ( CBIndexRef );			return -1;		}	if (!needfull)		indexSize = sizeof (baseType);	HBase = (baseHndl) NewHandle (indexSize);		SetFPos ( CBIndexRef, fsFromStart, 0L );		if ( FSRead ( CBIndexRef, &indexSize, (Ptr) *HBase ) )	{		FSClose ( CBIndexRef );		FSClose ( CBHeadRef );		FSClose ( CBTextRef );				DisposeHandle ( (Handle) HBase );				return -1;	}		CurrentBaseNumber = AreaNumber;		return AreaNumber;}Boolean CloseBase (short needupdate){	long	counter;	if ( CurrentBaseNumber == -1 )		return FALSE;	if (needupdate)	{		SetFPos ( CBIndexRef, fsFromStart, 0L );				if (needupdate != 2)			SetEOF ( CBIndexRef, 0L );		counter = GetHandleSize ( (Handle) HBase );		FSWrite ( CBIndexRef, &counter, (Ptr) *HBase );	}		FSClose ( CBIndexRef );	FSClose ( CBHeadRef );	FSClose ( CBTextRef );		DisposeHandle ( (Handle) HBase );	CurrentBaseNumber = -1;	return TRUE;}static long RealNum (long Num){	long	counter = (GetHandleSize ( (Handle) HBase ) - sizeof (baseIndexHeaderType)) /																			sizeof (indexAtomType);	long	i, j;		if (counter)	{		for ( j = 0, i = 0; j < (*HBase)->NumberOfMessages; i++ )			if ( ((*HBase)->indexAtom[i].deleted & 0x0003) == 0 )				if ( j == Num )					return i;				else					j++;	}		return 0x7FFFFFFF;}Boolean LookForToMe (long from){	pktmsg		*m;	short		lock;	Boolean		res = false;	char		tmp[64];		long		r = RealNum (from);	long		counter = (GetHandleSize ( (Handle) HBase ) - sizeof (baseIndexHeaderType)) /																		sizeof (indexAtomType);	long		i, j;		if (counter)	{		for (i = r, j = from; i < counter; i++ )		{			if ((*HBase)->indexAtom[i].deleted & 0x0003)				continue;			if (((*HBase)->indexAtom[i].deleted & 0x4000) == 0)			{				if (!ReadMessageWOText (j, &m, &lock))					break;							strcpy ( &tmp[1], m->toname );				tmp[0] = strlen ( &tmp[1] );				if (myname ((StringPtr) tmp))				{					res = true;					FreePktMsg (m);					break;				}								FreePktMsg (m);			}						j++;		}	}	return res;}long LookForUnread (long Num, short mode){	long	counter = (GetHandleSize ( (Handle) HBase ) - sizeof (baseIndexHeaderType)) /																			sizeof (indexAtomType);	long	r = RealNum (Num);	long	i, j = (*HBase)->NumberOfMessages - 1;	long	k = (mode) ? Num : 0;		if (counter)	{		i = (mode) ? r + mode : 0;				for (; i >= 0 && i < counter; i += (mode) ? mode : 1)		{			if ((*HBase)->indexAtom[i].deleted & 0x0003)				continue;			if (((*HBase)->indexAtom[i].deleted & 0x4000) == 0)				if (mode)				{					j = k + mode;										if (!mode)						j++;					break;				}				else				{					j = k;					break;				}					k += (mode) ? mode : 1;		}	}		return j;}void UnUnread (void){	long	i;	long	counter = (GetHandleSize ( (Handle) HBase ) - sizeof (baseIndexHeaderType)) /																			sizeof (indexAtomType);	if (counter)	{		for (i = 0; i < counter; i++)		{			if ((*HBase)->indexAtom[i].deleted & 0x0003)				continue;			(*HBase)->indexAtom[i].deleted |= 0x4000;		}	}}Boolean ReadMessageAtom ( long MsgNum, indexAtomPtr Atom ){	short		iErr;	long		counter = RealNum (MsgNum);		if ( MsgNum >= (*HBase)->NumberOfMessages )		return FALSE;	if ( counter*sizeof(indexAtomType) + sizeof (baseIndexHeaderType) >= GetHandleSize ((Handle)HBase) )		return FALSE;	*Atom = (*HBase)->indexAtom[counter];	return TRUE;}Boolean WriteMessageAtom ( long MsgNum, indexAtomPtr Atom ){	short		iErr;	long		counter;	if ( MsgNum > (*HBase)->NumberOfMessages )		// Can append here!		return FALSE;	GetDateTime ( (unsigned long *) &Atom->storedTime );	if ( MsgNum == (*HBase)->NumberOfMessages )		// Append	{		counter = (GetHandleSize ( (Handle) HBase ) - sizeof (baseIndexHeaderType)) /																			sizeof (indexAtomType);		SetHandleSize ( (Handle) HBase, (counter+1)*sizeof (indexAtomType) +																	sizeof (baseIndexHeaderType));		(*HBase)->indexAtom[counter] = *Atom;		(*HBase)->NumberOfMessages++;	}	else	{		counter = RealNum (MsgNum);		(*HBase)->indexAtom[counter] = *Atom;	}}Boolean WriteMessageAtom1 ( long MsgNum, indexAtomPtr Atom ){	short		iErr;	long		counter;	if ( MsgNum > (*HBase)->NumberOfMessages )		// Can append here!		return FALSE;	if ( MsgNum == (*HBase)->NumberOfMessages )		// Append	{		counter = (GetHandleSize ( (Handle) HBase ) - sizeof (baseIndexHeaderType)) /																			sizeof (indexAtomType);		SetHandleSize ( (Handle) HBase, (counter+1)*sizeof (indexAtomType) +																	sizeof (baseIndexHeaderType));		(*HBase)->indexAtom[counter] = *Atom;		(*HBase)->NumberOfMessages++;	}	else	{		counter = RealNum (MsgNum);		(*HBase)->indexAtom[counter] = *Atom;	}}long GetNumOfMessages (void){	return (*HBase)->NumberOfMessages;}long GetLastRead (void){	return (*HBase)->lastRead;}void SetNumOfMessages ( long Messages ){	(*HBase)->NumberOfMessages = Messages;}void SetLastRead ( long CurrentMsg ){	(*HBase)->lastRead = CurrentMsg;}static void SetDirtyFlag (void){	(*HBase)->busy = 1;}Boolean ReadMessage ( long MsgNum, pktmsg **m ){	indexAtomType	Atom;	long			baseTextSize;	long			counter;	char			fromname[MName],					toname[MName];	char			date[MDate],					subj[MSubject];	Handle			h;		if ( !ReadMessageAtom ( MsgNum, &Atom ) )		return FALSE;	if ( SetFPos (CBHeadRef, fsFromStart, Atom.headOffset) )		return FALSE;	if ( !GetASCIIZ ( CBHeadRef, fromname, MName ) ||		 !GetASCIIZ ( CBHeadRef, toname, MName ) ||		 !GetASCIIZ ( CBHeadRef, date, MDate ) ||		 !GetASCIIZ ( CBHeadRef, subj, MSubject ) )		return FALSE;	if ( SetFPos (CBTextRef, fsFromStart, Atom.textOffset) )		return FALSE;	h = NewHandle ( 0 );	if ( !GetMSGText ( CBTextRef, h ) )		return FALSE;	*m = (pktmsg *) NewPtr ( sizeof (pktmsg) );		(*m)->flags = Atom.flags;		(*m)->from = Atom.from;	(*m)->to = Atom.to;	(*m)->reply = Atom.reply;		(*m)->msgid = Atom.msgID;	(*m)->replyid = Atom.repID;	strcpy ( (*m)->date, date );	strcpy ( (*m)->toname, toname );	strcpy ( (*m)->fromname, fromname );	strcpy ( (*m)->subj, subj );	(*m)->text = h;//	(*HBase)->AreaName[(*HBase)->AreaName[0]+1] = 0;//	if (CurrentBaseNumber)//		strcpy ( (*m)->area, (char *) &(*HBase)->AreaName[1] );//	else//		(*m)->area[0] = 0;	if (CurrentBaseNumber)		strcpy ( (*m)->area, (char *) &CurrentArea[1] );	else		(*m)->area[0] = 0;	(*m)->seenby.nodes = (*m)->seenby.nets = NULL;	(*m)->path.nodes = (*m)->path.nets = NULL;	(*m)->path.items = (*m)->seenby.items = 0;	return TRUE;}Boolean ReadMessageWOText ( long MsgNum, pktmsg **m, short *locked ){	indexAtomType	Atom;	long			baseTextSize;	long			counter;	char			fromname[MName],					toname[MName];	char			date[MDate],					subj[MSubject];	Handle			h;		if ( !ReadMessageAtom ( MsgNum, &Atom ) )		return FALSE;	*locked = Atom.deleted & 0x8000;	if ( SetFPos (CBHeadRef, fsFromStart, Atom.headOffset) )		return FALSE;	if ( !GetASCIIZ ( CBHeadRef, fromname, MName ) ||		 !GetASCIIZ ( CBHeadRef, toname, MName ) ||		 !GetASCIIZ ( CBHeadRef, date, MDate ) ||		 !GetASCIIZ ( CBHeadRef, subj, MSubject ) )		return FALSE;	if ( SetFPos (CBTextRef, fsFromStart, Atom.textOffset) )		return FALSE;	h = NewHandle ( 0 );//	if ( !GetMSGText ( CBTextRef, h ) )//		return FALSE;	*m = (pktmsg *) NewPtr ( sizeof (pktmsg) );		(*m)->flags = Atom.flags;		(*m)->from = Atom.from;	(*m)->to = Atom.to;	(*m)->reply = Atom.reply;		(*m)->msgid = Atom.msgID;	(*m)->replyid = Atom.repID;	strcpy ( (*m)->date, date );	strcpy ( (*m)->toname, toname );	strcpy ( (*m)->fromname, fromname );	strcpy ( (*m)->subj, subj );	(*m)->text = h;//	(*HBase)->AreaName[(*HBase)->AreaName[0]+1] = 0;//	if (CurrentBaseNumber)//		strcpy ( (*m)->area, (char *) &(*HBase)->AreaName[1] );//	else//		(*m)->area[0] = 0;	if (CurrentBaseNumber)		strcpy ( (*m)->area, (char *) &CurrentArea[1] );	else		(*m)->area[0] = 0;	(*m)->seenby.nodes = (*m)->seenby.nets = NULL;	(*m)->path.nodes = (*m)->path.nets = NULL;	(*m)->path.items = (*m)->seenby.items = 0;	return TRUE;}Boolean AppendMessage ( pktmsg *m ){	indexAtomType	Atom;	long			baseTextSize;	long			counter;			memset ( &Atom, 0, sizeof (indexAtomType) );	Atom.flags = m->flags;	Atom.deleted = 0;		Atom.from = m->from;	Atom.to = m->to;	Atom.reply = m->reply;		Atom.msgID = m->msgid;	Atom.repID = m->replyid;	Atom.BaseReplyTo = -1;	Atom.BaseNextReply = -1;	GetEOF ( CBHeadRef, &baseTextSize );	Atom.headOffset = baseTextSize;	SetFPos ( CBHeadRef, fsFromLEOF, 0L );		counter = strlen ( m->fromname ) + 1;	FSWrite ( CBHeadRef, &counter, m->fromname );	counter = strlen ( m->toname ) + 1;	FSWrite ( CBHeadRef, &counter, m->toname );	counter = strlen ( m->date ) + 1;	FSWrite ( CBHeadRef, &counter, m->date );	counter = strlen ( m->subj ) + 1;	FSWrite ( CBHeadRef, &counter, m->subj );	GetEOF ( CBTextRef, &baseTextSize );	Atom.textOffset = baseTextSize;		SetFPos ( CBTextRef, fsFromLEOF, 0 );	counter = GetHandleSize ( m->text );	FSWrite ( CBTextRef, &counter, *(m->text) );	WriteMessageAtom ( (*HBase)->NumberOfMessages, &Atom );		SetDirtyFlag ();		return TRUE;}