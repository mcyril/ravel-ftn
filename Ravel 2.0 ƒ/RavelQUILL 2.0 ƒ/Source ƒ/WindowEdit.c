#include <Sound.h>#include <string.h>#include <stdio.h>#include "hqx.h"#include "TE32K.h"/*본본본본본본본본본본본본본본본본본본본본본본본본본본본본본본본본본본본본본본*///#include "Ravel_FTN.h"#include "ravel_msg_base.h"#include "Ravel_Prefs.h"#include "Preferences.h"#include "pktparse.h"//#include "BaseManager.h"/*본본본본본본본본본본본본본본본본본본본본본본본본본본본본본본본본본본본본본본*/#include "PascalStr.h"#include "stringutl.h"#include "DialogLib.h"#include "WSubjects.h"#include "WEdit.h"#include "WNodes.h"#include "WASelect.h"#include "WAddressee.h"#include "PopUpLib.h"#include "myTEdit.h"#include "CommonData.h"#include "WindowsList.h"#include "nodelist.h"#include "Filter.h"#include "quoting.h"//#include "Cookies.h"#include "SoundLib.h"#include "Plug-Ins.h"/*본본본본본본본본본본본본본본본본본본본본본본본본본본본본본본본본본본본본본본*/#include "Templates.h"#include "pathes2.h"#include "rMenus.h"/*본본본본본본본본본본본본본본본본본본본본본본본본본본본본본본본본본본본본본본*/extern	short	viewFont;extern	Handle	*markArray;extern	Cursor	crs[3];extern	short	crsI;extern	long	hqxlines;typedef struct _wloc {	Point	topleft;	short	bottom;	} wloc;typedef struct _oneRecord {	addr	address;	Str63	name;	} oneRec, *oneRecPtr;static	Rect	originalView = {0,0,0,0};static char *hqxstart;static char *hqxstop;static char *hqxstart1 =	"-[HQX Segment Start %3d/%3d]------------------------------------\r";static char *hqxstop1 =		"-[HQX Segment End   %3d/%3d]------------------------------------\r";static char *uuestart1 =	"-[UUE Segment Start %3d/%3d]---------------------------------\r";static char *uuestop1 =		"-[UUE Segment End   %3d/%3d]---------------------------------\r";static char *prevent_d = "Hi, ";static char *replyText_d = " wrote to ";//static char	*tearLine_d = "--- " QUILLNAME " " RAVELVERS " " RAVELISA " " RAVELBUILD " for Macintosh\xD";#ifndef LITEstatic char	*tearLine_d = "--- " QUILLNAME " " RAVELVERS " " RAVELISA " for Macintosh\xD";#elsestatic char	*tearLine_d = "--- " QUILLNAME " " RAVELVERS " for Macintosh\xD";#endifstatic char	*originLine = " * Origin: %s (%#s)\xD";static char *delimiter = "=============================================================================\xD";//static short	RedirectKludge;extern Handle	selection_to_reply;void		AppendMark (long area);void		DeleteMark (long area, long message);#if defined(powerc) || defined(__powerc)	extern UniversalProcPtr uupMyAlertProc;#else	pascal Boolean myAlertProc ( DialogPtr theDialog, EventRecord *theEvent, short *itemHit );#endifstatic void FullAKAs (MenuHandle menu){	Str255		tmp;	short		i;		AppendMenu (menu, "\pdummy");	printaddr (&(*homesystem)->mainAddr.ad, (char *) &tmp[1]);	tmp[0] = strlen ((char *) &tmp[1]);	SetMenuItemText (menu, 1, tmp);	for (i=0; i<(*homesystem)->AKAcount; i++)	{		AppendMenu (menu, "\pdummy");		printaddr (&(*homesystem)->AKAAddr[i].ad, (char *) &tmp[1]);		tmp[0] = strlen ((char *) &tmp[1]);		SetMenuItemText (menu, i+2, tmp);	}}static ControlHandle InsertOneButton (DialogPtr dialog, short ID, short pos, short vpos){	Rect			cRect;	SetRect (&cRect, pos, vpos, 0, 0);		return NewControl (						dialog,						&cRect,						"\p",						true,						ID,						0,						1000,						(128 << 4),						0					);}static void InsertButtons (commonDataPtr common){	ControlHandle	cHandle;	short			r = (common->cMsgEdit.dialog)->portRect.right - 5;	short			iType;	Handle			iHandle;	Rect			iRect, rView;	GetDialogItem ( common->cMsgEdit.dialog, miBar, &iType, &iHandle, &rView );		rView.top += 3;		cHandle = InsertOneButton (common->cMsgEdit.dialog, btIDSend, r - btWidth * 1, rView.top);	common->cMsgEdit.controlsArray[btSend] = cHandle;	r -= 5;	cHandle = InsertOneButton (common->cMsgEdit.dialog, btIDRRead, r - btWidth * 2, rView.top);	common->cMsgEdit.controlsArray[btRRead] = cHandle;	cHandle = InsertOneButton (common->cMsgEdit.dialog, btIDLRead, r - btWidth * 3, rView.top);	common->cMsgEdit.controlsArray[btLRead] = cHandle;	cHandle = InsertOneButton (common->cMsgEdit.dialog, btIDHRead, r - btWidth * 4, rView.top);	common->cMsgEdit.controlsArray[btHRead] = cHandle;	r -= 5;	cHandle = InsertOneButton (common->cMsgEdit.dialog, btIDTRight, r - btWidth * 5, rView.top);	common->cMsgEdit.controlsArray[btTRight] = cHandle;	cHandle = InsertOneButton (common->cMsgEdit.dialog, btIDTLeft, r - btWidth * 6, rView.top);	common->cMsgEdit.controlsArray[btTLeft] = cHandle;	cHandle = InsertOneButton (common->cMsgEdit.dialog, btIDTHome, r - btWidth * 7, rView.top);	common->cMsgEdit.controlsArray[btTHome] = cHandle;	r -= 5;	cHandle = InsertOneButton (common->cMsgEdit.dialog, btIDRight, r - btWidth * 8, rView.top);	common->cMsgEdit.controlsArray[btRight] = cHandle;	cHandle = InsertOneButton (common->cMsgEdit.dialog, btIDLeft, r - btWidth * 9, rView.top);	common->cMsgEdit.controlsArray[btLeft] = cHandle;	cHandle = InsertOneButton (common->cMsgEdit.dialog, btIDNew, 4 + btWidth * 0, rView.top);	common->cMsgEdit.controlsArray[btNew] = cHandle;	cHandle = InsertOneButton (common->cMsgEdit.dialog, btIDReplyQ, 4 + btWidth * 1, rView.top);	common->cMsgEdit.controlsArray[btReplyQ] = cHandle;	cHandle = InsertOneButton (common->cMsgEdit.dialog, btIDReply, 4 + btWidth * 2, rView.top);	common->cMsgEdit.controlsArray[btReply] = cHandle;	cHandle = InsertOneButton (common->cMsgEdit.dialog, btIDEdit, 4 + btWidth * 3, rView.top);	common->cMsgEdit.controlsArray[btEdit] = cHandle;	cHandle = InsertOneButton (common->cMsgEdit.dialog, btIDKill, 4 + btWidth * 4, rView.top);	common->cMsgEdit.controlsArray[btKill] = cHandle;		r = (common->cMsgEdit.dialog)->portRect.right - 5;	GetDialogItem ( common->cMsgEdit.dialog, miStatus, &iType, &iHandle, &rView );	rView.top += 2;		cHandle = InsertOneButton (common->cMsgEdit.dialog, btIDUMarked, r - btWidthS * 1, rView.top);	common->cMsgEdit.controlsArray[btMarked] = cHandle;	cHandle = InsertOneButton (common->cMsgEdit.dialog, btIDULocked, r - btWidthS * 2, rView.top);	common->cMsgEdit.controlsArray[btLocked] = cHandle;	cHandle = InsertOneButton (common->cMsgEdit.dialog, btIDUKludge, r - btWidthS * 3, rView.top);	common->cMsgEdit.controlsArray[btKludge] = cHandle;	cHandle = InsertOneButton (common->cMsgEdit.dialog, btIDUPgf, r - btWidthS * 4, rView.top);	common->cMsgEdit.controlsArray[btPgf] = cHandle;}static void DisposeButtons (commonDataPtr common){	short	i;			for (i = 0; i < 20; i++)		if (common->cMsgEdit.controlsArray[i])		{			DisposeControl (common->cMsgEdit.controlsArray[i]);			common->cMsgEdit.controlsArray[i] = NULL;		}}static void HiliteButton (commonDataPtr common, long mask){	short	i;			for (i = 0; i < 20; i++)		if (common->cMsgEdit.controlsArray[i])			HiliteControl (common->cMsgEdit.controlsArray[i], (mask & (1L << i)) ? 0 : 255);}static short LocateButton (commonDataPtr common, ControlHandle whichControl){	short	i;			for (i = 0; i < 20; i++)		if (common->cMsgEdit.controlsArray[i] == whichControl)			return i;	return -1;}static void DrawContents (commonDataPtr common){	short		iType;	Handle		iHandle;	Rect		iRect, rView;	RGBColor	color, color1;	Str63		stemp, temp;	char		ttt[128];	SetPort (common->cMsgEdit.dialog);	GetDialogItem ( common->cMsgEdit.dialog, miBody, &iType, &iHandle, &rView );	MoveTo (0, rView.top - 1);	LineTo ((common->cMsgEdit.dialog)->portRect.right, rView.top - 1);	//	GetDialogItem ( common->cMsgEdit.dialog, miFlags, &iType, &iHandle, &rView );//	MoveTo (0, rView.top - 1);//	LineTo ((common->cMsgEdit.dialog)->portRect.right, rView.top - 1);		GetDialogItem ( common->cMsgEdit.dialog, miBar, &iType, &iHandle, &rView );	MoveTo (0, rView.top - 1);	LineTo ((common->cMsgEdit.dialog)->portRect.right, rView.top - 1);	MoveTo (0, rView.bottom);	LineTo ((common->cMsgEdit.dialog)->portRect.right, rView.bottom);		GetBackColor (&color1);	color.red = color.green = color.blue = 0xFFFF;	RGBBackColor(&color);	GetDialogItem ( common->cMsgEdit.dialog, miFrom, &iType, &iHandle, &rView );	EraseRect ( &rView );	GetDialogItem ( common->cMsgEdit.dialog, miTo, &iType, &iHandle, &rView );	EraseRect ( &rView );	GetDialogItem ( common->cMsgEdit.dialog, miSubj, &iType, &iHandle, &rView );	EraseRect ( &rView );	GetDialogItem ( common->cMsgEdit.dialog, miDate, &iType, &iHandle, &rView );	EraseRect ( &rView );//	GetDialogItem ( common->cMsgEdit.dialog, miAka, &iType, &iHandle, &rView );//	EraseRect ( &rView );	if (!common->cMsgEdit.area_number)	{		GetDialogItem ( common->cMsgEdit.dialog, miToAd, &iType, &iHandle, &rView );		EraseRect ( &rView );	}	//	color.red = color.green = color.blue = 50000;	RGBBackColor(&color1);/*		if (common->cMsgEdit.MessageBody)	{		TextFace (condense);		flags_to_string ( (common->cMsgEdit.MessageBody)->flags, ttt );		GetDialogItem ( common->cMsgEdit.dialog, miFlags, &iType, &iHandle, &rView );		TextBox ( ttt, strlen (ttt), &rView, teForceLeft );		TextFace (0);	}*///	OpenBase (common->cMsgEdit.area_number, false);/*	if (GetNumOfMessages ())	{		GetDialogItem ( common->cMsgEdit.dialog, miMsgNum, &iType, &iHandle, &rView );		NumToString (common->cMsgEdit.message_number + 1, stemp);				pStrCopy ("\p     ", temp);		for (iType = 1; iType <= stemp[0]; iType++)			temp[temp[0] - stemp[0] + iType] = stemp[iType];				SetDialogItemText (iHandle, temp);		GetDialogItem ( common->cMsgEdit.dialog, miOfNum, &iType, &iHandle, &rView );		NumToString (GetNumOfMessages (), stemp);		SetDialogItemText (iHandle, stemp);		GetDialogItem ( common->cMsgEdit.dialog, miOf, &iType, &iHandle, &rView );		SetDialogItemText (iHandle, "\pof");	}	else	{		GetDialogItem ( common->cMsgEdit.dialog, miMsgNum, &iType, &iHandle, &rView );		SetDialogItemText (iHandle, "\p");		GetDialogItem ( common->cMsgEdit.dialog, miOfNum, &iType, &iHandle, &rView );		SetDialogItemText (iHandle, "\p");		GetDialogItem ( common->cMsgEdit.dialog, miOf, &iType, &iHandle, &rView );		SetDialogItemText (iHandle, "\p");	}*///	CloseBase (0);}static void InitContents (windowsQElPtr dialogInfo, long base, long message){	short			iType;	Handle			iHandle;	Rect			iRect, rView;	char			ttt[128];	RGBColor		color, color1;	Str255			stemp, temp;	long			nm, mask;	msgbase_atom	Atom;	DateTimeRec		dtr;	addr			tempaddr;	short			akaNumber, i;	pktmsg			*m;		//	RedirectKludge = -1;	GetDialogItem ( (dialogInfo->common)->cMsgEdit.dialog, 12, &iType, &iHandle, &rView );	SetDialogItemText (iHandle, "\pSubj:");		q_subj[0] = 0;		switch ((dialogInfo->common)->cMsgEdit.editmode)	{	case editNew:	case editPost:	case editForward:				(dialogInfo->common)->cMsgEdit.currentTE = (base) ? 5 : 3;		break;			case editReplyQ:	case editReply:	case editReplyQto:	case editReplyto:	case editCommentQ:	case editComment:	case editCommentQto:	case editCommentto:			(dialogInfo->common)->cMsgEdit.currentTE = 5;		break;	case editEdit:		(dialogInfo->common)->cMsgEdit.currentTE = 0;		break;	}	if ((dialogInfo->common)->cMsgEdit.editmode != editEdit)	{		(dialogInfo->common)->cMsgEdit.firsttouch = 0;		TE32KActivate ((dialogInfo->common)->cMsgEdit.te.array[(dialogInfo->common)->cMsgEdit.currentTE-1]);//		LongRectToRect (&(*(dialogInfo->common)->cMsgEdit.te.array[(dialogInfo->common)->cMsgEdit.currentTE-1])->viewRect, &rView);//		InsetRect (&rView, -2, -2);//		InvalRect (&rView);	}	else	{		(dialogInfo->common)->cMsgEdit.firsttouch = 1;		TE32KActivate ((*(dialogInfo->common)->cMsgEdit.bodytext)->bodytext);	}	(dialogInfo->common)->cMsgEdit.dirty = 0;/*	mask = (base != AreasNumber+1) ? (1L << btNew) : 0;		(dialogInfo->common)->cMsgEdit.currentTE = 0;		if ((dialogInfo->common)->cMsgEdit.MessageBody)	{		FreePktMsg ( (dialogInfo->common)->cMsgEdit.MessageBody );		(dialogInfo->common)->cMsgEdit.MessageBody = NULL;	}*/	pStrCopy ((base == 0L) ? "\pNETMAIL" :				(base == AreasNumber+1) ? "\pBADMAIL" :					(*areasHndls[base-1])->areaName, stemp);/*	if (GetNumOfMessages ())		NumToString (message+1, temp);	else		pStrCopy ("\pEmpty", temp);	pStrConc (stemp, "\p: ", stemp);	pStrConc (stemp, temp, stemp);*/	if (!base)	{		(*(dialogInfo->common)->cMsgEdit.flagsPopUp)->statmenu = 1L << ffPrivate;		(*(dialogInfo->common)->cMsgEdit.flagsPopUp)->enable &= ~(1L << ffPrivate);	}	else	{		(*(dialogInfo->common)->cMsgEdit.flagsPopUp)->statmenu = 0L;		(*(dialogInfo->common)->cMsgEdit.flagsPopUp)->enable = 1L | (1L << ffPrivate);	}	switch ((dialogInfo->common)->cMsgEdit.editmode)	{	case editPost:				pStrConc ("\pPost: ", stemp, temp);		break;			case editNew:				pStrConc ("\pNew: ", stemp, temp);		break;			case editReplyQ:	case editReply:			pStrConc ("\pReply: ", stemp, temp);		break;	case editReplyQto:	case editReplyto:			pStrConc ("\pReply to: ", stemp, temp);		break;		case editCommentQ:	case editComment:		pStrConc ("\pComment: ", stemp, temp);		break;	case editCommentQto:	case editCommentto:		pStrConc ("\pComment to: ", stemp, temp);		break;			case editForward:			pStrConc ("\pForward: ", stemp, temp);		break;	case editEdit:		pStrConc ("\pEdit: ", stemp, temp);		break;	}		SetWTitle (dialogInfo->dialog, temp);	if ((dialogInfo->common)->cMsgEdit.editmode != editEdit)	{		(dialogInfo->common)->cMsgEdit.MessageBody = (pktmsg *) NewPtrClear ( sizeof (pktmsg) );		(dialogInfo->common)->cMsgEdit.MessageBody->flags = MSGLOCAL | ((base == 0) ? MSGPRIVATE : 0);		(dialogInfo->common)->cMsgEdit.MessageBody->seenby.nets = NULL;		(dialogInfo->common)->cMsgEdit.MessageBody->seenby.nodes = NULL;		(dialogInfo->common)->cMsgEdit.MessageBody->path.nets = NULL;		(dialogInfo->common)->cMsgEdit.MessageBody->path.nodes = NULL;		(dialogInfo->common)->cMsgEdit.MessageBody->msg_reply_prev = -1;		(dialogInfo->common)->cMsgEdit.MessageBody->msg_reply_next = -1;		(dialogInfo->common)->cMsgEdit.MessageBody->text = NULL;		(dialogInfo->common)->cMsgEdit.MessageBody->storedtime = 0;		if (base)		{			(*areasHndls[base-1])->areaName[(*areasHndls[base-1])->areaName[0]+1] = 0;			strcpy ( (dialogInfo->common)->cMsgEdit.MessageBody->area, (char *) &(*areasHndls[base-1])->areaName[1] );		}		else			(dialogInfo->common)->cMsgEdit.MessageBody->area[0] = 0;		strcpy ( (dialogInfo->common)->cMsgEdit.MessageBody->fromname, username[cuser] );		tempaddr.zone = 0;		switch ((dialogInfo->common)->cMsgEdit.editmode)		{		case editReplyQ:		case editReply:					(dialogInfo->common)->cMsgEdit.MessageBody->msg_reply_prev = (dialogInfo->common)->cMsgEdit.message_number;			if (!(dialogInfo->common)->cMsgEdit.area_number)			{				msgbase_open_idx ((dialogInfo->common)->cMsgEdit.area_number, true);				if (msgbase_read_message ((dialogInfo->common)->cMsgEdit.message_number, &m, READMODE_ONLY))				{					tempaddr = m->to;					FreePktMsg (m);				}				msgbase_close (CLOSE_ONLY);			}			else			{				msgbase_open_idx ((dialogInfo->common)->cMsgEdit.area_number, true);				if (msgbase_read_message ((dialogInfo->common)->cMsgEdit.message_number, &m, READMODE_TEXT))				{					short	redirect;									/*kill if bad!*/					HLock (m->text);					if ((redirect = parseForCC (m->text)) != -1)					{						FreePktMsg (m);						msgbase_close (CLOSE_ONLY);												(dialogInfo->common)->cMsgEdit.o_area_number = (dialogInfo->common)->cMsgEdit.area_number;						(dialogInfo->common)->cMsgEdit.area_number = redirect;												if ((dialogInfo->common)->cMsgEdit.editmode == editReplyQ)							(dialogInfo->common)->cMsgEdit.editmode = editReplyQto;						else							(dialogInfo->common)->cMsgEdit.editmode = editReplyto;												(dialogInfo->common)->cMsgEdit.MessageBody->msg_reply_prev = -1;						pStrConc ("\pReply to: ", (*areasHndls[redirect-1])->areaName, temp);						SetWTitle (dialogInfo->dialog, temp);												goto replyto;					}/*kill if bad!*/									FreePktMsg (m);				}				msgbase_close (CLOSE_ONLY);			}						break;		case editReplyQto:		case editReplyto:				replyto:					if (!(dialogInfo->common)->cMsgEdit.area_number &&				(dialogInfo->common)->cMsgEdit.o_area_number != AreasNumber+1)			{				if ((dialogInfo->common)->cMsgEdit.o_area_number)				{					tempaddr = ((*areasHndls[(dialogInfo->common)->cMsgEdit.o_area_number-1])->useAKA) ?						(*homesystem)->AKAAddr[(*areasHndls[(dialogInfo->common)->cMsgEdit.o_area_number-1])->useAKA-1].ad : (*homesystem)->mainAddr.ad;				}				else				{					tempaddr = ((*mailHndl)->useAKA) ?						(*homesystem)->AKAAddr[(*mailHndl)->useAKA-1].ad : (*homesystem)->mainAddr.ad;				}			}						break;		case editCommentQ:		case editComment:			(dialogInfo->common)->cMsgEdit.MessageBody->msg_reply_prev = (dialogInfo->common)->cMsgEdit.message_number;		case editCommentQto:		case editCommentto:			goto nope_addr;		}				if (!tempaddr.zone)			goto nope_addr;		akaNumber = -1;		if (tempaddr.zone == (*homesystem)->mainAddr.ad.zone &&			tempaddr.net == (*homesystem)->mainAddr.ad.net &&			tempaddr.node == (*homesystem)->mainAddr.ad.node &&			tempaddr.point == (*homesystem)->mainAddr.ad.point)		{			akaNumber = 0;		}		else		{			for (i = 0; i < (*homesystem)->AKAcount; i++)				if (tempaddr.zone == (*homesystem)->AKAAddr[i].ad.zone &&					tempaddr.net == (*homesystem)->AKAAddr[i].ad.net &&					tempaddr.node == (*homesystem)->AKAAddr[i].ad.node &&					tempaddr.point == (*homesystem)->AKAAddr[i].ad.point)					break;								if (i < (*homesystem)->AKAcount)				akaNumber = i+1;		}				if (akaNumber < 0)			goto nope_addr;	}	else	{//		if ((dialogInfo->common)->cMsgEdit.area_number == AreasNumber+1)//			OpenBase ( BADAREA, true );//		else//			OpenBase ((dialogInfo->common)->cMsgEdit.area_number, true);		msgbase_open_idx ((dialogInfo->common)->cMsgEdit.area_number, true);		msgbase_read_message ((dialogInfo->common)->cMsgEdit.message_number, &(dialogInfo->common)->cMsgEdit.MessageBody, READMODE_TEXT | READMODE_REPLY);				msgbase_close (CLOSE_ONLY);		(dialogInfo->common)->cMsgEdit.MessageBody->storedtime = 0;		(dialogInfo->common)->cMsgEdit.editunsent =			(((dialogInfo->common)->cMsgEdit.MessageBody->flags & MSGSENT) == 0);		(dialogInfo->common)->cMsgEdit.MessageBody->flags &= ~MSGSENT;		if (!base)		{			if (((dialogInfo->common)->cMsgEdit.MessageBody)->flags & MSGHOLD)				(*(dialogInfo->common)->cMsgEdit.flagsPopUp)->statmenu |= (1L << ffHold);			if (((dialogInfo->common)->cMsgEdit.MessageBody)->flags & MSGDIRECT)				(*(dialogInfo->common)->cMsgEdit.flagsPopUp)->statmenu |= (1L << ffDirect);			if (((dialogInfo->common)->cMsgEdit.MessageBody)->flags & MSGCRASH)				(*(dialogInfo->common)->cMsgEdit.flagsPopUp)->statmenu |= (1L << ffCrash);			if (((dialogInfo->common)->cMsgEdit.MessageBody)->flags & MSGKILL)				(*(dialogInfo->common)->cMsgEdit.flagsPopUp)->statmenu |= (1L << ffKillSent);			if (((dialogInfo->common)->cMsgEdit.MessageBody)->flags & MSGRRREQ)				(*(dialogInfo->common)->cMsgEdit.flagsPopUp)->statmenu |= (1L << ffRRq);			if (((dialogInfo->common)->cMsgEdit.MessageBody)->flags & MSGCFM)				(*(dialogInfo->common)->cMsgEdit.flagsPopUp)->statmenu |= (1L << ffCfm);			if (((dialogInfo->common)->cMsgEdit.MessageBody)->flags & MSGFREQ)				(*(dialogInfo->common)->cMsgEdit.flagsPopUp)->statmenu |= (1L << ffFreq);			if (((dialogInfo->common)->cMsgEdit.MessageBody)->flags & MSGFILE)				(*(dialogInfo->common)->cMsgEdit.flagsPopUp)->statmenu |= (1L << ffAttach);			if (((dialogInfo->common)->cMsgEdit.MessageBody)->flags & MSGKFS)				(*(dialogInfo->common)->cMsgEdit.flagsPopUp)->statmenu |= (1L << ffAttKill);		}		else			if (((dialogInfo->common)->cMsgEdit.MessageBody)->flags & MSGPRIVATE)				(*(dialogInfo->common)->cMsgEdit.flagsPopUp)->statmenu |= (1L << ffPrivate);				(dialogInfo->common)->cMsgEdit.MessageBody->msg_reply_next = -1;		HLock ((dialogInfo->common)->cMsgEdit.MessageBody->text);		TE32KSetText (*(dialogInfo->common)->cMsgEdit.MessageBody->text,			strlen (*(dialogInfo->common)->cMsgEdit.MessageBody->text),			(*(dialogInfo->common)->cMsgEdit.bodytext)->bodytext);		DisposeHandle ((dialogInfo->common)->cMsgEdit.MessageBody->text);		(dialogInfo->common)->cMsgEdit.MessageBody->text = NULL;				TE32KSetSelect (0, 0, (*(dialogInfo->common)->cMsgEdit.bodytext)->bodytext);		myTEScrollRedraw ((dialogInfo->common)->cMsgEdit.bodytext);			tempaddr = (dialogInfo->common)->cMsgEdit.MessageBody->from;				akaNumber = -1;		if (tempaddr.zone == (*homesystem)->mainAddr.ad.zone &&			tempaddr.net == (*homesystem)->mainAddr.ad.net &&			tempaddr.node == (*homesystem)->mainAddr.ad.node &&			tempaddr.point == (*homesystem)->mainAddr.ad.point)		{			akaNumber = 0;		}		else		{			for (i = 0; i < (*homesystem)->AKAcount; i++)				if (tempaddr.zone == (*homesystem)->AKAAddr[i].ad.zone &&					tempaddr.net == (*homesystem)->AKAAddr[i].ad.net &&					tempaddr.node == (*homesystem)->AKAAddr[i].ad.node &&					tempaddr.point == (*homesystem)->AKAAddr[i].ad.point)					break;								if (i < (*homesystem)->AKAcount)				akaNumber = i+1;		}				if (akaNumber < 0)		{		nope_addr:					if (base)			{				tempaddr = ((*areasHndls[base-1])->useAKA) ?					(*homesystem)->AKAAddr[(*areasHndls[base-1])->useAKA-1].ad : (*homesystem)->mainAddr.ad;				akaNumber = (*areasHndls[base-1])->useAKA;			}			else			{				tempaddr = ((*mailHndl)->useAKA) ?					(*homesystem)->AKAAddr[(*mailHndl)->useAKA-1].ad : (*homesystem)->mainAddr.ad;				akaNumber = (*mailHndl)->useAKA;			}		}	}	printaddr (&tempaddr, &ttt[1]);	ttt[0] = strlen (&ttt[1]);		(*(dialogInfo->common)->cMsgEdit.AkaPopUp)->statmenu = 1L << (akaNumber + 1);	(*(dialogInfo->common)->cMsgEdit.AkaPopUp)->theValue = akaNumber + 1;	pStrCopy ((StringPtr) ttt, (*(dialogInfo->common)->cMsgEdit.AkaPopUp)->title);		(dialogInfo->common)->cMsgEdit.MessageBody->from = tempaddr;//	(*homesystem)->sysop[(*homesystem)->sysop[0]+1] = 0;//	strcpy ( ((dialogInfo->common)->cMsgEdit.MessageBody)->fromname, (char *) &(*homesystem)->sysop[1] );		(dialogInfo->common)->cMsgEdit.MessageBody->base_flags = 0;	switch ((dialogInfo->common)->cMsgEdit.editmode)	{	case editForward://		if ((dialogInfo->common)->cMsgEdit.o_area_number == AreasNumber+1)//			OpenBase ( BADAREA, true );//		else//			OpenBase ((dialogInfo->common)->cMsgEdit.o_area_number, true);		msgbase_open_idx ((dialogInfo->common)->cMsgEdit.o_area_number, true);		if ( msgbase_read_message ((dialogInfo->common)->cMsgEdit.message_number, &m, READMODE_ONLY) )		{			strcpy ( (dialogInfo->common)->cMsgEdit.MessageBody->subj, m->subj );						FreePktMsg (m);		}		else			(dialogInfo->common)->cMsgEdit.MessageBody->subj[0] = 0;				msgbase_close (CLOSE_ONLY);		/* FALL THROUGH */			case editPost:	case editNew:				if (base)			strcpy ( ((dialogInfo->common)->cMsgEdit.MessageBody)->toname, "All" );		else			(dialogInfo->common)->cMsgEdit.MessageBody->toname[0] = 0;				if ((dialogInfo->common)->cMsgEdit.editmode != editForward)			(dialogInfo->common)->cMsgEdit.MessageBody->subj[0] = 0;		(dialogInfo->common)->cMsgEdit.MessageBody->reply.zone = 0;		(dialogInfo->common)->cMsgEdit.MessageBody->reply.net = 0;		(dialogInfo->common)->cMsgEdit.MessageBody->reply.node = 0;		(dialogInfo->common)->cMsgEdit.MessageBody->reply.point = 0;		(dialogInfo->common)->cMsgEdit.MessageBody->reply_num = 0;		(dialogInfo->common)->cMsgEdit.MessageBody->reply_crc = 0;		(dialogInfo->common)->cMsgEdit.MessageBody->reply_str = 0;		(dialogInfo->common)->cMsgEdit.MessageBody->to.zone = -1;		(dialogInfo->common)->cMsgEdit.MessageBody->to.net = -1;		(dialogInfo->common)->cMsgEdit.MessageBody->to.node = -1;		(dialogInfo->common)->cMsgEdit.MessageBody->to.point = 0;		break;	case editReplyQ:	case editReply:	//		if ((dialogInfo->common)->cMsgEdit.area_number == AreasNumber+1)//			OpenBase ( BADAREA, true );//		else//			OpenBase ((dialogInfo->common)->cMsgEdit.area_number, true);		msgbase_open_idx ((dialogInfo->common)->cMsgEdit.area_number, true);		if ( msgbase_read_message ((dialogInfo->common)->cMsgEdit.message_number, &m, READMODE_REPLY) )		{			strcpy ( q_wasfrom, m->fromname );			strcpy ( q_wasto, m->toname );			strcpy ( q_date, m->date );			strcpy ( q_subj, m->subj );			strcpy ( (dialogInfo->common)->cMsgEdit.MessageBody->toname, m->fromname );			strcpy ( (dialogInfo->common)->cMsgEdit.MessageBody->subj, m->subj );			msgbase_prep_reply (m, (dialogInfo->common)->cMsgEdit.MessageBody);//			(dialogInfo->common)->cMsgEdit.MessageBody->reply = m->from;//			(dialogInfo->common)->cMsgEdit.MessageBody->replyid = m->msgid;			if (!base)			{				(dialogInfo->common)->cMsgEdit.MessageBody->to = m->from;						if (uucpaware)					parseForInternetReply ( m->text,						(dialogInfo->common)->cMsgEdit.MessageBody->toname,						&(dialogInfo->common)->cMsgEdit.MessageBody->to );			}						FreePktMsg (m);		}				msgbase_close (CLOSE_ONLY);				break;	case editReplyQto:	case editReplyto:	//		if ((dialogInfo->common)->cMsgEdit.o_area_number == AreasNumber+1)//			OpenBase ( BADAREA, true );//		else//			OpenBase ((dialogInfo->common)->cMsgEdit.o_area_number, true);		msgbase_open_idx ((dialogInfo->common)->cMsgEdit.o_area_number, true);		if ( msgbase_read_message ((dialogInfo->common)->cMsgEdit.message_number, &m, READMODE_TEXT | READMODE_REPLY) )		{			strcpy ( q_wasfrom, m->fromname );			strcpy ( q_wasto, m->toname );			strcpy ( q_date, m->date );			strcpy ( q_subj, m->subj );			strcpy ( (dialogInfo->common)->cMsgEdit.MessageBody->toname, m->fromname );			strcpy ( (dialogInfo->common)->cMsgEdit.MessageBody->subj, m->subj );			msgbase_prep_reply (m, (dialogInfo->common)->cMsgEdit.MessageBody);//			(dialogInfo->common)->cMsgEdit.MessageBody->reply = m->from;//			(dialogInfo->common)->cMsgEdit.MessageBody->replyid = m->msgid;			if (!base)			{				(dialogInfo->common)->cMsgEdit.MessageBody->to = m->from;						if (uucpaware)					parseForInternetReply ( m->text,						(dialogInfo->common)->cMsgEdit.MessageBody->toname,						&(dialogInfo->common)->cMsgEdit.MessageBody->to );			}						FreePktMsg (m);		}				msgbase_close (CLOSE_ONLY);				break;	case editCommentQ:	case editComment:	//		if ((dialogInfo->common)->cMsgEdit.area_number == AreasNumber+1)//			OpenBase ( BADAREA, true );//		else//			OpenBase ((dialogInfo->common)->cMsgEdit.area_number, true);		msgbase_open_idx ((dialogInfo->common)->cMsgEdit.area_number, true);		if ( msgbase_read_message ((dialogInfo->common)->cMsgEdit.message_number, &m, READMODE_REPLY ) )		{			strcpy ( q_wasfrom, m->fromname );			strcpy ( q_wasto, m->toname );			strcpy ( q_date, m->date );			strcpy ( q_subj, m->subj );			strcpy ( (dialogInfo->common)->cMsgEdit.MessageBody->toname, m->toname );			strcpy ( (dialogInfo->common)->cMsgEdit.MessageBody->subj, m->subj );			msgbase_prep_reply (m, (dialogInfo->common)->cMsgEdit.MessageBody);//			(dialogInfo->common)->cMsgEdit.MessageBody->reply = m->from;//			(dialogInfo->common)->cMsgEdit.MessageBody->replyid = m->msgid;			FreePktMsg (m);		}				msgbase_close (CLOSE_ONLY);				break;	case editCommentQto:	case editCommentto:	//		if ((dialogInfo->common)->cMsgEdit.o_area_number == AreasNumber+1)//			OpenBase ( BADAREA, true );//		else//			OpenBase ((dialogInfo->common)->cMsgEdit.o_area_number, true);		msgbase_open_idx ((dialogInfo->common)->cMsgEdit.o_area_number, true);		if ( msgbase_read_message ((dialogInfo->common)->cMsgEdit.message_number, &m, READMODE_REPLY ) )		{			strcpy ( q_wasfrom, m->fromname );			strcpy ( q_wasto, m->toname );			strcpy ( q_date, m->date );			strcpy ( q_subj, m->subj );			strcpy ( (dialogInfo->common)->cMsgEdit.MessageBody->toname, m->toname );			strcpy ( (dialogInfo->common)->cMsgEdit.MessageBody->subj, m->subj );			msgbase_prep_reply (m, (dialogInfo->common)->cMsgEdit.MessageBody);//			(dialogInfo->common)->cMsgEdit.MessageBody->reply = m->from;//			(dialogInfo->common)->cMsgEdit.MessageBody->replyid = m->msgid;			FreePktMsg (m);		}				msgbase_close (CLOSE_ONLY);				break;	}	if ((dialogInfo->common)->cMsgEdit.editmode != editEdit ||		((dialogInfo->common)->cMsgEdit.editmode == editEdit && !(dialogInfo->common)->cMsgEdit.editunsent))	{//		GetTime ( &dtr );		//		dtr.year %= 100;//		sprintf ( ttt, "%.2d %s %.2d  %.2d:%.2d:%.2d",//						dtr.day, mnt[dtr.month-1], dtr.year, dtr.hour, dtr.minute, dtr.second );//		strcpy ( (dialogInfo->common)->cMsgEdit.MessageBody->date, ttt );		msgbase_ftn_date ((dialogInfo->common)->cMsgEdit.MessageBody->date, NULL);				(dialogInfo->common)->cMsgEdit.MessageBody->msgid_num = 0;		msgbase_prep_msgid ((dialogInfo->common)->cMsgEdit.MessageBody);	}	GetBackColor (&color1);	color.red = color.green = color.blue = 0xFFFF;	RGBBackColor(&color);	TE32KSetText (((dialogInfo->common)->cMsgEdit.MessageBody)->fromname,				strlen (((dialogInfo->common)->cMsgEdit.MessageBody)->fromname),					(dialogInfo->common)->cMsgEdit.te.named.from);	TE32KSetText (((dialogInfo->common)->cMsgEdit.MessageBody)->toname,				strlen (((dialogInfo->common)->cMsgEdit.MessageBody)->toname),					(dialogInfo->common)->cMsgEdit.te.named.to);		(*(dialogInfo->common)->cMsgEdit.te.named.subj)->txFont =		(((dialogInfo->common)->cMsgEdit.MessageBody)->flags & MSGFILE) ? 4 : viewFont;	TE32KSetText (((dialogInfo->common)->cMsgEdit.MessageBody)->subj,				strlen (((dialogInfo->common)->cMsgEdit.MessageBody)->subj),					(dialogInfo->common)->cMsgEdit.te.named.subj);	if ((((dialogInfo->common)->cMsgEdit.MessageBody)->flags & (MSGFILE | MSGFREQ)) != 0)		SetDialogItemText (iHandle, "\pFile:");		TE32KSetText (((dialogInfo->common)->cMsgEdit.MessageBody)->date,				strlen (((dialogInfo->common)->cMsgEdit.MessageBody)->date),					(dialogInfo->common)->cMsgEdit.te.named.date);	if (!base)	{		if ((dialogInfo->common)->cMsgEdit.editmode == editNew ||			(dialogInfo->common)->cMsgEdit.editmode == editPost)		{			TE32KSetText ("", 0, (dialogInfo->common)->cMsgEdit.te.named.toaddr);//			TE32KDeactivate ((dialogInfo->common)->cMsgEdit.te.named.toaddr);		}		else		{			printaddr (&((dialogInfo->common)->cMsgEdit.MessageBody)->to, ttt);			TE32KSetText (ttt, strlen (ttt), (dialogInfo->common)->cMsgEdit.te.named.toaddr);		}	}	DrawPopUp ((dialogInfo->common)->cMsgEdit.AkaPopUp);//	color.red = color.green = color.blue = 50000;	RGBBackColor(&color1);	InvalRect (&(dialogInfo->dialog)->portRect);}static Boolean PrepareBody (windowsQElPtr dialogInfo){	Handle		hndl, quoted;	Ptr			storage, middle;	char		tmp[128], tmp1[128];	Str255		ttt;	long		whr;	pktmsg		*m;		long		buffsize, actualsize;	char		buff[256];			hndl = NewHandle (0);	switch ((dialogInfo->common)->cMsgEdit.editmode)	{	case editNew:	case editPost:	asnew:	//	look_for_template (char *areaname, templateRecordPtr templates, char *default_template)			if (!(middle = look_for_template (((dialogInfo->common)->cMsgEdit.MessageBody)->area, prevent, prevent_def)))		{			PtrAndHand ( prevent_d, hndl, strlen (prevent_d) );			PtrAndHand ( q_nowto, hndl, strlen (q_nowto) );			PtrAndHand ( ".\xd", hndl, 2 );		}		else		{			performsubstitution (&storage, middle);			PtrAndHand ( storage, hndl, strlen (storage) );			DisposePtr ( storage );		}		PtrAndHand ( "\xd\xd", hndl, 2 );				whr = GetHandleSize (hndl);				if (!(middle = look_for_template (((dialogInfo->common)->cMsgEdit.MessageBody)->area, poster, poster_def)))		{			PtrAndHand ( q_nowfrom, hndl, strlen (q_nowfrom) );			PtrAndHand ( "\xd\xd", hndl, 2 );		}		else		{			performsubstitution (&storage, middle);			PtrAndHand ( storage, hndl, strlen (storage) );			DisposePtr ( storage );		}				{			pktmsg	m;						m.text = hndl;			CallPlugIns (plugMsgBodyDone, &m, 0);		}//		dealCookie (hndl);				if (CallParmPlugIns (plugMsgBodyAskTearline, (dialogInfo->common)->cMsgEdit.MessageBody, 255, &actualsize, buff, 0))		{			strcpy (tmp, "---");						if (actualsize)			{				buff[actualsize] = 0;				strcat (tmp, " ");				strcat (tmp, buff);			}			strcat (tmp, "\xD");						PtrAndHand ( tmp, hndl, strlen (tmp) );		}		else			if (tearLine)			{				strcpy (tmp, "---");								if (tearLine[0])				{					strcat (tmp, " ");					strcat (tmp, tearLine);				}				strcat (tmp, "\xD");								PtrAndHand ( tmp, hndl, strlen (tmp) );			}			else				PtrAndHand ( tearLine_d, hndl, strlen (tearLine_d) );		if ((dialogInfo->common)->cMsgEdit.area_number || netmailorigin)		{			GetCItemPopUp ((dialogInfo->common)->cMsgEdit.AkaPopUp, FullAKAs, ttt);						if (CallParmPlugIns (plugMsgBodyAskOrigin, (dialogInfo->common)->cMsgEdit.MessageBody, 255, &actualsize, buff, 0))			{				buff[actualsize] = 0;				sprintf ( tmp, originLine, buff, ttt);			}			else				sprintf ( tmp, originLine, origin[corigin], ttt);						PtrAndHand ( tmp, hndl, strlen (tmp) );		}		break;	case editForward:		if (!(middle = look_for_template (((dialogInfo->common)->cMsgEdit.MessageBody)->area, prevent, prevent_def)))		{			PtrAndHand ( prevent_d, hndl, strlen (prevent_d) );			PtrAndHand ( q_nowto, hndl, strlen (q_nowto) );			PtrAndHand ( ".\xd", hndl, 2 );		}		else		{			performsubstitution (&storage, middle);			PtrAndHand ( storage, hndl, strlen (storage) );			DisposePtr ( storage );		}		PtrAndHand ( "\xd", hndl, 1 );//		if ((dialogInfo->common)->cMsgEdit.o_area_number == AreasNumber+1)//			OpenBase ( BADAREA, true );//		else//			OpenBase ((dialogInfo->common)->cMsgEdit.o_area_number, true);		msgbase_open_idx ((dialogInfo->common)->cMsgEdit.o_area_number, true);		if ( msgbase_read_message ((dialogInfo->common)->cMsgEdit.message_number, &m, READMODE_TEXT ) )		{			PtrAndHand ( delimiter, hndl, strlen (delimiter) );						sprintf ( tmp, "Forwarded by %s (%s)\xD",				((dialogInfo->common)->cMsgEdit.MessageBody)->fromname,				printaddr ( &((dialogInfo->common)->cMsgEdit.MessageBody)->from, tmp1 ) );			PtrAndHand ( tmp, hndl, strlen (tmp) );			if (m->area[0])				strcpy ( tmp1, m->area );			else				strcpy ( tmp1, "NetMail" );			sprintf ( tmp, "Area: %s\xD", tmp1 );			PtrAndHand ( tmp, hndl, strlen (tmp) );			sprintf ( tmp, "From: %s (%s) %s\xD", m->fromname, printaddr ( &m->from, tmp1 ), m->date );			PtrAndHand ( tmp, hndl, strlen (tmp) );			if (m->area[0])				sprintf ( tmp, "To:   %s\xD", m->toname );			else				sprintf ( tmp, "To:   %s (%s)\xD", m->toname, printaddr ( &m->to, tmp1 ) );						PtrAndHand ( tmp, hndl, strlen (tmp) );			sprintf ( tmp, "Subj: %s\xD", m->subj );			PtrAndHand ( tmp, hndl, strlen (tmp) );			PtrAndHand ( delimiter, hndl, strlen (delimiter) );			HLock (m->text);			callFilter (m->text);			forwardFilter (m->text);			PtrAndHand (*(m->text), hndl, strlen (*(m->text)));			HUnlock (m->text);			PtrAndHand ( delimiter, hndl, strlen (delimiter) );			FreePktMsg (m);		}				msgbase_close (CLOSE_ONLY);		PtrAndHand ( "\xd\xd", hndl, 2 );				whr = GetHandleSize (hndl);				if (!(middle = look_for_template (((dialogInfo->common)->cMsgEdit.MessageBody)->area, poster, poster_def)))		{			PtrAndHand ( q_nowfrom, hndl, strlen (q_nowfrom) );			PtrAndHand ( "\xd\xd", hndl, 2 );		}		else		{			performsubstitution (&storage, middle);			PtrAndHand ( storage, hndl, strlen (storage) );			DisposePtr ( storage );		}				{			pktmsg	m;						m.text = hndl;			CallPlugIns (plugMsgBodyDone, &m, 0);		}//		dealCookie (hndl);		if (CallParmPlugIns (plugMsgBodyAskTearline, (dialogInfo->common)->cMsgEdit.MessageBody, 255, &actualsize, buff, 0))		{			strcpy (tmp, "---");						if (actualsize)			{				buff[actualsize] = 0;				strcat (tmp, " ");				strcat (tmp, buff);			}			strcat (tmp, "\xD");						PtrAndHand ( tmp, hndl, strlen (tmp) );		}		else			if (tearLine)			{				strcpy (tmp, "---");								if (tearLine[0])				{					strcat (tmp, " ");					strcat (tmp, tearLine);				}				strcat (tmp, "\xD");								PtrAndHand ( tmp, hndl, strlen (tmp) );			}			else				PtrAndHand ( tearLine_d, hndl, strlen (tearLine_d) );		if ((dialogInfo->common)->cMsgEdit.area_number || netmailorigin)		{			GetCItemPopUp ((dialogInfo->common)->cMsgEdit.AkaPopUp, FullAKAs, ttt);			if (CallParmPlugIns (plugMsgBodyAskOrigin, (dialogInfo->common)->cMsgEdit.MessageBody, 255, &actualsize, buff, 0))			{				buff[actualsize] = 0;				sprintf ( tmp, originLine, buff, ttt);			}			else				sprintf ( tmp, originLine, origin[corigin], ttt);						PtrAndHand ( tmp, hndl, strlen (tmp) );		}		break;	case editReply:	case editReplyQ:	case editReplyto:	case editReplyQto:		toolarge:			if (!(dialogInfo->common)->cMsgEdit.area_number && replyaddr[0])		{			PtrAndHand ( "TO: ", hndl, 4 );			PtrAndHand ( &replyaddr[1], hndl, replyaddr[0] );			PtrAndHand ( "\xd\xd", hndl, 2 );		}				if ((dialogInfo->common)->cMsgEdit.editmode == editReplyto ||			(dialogInfo->common)->cMsgEdit.editmode == editReplyQto)		{			pStrCopy (((dialogInfo->common)->cMsgEdit.o_area_number == 0L) ? "\pNetMail" :						((dialogInfo->common)->cMsgEdit.o_area_number == AreasNumber+1) ? "\pBADMAIL" :							(*areasHndls[(dialogInfo->common)->cMsgEdit.o_area_number-1])->areaName, ttt);			sprintf ( tmp, "* Answer to a message posted in %#s\xD\xD", ttt );			PtrAndHand ( tmp, hndl, strlen (tmp) );		}		//		if (!prevent)//		{//			PtrAndHand ( prevent_d, hndl, strlen (prevent_d) );//			PtrAndHand ( q_nowto, hndl, strlen (q_nowto) );//			PtrAndHand ( ".\xd", hndl, 2 );//		}//		else//		{//			performsubstitution (&storage, prevent);//			PtrAndHand ( storage, hndl, strlen (storage) );//			DisposePtr ( storage );//		}		if (!(middle = look_for_template (((dialogInfo->common)->cMsgEdit.MessageBody)->area, replyText, replyText_def)))		{			PtrAndHand ( q_wasfrom, hndl, strlen (q_wasfrom) );			PtrAndHand ( replyText_d, hndl, strlen (replyText_d) );			PtrAndHand ( q_wasto, hndl, strlen (q_wasto) );			PtrAndHand ( ".\xd\xd", hndl, 3 );		}		else		{			performsubstitution (&storage, middle);			PtrAndHand ( storage, hndl, strlen (storage) );			DisposePtr ( storage );		}		PtrAndHand ( "\xd", hndl, 1 );		if ((dialogInfo->common)->cMsgEdit.editmode != editReply &&			(dialogInfo->common)->cMsgEdit.editmode != editReplyto)		{			if ((*(dialogInfo->common)->cMsgEdit.bodytext)->replyselected)			{				HLock ((*(dialogInfo->common)->cMsgEdit.bodytext)->storedText);				callFilter ((*(dialogInfo->common)->cMsgEdit.bodytext)->storedText);				prepareQuoting (*((*(dialogInfo->common)->cMsgEdit.bodytext)->storedText), &quoted, q_wasfrom);				HandAndHand (quoted, hndl);				DisposeHandle (quoted);				DisposeHandle ((*(dialogInfo->common)->cMsgEdit.bodytext)->storedText);				(*(dialogInfo->common)->cMsgEdit.bodytext)->storedText = NULL;				(*(dialogInfo->common)->cMsgEdit.bodytext)->replyselected = false;			}			else			{				if ((dialogInfo->common)->cMsgEdit.editmode == editReplyQ)				{					msgbase_open_idx ((dialogInfo->common)->cMsgEdit.area_number, true);				}				else				{					msgbase_open_idx ((dialogInfo->common)->cMsgEdit.o_area_number, true);				}								if ( msgbase_read_message ((dialogInfo->common)->cMsgEdit.message_number, &m, READMODE_TEXT ) )				{					HLock (m->text);					callFilter (m->text);				//	HUnlock (m->text);					prepareQuoting (*(m->text), &quoted, q_wasfrom);					HandAndHand (quoted, hndl);					DisposeHandle (quoted);					FreePktMsg (m);				}								msgbase_close (CLOSE_ONLY);			}					}				PtrAndHand ( "\xd", hndl, 1 );				whr = GetHandleSize (hndl);				if (!(middle = look_for_template (((dialogInfo->common)->cMsgEdit.MessageBody)->area, poster, poster_def)))		{			PtrAndHand ( q_nowfrom, hndl, strlen (q_nowfrom) );			PtrAndHand ( "\xd\xd", hndl, 2 );		}		else		{			performsubstitution (&storage, middle);			PtrAndHand ( storage, hndl, strlen (storage) );			DisposePtr ( storage );		}				{			pktmsg	m;						m.text = hndl;			CallPlugIns (plugMsgBodyDone, &m, 0);		}//		dealCookie (hndl);		if (CallParmPlugIns (plugMsgBodyAskTearline, (dialogInfo->common)->cMsgEdit.MessageBody, 255, &actualsize, buff, 0))		{			strcpy (tmp, "---");						if (actualsize)			{				buff[actualsize] = 0;				strcat (tmp, " ");				strcat (tmp, buff);			}			strcat (tmp, "\xD");						PtrAndHand ( tmp, hndl, strlen (tmp) );		}		else			if (tearLine)			{				strcpy (tmp, "---");								if (tearLine[0])				{					strcat (tmp, " ");					strcat (tmp, tearLine);				}				strcat (tmp, "\xD");								PtrAndHand ( tmp, hndl, strlen (tmp) );			}			else				PtrAndHand ( tearLine_d, hndl, strlen (tearLine_d) );		if ((dialogInfo->common)->cMsgEdit.area_number || netmailorigin)		{			GetCItemPopUp ((dialogInfo->common)->cMsgEdit.AkaPopUp, FullAKAs, ttt);			if (CallParmPlugIns (plugMsgBodyAskOrigin, (dialogInfo->common)->cMsgEdit.MessageBody, 255, &actualsize, buff, 0))			{				buff[actualsize] = 0;				sprintf ( tmp, originLine, buff, ttt);			}			else				sprintf ( tmp, originLine, origin[corigin], ttt);						PtrAndHand ( tmp, hndl, strlen (tmp) );		}		if (GetHandleSize (hndl) > 0x7F00)		{			if ((dialogInfo->common)->cMsgEdit.editmode == editReplyQ)				(dialogInfo->common)->cMsgEdit.editmode = editReply;			else				if ((dialogInfo->common)->cMsgEdit.editmode == editReplyQto)					(dialogInfo->common)->cMsgEdit.editmode = editReplyto;				else				{					DebugStr ("\pWhow! Something wrong!!");					(dialogInfo->common)->cMsgEdit.editmode = editReply;				}								DisposeHandle (hndl);			hndl = NewHandle (0);			goto toolarge;		}				break;	case editCommentQ:	case editComment:	case editCommentQto:	case editCommentto:	toolargeC:			if ((dialogInfo->common)->cMsgEdit.editmode == editCommentto ||			(dialogInfo->common)->cMsgEdit.editmode == editCommentQto)		{			pStrCopy (((dialogInfo->common)->cMsgEdit.o_area_number == 0L) ? "\pNetMail" :						((dialogInfo->common)->cMsgEdit.o_area_number == AreasNumber+1) ? "\pBADMAIL" :							(*areasHndls[(dialogInfo->common)->cMsgEdit.o_area_number-1])->areaName, ttt);			sprintf ( tmp, "* Comment to a message posted in %#s\xD\xD", ttt );			PtrAndHand ( tmp, hndl, strlen (tmp) );		}		//		if (!prevent)//		{//			PtrAndHand ( prevent_d, hndl, strlen (prevent_d) );//			PtrAndHand ( q_nowto, hndl, strlen (q_nowto) );//			PtrAndHand ( ".\xd", hndl, 2 );//		}//		else//		{//			performsubstitution (&storage, prevent);//			PtrAndHand ( storage, hndl, strlen (storage) );//			DisposePtr ( storage );//		}		if (!(middle = look_for_template (((dialogInfo->common)->cMsgEdit.MessageBody)->area, commentText, commentText_def)))		{			PtrAndHand ( q_wasfrom, hndl, strlen (q_wasfrom) );			PtrAndHand ( replyText_d, hndl, strlen (replyText_d) );			PtrAndHand ( q_wasto, hndl, strlen (q_wasto) );			PtrAndHand ( ".\xd\xd", hndl, 3 );		}		else		{			performsubstitution (&storage, middle);			PtrAndHand ( storage, hndl, strlen (storage) );			DisposePtr ( storage );		}		PtrAndHand ( "\xd", hndl, 1 );		if ((dialogInfo->common)->cMsgEdit.editmode != editComment &&			(dialogInfo->common)->cMsgEdit.editmode != editCommentto)		{			if ((*(dialogInfo->common)->cMsgEdit.bodytext)->replyselected)			{				HLock ((*(dialogInfo->common)->cMsgEdit.bodytext)->storedText);				callFilter ((*(dialogInfo->common)->cMsgEdit.bodytext)->storedText);				prepareQuoting (*((*(dialogInfo->common)->cMsgEdit.bodytext)->storedText), &quoted, q_wasfrom);				HandAndHand (quoted, hndl);				DisposeHandle (quoted);				DisposeHandle ((*(dialogInfo->common)->cMsgEdit.bodytext)->storedText);				(*(dialogInfo->common)->cMsgEdit.bodytext)->storedText = NULL;				(*(dialogInfo->common)->cMsgEdit.bodytext)->replyselected = false;			}			else			{				if ((dialogInfo->common)->cMsgEdit.editmode == editCommentQ)				{					msgbase_open_idx ((dialogInfo->common)->cMsgEdit.area_number, true);				}				else				{					msgbase_open_idx ((dialogInfo->common)->cMsgEdit.o_area_number, true);				}								if ( msgbase_read_message ((dialogInfo->common)->cMsgEdit.message_number, &m, READMODE_TEXT ) )				{					HLock (m->text);					callFilter (m->text);				//	HUnlock (m->text);					prepareQuoting (*(m->text), &quoted, q_wasfrom);					HandAndHand (quoted, hndl);					DisposeHandle (quoted);					FreePktMsg (m);				}								msgbase_close (CLOSE_ONLY);			}		}				PtrAndHand ( "\xd", hndl, 1 );				whr = GetHandleSize (hndl);				if (!(middle = look_for_template (((dialogInfo->common)->cMsgEdit.MessageBody)->area, poster, poster_def)))		{			PtrAndHand ( q_nowfrom, hndl, strlen (q_nowfrom) );			PtrAndHand ( "\xd\xd", hndl, 2 );		}		else		{			performsubstitution (&storage, middle);			PtrAndHand ( storage, hndl, strlen (storage) );			DisposePtr ( storage );		}				{			pktmsg	m;						m.text = hndl;			CallPlugIns (plugMsgBodyDone, &m, 0);		}//		dealCookie (hndl);		if (CallParmPlugIns (plugMsgBodyAskTearline, (dialogInfo->common)->cMsgEdit.MessageBody, 255, &actualsize, buff, 0))		{			strcpy (tmp, "---");						if (actualsize)			{				buff[actualsize] = 0;				strcat (tmp, " ");				strcat (tmp, buff);			}			strcat (tmp, "\xD");						PtrAndHand ( tmp, hndl, strlen (tmp) );		}		else			if (tearLine)			{				strcpy (tmp, "---");								if (tearLine[0])				{					strcat (tmp, " ");					strcat (tmp, tearLine);				}				strcat (tmp, "\xD");								PtrAndHand ( tmp, hndl, strlen (tmp) );			}			else				PtrAndHand ( tearLine_d, hndl, strlen (tearLine_d) );		if ((dialogInfo->common)->cMsgEdit.area_number || netmailorigin)		{			GetCItemPopUp ((dialogInfo->common)->cMsgEdit.AkaPopUp, FullAKAs, ttt);			if (CallParmPlugIns (plugMsgBodyAskOrigin, (dialogInfo->common)->cMsgEdit.MessageBody, 255, &actualsize, buff, 0))			{				buff[actualsize] = 0;				sprintf ( tmp, originLine, buff, ttt);			}			else				sprintf ( tmp, originLine, origin[corigin], ttt);						PtrAndHand ( tmp, hndl, strlen (tmp) );		}		if (GetHandleSize (hndl) > 0x7F00)		{			if ((dialogInfo->common)->cMsgEdit.editmode == editCommentQ)				(dialogInfo->common)->cMsgEdit.editmode = editComment;			else				if ((dialogInfo->common)->cMsgEdit.editmode == editCommentQto)					(dialogInfo->common)->cMsgEdit.editmode = editCommentto;				else				{					DebugStr ("\pWhow! Something wrong!!");					(dialogInfo->common)->cMsgEdit.editmode = editComment;				}						DisposeHandle (hndl);			hndl = NewHandle (0);			goto toolargeC;		}				break;	}		if ((dialogInfo->common)->cMsgEdit.editmode != editEdit)	{		pktmsg	m;				m.text = hndl;		CallPlugIns (plugMsgBodyDoneWithTech, &m, 0);	}		HLock (hndl);	TE32KSetText (*hndl, GetHandleSize (hndl), (*(dialogInfo->common)->cMsgEdit.bodytext)->bodytext);	DisposeHandle (hndl);		TE32KSetSelect (whr, whr, (*(dialogInfo->common)->cMsgEdit.bodytext)->bodytext);//	TE32KKey (UpArrowKey, (*(dialogInfo->common)->cMsgEdit.bodytext)->bodytext);//	TE32KKey (DownArrowKey, (*(dialogInfo->common)->cMsgEdit.bodytext)->bodytext);	TE32KKey (LeftArrowKey, (*(dialogInfo->common)->cMsgEdit.bodytext)->bodytext);		(*(dialogInfo->common)->cMsgEdit.bodytext)->storedText = NULL;	(*(dialogInfo->common)->cMsgEdit.bodytext)->canundo = false;		myTEUpdate ((dialogInfo->common)->cMsgEdit.bodytext);	myTEScrollRedraw ((dialogInfo->common)->cMsgEdit.bodytext);}typedef struct _temp_file {	long	lines;	short	fref;	} temp_file, *temp_file_p;static OSErr myHQXSink (void* buffer, long count, long refcon){	temp_file_p		tfi;	OSErr			iErr;	long			i, ioCount;	char			*buff = buffer;			tfi = (temp_file_p) refcon;	for (i = 0; i < count; i++)	{		if (buff[i] == 0x0A)			buff[i] = 0x0D;			if (buff[i] == 0x0D)			tfi->lines++;	}		ioCount = count;		iErr = FSWrite (tfi->fref, &ioCount, buffer);		return iErr;}static short isPressed (unsigned short k){	unsigned char km[16];	GetKeys( (unsigned long *) km);	return ( ( km[k>>3] >> (k & 7) ) & 1);}static void SendMessage (windowsQElPtr dialogInfo, addr *toaddr){	addr			tempaddr;	char			s[128];	short			iType, err;	Handle			iHandle, hdr;	Rect			iRect;	unsigned long	secs;	msgbase_atom	Atom;	Str255			sTemp;		long			tolist, ii, wheres, blen;	Point			where = {0,0};	SFReply			reply;		char			ss[128], *q, subjstore[128];	temp_file		tfi;		short			currblock, totalblks;	short			linecounter;	FILE			*fp;	long			buffsize, actualsize;	char			buff[256];	if ((dialogInfo->common)->cMsgEdit.editmode == editPost)	{		if (isPressed (0x003A))		{#if defined(powerc) || defined(__powerc)			ii = Alert (505, uupMyAlertProc);#else			ii = Alert (505, myAlertProc);#endif		}		else			ii = 1;			if (ii == 1)		{			hqxstart = hqxstart1;			hqxstop = hqxstop1;		}		else		{			hqxstart = uuestart1;			hqxstop = uuestop1;		}			memcpy (((dialogInfo->common)->cMsgEdit.MessageBody)->fromname,				*(*(dialogInfo->common)->cMsgEdit.te.named.from)->hText,				(*(dialogInfo->common)->cMsgEdit.te.named.from)->teLength);		((dialogInfo->common)->cMsgEdit.MessageBody)->fromname[(*(dialogInfo->common)->cMsgEdit.te.named.from)->teLength] = 0;		memcpy (((dialogInfo->common)->cMsgEdit.MessageBody)->toname,				*(*(dialogInfo->common)->cMsgEdit.te.named.to)->hText,				(*(dialogInfo->common)->cMsgEdit.te.named.to)->teLength);		((dialogInfo->common)->cMsgEdit.MessageBody)->toname[(*(dialogInfo->common)->cMsgEdit.te.named.to)->teLength] = 0;		memcpy (((dialogInfo->common)->cMsgEdit.MessageBody)->date,				*(*(dialogInfo->common)->cMsgEdit.te.named.date)->hText,				(*(dialogInfo->common)->cMsgEdit.te.named.date)->teLength);		((dialogInfo->common)->cMsgEdit.MessageBody)->date[(*(dialogInfo->common)->cMsgEdit.te.named.date)->teLength] = 0;//		memcpy (((dialogInfo->common)->cMsgEdit.MessageBody)->subj,//				*(*(dialogInfo->common)->cMsgEdit.te.named.subj)->hText,//				(*(dialogInfo->common)->cMsgEdit.te.named.subj)->teLength);//		((dialogInfo->common)->cMsgEdit.MessageBody)->subj[(*(dialogInfo->common)->cMsgEdit.te.named.subj)->teLength] = 0;		memcpy (subjstore,				*(*(dialogInfo->common)->cMsgEdit.te.named.subj)->hText,				(*(dialogInfo->common)->cMsgEdit.te.named.subj)->teLength);		subjstore[(*(dialogInfo->common)->cMsgEdit.te.named.subj)->teLength] = 0;		tempaddr.zone = 0;		tempaddr.net = 0;		tempaddr.node = 0;		tempaddr.point = 0;		if ((dialogInfo->common)->cMsgEdit.area_number == 0)		{			memcpy (s,					*(*(dialogInfo->common)->cMsgEdit.te.named.toaddr)->hText,					(*(dialogInfo->common)->cMsgEdit.te.named.toaddr)->teLength);			s[(*(dialogInfo->common)->cMsgEdit.te.named.toaddr)->teLength] = 0;						parseaddr (&tempaddr, s);		}		((dialogInfo->common)->cMsgEdit.MessageBody)->to = tempaddr;				((dialogInfo->common)->cMsgEdit.MessageBody)->from =				((*(dialogInfo->common)->cMsgEdit.AkaPopUp)->theValue == 1) ?				 (*homesystem)->mainAddr.ad :				 (*homesystem)->AKAAddr[(*(dialogInfo->common)->cMsgEdit.AkaPopUp)->theValue-2].ad;//		GetDateTime (&secs);//		((dialogInfo->common)->cMsgEdit.MessageBody)->msgid = secs;//		((dialogInfo->common)->cMsgEdit.MessageBody)->msgid = GetMSGID ();		(dialogInfo->common)->cMsgEdit.MessageBody->msgid_num = 0;		msgbase_prep_msgid ((dialogInfo->common)->cMsgEdit.MessageBody);//		FLAGS processing		((dialogInfo->common)->cMsgEdit.MessageBody)->flags &= ~(MSGHOLD |			MSGDIRECT | MSGCRASH | MSGKILL | MSGRRREQ | MSGFREQ | MSGFILE | MSGKFS);				if ((dialogInfo->common)->cMsgEdit.area_number != 0)			((dialogInfo->common)->cMsgEdit.MessageBody)->flags &= ~(MSGPRIVATE);		secs = (**(dialogInfo->common)->cMsgEdit.flagsPopUp).statmenu;		if (secs & (1L << ffHold))			((dialogInfo->common)->cMsgEdit.MessageBody)->flags |= MSGHOLD;		if (secs & (1L << ffDirect))			((dialogInfo->common)->cMsgEdit.MessageBody)->flags |= MSGDIRECT;		if (secs & (1L << ffCrash))			((dialogInfo->common)->cMsgEdit.MessageBody)->flags |= MSGCRASH;		if (secs & (1L << ffKillSent))			((dialogInfo->common)->cMsgEdit.MessageBody)->flags |= MSGKILL;		if (secs & (1L << ffRRq))			((dialogInfo->common)->cMsgEdit.MessageBody)->flags |= MSGRRREQ;		if (secs & (1L << ffCfm))			((dialogInfo->common)->cMsgEdit.MessageBody)->flags |= MSGCFM;		if (secs & (1L << ffFreq))			((dialogInfo->common)->cMsgEdit.MessageBody)->flags |= MSGFREQ;		if ((dialogInfo->common)->cMsgEdit.area_number != 0)			if (secs & (1L << ffPrivate))				((dialogInfo->common)->cMsgEdit.MessageBody)->flags |= MSGPRIVATE;		if (secs & (1L << ffAttach))		{			((dialogInfo->common)->cMsgEdit.MessageBody)->flags |= MSGFILE;			if (secs & (1L << ffAttKill))				((dialogInfo->common)->cMsgEdit.MessageBody)->flags |= MSGKFS;		}		//		(dialogInfo->common)->cMsgEdit.MessageBody->text = NULL;				SFPGetFile (where, "\p", NULL, -1, NULL, NULL, &reply, 4000, NULL);		(dialogInfo->common)->cMsgEdit.firsttouch = 1;				if (reply.good)		{			Create ("\pHQXTEMP", 0, 'RvlQ', 'TEMP');			if (FSOpen ("\pHQXTEMP", 0, &tfi.fref) != noErr)			{//				(dialogInfo->common)->cMsgEdit.MessageBody->text = NULL;				FreePktMsg ((dialogInfo->common)->cMsgEdit.MessageBody);				SysBeep (10);				SysBeep (10);				return;			//본 !! 본			}						SetEOF (tfi.fref, 0L);			tfi.lines = 0;			if (ii == 1)				err = HQXEncode (reply.fName, reply.vRefNum, 0, myHQXSink, (long) &tfi);			else				err = UUEncode (reply.fName, reply.vRefNum, 0, myHQXSink, (long) &tfi);						if (err)			{				FSClose (tfi.fref);								FSDelete ("\pHQXTEMP", 0);				//				(dialogInfo->common)->cMsgEdit.MessageBody->text = NULL;				FreePktMsg ((dialogInfo->common)->cMsgEdit.MessageBody);				SysBeep (10);				SysBeep (10);				return;			//본 !! 본			}			else			{//	본		Append [0/nn]				totalblks = (tfi.lines + (hqxlines-1)) / hqxlines;				FSClose (tfi.fref);								if ((*(*(dialogInfo->common)->cMsgEdit.bodytext)->bodytext)->teLength)	//	non-null message body				{					sprintf (ss, "[0/%d] ", totalblks);					strcat (ss, subjstore);					ss[MSubject - 1] = 0;										strcpy (((dialogInfo->common)->cMsgEdit.MessageBody)->subj, ss);										if ((*(*(*(dialogInfo->common)->cMsgEdit.bodytext)->bodytext)->hText)							[(*(*(dialogInfo->common)->cMsgEdit.bodytext)->bodytext)->teLength-1] == 0x0D)					{						((dialogInfo->common)->cMsgEdit.MessageBody)->text =							NewHandle ((*(*(dialogInfo->common)->cMsgEdit.bodytext)->bodytext)->teLength+1);						(*((dialogInfo->common)->cMsgEdit.MessageBody)->text)							[(*(*(dialogInfo->common)->cMsgEdit.bodytext)->bodytext)->teLength] = 0x00;					}					else					{						((dialogInfo->common)->cMsgEdit.MessageBody)->text =							NewHandle ((*(*(dialogInfo->common)->cMsgEdit.bodytext)->bodytext)->teLength+2);						(*((dialogInfo->common)->cMsgEdit.MessageBody)->text)							[(*(*(dialogInfo->common)->cMsgEdit.bodytext)->bodytext)->teLength] = 0x0D;						(*((dialogInfo->common)->cMsgEdit.MessageBody)->text)							[(*(*(dialogInfo->common)->cMsgEdit.bodytext)->bodytext)->teLength+1] = 0x00;					}					BlockMove (	*(*(*(dialogInfo->common)->cMsgEdit.bodytext)->bodytext)->hText,								*((dialogInfo->common)->cMsgEdit.MessageBody)->text,								(*(*(dialogInfo->common)->cMsgEdit.bodytext)->bodytext)->teLength);//					if ((dialogInfo->common)->cMsgEdit.area_number == AreasNumber+1)//						OpenBase ( BADAREA, true );//					else//						OpenBase ((dialogInfo->common)->cMsgEdit.area_number, true);					msgbase_open_idx ((dialogInfo->common)->cMsgEdit.area_number, true);										AppendMark ((dialogInfo->common)->cMsgEdit.area_number);					msgbase_append_message ((dialogInfo->common)->cMsgEdit.MessageBody, true);					msgbase_close (CLOSE_UPDATE);										Broadcast (wtMsgView, broadAppendCell,							(dialogInfo->common)->cMsgEdit.area_number, 0);					Broadcast (wtSubjects, broadAppendCell,							(dialogInfo->common)->cMsgEdit.area_number, 0);					Broadcast (wtAreasList, broadRedrawCell,						(dialogInfo->common)->cMsgEdit.area_number, 0);					DisposeHandle (((dialogInfo->common)->cMsgEdit.MessageBody)->text);				}				if ((fp = fopen ("HQXTEMP", "r")) == NULL)				{					(dialogInfo->common)->cMsgEdit.MessageBody->text = NULL;					FreePktMsg ((dialogInfo->common)->cMsgEdit.MessageBody);					SysBeep (10);					SysBeep (10);					return;			//본 !! 본				}				linecounter = 0;				currblock = 1;				while (fgets (ss, 79, fp) != NULL)				{					if (!linecounter)					{						(dialogInfo->common)->cMsgEdit.MessageBody->text = NewHandle (0);						sprintf (s, hqxstart, currblock, totalblks);						PtrAndHand (s, (dialogInfo->common)->cMsgEdit.MessageBody->text, strlen (s));					}										linecounter++;										blen = strlen (ss);					for (ii = 0; ii < blen; ii++)					{						if (ss[ii] == 0x0A)							ss[ii] = 0x0D;					}										PtrAndHand (ss, (dialogInfo->common)->cMsgEdit.MessageBody->text, blen);										if (linecounter == (hqxlines-1))					{						sprintf (s, hqxstop, currblock, totalblks);						PtrAndHand (s, (dialogInfo->common)->cMsgEdit.MessageBody->text, strlen (s));						PtrAndHand ( tearLine_d, (dialogInfo->common)->cMsgEdit.MessageBody->text, strlen (tearLine_d) );						if ((dialogInfo->common)->cMsgEdit.area_number || netmailorigin)						{							GetCItemPopUp ((dialogInfo->common)->cMsgEdit.AkaPopUp, FullAKAs, (StringPtr) ss);							if (CallParmPlugIns (plugMsgBodyAskOrigin, (dialogInfo->common)->cMsgEdit.MessageBody, 255, &actualsize, buff, 0))							{								buff[actualsize] = 0;								sprintf ( s, originLine, buff, ss);							}							else								sprintf ( s, originLine, origin[corigin], ss);														PtrAndHand ( s, (dialogInfo->common)->cMsgEdit.MessageBody->text, strlen (s) );						}						PtrAndHand ( "", (dialogInfo->common)->cMsgEdit.MessageBody->text, 1 );												sprintf (ss, "[%d/%d] ", currblock, totalblks);						strcat (ss, subjstore);						ss[MSubject - 1] = 0;						//						((dialogInfo->common)->cMsgEdit.MessageBody)->msgid = GetMSGID ();												(dialogInfo->common)->cMsgEdit.MessageBody->msgid_num = 0;						msgbase_prep_msgid ((dialogInfo->common)->cMsgEdit.MessageBody);												strcpy (((dialogInfo->common)->cMsgEdit.MessageBody)->subj, ss);						//						if ((dialogInfo->common)->cMsgEdit.area_number == AreasNumber+1)//							OpenBase ( BADAREA, true );//						else//							OpenBase ((dialogInfo->common)->cMsgEdit.area_number, true);						msgbase_open_idx ((dialogInfo->common)->cMsgEdit.area_number, true);											AppendMark ((dialogInfo->common)->cMsgEdit.area_number);						msgbase_append_message ((dialogInfo->common)->cMsgEdit.MessageBody, true);												msgbase_close (CLOSE_UPDATE);												Broadcast (wtMsgView, broadAppendCell,								(dialogInfo->common)->cMsgEdit.area_number, 0);						Broadcast (wtSubjects, broadAppendCell,								(dialogInfo->common)->cMsgEdit.area_number, 0);						Broadcast (wtAreasList, broadRedrawCell,							(dialogInfo->common)->cMsgEdit.area_number, 0);						DisposeHandle ((dialogInfo->common)->cMsgEdit.MessageBody->text);						linecounter = 0;						currblock++;					}				}								if (linecounter)				{					sprintf (s, hqxstop, currblock, totalblks);					PtrAndHand (s, (dialogInfo->common)->cMsgEdit.MessageBody->text, strlen (s));					PtrAndHand ( tearLine_d, (dialogInfo->common)->cMsgEdit.MessageBody->text, strlen (tearLine_d) );					if ((dialogInfo->common)->cMsgEdit.area_number || netmailorigin)					{						GetCItemPopUp ((dialogInfo->common)->cMsgEdit.AkaPopUp, FullAKAs, (StringPtr) ss);						if (CallParmPlugIns (plugMsgBodyAskOrigin, (dialogInfo->common)->cMsgEdit.MessageBody, 255, &actualsize, buff, 0))						{							buff[actualsize] = 0;							sprintf ( s, originLine, buff, ss);						}						else							sprintf ( s, originLine, origin[corigin], ss);												PtrAndHand ( s, (dialogInfo->common)->cMsgEdit.MessageBody->text, strlen (s) );					}					PtrAndHand ( "", (dialogInfo->common)->cMsgEdit.MessageBody->text, 1 );								sprintf (ss, "[%d/%d] ", currblock, totalblks);					strcat (ss, subjstore);					ss[MSubject - 1] = 0;					//					((dialogInfo->common)->cMsgEdit.MessageBody)->msgid = GetMSGID ();					(dialogInfo->common)->cMsgEdit.MessageBody->msgid_num = 0;					msgbase_prep_msgid ((dialogInfo->common)->cMsgEdit.MessageBody);					strcpy (((dialogInfo->common)->cMsgEdit.MessageBody)->subj, ss);					//					if ((dialogInfo->common)->cMsgEdit.area_number == AreasNumber+1)//						OpenBase ( BADAREA, true );//					else//						OpenBase ((dialogInfo->common)->cMsgEdit.area_number, true);					msgbase_open_idx ((dialogInfo->common)->cMsgEdit.area_number, true);					AppendMark ((dialogInfo->common)->cMsgEdit.area_number);					msgbase_append_message ((dialogInfo->common)->cMsgEdit.MessageBody, true);										msgbase_close (CLOSE_UPDATE);										Broadcast (wtMsgView, broadAppendCell,							(dialogInfo->common)->cMsgEdit.area_number, 0);					Broadcast (wtSubjects, broadAppendCell,							(dialogInfo->common)->cMsgEdit.area_number, 0);					Broadcast (wtAreasList, broadRedrawCell,						(dialogInfo->common)->cMsgEdit.area_number, 0);					DisposeHandle ((dialogInfo->common)->cMsgEdit.MessageBody->text);				}								fclose (fp);				FSDelete ("\pHQXTEMP", 0);			}		}		(dialogInfo->common)->cMsgEdit.MessageBody->text = NULL;		FreePktMsg ((dialogInfo->common)->cMsgEdit.MessageBody);	}	else	if (!toaddr)	{		memcpy (((dialogInfo->common)->cMsgEdit.MessageBody)->fromname,				*(*(dialogInfo->common)->cMsgEdit.te.named.from)->hText,				(*(dialogInfo->common)->cMsgEdit.te.named.from)->teLength);		((dialogInfo->common)->cMsgEdit.MessageBody)->fromname[(*(dialogInfo->common)->cMsgEdit.te.named.from)->teLength] = 0;		memcpy (((dialogInfo->common)->cMsgEdit.MessageBody)->toname,				*(*(dialogInfo->common)->cMsgEdit.te.named.to)->hText,				(*(dialogInfo->common)->cMsgEdit.te.named.to)->teLength);		((dialogInfo->common)->cMsgEdit.MessageBody)->toname[(*(dialogInfo->common)->cMsgEdit.te.named.to)->teLength] = 0;		memcpy (((dialogInfo->common)->cMsgEdit.MessageBody)->date,				*(*(dialogInfo->common)->cMsgEdit.te.named.date)->hText,				(*(dialogInfo->common)->cMsgEdit.te.named.date)->teLength);		((dialogInfo->common)->cMsgEdit.MessageBody)->date[(*(dialogInfo->common)->cMsgEdit.te.named.date)->teLength] = 0;		memcpy (((dialogInfo->common)->cMsgEdit.MessageBody)->subj,				*(*(dialogInfo->common)->cMsgEdit.te.named.subj)->hText,				(*(dialogInfo->common)->cMsgEdit.te.named.subj)->teLength);		((dialogInfo->common)->cMsgEdit.MessageBody)->subj[(*(dialogInfo->common)->cMsgEdit.te.named.subj)->teLength] = 0;		tempaddr.zone = 0;		tempaddr.net = 0;		tempaddr.node = 0;		tempaddr.point = 0;		if ((dialogInfo->common)->cMsgEdit.area_number == 0)		{			memcpy (s,					*(*(dialogInfo->common)->cMsgEdit.te.named.toaddr)->hText,					(*(dialogInfo->common)->cMsgEdit.te.named.toaddr)->teLength);			s[(*(dialogInfo->common)->cMsgEdit.te.named.toaddr)->teLength] = 0;						parseaddr (&tempaddr, s);		}		((dialogInfo->common)->cMsgEdit.MessageBody)->to = tempaddr;				((dialogInfo->common)->cMsgEdit.MessageBody)->from =				((*(dialogInfo->common)->cMsgEdit.AkaPopUp)->theValue == 1) ?				 (*homesystem)->mainAddr.ad :				 (*homesystem)->AKAAddr[(*(dialogInfo->common)->cMsgEdit.AkaPopUp)->theValue-2].ad;//		GetDateTime (&secs);//		((dialogInfo->common)->cMsgEdit.MessageBody)->msgid = secs;//		((dialogInfo->common)->cMsgEdit.MessageBody)->msgid = GetMSGID ();		(dialogInfo->common)->cMsgEdit.MessageBody->msgid_num = 0;		msgbase_prep_msgid ((dialogInfo->common)->cMsgEdit.MessageBody);//		FLAGS processing		((dialogInfo->common)->cMsgEdit.MessageBody)->flags &= ~(MSGHOLD |			MSGDIRECT | MSGCRASH | MSGKILL | MSGRRREQ | MSGFREQ | MSGFILE | MSGKFS);				if ((dialogInfo->common)->cMsgEdit.area_number != 0)			((dialogInfo->common)->cMsgEdit.MessageBody)->flags &= ~(MSGPRIVATE);				secs = (**(dialogInfo->common)->cMsgEdit.flagsPopUp).statmenu;		if (secs & (1L << ffHold))			((dialogInfo->common)->cMsgEdit.MessageBody)->flags |= MSGHOLD;		if (secs & (1L << ffDirect))			((dialogInfo->common)->cMsgEdit.MessageBody)->flags |= MSGDIRECT;		if (secs & (1L << ffCrash))			((dialogInfo->common)->cMsgEdit.MessageBody)->flags |= MSGCRASH;		if (secs & (1L << ffKillSent))			((dialogInfo->common)->cMsgEdit.MessageBody)->flags |= MSGKILL;		if (secs & (1L << ffRRq))			((dialogInfo->common)->cMsgEdit.MessageBody)->flags |= MSGRRREQ;		if (secs & (1L << ffCfm))			((dialogInfo->common)->cMsgEdit.MessageBody)->flags |= MSGCFM;		if (secs & (1L << ffFreq))			((dialogInfo->common)->cMsgEdit.MessageBody)->flags |= MSGFREQ;		if (secs & (1L << ffAttach))		{			((dialogInfo->common)->cMsgEdit.MessageBody)->flags |= MSGFILE;			if (secs & (1L << ffAttKill))				((dialogInfo->common)->cMsgEdit.MessageBody)->flags |= MSGKFS;		}				if ((dialogInfo->common)->cMsgEdit.area_number != 0)			if (secs & (1L << ffPrivate))				((dialogInfo->common)->cMsgEdit.MessageBody)->flags |= MSGPRIVATE;		if ((*(*(dialogInfo->common)->cMsgEdit.bodytext)->bodytext)->teLength)	//	non-null message body		{			if ((*(*(*(dialogInfo->common)->cMsgEdit.bodytext)->bodytext)->hText)					[(*(*(dialogInfo->common)->cMsgEdit.bodytext)->bodytext)->teLength-1] == 0x0D)			{				((dialogInfo->common)->cMsgEdit.MessageBody)->text =					NewHandle ((*(*(dialogInfo->common)->cMsgEdit.bodytext)->bodytext)->teLength+1);				(*((dialogInfo->common)->cMsgEdit.MessageBody)->text)					[(*(*(dialogInfo->common)->cMsgEdit.bodytext)->bodytext)->teLength] = 0x00;			}			else			{				((dialogInfo->common)->cMsgEdit.MessageBody)->text =					NewHandle ((*(*(dialogInfo->common)->cMsgEdit.bodytext)->bodytext)->teLength+2);				(*((dialogInfo->common)->cMsgEdit.MessageBody)->text)					[(*(*(dialogInfo->common)->cMsgEdit.bodytext)->bodytext)->teLength] = 0x0D;				(*((dialogInfo->common)->cMsgEdit.MessageBody)->text)					[(*(*(dialogInfo->common)->cMsgEdit.bodytext)->bodytext)->teLength+1] = 0x00;			}			BlockMove (	*(*(*(dialogInfo->common)->cMsgEdit.bodytext)->bodytext)->hText,						*((dialogInfo->common)->cMsgEdit.MessageBody)->text,						(*(*(dialogInfo->common)->cMsgEdit.bodytext)->bodytext)->teLength);		}		else		//	null message body		{			((dialogInfo->common)->cMsgEdit.MessageBody)->text = NewHandle (1);			**((dialogInfo->common)->cMsgEdit.MessageBody)->text = 0x00;		}	//		if ((dialogInfo->common)->cMsgEdit.area_number == AreasNumber+1)//			OpenBase ( BADAREA, true );//		else//			OpenBase ((dialogInfo->common)->cMsgEdit.area_number, true);		msgbase_open_idx ((dialogInfo->common)->cMsgEdit.area_number, true);				AppendMark ((dialogInfo->common)->cMsgEdit.area_number);		msgbase_append_message ((dialogInfo->common)->cMsgEdit.MessageBody, true);			msgbase_close (CLOSE_UPDATE);				Broadcast (wtMsgView, broadAppendCell,				(dialogInfo->common)->cMsgEdit.area_number, 0);		Broadcast (wtSubjects, broadAppendCell,				(dialogInfo->common)->cMsgEdit.area_number, 0);		Broadcast (wtAreasList, broadRedrawCell,			(dialogInfo->common)->cMsgEdit.area_number, 0);		if ((dialogInfo->common)->cMsgEdit.editmode == editEdit &&			(dialogInfo->common)->cMsgEdit.editunsent)		{			// kill edited message here		//			if ((dialogInfo->common)->cMsgEdit.area_number == AreasNumber+1)//				OpenBase ( BADAREA, true );//			else//				OpenBase ((dialogInfo->common)->cMsgEdit.area_number, true);			msgbase_open_idx ((dialogInfo->common)->cMsgEdit.area_number, true);						DeleteMark ((dialogInfo->common)->cMsgEdit.area_number,						(dialogInfo->common)->cMsgEdit.message_number);			msgbase_delete_message ((dialogInfo->common)->cMsgEdit.message_number, ATOM_HARDDELETED);			msgbase_close (CLOSE_UPDATE);			Broadcast (wtMsgView, broadDeleteCell,					(dialogInfo->common)->cMsgEdit.area_number,					(dialogInfo->common)->cMsgEdit.message_number);			Broadcast (wtSubjects, broadDeleteCell,					(dialogInfo->common)->cMsgEdit.area_number,					(dialogInfo->common)->cMsgEdit.message_number);			Broadcast (wtAreasList, broadRedrawCell,				(dialogInfo->common)->cMsgEdit.area_number, 0);/*			if (msgbase_read_atom ((dialogInfo->common)->cMsgEdit.message_number, &Atom))			{				Atom.base_flags = ATOM_HARDDELETED;				msgbase_write_atom ((dialogInfo->common)->cMsgEdit.message_number, &Atom);							DeleteMark ((dialogInfo->common)->cMsgEdit.area_number,							(dialogInfo->common)->cMsgEdit.message_number);								msgbase_setnummsg (msgbase_getnummsg () - 1);								msgbase_close (CLOSE_UPDATE);				Broadcast (wtMsgView, broadDeleteCell,						(dialogInfo->common)->cMsgEdit.area_number,						(dialogInfo->common)->cMsgEdit.message_number);				Broadcast (wtSubjects, broadDeleteCell,						(dialogInfo->common)->cMsgEdit.area_number,						(dialogInfo->common)->cMsgEdit.message_number);				Broadcast (wtAreasList, broadRedrawCell,					(dialogInfo->common)->cMsgEdit.area_number, 0);			}			else				msgbase_close (CLOSE_ONLY);*/		}	}	else	{		if ((dialogInfo->common)->cMsgEdit.area_number)		{			memcpy (((dialogInfo->common)->cMsgEdit.MessageBody)->fromname,					*(*(dialogInfo->common)->cMsgEdit.te.named.from)->hText,					(*(dialogInfo->common)->cMsgEdit.te.named.from)->teLength);			((dialogInfo->common)->cMsgEdit.MessageBody)->fromname[(*(dialogInfo->common)->cMsgEdit.te.named.from)->teLength] = 0;			memcpy (((dialogInfo->common)->cMsgEdit.MessageBody)->toname,					*(*(dialogInfo->common)->cMsgEdit.te.named.to)->hText,					(*(dialogInfo->common)->cMsgEdit.te.named.to)->teLength);			((dialogInfo->common)->cMsgEdit.MessageBody)->toname[(*(dialogInfo->common)->cMsgEdit.te.named.to)->teLength] = 0;			memcpy (((dialogInfo->common)->cMsgEdit.MessageBody)->date,					*(*(dialogInfo->common)->cMsgEdit.te.named.date)->hText,					(*(dialogInfo->common)->cMsgEdit.te.named.date)->teLength);			((dialogInfo->common)->cMsgEdit.MessageBody)->date[(*(dialogInfo->common)->cMsgEdit.te.named.date)->teLength] = 0;			memcpy (((dialogInfo->common)->cMsgEdit.MessageBody)->subj,					*(*(dialogInfo->common)->cMsgEdit.te.named.subj)->hText,					(*(dialogInfo->common)->cMsgEdit.te.named.subj)->teLength);			((dialogInfo->common)->cMsgEdit.MessageBody)->subj[(*(dialogInfo->common)->cMsgEdit.te.named.subj)->teLength] = 0;			tempaddr.zone = 0;			tempaddr.net = 0;			tempaddr.node = 0;			tempaddr.point = 0;			((dialogInfo->common)->cMsgEdit.MessageBody)->to = tempaddr;						hdr = NewHandle (0);						for (ii = 1; ii <= AreasNumber; ii++)			{				if (!(*((Handle) toaddr))[ii-1])					continue;				pStrConc ( "\p* Message crossposted in ", (*areasHndls[ii-1])->areaName, sTemp );				pStrConc ( sTemp, "\p\xD", sTemp );				PtrAndHand ( &sTemp[1], hdr, sTemp[0] );			}						PtrAndHand ("\xD", hdr, 1);						((dialogInfo->common)->cMsgEdit.MessageBody)->text = hdr;			HandToHand (&((dialogInfo->common)->cMsgEdit.MessageBody)->text);						if ((*(*(dialogInfo->common)->cMsgEdit.bodytext)->bodytext)->teLength)	//	non-null message body			{				HLock ((*(*(dialogInfo->common)->cMsgEdit.bodytext)->bodytext)->hText);								PtrAndHand (*(*(*(dialogInfo->common)->cMsgEdit.bodytext)->bodytext)->hText,					((dialogInfo->common)->cMsgEdit.MessageBody)->text,						(*(*(dialogInfo->common)->cMsgEdit.bodytext)->bodytext)->teLength);				HUnlock ((*(*(dialogInfo->common)->cMsgEdit.bodytext)->bodytext)->hText);				if ((*(*(*(dialogInfo->common)->cMsgEdit.bodytext)->bodytext)->hText)						[(*(*(dialogInfo->common)->cMsgEdit.bodytext)->bodytext)->teLength-1] == 0x0D)				{					PtrAndHand ("\x0", ((dialogInfo->common)->cMsgEdit.MessageBody)->text, 1);				}				else				{					PtrAndHand ("\xD\x0", ((dialogInfo->common)->cMsgEdit.MessageBody)->text, 2);				}			}			//		GetDateTime (&secs);	//		((dialogInfo->common)->cMsgEdit.MessageBody)->msgid = secs;			for (ii = 1; ii <= AreasNumber; ii++)			{				if (!(*((Handle) toaddr))[ii-1])					continue;								tolist = ii;				//				((dialogInfo->common)->cMsgEdit.MessageBody)->msgid = GetMSGID ();				(dialogInfo->common)->cMsgEdit.MessageBody->msgid_num = 0;				msgbase_prep_msgid ((dialogInfo->common)->cMsgEdit.MessageBody);				((dialogInfo->common)->cMsgEdit.MessageBody)->from =					((*areasHndls[tolist-1])->useAKA) ?						(*homesystem)->AKAAddr[(*areasHndls[tolist-1])->useAKA-1].ad : (*homesystem)->mainAddr.ad;//				if (tolist == AreasNumber+1)//					OpenBase ( BADAREA, true );//				else//					OpenBase (tolist, true);				msgbase_open_idx (tolist, true);								AppendMark (tolist);				msgbase_append_message ((dialogInfo->common)->cMsgEdit.MessageBody, true);							msgbase_close (CLOSE_UPDATE);								Broadcast (wtMsgView, broadAppendCell, tolist, 0);				Broadcast (wtSubjects, broadAppendCell, tolist, 0);				Broadcast (wtAreasList, broadRedrawCell, tolist, 0);			}					DisposeHandle (hdr);		}		else		{			tolist = GetHandleSize ((Handle) toaddr) / sizeof (oneRec);					memcpy (((dialogInfo->common)->cMsgEdit.MessageBody)->fromname,					*(*(dialogInfo->common)->cMsgEdit.te.named.from)->hText,					(*(dialogInfo->common)->cMsgEdit.te.named.from)->teLength);			((dialogInfo->common)->cMsgEdit.MessageBody)->fromname[(*(dialogInfo->common)->cMsgEdit.te.named.from)->teLength] = 0;/*			memcpy (((dialogInfo->common)->cMsgEdit.MessageBody)->toname,					*(*(dialogInfo->common)->cMsgEdit.te.named.to)->hText,					(*(dialogInfo->common)->cMsgEdit.te.named.to)->teLength);			((dialogInfo->common)->cMsgEdit.MessageBody)->toname[(*(dialogInfo->common)->cMsgEdit.te.named.to)->teLength] = 0;*/			memcpy (((dialogInfo->common)->cMsgEdit.MessageBody)->date,					*(*(dialogInfo->common)->cMsgEdit.te.named.date)->hText,					(*(dialogInfo->common)->cMsgEdit.te.named.date)->teLength);			((dialogInfo->common)->cMsgEdit.MessageBody)->date[(*(dialogInfo->common)->cMsgEdit.te.named.date)->teLength] = 0;			memcpy (((dialogInfo->common)->cMsgEdit.MessageBody)->subj,					*(*(dialogInfo->common)->cMsgEdit.te.named.subj)->hText,					(*(dialogInfo->common)->cMsgEdit.te.named.subj)->teLength);			((dialogInfo->common)->cMsgEdit.MessageBody)->subj[(*(dialogInfo->common)->cMsgEdit.te.named.subj)->teLength] = 0;/*			tempaddr.zone = 0;			tempaddr.net = 0;			tempaddr.node = 0;			tempaddr.point = 0;			memcpy (s,					*(*(dialogInfo->common)->cMsgEdit.te.named.toaddr)->hText,					(*(dialogInfo->common)->cMsgEdit.te.named.toaddr)->teLength);			s[(*(dialogInfo->common)->cMsgEdit.te.named.toaddr)->teLength] = 0;						parseaddr (&tempaddr, s);			((dialogInfo->common)->cMsgEdit.MessageBody)->to = tempaddr;*/			((dialogInfo->common)->cMsgEdit.MessageBody)->from =					((*(dialogInfo->common)->cMsgEdit.AkaPopUp)->theValue == 1) ?					 (*homesystem)->mainAddr.ad :					 (*homesystem)->AKAAddr[(*(dialogInfo->common)->cMsgEdit.AkaPopUp)->theValue-2].ad;	//		GetDateTime (&secs);	//		((dialogInfo->common)->cMsgEdit.MessageBody)->msgid = secs;//			((dialogInfo->common)->cMsgEdit.MessageBody)->msgid = GetMSGID ();			(dialogInfo->common)->cMsgEdit.MessageBody->msgid_num = 0;			msgbase_prep_msgid ((dialogInfo->common)->cMsgEdit.MessageBody);	//		FLAGS processing			((dialogInfo->common)->cMsgEdit.MessageBody)->flags &= ~(MSGHOLD |				MSGDIRECT | MSGCRASH | MSGKILL | MSGRRREQ | MSGFREQ | MSGFILE | MSGKFS);						secs = (**(dialogInfo->common)->cMsgEdit.flagsPopUp).statmenu;			if (secs & (1L << ffHold))				((dialogInfo->common)->cMsgEdit.MessageBody)->flags |= MSGHOLD;			if (secs & (1L << ffDirect))				((dialogInfo->common)->cMsgEdit.MessageBody)->flags |= MSGDIRECT;			if (secs & (1L << ffCrash))				((dialogInfo->common)->cMsgEdit.MessageBody)->flags |= MSGCRASH;			if (secs & (1L << ffKillSent))				((dialogInfo->common)->cMsgEdit.MessageBody)->flags |= MSGKILL;			if (secs & (1L << ffRRq))				((dialogInfo->common)->cMsgEdit.MessageBody)->flags |= MSGRRREQ;			if (secs & (1L << ffCfm))				((dialogInfo->common)->cMsgEdit.MessageBody)->flags |= MSGCFM;			if (secs & (1L << ffFreq))				((dialogInfo->common)->cMsgEdit.MessageBody)->flags |= MSGFREQ;			if (secs & (1L << ffAttach))			{				((dialogInfo->common)->cMsgEdit.MessageBody)->flags |= MSGFILE;				if (secs & (1L << ffAttKill))					((dialogInfo->common)->cMsgEdit.MessageBody)->flags |= MSGKFS;			}						((dialogInfo->common)->cMsgEdit.MessageBody)->text = NewHandle (0);						strcpy (ss, "CC: ");			blen = 0;			for (ii = 0; ii < tolist; ii++)			{				char	stemp[128];							sprintf (subjstore, "%#s (%s), ", (*((oneRecPtr *) toaddr))[ii].name, printaddr(&(*((oneRecPtr *) toaddr))[ii].address, stemp));								if ((strlen (ss) + strlen (subjstore) - 2) > 79)				{					if (blen == 0)						strcat (ss, subjstore);					ss[strlen(ss)-2] = 0;					strcat (ss, "\xD");					PtrAndHand (ss, ((dialogInfo->common)->cMsgEdit.MessageBody)->text, strlen (ss));					strcpy (ss, "CC: ");					strcat (ss, subjstore);					blen = 0;				}				else				{					strcat (ss, subjstore);					blen++;				}			}						if (blen)			{				ss[strlen(ss)-2] = 0;				strcat (ss, "\xD");				PtrAndHand (ss, ((dialogInfo->common)->cMsgEdit.MessageBody)->text, strlen (ss));			}			PtrAndHand ("\xD", ((dialogInfo->common)->cMsgEdit.MessageBody)->text, 1);			if ((*(*(dialogInfo->common)->cMsgEdit.bodytext)->bodytext)->teLength)	//	non-null message body			{				PtrAndHand (*(*(*(dialogInfo->common)->cMsgEdit.bodytext)->bodytext)->hText,							((dialogInfo->common)->cMsgEdit.MessageBody)->text,							(*(*(dialogInfo->common)->cMsgEdit.bodytext)->bodytext)->teLength);				if ((*(*(*(dialogInfo->common)->cMsgEdit.bodytext)->bodytext)->hText)						[(*(*(dialogInfo->common)->cMsgEdit.bodytext)->bodytext)->teLength-1] == 0x0D)				{					PtrAndHand ("\x0", ((dialogInfo->common)->cMsgEdit.MessageBody)->text, 1);				}				else				{					PtrAndHand ("\xD\x0", ((dialogInfo->common)->cMsgEdit.MessageBody)->text, 2);				}			}/*			if ((*(*(dialogInfo->common)->cMsgEdit.bodytext)->bodytext)->teLength)	//	non-null message body			{				if ((*(*(*(dialogInfo->common)->cMsgEdit.bodytext)->bodytext)->hText)						[(*(*(dialogInfo->common)->cMsgEdit.bodytext)->bodytext)->teLength-1] == 0x0D)				{					((dialogInfo->common)->cMsgEdit.MessageBody)->text =						NewHandle ((*(*(dialogInfo->common)->cMsgEdit.bodytext)->bodytext)->teLength+1);					(*((dialogInfo->common)->cMsgEdit.MessageBody)->text)						[(*(*(dialogInfo->common)->cMsgEdit.bodytext)->bodytext)->teLength] = 0x00;				}				else				{					((dialogInfo->common)->cMsgEdit.MessageBody)->text =						NewHandle ((*(*(dialogInfo->common)->cMsgEdit.bodytext)->bodytext)->teLength+2);					(*((dialogInfo->common)->cMsgEdit.MessageBody)->text)						[(*(*(dialogInfo->common)->cMsgEdit.bodytext)->bodytext)->teLength] = 0x0D;					(*((dialogInfo->common)->cMsgEdit.MessageBody)->text)						[(*(*(dialogInfo->common)->cMsgEdit.bodytext)->bodytext)->teLength+1] = 0x00;				}				BlockMove (	*(*(*(dialogInfo->common)->cMsgEdit.bodytext)->bodytext)->hText,							*((dialogInfo->common)->cMsgEdit.MessageBody)->text,							(*(*(dialogInfo->common)->cMsgEdit.bodytext)->bodytext)->teLength);			}			else		//	null message body			{				((dialogInfo->common)->cMsgEdit.MessageBody)->text = NewHandle (1);				**((dialogInfo->common)->cMsgEdit.MessageBody)->text = 0x00;			}		//			((dialogInfo->common)->cMsgEdit.MessageBody)->msgid = GetMSGID ();*/			(dialogInfo->common)->cMsgEdit.MessageBody->msgid_num = 0;			msgbase_prep_msgid ((dialogInfo->common)->cMsgEdit.MessageBody);						for (ii = 0; ii < tolist; ii++)			{				((dialogInfo->common)->cMsgEdit.MessageBody)->to = (*((oneRecPtr *) toaddr))[ii].address;				memcpy (((dialogInfo->common)->cMsgEdit.MessageBody)->toname,						&(*((oneRecPtr *) toaddr))[ii].name[1], (*((oneRecPtr *) toaddr))[ii].name[0]);				((dialogInfo->common)->cMsgEdit.MessageBody)->toname[(*((oneRecPtr *) toaddr))[ii].name[0]] = 0;//				OpenBase (0, true);				msgbase_open (NETMAIL, true);				AppendMark (0);				msgbase_append_message ((dialogInfo->common)->cMsgEdit.MessageBody, true);				msgbase_close (CLOSE_UPDATE);				Broadcast (wtMsgView, broadAppendCell, 0, 0);				Broadcast (wtSubjects, broadAppendCell, 0, 0);				Broadcast (wtAreasList, broadRedrawCell, 0, 0);//				((dialogInfo->common)->cMsgEdit.MessageBody)->msgid = GetMSGID ();				(dialogInfo->common)->cMsgEdit.MessageBody->msgid_num = 0;				msgbase_prep_msgid ((dialogInfo->common)->cMsgEdit.MessageBody);			}		}	}}static Boolean checkPossibility (windowsQElPtr dialogInfo){	addr			tempaddr;	char			s[128];		if (!(*(dialogInfo->common)->cMsgEdit.te.named.from)->teLength ||		(*(dialogInfo->common)->cMsgEdit.te.named.from)->teLength > MName-1)		return false;		if (!(*(dialogInfo->common)->cMsgEdit.te.named.to)->teLength ||		(*(dialogInfo->common)->cMsgEdit.te.named.to)->teLength > MName-1)		return false;		if ((*(dialogInfo->common)->cMsgEdit.te.named.subj)->teLength > MSubject-1)		return false;		if (!(dialogInfo->common)->cMsgEdit.area_number)	{		if (!(*(dialogInfo->common)->cMsgEdit.te.named.toaddr)->teLength)			return false;				tempaddr.zone = -1;		tempaddr.net = -1;		tempaddr.node = -1;		tempaddr.point = 0;		memcpy (s,				*(*(dialogInfo->common)->cMsgEdit.te.named.toaddr)->hText,				(*(dialogInfo->common)->cMsgEdit.te.named.toaddr)->teLength);		s[(*(dialogInfo->common)->cMsgEdit.te.named.toaddr)->teLength] = 0;				parseaddr (&tempaddr, s);				if (tempaddr.zone == -1 ||			tempaddr.net == -1 ||			tempaddr.node == -1)			return false;	}	memcpy (s,			*(*(dialogInfo->common)->cMsgEdit.te.named.from)->hText,			(*(dialogInfo->common)->cMsgEdit.te.named.from)->teLength);	s[(*(dialogInfo->common)->cMsgEdit.te.named.from)->teLength] = 0;	strcpy (q_nowfrom, s);	memcpy (s,			*(*(dialogInfo->common)->cMsgEdit.te.named.to)->hText,			(*(dialogInfo->common)->cMsgEdit.te.named.to)->teLength);	s[(*(dialogInfo->common)->cMsgEdit.te.named.to)->teLength] = 0;	strcpy (q_nowto, s);	return true;}#define	MDate			20#define	MName			36#define	MSubject		72static void AdjustFields (DialogPtr dialog, myTE32KHandle bodytext){	FontInfo	fInfo;	short		iType, wSpace;	Handle		iHandle;	Rect		rView;		short		hStep, nextHPos, nextVPos;	TextFont (viewFont);	TextSize (viewSize);	GetFontInfo (&fInfo);	wSpace = CharWidth (' ');	hStep = fInfo.ascent + fInfo.descent + 5;	GetDialogItem ( dialog, miFrom, &iType, &iHandle, &rView );	nextVPos = rView.top;	nextHPos = rView.left;	SetRect (&rView, nextHPos, nextVPos, nextHPos + /*fInfo.widMax*/ wSpace * MName, nextVPos + hStep - 5);	SetDialogItem ( dialog, miFrom, iType, iHandle, &rView );	nextHPos = rView.right + 5;	GetDialogItem ( dialog, 10, &iType, &iHandle, &rView );	SetRect (&rView, rView.left, nextVPos+fInfo.descent, rView.right, nextVPos+fInfo.descent+(rView.bottom-rView.top));	SetDialogItem ( dialog, 10, iType, iHandle, &rView );	GetDialogItem ( dialog, miAka, &iType, &iHandle, &rView );	SetRect (&rView, nextHPos, nextVPos, nextHPos + /*fInfo.widMax*/ wSpace * MAddr, nextVPos + hStep - 5);	InsetRect (&rView, 0, -2);	SetDialogItem ( dialog, miAka, iType, iHandle, &rView );	nextHPos = rView.right + 5;	GetDialogItem ( dialog, miDate, &iType, &iHandle, &rView );	SetRect (&rView, nextHPos, nextVPos, nextHPos + /*fInfo.widMax*/ wSpace * MDate, nextVPos + hStep - 5);	SetDialogItem ( dialog, miDate, iType, iHandle, &rView );	nextVPos += hStep;		GetDialogItem ( dialog, miTo, &iType, &iHandle, &rView );	nextHPos = rView.left;	SetRect (&rView, nextHPos, nextVPos, nextHPos + /*fInfo.widMax*/ wSpace * MName, nextVPos + hStep - 5);	SetDialogItem ( dialog, miTo, iType, iHandle, &rView );	nextHPos = rView.right + 5;		GetDialogItem ( dialog, 11, &iType, &iHandle, &rView );	SetRect (&rView, rView.left, nextVPos+fInfo.descent, rView.right, nextVPos+fInfo.descent+(rView.bottom-rView.top));	SetDialogItem ( dialog, 11, iType, iHandle, &rView );	GetDialogItem ( dialog, miToAd, &iType, &iHandle, &rView );	SetRect (&rView, nextHPos, nextVPos, nextHPos + /*fInfo.widMax*/ wSpace * MAddr, nextVPos + hStep - 5);	SetDialogItem ( dialog, miToAd, iType, iHandle, &rView );	nextHPos = rView.right + 5;	GetDialogItem ( dialog, miFlags, &iType, &iHandle, &rView );	SetRect (&rView, nextHPos, nextVPos, nextHPos + /*fInfo.widMax*/ wSpace * MDate, nextVPos + hStep - 5);	InsetRect (&rView, 0, -2);	SetDialogItem ( dialog, miFlags, iType, iHandle, &rView );	nextVPos += hStep;	GetDialogItem ( dialog, miSubj, &iType, &iHandle, &rView );	SetRect (&rView, rView.left, nextVPos, rView.left + /*fInfo.widMax*/ wSpace * MSubject, nextVPos + hStep - 5);	SetDialogItem ( dialog, miSubj, iType, iHandle, &rView );	GetDialogItem ( dialog, 12, &iType, &iHandle, &rView );	SetRect (&rView, rView.left, nextVPos+fInfo.descent, rView.right, nextVPos+fInfo.descent+(rView.bottom-rView.top));	SetDialogItem ( dialog, 12, iType, iHandle, &rView );	nextVPos += hStep;	GetDialogItem ( dialog, miBody, &iType, &iHandle, &rView );	SetRect (&rView, rView.left, nextVPos, rView.right, rView.bottom);	SetDialogItem ( dialog, miBody, iType, iHandle, &rView );	(*((*bodytext)->bodytext))->destRect.top = nextVPos+2;	(*((*bodytext)->bodytext))->viewRect.top = nextVPos+2;}static void AdjustWinSize (myTE32KHandle bodytext, short max){	short		iType, ii, dummy, neww, newh, newc;	Handle		iHandle;	Rect		iRect, rView, rDataBnds;//	FontInfo	fInfo;		GetDialogItem ( (*bodytext)->dialog, miBody, &iType, &iHandle, &rView );	newc = (*((*bodytext)->bodytext))->lineHeight;	TextFont (viewFont);	TextSize (viewSize);//	GetFontInfo (&fInfo);	//	neww = 2 + 81 * fInfo.widMax + 2 + 15;	neww = 2 + 81 * CharWidth (' ') + 2 + 15;	newh = 4 + rView.top + (((max - rView.top - 4) / newc) * newc);		SizeWindow ( (*bodytext)->dialog, neww, newh, true);	myTESize (bodytext);	originalView.bottom = newh;//	EraseRect (&((*bodytext)->dialog)->portRect);//	InvalRect (&((*bodytext)->dialog)->portRect);}#define	undoOther	0#define	undoTyping	1#define	undoKilling	2static void RegisterUndo (windowsQElPtr dialogInfo, short undotype){	if ((*(dialogInfo->common)->cMsgEdit.bodytext)->undotype &&		((*(dialogInfo->common)->cMsgEdit.bodytext)->undotype == undotype))		return;	if ((*(dialogInfo->common)->cMsgEdit.bodytext)->canundo)		DisposeHandle ((*(dialogInfo->common)->cMsgEdit.bodytext)->storedText);		(*(dialogInfo->common)->cMsgEdit.bodytext)->canundo = true;	(*(dialogInfo->common)->cMsgEdit.bodytext)->itsredo = false;		(*(dialogInfo->common)->cMsgEdit.bodytext)->storedStart = (*(*(dialogInfo->common)->cMsgEdit.bodytext)->bodytext)->selStart;	(*(dialogInfo->common)->cMsgEdit.bodytext)->storedEnd = (*(*(dialogInfo->common)->cMsgEdit.bodytext)->bodytext)->selEnd;	(*(dialogInfo->common)->cMsgEdit.bodytext)->storedText = (*(*(dialogInfo->common)->cMsgEdit.bodytext)->bodytext)->hText;	(*(dialogInfo->common)->cMsgEdit.bodytext)->undotype = undotype;		HandToHand (&(*(dialogInfo->common)->cMsgEdit.bodytext)->storedText);		if (MemError () != noErr)	{		SysBeep (10);		(*(dialogInfo->common)->cMsgEdit.bodytext)->canundo = false;	}	else		SetHandleSize ((*(dialogInfo->common)->cMsgEdit.bodytext)->storedText, (*(*(dialogInfo->common)->cMsgEdit.bodytext)->bodytext)->teLength);}					void WEditEventProcessor (EventRecord *event, windowsQElPtr dialogInfo, long info){	DialogPtr	dialog;	myTE32KHandle	bodytext;	RGBColor	color, color1;	short		iType, ii, dummy, neww, newh, newc, menuItem;	Handle		iHandle;	Rect		iRect, rView, rDataBnds;	Point		cellSize, theCell;	Point		where;		long		lSizeVH, mn, ctemp, ltemp;		Str255		stemp, stemp1;	Str63		stmp;		char		key;		short		iPartCode, iCtlPart, oldTE;		WStateData	*WStDat;	MenuHandle	hMenu;		windowsQElPtr	dInfo;	WindowPtr		window;		commonDataPtr	pcommon;	ControlHandle	whichCtl;	PopUpMenuHandle	popup, popupa;	msgbase_atom	Atom;	GrafPtr			oldPort;//	LongRect		tlRect;	Rect			tRect;	PScrapStuff		pScrpInf;		addr			tempaddr;	switch (info & 0xFFFF)	{	case actionSetSize:				originalView.left = ((wloc *) event)->topleft.h;		originalView.top = ((wloc *) event)->topleft.v;		originalView.bottom = ((wloc *) event)->bottom;				break;		case actionGetSize:				((wloc *) event)->topleft.h = originalView.left;		((wloc *) event)->topleft.v = originalView.top;		((wloc *) event)->bottom = originalView.bottom;				break;		case actionCreate://		if ((short) event == AreasNumber+1)//			OpenBase ( BADAREA, true );//		else//			OpenBase ((short) event, true);		msgbase_open_idx ((short) event, true);//		if (((long) dialogInfo) < 0)//			*((long *) &dialogInfo) = GetLastRead ();		if (dInfo = windowsOpened (wtMsgEdit, (long) event, 0))		{			msgbase_close (CLOSE_ONLY);			SelectWindow (dInfo->dialog);			break;		}				dialog = GetNewDialog (128 + wtMsgView, NULL, (WindowPtr) -1);		((WindowPeek)dialog)->windowKind = myKind;		SetPort ( dialog );		if (originalView.bottom)		{			if (!SuchWindow (wtMsgEdit) || qd.screenBits.bounds.bottom - originalView.top - 20 < originalView.bottom)			{				if (!originalView.top)				{					originalView.top = (*(((WindowPeek)dialog)->contRgn))->rgnBBox.top;					originalView.left = (*(((WindowPeek)dialog)->contRgn))->rgnBBox.left;	//				originalView.bottom = dialog->portRect.bottom;					originalView.top = LMGetMBarHeight () * 2;				}			}			else			{				originalView.left += 20;				originalView.top += 20;			}		}		else		{			originalView = (*(((WindowPeek)dialog)->contRgn))->rgnBBox;			originalView.bottom = dialog->portRect.bottom;			originalView.top = LMGetMBarHeight () * 2;		}				MoveWindow (dialog, originalView.left, originalView.top, false);		SizeWindow (dialog, dialog->portRect.right, originalView.bottom, false);		TextFont (viewFont);		TextSize (viewSize);				GetDialogItem ( dialog, miBody, &iType, &iHandle, &rView );		bodytext = myTENew (dialog, &rView, true, true, false);				AdjustFields (dialog, bodytext);		AdjustWinSize (bodytext, dialog->portRect.bottom);		popup = InitPopUp (dialog, 500, miFlags, 1, "\p Flags", 0, NULL);		DrawPopUp (popup);//		HilitePopUp (popup, false);				popupa = InitPopUp (dialog, 501, miAka, 1, "\p", 2, FullAKAs);		DrawPopUp (popupa);//		HilitePopUp (popupa, false);				WStDat = (WStateData *) *((WindowPeek) dialog)->dataHandle;				SetRect (&(WStDat->stdState),			WStDat->stdState.left + dialog->portRect.left,			WStDat->stdState.top + dialog->portRect.top,			WStDat->stdState.left + dialog->portRect.right,			qd.screenBits.bounds.bottom);		pcommon = (commonDataPtr) NewPtrClear (sizeof (commonMsgEdit));		pcommon->cMsgEdit.dialog = dialog;		pcommon->cMsgEdit.bodytext = bodytext;		pcommon->cMsgEdit.flagsPopUp = popup;		pcommon->cMsgEdit.AkaPopUp = popupa;		pcommon->cMsgEdit.area_number = (long) event;		pcommon->cMsgEdit.message_number = (long) dialogInfo;//		pcommon->cMsgEdit.dirty = 0;//		pcommon->cMsgEdit.firsttouch = 0;//		pcommon->cMsgEdit.message_total = GetNumOfMessages ();				if (selection_to_reply)		{			(*pcommon->cMsgEdit.bodytext)->storedText = selection_to_reply;						HLock ((Handle) pcommon->cMsgEdit.bodytext);			HandToHand (&(*pcommon->cMsgEdit.bodytext)->storedText);			HUnlock ((Handle) pcommon->cMsgEdit.bodytext);			DisposeHandle (selection_to_reply);			selection_to_reply = NULL;			(*pcommon->cMsgEdit.bodytext)->replyselected = true;		}		else		{			(*pcommon->cMsgEdit.bodytext)->storedText = NULL;			(*pcommon->cMsgEdit.bodytext)->replyselected = false;		}				(*pcommon->cMsgEdit.bodytext)->canundo = false;		(*pcommon->cMsgEdit.bodytext)->itsredo = false;		(*pcommon->cMsgEdit.bodytext)->undotype = -1;		pcommon->cMsgEdit.te.named.from = littleTENew (dialog, miFrom, false, false);		pcommon->cMsgEdit.te.named.to = littleTENew (dialog, miTo, false, false);		pcommon->cMsgEdit.te.named.toaddr = littleTENew (dialog, miToAd, false, false);		pcommon->cMsgEdit.te.named.subj = littleTENew (dialog, miSubj, false, false);		pcommon->cMsgEdit.te.named.date = littleTENew (dialog, miDate, false, false);		pcommon->cMsgEdit.currentTE = 0;				InsertButtons (pcommon);		HiliteButton (pcommon, 1L << btSend);				windowsAdd (dialog, wtMsgEdit, pcommon, WEditEventProcessor, WEditDialogProcessor);		dInfo = windowsLookUp (dialog);				SetWRefCon (dialog, (long) dInfo);		dInfo->inFront = true;				ShowWindow ( dialog );//		DrawDialog ( dialog );				msgbase_close (CLOSE_ONLY);		//		InitContents (windowsLookUp (dialog), (long) event, (long) dialogInfo, true);				WEditEventProcessor (NULL, dInfo, ((long) inMenuBar << 16) | mouseDown);		break;	case actionClose:		originalView = (*(((WindowPeek)(dialogInfo->dialog))->contRgn))->rgnBBox;		originalView.bottom = (dialogInfo->dialog)->portRect.bottom;		if ((dialogInfo->common)->cMsgEdit.dirty)		{			SelectWindow (dialogInfo->dialog);						WEditEventProcessor (NULL, dialogInfo, updateEvt);			#if defined(powerc) || defined(__powerc)			ii = Alert (502, uupMyAlertProc);#else			ii = Alert (502, myAlertProc);#endif			if (ii == 2)				break;		}		DisposeButtons (dialogInfo->common);				DisposePopUp ((dialogInfo->common)->cMsgEdit.flagsPopUp);		DisposePopUp ((dialogInfo->common)->cMsgEdit.AkaPopUp);				if ((*(dialogInfo->common)->cMsgEdit.bodytext)->storedText)			DisposeHandle ((*(dialogInfo->common)->cMsgEdit.bodytext)->storedText);				myTEDispose ((dialogInfo->common)->cMsgEdit.bodytext);		TE32KDispose ((dialogInfo->common)->cMsgEdit.te.named.from);//		TE32KDispose ((dialogInfo->common)->cMsgEdit.te.named.fromaddr);		TE32KDispose ((dialogInfo->common)->cMsgEdit.te.named.to);//		if (!(dialogInfo->common)->cMsgEdit.area_number)			TE32KDispose ((dialogInfo->common)->cMsgEdit.te.named.toaddr);		TE32KDispose ((dialogInfo->common)->cMsgEdit.te.named.subj);		TE32KDispose ((dialogInfo->common)->cMsgEdit.te.named.date);		if ((dialogInfo->common)->cMsgEdit.MessageBody)		{			FreePktMsg ( (dialogInfo->common)->cMsgEdit.MessageBody );			(dialogInfo->common)->cMsgEdit.MessageBody = NULL;		}		DisposePtr ((Ptr) dialogInfo->common);		DisposeDialog (dialogInfo->dialog);		windowsKill (dialogInfo->dialog);				break;		case actionActive:	//		DrawOnlyGrowIcon (dialogInfo->dialog);		SetPort (dialogInfo->dialog);			MoveControl ((*((dialogInfo->common)->cMsgEdit.bodytext))->scroll,			(*(*((dialogInfo->common)->cMsgEdit.bodytext))->bodytext)->viewRect.right + ((dialogInfo->inFront) ? 2 : 17),			(*(*((dialogInfo->common)->cMsgEdit.bodytext))->bodytext)->viewRect.top - 3);				HilitePopUp ((dialogInfo->common)->cMsgEdit.flagsPopUp, dialogInfo->inFront);		HilitePopUp ((dialogInfo->common)->cMsgEdit.AkaPopUp, dialogInfo->inFront);		if (dialogInfo->inFront)		{			if ((dialogInfo->common)->cMsgEdit.currentTE)			{				TE32KActivate ((dialogInfo->common)->cMsgEdit.te.array[(dialogInfo->common)->cMsgEdit.currentTE-1]);				LongRectToRect (&(*(dialogInfo->common)->cMsgEdit.te.array[(dialogInfo->common)->cMsgEdit.currentTE-1])->viewRect, &rView);				InsetRect (&rView, -2, -2);				InvalRect (&rView);			}			else				TE32KActivate ((*(dialogInfo->common)->cMsgEdit.bodytext)->bodytext);		}		else		{			if ((dialogInfo->common)->cMsgEdit.currentTE)			{				TE32KDeactivate ((dialogInfo->common)->cMsgEdit.te.array[(dialogInfo->common)->cMsgEdit.currentTE-1]);				LongRectToRect (&(*(dialogInfo->common)->cMsgEdit.te.array[(dialogInfo->common)->cMsgEdit.currentTE-1])->viewRect, &rView);				InsetRect (&rView, -2, -2);				InvalRect (&rView);			}			else				TE32KDeactivate ((*(dialogInfo->common)->cMsgEdit.bodytext)->bodytext);		}				break;	case actionBroadcast:			GetPort (&oldPort);		SetPort (dialogInfo->dialog);//		(dialogInfo->common)->cMsgEdit.message_number////		editNew			-	ignore//		editReply(Q)	-	msgnum what replyed//		editReply(Q)to	-	echonum/msgnum what replyed//		editForward		-	echonum/msgnum what forwarded		switch (((BroadcastRecPtr) event)->synctype)		{		case teCmdGetFieldID:			{				WinComPtr	wcp = (WinComPtr)((BroadcastRecPtr) event)->param[0];				wcp->arg.TEC->fieldnumber = (dialogInfo->common)->cMsgEdit.currentTE;				wcp->result = 0;			}			break;				case teCmdGetText:			{				WinComPtr	wcp = (WinComPtr)((BroadcastRecPtr) event)->param[0];							if ((dialogInfo->common)->cMsgEdit.currentTE == wcp->arg.TEC->fieldnumber)				{					TECommand	tec = wcp->arg.TEC;					TE32KHandle	te = (tec->fieldnumber) ?									(dialogInfo->common)->cMsgEdit.te.array[tec->fieldnumber-1] :									(*(dialogInfo->common)->cMsgEdit.bodytext)->bodytext;					long		frompos, topos, actual;										frompos = __max(0, tec->frompos);					topos = __min((*te)->teLength, tec->topos);					actual = __min(tec->textlen, topos - frompos);					if (actual > 0)					{						HLock((*te)->hText);						memcpy(tec->text, *(*te)->hText, actual);						HUnlock((*te)->hText);						tec->textlen = actual;						wcp->result = 0;					}					else						wcp->result = -1;				}				else					wcp->result = -1;			}			break;		case teCmdGetSelection:			{				WinComPtr	wcp = (WinComPtr)((BroadcastRecPtr) event)->param[0];							if ((dialogInfo->common)->cMsgEdit.currentTE == wcp->arg.TEC->fieldnumber)				{					TECommand	tec = wcp->arg.TEC;					TE32KHandle	te = (tec->fieldnumber) ?									(dialogInfo->common)->cMsgEdit.te.array[tec->fieldnumber-1] :									(*(dialogInfo->common)->cMsgEdit.bodytext)->bodytext;									tec->frompos = (*te)->selStart;					tec->topos = (*te)->selEnd;					wcp->result = 0;				}				else					wcp->result = -1;			}			break;				case teCmdInsertText:			{				WinComPtr	wcp = (WinComPtr)((BroadcastRecPtr) event)->param[0];							if ((dialogInfo->common)->cMsgEdit.currentTE == wcp->arg.TEC->fieldnumber)				{					TECommand	tec = wcp->arg.TEC;					TE32KHandle	te = (tec->fieldnumber) ?									(dialogInfo->common)->cMsgEdit.te.array[tec->fieldnumber-1] :									(*(dialogInfo->common)->cMsgEdit.bodytext)->bodytext;					if (tec->fieldnumber == 0)						RegisterUndo (dialogInfo, undoOther);					GetBackColor (&color1);					color.red = color.green = color.blue = 0xFFFF;					RGBBackColor(&color);					TE32KInsert (tec->text, tec->textlen, te);//					color.red = color.green = color.blue = 50000;					RGBBackColor(&color1);					if (tec->fieldnumber == 0)						AdjustV ((*(dialogInfo->common)->cMsgEdit.bodytext)->scroll,									(*(dialogInfo->common)->cMsgEdit.bodytext)->bodytext, false);					wcp->result = 0;				}				else					wcp->result = -1;			}			break;				case teCmdClearText:			{				WinComPtr	wcp = (WinComPtr)((BroadcastRecPtr) event)->param[0];							if ((dialogInfo->common)->cMsgEdit.currentTE == wcp->arg.TEC->fieldnumber)				{					TECommand	tec = wcp->arg.TEC;					TE32KHandle	te = (tec->fieldnumber) ?									(dialogInfo->common)->cMsgEdit.te.array[tec->fieldnumber-1] :									(*(dialogInfo->common)->cMsgEdit.bodytext)->bodytext;					if (tec->fieldnumber == 0)						RegisterUndo (dialogInfo, undoOther);					GetBackColor (&color1);					color.red = color.green = color.blue = 0xFFFF;					RGBBackColor(&color);					TE32KDelete (te);					if (tec->fieldnumber == 0)						AdjustV ((*(dialogInfo->common)->cMsgEdit.bodytext)->scroll,									(*(dialogInfo->common)->cMsgEdit.bodytext)->bodytext, false);//					color.red = color.green = color.blue = 50000;					RGBBackColor(&color1);					wcp->result = 0;				}				else					wcp->result = -1;			}			break;				case teCmdSelectText:			{				WinComPtr	wcp = (WinComPtr)((BroadcastRecPtr) event)->param[0];							if ((dialogInfo->common)->cMsgEdit.currentTE == wcp->arg.TEC->fieldnumber)				{					TECommand	tec = wcp->arg.TEC;					TE32KHandle	te = (tec->fieldnumber) ?									(dialogInfo->common)->cMsgEdit.te.array[tec->fieldnumber-1] :									(*(dialogInfo->common)->cMsgEdit.bodytext)->bodytext;					GetBackColor (&color1);					color.red = color.green = color.blue = 0xFFFF;					RGBBackColor(&color);					TE32KSetSelect (tec->frompos, tec->topos, te);//					color.red = color.green = color.blue = 50000;					RGBBackColor(&color1);					wcp->result = 0;				}				else					wcp->result = -1;			}			break;				case teCmdScrollToVisible:			{				WinComPtr	wcp = (WinComPtr)((BroadcastRecPtr) event)->param[0];							if ((dialogInfo->common)->cMsgEdit.currentTE == 0 &&					(dialogInfo->common)->cMsgEdit.currentTE == wcp->arg.TEC->fieldnumber)				{					TECommand	tec = wcp->arg.TEC;					TE32KHandle	te = (*(dialogInfo->common)->cMsgEdit.bodytext)->bodytext;					GetBackColor (&color1);					color.red = color.green = color.blue = 0xFFFF;					RGBBackColor(&color);					TE32KSelView (te);					if (tec->fieldnumber == 0)						AdjustV ((*(dialogInfo->common)->cMsgEdit.bodytext)->scroll,									(*(dialogInfo->common)->cMsgEdit.bodytext)->bodytext, false);//					color.red = color.green = color.blue = 50000;					RGBBackColor(&color1);					wcp->result = 0;				}				else					wcp->result = -1;			}			break;				case editPost:					if (((BroadcastRecPtr) event)->area != (dialogInfo->common)->cMsgEdit.area_number)				break;			(dialogInfo->common)->cMsgEdit.editmode = ((BroadcastRecPtr) event)->synctype;			InitContents (dialogInfo, (dialogInfo->common)->cMsgEdit.area_number, 0);			break;				case editNew:						if (((BroadcastRecPtr) event)->area != (dialogInfo->common)->cMsgEdit.area_number)				break;			(dialogInfo->common)->cMsgEdit.editmode = ((BroadcastRecPtr) event)->synctype;			InitContents (dialogInfo, (dialogInfo->common)->cMsgEdit.area_number, 0);			break;					case editReplyQ:					if (((BroadcastRecPtr) event)->area != (dialogInfo->common)->cMsgEdit.area_number)				break;			(dialogInfo->common)->cMsgEdit.editmode = ((BroadcastRecPtr) event)->synctype;			(dialogInfo->common)->cMsgEdit.message_number = ((BroadcastRecPtr) event)->message;			InitContents (dialogInfo, (dialogInfo->common)->cMsgEdit.area_number, 0);			break;					case editReply:					if (((BroadcastRecPtr) event)->area != (dialogInfo->common)->cMsgEdit.area_number)				break;			(dialogInfo->common)->cMsgEdit.editmode = ((BroadcastRecPtr) event)->synctype;			(dialogInfo->common)->cMsgEdit.message_number = ((BroadcastRecPtr) event)->message;			InitContents (dialogInfo, (dialogInfo->common)->cMsgEdit.area_number, 0);			break;		case editCommentQ:					if (((BroadcastRecPtr) event)->area != (dialogInfo->common)->cMsgEdit.area_number)				break;			(dialogInfo->common)->cMsgEdit.editmode = ((BroadcastRecPtr) event)->synctype;			(dialogInfo->common)->cMsgEdit.message_number = ((BroadcastRecPtr) event)->message;			InitContents (dialogInfo, (dialogInfo->common)->cMsgEdit.area_number, 0);			break;					case editComment:					if (((BroadcastRecPtr) event)->area != (dialogInfo->common)->cMsgEdit.area_number)				break;			(dialogInfo->common)->cMsgEdit.editmode = ((BroadcastRecPtr) event)->synctype;			(dialogInfo->common)->cMsgEdit.message_number = ((BroadcastRecPtr) event)->message;			InitContents (dialogInfo, (dialogInfo->common)->cMsgEdit.area_number, 0);			break;		case editForward:					if (((BroadcastRecPtr) event)->area != (dialogInfo->common)->cMsgEdit.area_number)				break;			(dialogInfo->common)->cMsgEdit.editmode = ((BroadcastRecPtr) event)->synctype;			(dialogInfo->common)->cMsgEdit.o_area_number = (dialogInfo->common)->cMsgEdit.area_number;			(dialogInfo->common)->cMsgEdit.area_number = ((BroadcastRecPtr) event)->message;			InitContents (dialogInfo, (dialogInfo->common)->cMsgEdit.area_number, 0);			break;					case editReplyQto:					if (((BroadcastRecPtr) event)->area != (dialogInfo->common)->cMsgEdit.area_number)				break;			(dialogInfo->common)->cMsgEdit.editmode = ((BroadcastRecPtr) event)->synctype;			(dialogInfo->common)->cMsgEdit.o_area_number = (dialogInfo->common)->cMsgEdit.area_number;			(dialogInfo->common)->cMsgEdit.area_number = ((BroadcastRecPtr) event)->message;			InitContents (dialogInfo, (dialogInfo->common)->cMsgEdit.area_number, 0);			break;					case editReplyto:					if (((BroadcastRecPtr) event)->area != (dialogInfo->common)->cMsgEdit.area_number)				break;			(dialogInfo->common)->cMsgEdit.editmode = ((BroadcastRecPtr) event)->synctype;			(dialogInfo->common)->cMsgEdit.o_area_number = (dialogInfo->common)->cMsgEdit.area_number;			(dialogInfo->common)->cMsgEdit.area_number = ((BroadcastRecPtr) event)->message;			InitContents (dialogInfo, (dialogInfo->common)->cMsgEdit.area_number, 0);			break;				case editCommentQto:					if (((BroadcastRecPtr) event)->area != (dialogInfo->common)->cMsgEdit.area_number)				break;			(dialogInfo->common)->cMsgEdit.editmode = ((BroadcastRecPtr) event)->synctype;			(dialogInfo->common)->cMsgEdit.o_area_number = (dialogInfo->common)->cMsgEdit.area_number;			(dialogInfo->common)->cMsgEdit.area_number = ((BroadcastRecPtr) event)->message;			InitContents (dialogInfo, (dialogInfo->common)->cMsgEdit.area_number, 0);			break;					case editCommentto:					if (((BroadcastRecPtr) event)->area != (dialogInfo->common)->cMsgEdit.area_number)				break;			(dialogInfo->common)->cMsgEdit.editmode = ((BroadcastRecPtr) event)->synctype;			(dialogInfo->common)->cMsgEdit.o_area_number = (dialogInfo->common)->cMsgEdit.area_number;			(dialogInfo->common)->cMsgEdit.area_number = ((BroadcastRecPtr) event)->message;			InitContents (dialogInfo, (dialogInfo->common)->cMsgEdit.area_number, 0);			break;				case editEdit:			if (((BroadcastRecPtr) event)->area != (dialogInfo->common)->cMsgEdit.area_number)				break;			(dialogInfo->common)->cMsgEdit.editmode = ((BroadcastRecPtr) event)->synctype;			(dialogInfo->common)->cMsgEdit.message_number = ((BroadcastRecPtr) event)->message;			(dialogInfo->common)->cMsgEdit.area_number = ((BroadcastRecPtr) event)->area;			InitContents (dialogInfo, (dialogInfo->common)->cMsgEdit.area_number, 0);			break;		case editSendto:			if (((BroadcastRecPtr) event)->area != (dialogInfo->common)->cMsgEdit.area_number)				break;			SendMessage (dialogInfo, (addr *) ((BroadcastRecPtr) event)->message);						(dialogInfo->common)->cMsgEdit.dirty = 0;			WEditEventProcessor (NULL, dialogInfo, actionClose);			break;		case broadClose:					if (((BroadcastRecPtr) event)->area != (dialogInfo->common)->cMsgEdit.area_number &&				((BroadcastRecPtr) event)->area != -1)				break;			WEditEventProcessor (NULL, dialogInfo, actionClose);			break;		case broadGlobalResync:			tempaddr.zone = ((BroadcastRecPtr) event)->area >> 16;			tempaddr.net = ((BroadcastRecPtr) event)->area & 0xFFFF;			tempaddr.node = ((BroadcastRecPtr) event)->message >> 16;			tempaddr.point = ((BroadcastRecPtr) event)->message & 0xFFFF;			if ( GetNameFromAddr ( &tempaddr, stemp ) )			{//				RectToLongRect (&(dialogInfo->dialog)->portRect, &tlRect);				GetBackColor (&color1);				color.red = color.green = color.blue = 0xFFFF;				RGBBackColor(&color);				TE32KSetText ((char *) &stemp[1], stemp[0], (dialogInfo->common)->cMsgEdit.te.named.to);				littleTE32KUpdate (&(dialogInfo->dialog)->portRect, (dialogInfo->common)->cMsgEdit.te.named.to);								if (!(dialogInfo->common)->cMsgEdit.area_number)				{					printaddr ( &tempaddr, (char *) &stemp1[1] );					stemp1[0] = strlen ((char *) &stemp1[1]);										TE32KSetText ((char *) &stemp1[1], stemp1[0], (dialogInfo->common)->cMsgEdit.te.named.toaddr);					littleTE32KUpdate (&(dialogInfo->dialog)->portRect, (dialogInfo->common)->cMsgEdit.te.named.toaddr);				}				//				color.red = color.green = color.blue = 50000;				RGBBackColor(&color1);			}						break;					case broadGlobalSync://			RectToLongRect (&(dialogInfo->dialog)->portRect, &tlRect);			GetBackColor (&color1);			color.red = color.green = color.blue = 0xFFFF;			RGBBackColor(&color);			TE32KSetText ((char *) &(((oneRecPtr)((BroadcastRecPtr) event)->area)->name)[1],				(((oneRecPtr)((BroadcastRecPtr) event)->area)->name)[0],					(dialogInfo->common)->cMsgEdit.te.named.to);			littleTE32KUpdate (&(dialogInfo->dialog)->portRect, (dialogInfo->common)->cMsgEdit.te.named.to);						if (!(dialogInfo->common)->cMsgEdit.area_number)			{				printaddr ( &((oneRecPtr)((BroadcastRecPtr) event)->area)->address, (char *) &stemp1[1] );				stemp1[0] = strlen ((char *) &stemp1[1]);				TE32KSetText ((char *) &stemp1[1], stemp1[0], (dialogInfo->common)->cMsgEdit.te.named.toaddr);				littleTE32KUpdate (&(dialogInfo->dialog)->portRect, (dialogInfo->common)->cMsgEdit.te.named.toaddr);			}			//			color.red = color.green = color.blue = 50000;			RGBBackColor(&color1);			break;		}				SetPort (oldPort);				break;		case actionMenu:		SetPort (dialogInfo->dialog);		menuItem = (info >> 16) & 0xFF;				switch ((info >> 24) & 0xFF)		{		case fileM:					switch (menuItem)			{			case fImport:								{					Point		where = {0,0};					SFTypeList	myTypes;					SFReply		reply;					short		gottaFile;					long		theSize;															myTypes[0] = 'TEXT';					SFPGetFile (where, "\p", NULL, 1, myTypes, NULL, &reply, 4000, NULL);									if (reply.good)					{						if (FSOpen (reply.fName, reply.vRefNum, &gottaFile) == noErr)						{							GetEOF (gottaFile, &theSize);													if ((theSize + (*(*(dialogInfo->common)->cMsgEdit.bodytext)->bodytext)->teLength) <= 32000)							{								iHandle = NewHandle (theSize);								HLock (iHandle);																if (FSRead (gottaFile, &theSize, *iHandle) == noErr)								{									GetBackColor (&color1);									color.red = color.green = color.blue = 0xFFFF;									RGBBackColor(&color);									TE32KInsert (*iHandle, theSize, (*(dialogInfo->common)->cMsgEdit.bodytext)->bodytext);									AdjustV ((*(dialogInfo->common)->cMsgEdit.bodytext)->scroll,										(*(dialogInfo->common)->cMsgEdit.bodytext)->bodytext, false);//									color.red = color.green = color.blue = 50000;									RGBBackColor(&color1);								}								else									SysBeep (10);																DisposeHandle (iHandle);							}							else								SysBeep (10);													FSClose (gottaFile);						}					}				}								break;			}						break;				case editM:					GetBackColor (&color1);			color.red = color.green = color.blue = 0xFFFF;			RGBBackColor(&color);			switch (menuItem)			{			case iUndo:							if (!(dialogInfo->common)->cMsgEdit.currentTE &&					(*(dialogInfo->common)->cMsgEdit.bodytext)->canundo)				{					Handle		newH;					long		newS, newE;												//	(*(dialogInfo->common)->cMsgEdit.bodytext)->canundo = false;					(*(dialogInfo->common)->cMsgEdit.bodytext)->undotype = -1;					(*(dialogInfo->common)->cMsgEdit.bodytext)->itsredo = !(*(dialogInfo->common)->cMsgEdit.bodytext)->itsredo;										newH = (*(*(dialogInfo->common)->cMsgEdit.bodytext)->bodytext)->hText;					HUnlock (newH);					SetHandleSize (newH, (*(*(dialogInfo->common)->cMsgEdit.bodytext)->bodytext)->teLength);					newS = (*(*(dialogInfo->common)->cMsgEdit.bodytext)->bodytext)->selStart;					newE = (*(*(dialogInfo->common)->cMsgEdit.bodytext)->bodytext)->selEnd;										(*(*(dialogInfo->common)->cMsgEdit.bodytext)->bodytext)->hText = NULL;					TE32KUseTextHandle ((*(dialogInfo->common)->cMsgEdit.bodytext)->storedText,										GetHandleSize ((*(dialogInfo->common)->cMsgEdit.bodytext)->storedText),										(*(dialogInfo->common)->cMsgEdit.bodytext)->bodytext);					TE32KSetSelect ((*(dialogInfo->common)->cMsgEdit.bodytext)->storedStart,									(*(dialogInfo->common)->cMsgEdit.bodytext)->storedEnd,									(*(dialogInfo->common)->cMsgEdit.bodytext)->bodytext);					(*(dialogInfo->common)->cMsgEdit.bodytext)->storedText = newH;					(*(dialogInfo->common)->cMsgEdit.bodytext)->storedStart = newS;					(*(dialogInfo->common)->cMsgEdit.bodytext)->storedEnd = newE;										InvalRect (&(dialogInfo->dialog)->portRect);					TE32KSelView ((*(dialogInfo->common)->cMsgEdit.bodytext)->bodytext);					AdjustV ((*(dialogInfo->common)->cMsgEdit.bodytext)->scroll,						(*(dialogInfo->common)->cMsgEdit.bodytext)->bodytext, false);				}								break;						case iCut:								if ((dialogInfo->common)->cMsgEdit.currentTE)					TE32KCutToScrap ((dialogInfo->common)->cMsgEdit.te.array[(dialogInfo->common)->cMsgEdit.currentTE-1]);				else				{					RegisterUndo (dialogInfo, undoOther);										TE32KCutToScrap ((*(dialogInfo->common)->cMsgEdit.bodytext)->bodytext);					TE32KSelView ((*(dialogInfo->common)->cMsgEdit.bodytext)->bodytext);					AdjustV ((*(dialogInfo->common)->cMsgEdit.bodytext)->scroll,						(*(dialogInfo->common)->cMsgEdit.bodytext)->bodytext, false);				}								break;			case iCopy:								if ((dialogInfo->common)->cMsgEdit.currentTE)					TE32KCopyToScrap ((dialogInfo->common)->cMsgEdit.te.array[(dialogInfo->common)->cMsgEdit.currentTE-1]);				else					TE32KCopyToScrap ((*(dialogInfo->common)->cMsgEdit.bodytext)->bodytext);							break;			case iPaste:								(dialogInfo->common)->cMsgEdit.dirty = 1;				if ((dialogInfo->common)->cMsgEdit.currentTE)					TE32KPasteFromScrap ((dialogInfo->common)->cMsgEdit.te.array[(dialogInfo->common)->cMsgEdit.currentTE-1]);				else				{					RegisterUndo (dialogInfo, undoOther);					TE32KPasteFromScrap ((*(dialogInfo->common)->cMsgEdit.bodytext)->bodytext);					AdjustV ((*(dialogInfo->common)->cMsgEdit.bodytext)->scroll,						(*(dialogInfo->common)->cMsgEdit.bodytext)->bodytext, false);				}				break;			case iClear:								if ((dialogInfo->common)->cMsgEdit.currentTE)					TE32KDelete ((dialogInfo->common)->cMsgEdit.te.array[(dialogInfo->common)->cMsgEdit.currentTE-1]);				else				{					RegisterUndo (dialogInfo, undoOther);					TE32KDelete ((*(dialogInfo->common)->cMsgEdit.bodytext)->bodytext);					AdjustV ((*(dialogInfo->common)->cMsgEdit.bodytext)->scroll,						(*(dialogInfo->common)->cMsgEdit.bodytext)->bodytext, false);				}								break;			case iSelectAll:								if ((dialogInfo->common)->cMsgEdit.currentTE)					TE32KSetSelect (0, 0x7FFF, (dialogInfo->common)->cMsgEdit.te.array[(dialogInfo->common)->cMsgEdit.currentTE-1]);				else					TE32KSetSelect (0, 0x7FFFFFFF,(*(dialogInfo->common)->cMsgEdit.bodytext)->bodytext);								break;			}//			color.red = color.green = color.blue = 50000;			RGBBackColor(&color1);			break;				case msgM:					switch (menuItem)			{			case mSend:								if (!checkPossibility (dialogInfo))				{					CallASndPlay (132);				}				else				{					SendMessage (dialogInfo, NULL);					(dialogInfo->common)->cMsgEdit.dirty = 0;					WEditEventProcessor (NULL, dialogInfo, actionClose);				}								break;			case mSendto:								if (!checkPossibility (dialogInfo))				{					CallASndPlay (132);				}				else				{					if ((dialogInfo->common)->cMsgEdit.area_number)						WASelectEventProcessor ((EventRecord *) (dialogInfo->common)->cMsgEdit.area_number,								(windowsQElPtr) mSendto, actionCreate);					else					{						oneRecPtr	temp;												temp = (oneRecPtr) NewPtr (sizeof (oneRec));						memcpy (&temp->name[1],								*(*(dialogInfo->common)->cMsgEdit.te.named.to)->hText,								(*(dialogInfo->common)->cMsgEdit.te.named.to)->teLength);						temp->name[0] = (*(dialogInfo->common)->cMsgEdit.te.named.to)->teLength;						memcpy (stemp,								*(*(dialogInfo->common)->cMsgEdit.te.named.toaddr)->hText,								(*(dialogInfo->common)->cMsgEdit.te.named.toaddr)->teLength);						stemp[(*(dialogInfo->common)->cMsgEdit.te.named.toaddr)->teLength] = 0;												temp->address.zone = 0;						temp->address.net = 0;						temp->address.node = 0;						temp->address.point = 0;						parseaddr (&temp->address, (char *) stemp);						WAddresseeEventProcessor (NULL, (windowsQElPtr) temp, actionCreate);					}				}								break;			}						break;					case nodeM:			switch (menuItem)			{			case nExpand:							if ((dialogInfo->common)->cMsgEdit.area_number)					break;									if ((dialogInfo->common)->cMsgEdit.currentTE == 4)				{					if (!(*(dialogInfo->common)->cMsgEdit.te.named.toaddr)->teLength)						break;										memcpy ((char *) &stemp[0], *(*(dialogInfo->common)->cMsgEdit.te.named.toaddr)->hText,						(*(dialogInfo->common)->cMsgEdit.te.named.toaddr)->teLength);					stemp[(*(dialogInfo->common)->cMsgEdit.te.named.toaddr)->teLength] = 0;										tempaddr.zone = 0;					tempaddr.net = 0;					tempaddr.node = 0;					tempaddr.point = 0;									parseaddr (&tempaddr, (char *) &stemp[0]);										if (!tempaddr.zone && !tempaddr.net && !tempaddr.node && !tempaddr.point )						break;										if ( !tempaddr.zone )						tempaddr.zone = ((dialogInfo->common)->cMsgEdit.MessageBody)->from.zone;										if ( !tempaddr.net )						tempaddr.net = ((dialogInfo->common)->cMsgEdit.MessageBody)->from.net;										printaddr ( &tempaddr, (char *) &stemp1[1] );					stemp1[0] = strlen ((char *) &stemp1[1]);										if ( GetNameFromAddr ( &tempaddr, stemp ) )					{//						RectToLongRect (&(dialogInfo->dialog)->portRect, &tlRect);						GetBackColor (&color1);						color.red = color.green = color.blue = 0xFFFF;						RGBBackColor(&color);						TE32KSetText ((char *) &stemp[1], stemp[0], (dialogInfo->common)->cMsgEdit.te.named.to);						littleTE32KUpdate (&(dialogInfo->dialog)->portRect, (dialogInfo->common)->cMsgEdit.te.named.to);												TE32KSetText ((char *) &stemp1[1], stemp1[0], (dialogInfo->common)->cMsgEdit.te.named.toaddr);						littleTE32KUpdate (&(dialogInfo->dialog)->portRect, (dialogInfo->common)->cMsgEdit.te.named.toaddr);//						color.red = color.green = color.blue = 50000;						RGBBackColor(&color1);					}					else						CallASndPlay (129);				}									break;			case nBrowse:								if ((dialogInfo->common)->cMsgEdit.MessageBody)				{					if (((dialogInfo->common)->cMsgEdit.MessageBody)->from.node)						ltemp = 2;					else						if (((dialogInfo->common)->cMsgEdit.MessageBody)->from.net)							ltemp = 1;						else							ltemp = 0;										WNodeEventProcessor ((EventRecord *) ltemp,						(windowsQElPtr) &((dialogInfo->common)->cMsgEdit.MessageBody)->from, actionCreate);				}				else					WNodeEventProcessor ((EventRecord *) 2L, (windowsQElPtr) &(*homesystem)->mainAddr.ad, actionCreate);								Broadcast (wtNodelist, broadGlobalResync, broadGlobalResync, (long) dialogInfo);								break;							case nNotepad:							WAddresseeEventProcessor ((EventRecord *) 1L, dialogInfo, actionCreate);				break;			default:							if ((dialogInfo->common)->cMsgEdit.currentTE == 3 ||					(dialogInfo->common)->cMsgEdit.currentTE == 4)				{					notePtr		tempNote = notepad;									menuItem -= nFirstCustom;										ii = 0;					while ( ii != menuItem )					{						tempNote = tempNote->next_note;						ii++;					}										GetBackColor (&color1);					color.red = color.green = color.blue = 0xFFFF;					RGBBackColor(&color);//					RectToLongRect (&(dialogInfo->dialog)->portRect, &tlRect);					if (!(dialogInfo->common)->cMsgEdit.area_number)					{						printaddr (&tempNote->pad_address, (char *)&stemp1[1]);						stemp1[0] = strlen ((char *)&stemp1[1]);												TE32KSetText ((char *) &stemp1[1], stemp1[0], (dialogInfo->common)->cMsgEdit.te.named.toaddr);						littleTE32KUpdate (&(dialogInfo->dialog)->portRect, (dialogInfo->common)->cMsgEdit.te.named.toaddr);					}										TE32KSetText ((char *) &tempNote->pad_name[1], tempNote->pad_name[0], (dialogInfo->common)->cMsgEdit.te.named.to);					littleTE32KUpdate (&(dialogInfo->dialog)->portRect, (dialogInfo->common)->cMsgEdit.te.named.to);//					color.red = color.green = color.blue = 50000;					RGBBackColor(&color1);				}							break;			}						break;		case windowM:					switch (menuItem)			{			case wSubjects:								WSubjectsEventProcessor ((EventRecord *) (dialogInfo->common)->cMsgEdit.area_number,					 (windowsQElPtr) -1L, actionCreate);				break;			}						break;		}		break;		case actionOpen:			break;		case mouseDown:		if ((info >> 16) != inMenuBar)			where = event->where;		switch (info >> 16)		{		case inMenuBar:					recalcWindowMenu ();						SetPt (&theCell, 0, 0);					hMenu = GetMenuHandle (fileM + 256);			(*hMenu)->enableFlags = 1L | (1L << fQuit) | (1L << fClose) | (1L << fPageSetup);			if (!(dialogInfo->common)->cMsgEdit.currentTE)				(*hMenu)->enableFlags |= (1L << fImport);						hMenu = GetMenuHandle (editM + 256);			(*hMenu)->enableFlags = 1L | (1L << iSelectAll) | (1L << iUserName) | (1L << iOrigin);			SetMenuItemText (hMenu, 1, "\pUndo");			if ((dialogInfo->common)->cMsgEdit.currentTE)			{				if ((*(dialogInfo->common)->cMsgEdit.te.array[(dialogInfo->common)->cMsgEdit.currentTE-1])->selStart !=					(*(dialogInfo->common)->cMsgEdit.te.array[(dialogInfo->common)->cMsgEdit.currentTE-1])->selEnd)					(*hMenu)->enableFlags |= (1L << iCopy) | (1L << iCut) | (1L << iClear);			}			else			{				if ((*(*(dialogInfo->common)->cMsgEdit.bodytext)->bodytext)->selStart !=					(*(*(dialogInfo->common)->cMsgEdit.bodytext)->bodytext)->selEnd)					(*hMenu)->enableFlags |= (1L << iCopy) | (1L << iCut) | (1L << iClear);									if ((*(dialogInfo->common)->cMsgEdit.bodytext)->canundo)				{					(*hMenu)->enableFlags |= (1L << iUndo);										if ((*(dialogInfo->common)->cMsgEdit.bodytext)->itsredo)						SetMenuItemText (hMenu, 1, "\pRedo");				}			}						pScrpInf = InfoScrap ();			if (pScrpInf->scrapSize)				(*hMenu)->enableFlags |= (1L << iPaste);						hMenu = GetMenuHandle (msgM + 256);			(*hMenu)->enableFlags = 1L | (1L << mSend);			if ((dialogInfo->common)->cMsgEdit.editmode != editEdit &&				(dialogInfo->common)->cMsgEdit.editmode != editPost)				(*hMenu)->enableFlags |= (1L << mSendto);			hMenu = GetMenuHandle (nodeM + 256);			(*hMenu)->enableFlags = 1L;						if (yep ())				(*hMenu)->enableFlags |= (1L << nBrowse);			if (padname[0])				(*hMenu)->enableFlags |= (1L << nNotepad);						if ((dialogInfo->common)->cMsgEdit.currentTE == 3 ||				(dialogInfo->common)->cMsgEdit.currentTE == 4)				(*hMenu)->enableFlags |= (-1L << nFirstCustom);			if ((dialogInfo->common)->cMsgEdit.currentTE == 4 && yep ())				(*hMenu)->enableFlags |= (1L << nExpand);						hMenu = GetMenuHandle (shuffleM + 256);			(*hMenu)->enableFlags = -1L;			hMenu = GetMenuHandle (windowM + 256);			if (((WindowPeek)(dialogInfo->dialog))->windowKind != myKind_top)			{				(*hMenu)->enableFlags = -1L;			}			else				(*hMenu)->enableFlags = 0;			DrawMenuBar ();			break;		case inContent:					FindWindow (event->where, &window);						if (window != FrontWindow ())			{				if (((WindowPeek)FrontWindow ())->windowKind == myKind_top)					SysBeep (10);				else					SelectWindow (window);			}			else			{				SetPort (dialogInfo->dialog);				GlobalToLocal (&where);						//		Check in bodytext				oldTE = (dialogInfo->common)->cMsgEdit.currentTE;				(*(dialogInfo->common)->cMsgEdit.bodytext)->undotype = 0;				if (!myTEMouseDown2 ((dialogInfo->common)->cMsgEdit.bodytext, where, event->modifiers))				{					iCtlPart = FindControl (where, dialogInfo->dialog, &whichCtl);										if (iCtlPart)					{						iPartCode = TrackControl (whichCtl, where, NULL);												if (iPartCode)						{							switch (LocateButton (dialogInfo->common, whichCtl))							{							case btSend:																if (!checkPossibility (dialogInfo))								{									CallASndPlay (132);								}								else								{									SendMessage (dialogInfo, NULL);									(dialogInfo->common)->cMsgEdit.dirty = 0;									WEditEventProcessor (NULL, dialogInfo, actionClose);								}																break;							}						}											break;					}					else					{						LongRectToRect (&(*((*(dialogInfo->common)->cMsgEdit.bodytext)->bodytext))->viewRect, &tRect);												if (PtInRect (where, &tRect))						{							if (!(dialogInfo->common)->cMsgEdit.firsttouch)							{								if (!checkPossibility (dialogInfo) /*||									(dialogInfo->common)->cMsgEdit.editmode == editPost*/)								{									CallASndPlay (132);									(dialogInfo->common)->cMsgEdit.currentTE = -1;								}								else								{									(dialogInfo->common)->cMsgEdit.firsttouch = 1;									(dialogInfo->common)->cMsgEdit.currentTE = 0;									PrepareBody (dialogInfo);								}							}							else								(dialogInfo->common)->cMsgEdit.currentTE = 0;						}						else						{							GetDialogItem (dialogInfo->dialog, miFrom, &iType, &iHandle, &iRect);							if (PtInRect (where, &iRect))								(dialogInfo->common)->cMsgEdit.currentTE = 1;							else							{								GetDialogItem (dialogInfo->dialog, miTo, &iType, &iHandle, &iRect);								if (PtInRect (where, &iRect))									(dialogInfo->common)->cMsgEdit.currentTE = 3;								else								{									GetDialogItem (dialogInfo->dialog, miToAd, &iType, &iHandle, &iRect);									if (PtInRect (where, &iRect))										(dialogInfo->common)->cMsgEdit.currentTE =											((dialogInfo->common)->cMsgEdit.area_number == 0) ? 4 : -1;									else									{										GetDialogItem (dialogInfo->dialog, miSubj, &iType, &iHandle, &iRect);										if (PtInRect (where, &iRect))											(dialogInfo->common)->cMsgEdit.currentTE = 5;										else											(dialogInfo->common)->cMsgEdit.currentTE = -1;									}								}							}						}					}				}				else					(dialogInfo->common)->cMsgEdit.currentTE = 0;								if ((dialogInfo->common)->cMsgEdit.currentTE == -1)				{					(dialogInfo->common)->cMsgEdit.currentTE = oldTE;					break;				}								GetBackColor (&color1);				color.red = color.green = color.blue = 0xFFFF;				RGBBackColor(&color);				if (oldTE != (dialogInfo->common)->cMsgEdit.currentTE)				{					if (oldTE)					{						TE32KSetSelect (0, 0,									(dialogInfo->common)->cMsgEdit.te.array[oldTE - 1]);						TE32KDeactivate ((dialogInfo->common)->cMsgEdit.te.array[oldTE - 1]);						LongRectToRect (&(*(dialogInfo->common)->cMsgEdit.te.array[oldTE-1])->viewRect, &rView);						InsetRect (&rView, -2, -2);						InvalRect (&rView);					}					else					{						TE32KDeactivate ((*(dialogInfo->common)->cMsgEdit.bodytext)->bodytext);					}					if ((dialogInfo->common)->cMsgEdit.currentTE)					{						TE32KActivate ((dialogInfo->common)->cMsgEdit.te.array[(dialogInfo->common)->cMsgEdit.currentTE - 1]);						LongRectToRect (&(*(dialogInfo->common)->cMsgEdit.te.array[(dialogInfo->common)->cMsgEdit.currentTE-1])->viewRect, &rView);						InsetRect (&rView, -2, -2);						InvalRect (&rView);						TE32KSetSelect (0, 0x07FFF,									(dialogInfo->common)->cMsgEdit.te.array[(dialogInfo->common)->cMsgEdit.currentTE - 1]);					}					else					{						TE32KActivate ((*(dialogInfo->common)->cMsgEdit.bodytext)->bodytext);					}				}				else				{					if (oldTE)					{						TE32KClick (where, (event->modifiers & shiftKey) != 0,							(dialogInfo->common)->cMsgEdit.te.array[oldTE - 1]);					}					else					{						LongRectToRect (&(*((*(dialogInfo->common)->cMsgEdit.bodytext)->bodytext))->viewRect, &tRect);												if (PtInRect (where, &tRect))						{							TE32KClick (where, (event->modifiers & shiftKey) != 0,									(*(dialogInfo->common)->cMsgEdit.bodytext)->bodytext);													if ((*(dialogInfo->common)->cMsgEdit.bodytext)->scroll)								myTEScrollRedraw ((dialogInfo->common)->cMsgEdit.bodytext);						}					}				}				//				color.red = color.green = color.blue = 50000;				RGBBackColor(&color1);			}			break;		case inZoomIn:		case inZoomOut:			SetPort (dialogInfo->dialog);			if (TrackBox (dialogInfo->dialog, event->where, info >> 16))			{				SetPort (dialogInfo->dialog);				ZoomWindow (dialogInfo->dialog, info >> 16, true);				AdjustWinSize ((dialogInfo->common)->cMsgEdit.bodytext, (dialogInfo->dialog)->portRect.bottom);				EraseRect (&(dialogInfo->dialog)->portRect);				GetBackColor (&color1);				color.red = color.green = color.blue = 0xFFFF;				RGBBackColor(&color);				LongRectToRect (&(*((*(dialogInfo->common)->cMsgEdit.bodytext)->bodytext))->viewRect, &tRect);				EraseRect (&tRect);//				color.red = color.green = color.blue = 50000;				RGBBackColor(&color1);				originalView = (*(((WindowPeek)(dialogInfo->dialog))->contRgn))->rgnBBox;				originalView.bottom = (dialogInfo->dialog)->portRect.bottom;				InvalRect (&(dialogInfo->dialog)->portRect);			}			break;				case inGoAway:					if (TrackGoAway (dialogInfo->dialog, event->where))				if (event->modifiers & optionKey)					Broadcast (wtMsgEdit, broadClose, -1, 0);				else					WEditEventProcessor (event, dialogInfo, actionClose);						break;		case inDrag:			FindWindow (event->where, &window);						if (window != FrontWindow ())			{				if (((WindowPeek)FrontWindow ())->windowKind == myKind_top)					SysBeep (10);				else					SelectWindow (window);			}			else			{				DragWindow ( dialogInfo->dialog, event->where, &qd.screenBits.bounds );				originalView = (*(((WindowPeek)(dialogInfo->dialog))->contRgn))->rgnBBox;				originalView.bottom = (dialogInfo->dialog)->portRect.bottom;			}						break;		case inGrow:					SetPort (dialogInfo->dialog);			GetDialogItem ( dialogInfo->dialog, miBody, &iType, &iHandle, &rView );						rDataBnds.top = rView.top + 10 * (*((*((dialogInfo->common)->cMsgEdit.bodytext))->bodytext))->lineHeight;			rDataBnds.bottom = qd.screenBits.bounds.bottom;			rDataBnds.left = (dialogInfo->dialog)->portRect.right;			rDataBnds.right = (dialogInfo->dialog)->portRect.right + 1;			SetPort (dialogInfo->dialog);			lSizeVH = GrowWindow ( dialogInfo->dialog, event->where, &rDataBnds );						if (lSizeVH)			{				SizeWindow (dialogInfo->dialog, LoWord (lSizeVH), HiWord (lSizeVH), true);				AdjustWinSize ((dialogInfo->common)->cMsgEdit.bodytext, HiWord (lSizeVH));				EraseRect (&(dialogInfo->dialog)->portRect);				GetBackColor (&color1);				color.red = color.green = color.blue = 0xFFFF;				RGBBackColor(&color);				LongRectToRect (&(*((*(dialogInfo->common)->cMsgEdit.bodytext)->bodytext))->viewRect, &tRect);				EraseRect (&tRect);//				color.red = color.green = color.blue = 50000;				RGBBackColor(&color1);				InvalRect (&(dialogInfo->dialog)->portRect);			}						break;		}			break;		case keyDown:	case autoKey:		//		key = event->message & 0xFF;//		TE32KKey (key, (*((dialogInfo->common)->cMsgEdit.bodytext))->bodytext);//		myTEScrollRedraw ((dialogInfo->common)->cMsgEdit.bodytext);		SetPort (dialogInfo->dialog);		key = event->message & 0xFF;				GetBackColor (&color1);		color.red = color.green = color.blue = 0xFFFF;		RGBBackColor(&color);		switch (key)		{		case HelpKey:			if ((dialogInfo->common)->cMsgEdit.area_number)				break;							if ((dialogInfo->common)->cMsgEdit.currentTE == 4)			{				if (!(*(dialogInfo->common)->cMsgEdit.te.named.toaddr)->teLength)					break;								memcpy ((char *) &stemp[0], *(*(dialogInfo->common)->cMsgEdit.te.named.toaddr)->hText,					(*(dialogInfo->common)->cMsgEdit.te.named.toaddr)->teLength);				stemp[(*(dialogInfo->common)->cMsgEdit.te.named.toaddr)->teLength] = 0;								tempaddr.zone = 0;				tempaddr.net = 0;				tempaddr.node = 0;				tempaddr.point = 0;							parseaddr (&tempaddr, (char *) &stemp[0]);								if (!tempaddr.zone && !tempaddr.net && !tempaddr.node && !tempaddr.point )					break;								if ( !tempaddr.zone )					tempaddr.zone = ((dialogInfo->common)->cMsgEdit.MessageBody)->from.zone;								if ( !tempaddr.net )					tempaddr.net = ((dialogInfo->common)->cMsgEdit.MessageBody)->from.net;								printaddr ( &tempaddr, (char *) &stemp1[1] );				stemp1[0] = strlen ((char *) &stemp1[1]);								if ( GetNameFromAddr ( &tempaddr, stemp ) )				{//					RectToLongRect (&(dialogInfo->dialog)->portRect, &tlRect);					color.red = color.green = color.blue = 0xFFFF;					RGBBackColor(&color);					TE32KSetText ((char *) &stemp[1], stemp[0], (dialogInfo->common)->cMsgEdit.te.named.to);					littleTE32KUpdate (&(dialogInfo->dialog)->portRect, (dialogInfo->common)->cMsgEdit.te.named.to);										TE32KSetText ((char *) &stemp1[1], stemp1[0], (dialogInfo->common)->cMsgEdit.te.named.toaddr);					littleTE32KUpdate (&(dialogInfo->dialog)->portRect, (dialogInfo->common)->cMsgEdit.te.named.toaddr);//					color.red = color.green = color.blue = 50000;					RGBBackColor(&color1);				}				else					CallASndPlay (129);			}			else				if ((dialogInfo->common)->cMsgEdit.currentTE == 3)				{					if ((dialogInfo->common)->cMsgEdit.MessageBody)					{						if (((dialogInfo->common)->cMsgEdit.MessageBody)->from.node)							ltemp = 2;						else							if (((dialogInfo->common)->cMsgEdit.MessageBody)->from.net)								ltemp = 1;							else								ltemp = 0;												WNodeEventProcessor ((EventRecord *) ltemp,							(windowsQElPtr) &((dialogInfo->common)->cMsgEdit.MessageBody)->from, actionCreate);					}					else						WNodeEventProcessor (NULL, NULL, actionCreate);										Broadcast (wtNodelist, broadGlobalResync, broadGlobalResync, (long) dialogInfo);				}							break;		case DeleteFwdKey:						if ((dialogInfo->common)->cMsgEdit.currentTE)				myTEDel ((dialogInfo->common)->cMsgEdit.te.array[(dialogInfo->common)->cMsgEdit.currentTE - 1]);			else			{				RegisterUndo (dialogInfo, undoKilling);				myTEDel ((*(dialogInfo->common)->cMsgEdit.bodytext)->bodytext);					}						break;				case TabKey:						oldTE = (dialogInfo->common)->cMsgEdit.currentTE;						if (oldTE)			{				switch (oldTE)				{				case 1:		//	fromname									(dialogInfo->common)->cMsgEdit.currentTE = 3;	//	toname					break;									case 3:		//	toname									(dialogInfo->common)->cMsgEdit.currentTE =						((dialogInfo->common)->cMsgEdit.area_number == 0) ? 4 : 5;	//	toaddr or subj					break;				case 4:		//	toaddr					(dialogInfo->common)->cMsgEdit.currentTE = 5;	//	subj					break;									case 5:		//	subj									(dialogInfo->common)->cMsgEdit.currentTE = 1;	//	fromname					break;				}							if (oldTE != (dialogInfo->common)->cMsgEdit.currentTE)				{					TE32KSetSelect (0, 0,								(dialogInfo->common)->cMsgEdit.te.array[oldTE - 1]);					TE32KDeactivate ((dialogInfo->common)->cMsgEdit.te.array[oldTE - 1]);					LongRectToRect (&(*(dialogInfo->common)->cMsgEdit.te.array[oldTE-1])->viewRect, &rView);					InsetRect (&rView, -2, -2);					InvalRect (&rView);					TE32KActivate ((dialogInfo->common)->cMsgEdit.te.array[(dialogInfo->common)->cMsgEdit.currentTE - 1]);					LongRectToRect (&(*(dialogInfo->common)->cMsgEdit.te.array[(dialogInfo->common)->cMsgEdit.currentTE-1])->viewRect, &rView);					InsetRect (&rView, -2, -2);					InvalRect (&rView);					TE32KSetSelect (0, 0x07FFF,								(dialogInfo->common)->cMsgEdit.te.array[(dialogInfo->common)->cMsgEdit.currentTE - 1]);				}			}			else			{				(dialogInfo->common)->cMsgEdit.dirty = 1;				goto allother;			}						break;				case 0x1B:						if ((dialogInfo->common)->cMsgEdit.currentTE)			{				WEditEventProcessor (NULL, dialogInfo, actionClose);			}			else			{				TE32KDeactivate ((*(dialogInfo->common)->cMsgEdit.bodytext)->bodytext);				TE32KActivate ((dialogInfo->common)->cMsgEdit.te.named.to);				LongRectToRect (&(*(dialogInfo->common)->cMsgEdit.te.named.to)->viewRect, &rView);				InsetRect (&rView, -2, -2);				InvalRect (&rView);				TE32KSetSelect (0, 0x07FFF, (dialogInfo->common)->cMsgEdit.te.named.to);				(dialogInfo->common)->cMsgEdit.currentTE = 3;			}						break;				case EnterKey:		case ReturnKey:					oldTE = (dialogInfo->common)->cMsgEdit.currentTE;			if (oldTE)			{				if (!(dialogInfo->common)->cMsgEdit.firsttouch)				{					if (!checkPossibility (dialogInfo) /*||						(dialogInfo->common)->cMsgEdit.editmode == editPost*/)					{						CallASndPlay (132);					}					else					{						(dialogInfo->common)->cMsgEdit.firsttouch = 1;						(dialogInfo->common)->cMsgEdit.currentTE = 0;						PrepareBody (dialogInfo);					}				}				else					(dialogInfo->common)->cMsgEdit.currentTE = 0;				if (oldTE != (dialogInfo->common)->cMsgEdit.currentTE)				{					TE32KSetSelect (0, 0, (dialogInfo->common)->cMsgEdit.te.array[oldTE - 1]);					TE32KDeactivate ((dialogInfo->common)->cMsgEdit.te.array[oldTE - 1]);					LongRectToRect (&(*(dialogInfo->common)->cMsgEdit.te.array[oldTE-1])->viewRect, &rView);					InsetRect (&rView, -2, -2);					InvalRect (&rView);					TE32KActivate ((*(dialogInfo->common)->cMsgEdit.bodytext)->bodytext);				}				break;			}			else			if ((*(*(dialogInfo->common)->cMsgEdit.bodytext)->bodytext)->selStart ==					(*(*(dialogInfo->common)->cMsgEdit.bodytext)->bodytext)->selEnd)			{				long lineInx, thisStart;				short qstart, qend;				char *textPtr;				Boolean needsplit = false;				char initials[64];							lineInx = TE32KIndexToLine((*(*(dialogInfo->common)->cMsgEdit.bodytext)->bodytext)->selStart,					(*(dialogInfo->common)->cMsgEdit.bodytext)->bodytext);								HLock((*(*(dialogInfo->common)->cMsgEdit.bodytext)->bodytext)->hText);				thisStart = (*(*(dialogInfo->common)->cMsgEdit.bodytext)->bodytext)->lineStarts[lineInx];				textPtr = *(*(*(dialogInfo->common)->cMsgEdit.bodytext)->bodytext)->hText;				if (hasInitials ((char *) &(textPtr[thisStart]), &qstart, &qend) &&					thisStart + qend < (*(*(dialogInfo->common)->cMsgEdit.bodytext)->bodytext)->selStart)				{					memset(initials, 0, 64);					initials[0] = ' ';					memcpy(&initials[1], &textPtr[thisStart+qstart], qend-qstart+1);					strcat(initials, " ");					needsplit = true;				}								HUnlock((*(*(dialogInfo->common)->cMsgEdit.bodytext)->bodytext)->hText);							if (needsplit)				{					RegisterUndo (dialogInfo, undoTyping);					TE32KKey (ReturnKey, (*(dialogInfo->common)->cMsgEdit.bodytext)->bodytext);							AdjustV ((*(dialogInfo->common)->cMsgEdit.bodytext)->scroll,						(*(dialogInfo->common)->cMsgEdit.bodytext)->bodytext, false);										TE32KInsert (initials, strlen(initials), (*(dialogInfo->common)->cMsgEdit.bodytext)->bodytext);										break;				}			}						key = ReturnKey;			(dialogInfo->common)->cMsgEdit.dirty = 1;			goto allother;				case HomeKey:					if ((dialogInfo->common)->cMsgEdit.currentTE)				TE32KSetSelect (0, 0, (dialogInfo->common)->cMsgEdit.te.array[(dialogInfo->common)->cMsgEdit.currentTE - 1]);			else			{				TE32KSetSelect (0, 0, (*((dialogInfo->common)->cMsgEdit.bodytext))->bodytext);//				TE32KKey (DownArrowKey, (*(dialogInfo->common)->cMsgEdit.bodytext)->bodytext);				TE32KKey (UpArrowKey, (*(dialogInfo->common)->cMsgEdit.bodytext)->bodytext);				AdjustV ((*((dialogInfo->common)->cMsgEdit.bodytext))->scroll,					(*((dialogInfo->common)->cMsgEdit.bodytext))->bodytext, true);			}						break;					case EndKey:					if ((dialogInfo->common)->cMsgEdit.currentTE)				TE32KSetSelect (0x7FFF, 0x7FFF, (dialogInfo->common)->cMsgEdit.te.array[(dialogInfo->common)->cMsgEdit.currentTE - 1]);			else			{				TE32KSetSelect (0x7FFFFFFFL, 0x7FFFFFFFL, (*((dialogInfo->common)->cMsgEdit.bodytext))->bodytext);//				TE32KKey (UpArrowKey, (*(dialogInfo->common)->cMsgEdit.bodytext)->bodytext);				TE32KKey (DownArrowKey, (*(dialogInfo->common)->cMsgEdit.bodytext)->bodytext);				AdjustV ((*((dialogInfo->common)->cMsgEdit.bodytext))->scroll,					(*((dialogInfo->common)->cMsgEdit.bodytext))->bodytext, true);			}						break;					case PageDownKey:		//			color.red = color.green = color.blue = 0xFFFF;//			RGBBackColor(&color);			VActionProc ((*((dialogInfo->common)->cMsgEdit.bodytext))->scroll, kControlPageDownPart);//			color.red = color.green = color.blue = 50000;//			RGBBackColor(&color);			break;				case PageUpKey:		//			color.red = color.green = color.blue = 0xFFFF;//			RGBBackColor(&color);			VActionProc ((*((dialogInfo->common)->cMsgEdit.bodytext))->scroll, kControlPageUpPart);//			color.red = color.green = color.blue = 50000;//			RGBBackColor(&color);			break;				default:			(dialogInfo->common)->cMsgEdit.dirty = 1;					case LeftArrowKey:		case RightArrowKey:		case DownArrowKey:		case UpArrowKey:		allother:					if ((dialogInfo->common)->cMsgEdit.currentTE)				TE32KKey (key, (dialogInfo->common)->cMsgEdit.te.array[(dialogInfo->common)->cMsgEdit.currentTE - 1]);			else			{				if (key != LeftArrowKey && key != RightArrowKey && key != DownArrowKey && key != UpArrowKey)					RegisterUndo (dialogInfo, (key == BackSpaceKey) ? undoKilling : undoTyping);				else					(*(dialogInfo->common)->cMsgEdit.bodytext)->undotype = 0;				TE32KKey (key, (*(dialogInfo->common)->cMsgEdit.bodytext)->bodytext);						AdjustV ((*(dialogInfo->common)->cMsgEdit.bodytext)->scroll,					(*(dialogInfo->common)->cMsgEdit.bodytext)->bodytext, false);			}						break;		}		//		color.red = color.green = color.blue = 50000;		RGBBackColor(&color1);				break;			case updateEvt:		SetPort (dialogInfo->dialog);		BeginUpdate (dialogInfo->dialog);//		iRect = (*(((WindowPeek)(dialogInfo->dialog))->updateRgn))->rgnBBox;		//		GlobalToLocal (&topLeft(iRect));//		GlobalToLocal (&botRight(iRect));		//		EraseRect (&iRect);		GetBackColor (&color1);		color.red = color.green = color.blue = 0xFFFF;		RGBBackColor(&color);		LongRectToRect (&(*((*(dialogInfo->common)->cMsgEdit.bodytext)->bodytext))->viewRect, &iRect);		iRect.bottom = (dialogInfo->dialog)->portRect.bottom - 2;		EraseRect (&iRect);//		color.red = color.green = color.blue = 50000;		RGBBackColor(&color1);		DrawContents (dialogInfo->common);//		GetBackColor (&color1);		color.red = color.green = color.blue = 0xFFFF;		RGBBackColor(&color);//		LongRectToRect (&(*((*(dialogInfo->common)->cMsgEdit.bodytext)->bodytext))->viewRect, &tRect);//		EraseRect (&tRect);//		color.red = color.green = color.blue = 50000;		RGBBackColor(&color1);		UpdateDialog (dialogInfo->dialog, (dialogInfo->dialog)->visRgn);		if (needpgf)			TE32KFeatureFlag (te32KFShowCarridgeReturns, TE32KBitSet, (*((dialogInfo->common)->cMsgEdit.bodytext))->bodytext);		else			TE32KFeatureFlag (te32KFShowCarridgeReturns, TE32KBitClear, (*((dialogInfo->common)->cMsgEdit.bodytext))->bodytext);		myTEUpdate ((dialogInfo->common)->cMsgEdit.bodytext);				if (!(dialogInfo->inFront))		{			SetRect (&iRect,				(*(*((dialogInfo->common)->cMsgEdit.bodytext))->bodytext)->viewRect.right + 2,				(*(*((dialogInfo->common)->cMsgEdit.bodytext))->bodytext)->viewRect.top - 2,				(dialogInfo->dialog)->portRect.right,				(dialogInfo->dialog)->portRect.bottom - 15);						EraseRect (&iRect);			MoveTo (iRect.left, iRect.top);			LineTo (iRect.left, iRect.bottom);		}		color.red = color.green = color.blue = 0xFFFF;		RGBBackColor(&color);//		RectToLongRect (&(dialogInfo->dialog)->portRect, &tlRect);		littleTE32KUpdate (&(dialogInfo->dialog)->portRect, (dialogInfo->common)->cMsgEdit.te.named.from);		littleTE32KUpdate (&(dialogInfo->dialog)->portRect, (dialogInfo->common)->cMsgEdit.te.named.to);		littleTE32KUpdate (&(dialogInfo->dialog)->portRect, (dialogInfo->common)->cMsgEdit.te.named.toaddr);		littleTE32KUpdate (&(dialogInfo->dialog)->portRect, (dialogInfo->common)->cMsgEdit.te.named.subj);		littleTE32KUpdate (&(dialogInfo->dialog)->portRect, (dialogInfo->common)->cMsgEdit.te.named.date);//		color.red = color.green = color.blue = 50000;		RGBBackColor(&color1);		UpdateControls (dialogInfo->dialog, (dialogInfo->dialog)->visRgn);		DrawPopUp ((dialogInfo->common)->cMsgEdit.flagsPopUp);		DrawPopUp ((dialogInfo->common)->cMsgEdit.AkaPopUp);		DrawOnlyGrowIcon (dialogInfo->dialog);		EndUpdate (dialogInfo->dialog);		break;	case nullEvent:				where = event->where;		GetPort (&oldPort);		SetPort (dialogInfo->dialog);				if (!(dialogInfo->common)->cMsgEdit.currentTE)			myTEIdle ((*(dialogInfo->common)->cMsgEdit.bodytext)->bodytext, false);		else			myTEIdle ((dialogInfo->common)->cMsgEdit.te.array[(dialogInfo->common)->cMsgEdit.currentTE - 1], false);		GlobalToLocal (&where);		LongRectToRect (&(*((*(dialogInfo->common)->cMsgEdit.bodytext)->bodytext))->viewRect, &tRect);				if (PtInRect (where, &tRect))		{			iType = 0;//			SetCursor (&iBeam);		}		else			iType = -1;//			InitCursor ();		if (crsI != iType)		{			crsI = iType;						if (crsI < 0)				InitCursor ();			else				SetCursor (&crs[crsI]);		}		SetPort (oldPort);		break;	}}void WEditDialogProcessor (EventRecord *event, windowsQElPtr dialogInfo, long info){	RGBColor	color, color1;	DialogPtr	dialog;	short		iHit, ii;	Point		where;	//	LongRect	tlRect;	Boolean		was_empty;	Handle		iHandle;	short		iType;	Rect		rView;			if (event->what == updateEvt)		return;		if (IsDialogEvent (event))	{		if (DialogSelect (event, &dialog, &iHit))		{			switch (iHit)			{			case miFlags:				//				if ((dialogInfo->common)->cMsgEdit.area_number)//					break;								if (!(dialogInfo->common)->cMsgEdit.area_number)				{					if ((**(dialogInfo->common)->cMsgEdit.flagsPopUp).statmenu & (1L << ffAttach))						(**(dialogInfo->common)->cMsgEdit.flagsPopUp).enable |= (1L << ffAttKill);					else						(**(dialogInfo->common)->cMsgEdit.flagsPopUp).enable &= ~(1L << ffAttKill);				}								if (HandlePopUp ((dialogInfo->common)->cMsgEdit.flagsPopUp, NULL))				{					switch ((**(dialogInfo->common)->cMsgEdit.flagsPopUp).theValue)					{					case ffHold:					case ffDirect:					case ffCrash:												if ((**(dialogInfo->common)->cMsgEdit.flagsPopUp).statmenu &							(1L << (**(dialogInfo->common)->cMsgEdit.flagsPopUp).theValue))						{							(**(dialogInfo->common)->cMsgEdit.flagsPopUp).statmenu &=								~((1L << ffHold) | (1L << ffDirect) | (1L << ffCrash));							break;						}						(**(dialogInfo->common)->cMsgEdit.flagsPopUp).statmenu &=							~((1L << ffHold) | (1L << ffDirect) | (1L << ffCrash));						(**(dialogInfo->common)->cMsgEdit.flagsPopUp).statmenu |=							(1L << (**(dialogInfo->common)->cMsgEdit.flagsPopUp).theValue);						break;					case ffPrivate:											if (((**(dialogInfo->common)->cMsgEdit.flagsPopUp).statmenu & (1L << ffPrivate)) == 0)						{#if defined(powerc) || defined(__powerc)							ii = Alert (504, uupMyAlertProc);#else							ii = Alert (504, myAlertProc);#endif							if (ii == 1)								break;						}					case ffKillSent:					case ffRRq:					case ffCfm:					case ffAttKill:						(**(dialogInfo->common)->cMsgEdit.flagsPopUp).statmenu ^=							(1L << (**(dialogInfo->common)->cMsgEdit.flagsPopUp).theValue);						break;											case ffAttach:					//	process file here											was_empty = ((**(dialogInfo->common)->cMsgEdit.flagsPopUp).statmenu & (1L << ffAttach)) == 0L;											if (was_empty)						{							register	Point	where = {0,0};							SFReply		reply;							Str255		fName;							SFPGetFile (where, "\p", NULL, -1, NULL, NULL, &reply, 4000, NULL);//							SFGetFile ( where, "\p", NULL, -1, NULL, NULL, &reply );														if (reply.good)							{								PathNameFromWD ( reply.vRefNum, fName );								pStrConc ( fName, reply.fName, fName );																if (fName[0] > MSubject)								{									CallASndPlay (132);									break;								}								else								{									TE32KSetText ((char *) &fName[1], fName[0],											(dialogInfo->common)->cMsgEdit.te.named.subj);								}							}							else								break;						}												GetBackColor (&color1);						color.red = color.green = color.blue = 0xFFFF;						RGBBackColor(&color);						(*(dialogInfo->common)->cMsgEdit.te.named.subj)->txFont = (was_empty) ? 4 : viewFont;//						RectToLongRect (&(dialogInfo->dialog)->portRect, &tlRect);						littleTE32KUpdate (&(dialogInfo->dialog)->portRect, (dialogInfo->common)->cMsgEdit.te.named.subj);//						color.red = color.green = color.blue = 50000;						RGBBackColor(&color1);					case ffFreq:												if ((**(dialogInfo->common)->cMsgEdit.flagsPopUp).theValue == ffFreq)						{							was_empty = ((**(dialogInfo->common)->cMsgEdit.flagsPopUp).statmenu & (1L << ffFreq)) == 0L;						}												GetDialogItem ( (dialogInfo->common)->cMsgEdit.dialog, 12, &iType, &iHandle, &rView );						SetDialogItemText (iHandle, (was_empty) ? "\pFile:" : "\pSubj:");						if ((**(dialogInfo->common)->cMsgEdit.flagsPopUp).statmenu &							(1L << (**(dialogInfo->common)->cMsgEdit.flagsPopUp).theValue))						{							(**(dialogInfo->common)->cMsgEdit.flagsPopUp).statmenu &=								~((1L << ffFreq) | (1L << ffAttach) | (1L << ffAttKill));							break;						}												(**(dialogInfo->common)->cMsgEdit.flagsPopUp).statmenu &=							~((1L << ffFreq) | (1L << ffAttach) | (1L << ffAttKill));						(**(dialogInfo->common)->cMsgEdit.flagsPopUp).statmenu |=							(1L << (**(dialogInfo->common)->cMsgEdit.flagsPopUp).theValue);						break;					}				}								event->what = 0;				break;							case miAka:								HandlePopUp ((dialogInfo->common)->cMsgEdit.AkaPopUp, FullAKAs);								if ((dialogInfo->common)->cMsgEdit.firsttouch)				{					char	*p;					Handle	hh;					long	whr1, whr2, whr3, whr4, len = (*((*((dialogInfo->common)->cMsgEdit.bodytext))->bodytext))->teLength;					Str255	ttt;														hh = (*((*((dialogInfo->common)->cMsgEdit.bodytext))->bodytext))->hText;					HLock (hh);										p = *hh;					whr1 = 0;										while (whr1 < len && p[whr1])					{						if ( !strncmp ( &p[whr1], " * Origin: ", 11 ) )							break;						while (p[whr1] && p[whr1] != 0x0D)							whr1++;												if (p[whr1] == 0x0D)							whr1++;					}					if (whr1 < len && p[whr1])					{						whr2 = whr1;											while (whr1 < len && p[whr1] && p[whr1] != 0x0D)							whr1++;												if (whr1 < len && p[whr1])						{							whr1--;													while (whr1 > whr2 && p[whr1] != '(')							{								if (p[whr1] == ')')									whr3 = whr1;								whr1--;							}														if (whr1 > whr2)							{								GetBackColor (&color1);								color.red = color.green = color.blue = 0xFFFF;								RGBBackColor(&color);								whr2 = (*((*((dialogInfo->common)->cMsgEdit.bodytext))->bodytext))->selStart;								whr4 = (*((*((dialogInfo->common)->cMsgEdit.bodytext))->bodytext))->selEnd;								TE32KSetSelect (whr1+1, whr3, (*(dialogInfo->common)->cMsgEdit.bodytext)->bodytext);								GetCItemPopUp ((dialogInfo->common)->cMsgEdit.AkaPopUp, FullAKAs, ttt);								TE32KDelete ((*(dialogInfo->common)->cMsgEdit.bodytext)->bodytext);								TE32KInsert ((char *) &ttt[1], ttt[0], (*(dialogInfo->common)->cMsgEdit.bodytext)->bodytext);								TE32KSetSelect (whr2, whr4, (*(dialogInfo->common)->cMsgEdit.bodytext)->bodytext);//								color.red = color.green = color.blue = 50000;								RGBBackColor(&color1);							}						}					}										HUnlock (hh);				}								event->what = 0;				break;							default:							break;			}		}	}}