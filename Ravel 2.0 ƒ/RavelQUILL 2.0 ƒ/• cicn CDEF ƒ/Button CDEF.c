#include	<Controls.h>#include 	<GrayColors.h>#define depthKey		2#define checkSize		12#define checkOffset		3enum {	ChunkyDepth = 0x0D60		/*[GLOBAL VAR]  depth of the pixels*/};#define DepthScreen	*(short *)(ChunkyDepth)static Boolean HasColor (void);static void Draw3DKey (Rect r, short depth, Boolean state);static void Draw3DCircle (Rect r, Boolean state);static void Draw (ControlHandle	control, short variation);static void DrawCenterString (Rect r, Str255 string, short center, Boolean state);pascal long main (short variation, ControlHandle control, short message, long param){	long		returnValue = 0L;	char		state;	Rect 		itemRect;	short 		var;	RgnHandle	reg;	GrafPtr		oldport;	state = HGetState ((Handle) control);	HLock ((Handle) control);	GetPort (&oldport);	itemRect = (*control)->contrlRect;	var = (short) GetCVariant (control);	switch (message) {		case drawCntl:			SetPort ((*control)->contrlOwner);			Draw (control, var);			break;		case testCntl:			SetPort ((*control)->contrlOwner);			if (((*control)->contrlVis != 0) && 					((*control)->contrlHilite != 255) &&						(PtInRect(*(Point *)&param, &itemRect)))				returnValue = inButton;			else				returnValue = false;			break;					case calcCRgns:			SetPort ((*control)->contrlOwner);			reg = (RgnHandle) StripAddress ((void *) param);			OpenRgn();			FrameRect (&itemRect);			CloseRgn (reg);			break;		case dragCntl:			returnValue = 0;						break;		case calcCntlRgn:			SetPort ((*control)->contrlOwner);			reg = (RgnHandle) param;			OpenRgn();			FrameRect (&itemRect);			CloseRgn (reg);			break;		default:			break;	}	HSetState ((Handle) control, state);	SetPort (oldport);	return (returnValue);	}static Boolean HasColor (){	SysEnvRec	myComputer;		SysEnvirons (2, &myComputer);	if (myComputer.hasColorQD && (DepthScreen > 1))		return true;	else		return false;}static void Draw3DKey (Rect r, short depth, Boolean state){	RGBColor	oldback, oldfore;	PenState 	oldstate;	Boolean 	hascolor;	short 		j;	hascolor = HasColor ();	if (hascolor) {		GetBackColor (&oldback);		GetForeColor (&oldfore);		GrayBackColor ((state) ? BackDark : BackLight);		GrayForeColor (ForeMain);	} else {		BackColor (whiteColor);		ForeColor (blackColor);	}					GetPenState (&oldstate);	PenNormal ();	InsetRect (&r, depth, depth);	EraseRect (&r);	InsetRect (&r, -1, -1);	FrameRect (&r);	for (j = depth; j > 0; j--) {		InsetRect (&r, 1, 1);		if (hascolor) 			GrayForeColor ((state) ? FrameLight : FrameDark);					else			ForeColor ((state) ? whiteColor : blackColor);		MoveTo (r.right-1, r.top);		LineTo (r.right-1, r.bottom-1);		LineTo (r.left, r.bottom-1);		if (hascolor) 			GrayForeColor ((state) ? FrameDark : FrameLight);					else 			ForeColor ((state) ? blackColor : whiteColor);		LineTo (r.left, r.top);		LineTo (r.right-1, r.top);	}	SetPenState (&oldstate);	if (hascolor) {		RGBBackColor (&oldback);		RGBForeColor (&oldfore);	} else		ForeColor (blackColor);}static void Draw3DCircle (Rect r, Boolean state){	RGBColor	oldback, oldfore;	Pattern		myGray;	if (HasColor ()) {		GetBackColor (&oldback);		GetForeColor (&oldfore);		GrayBackColor (BackLight);		GrayForeColor (ForeMain);		InsetRect (&r, 1, 1);		EraseOval (&r);		FrameOval (&r);		if (state) {			GrayForeColor (ForeMain);			GetIndPattern (&myGray, 0, 1);			InsetRect (&r, 3, 3);			FillOval (&r, &myGray);		}		RGBBackColor (&oldback);		RGBForeColor (&oldfore);	} else {		EraseRect (&r);		if (state) {			GetIndPattern (&myGray, 0, 4);			r.left++;			r.top++;			FillOval (&r, &myGray);			FrameOval (&r);		} else {			r.left++;			r.top++;			FrameOval (&r);			OffsetRect (&r, -1, -1);			EraseOval (&r);			FrameOval (&r);		}			}}static void DrawCenterString (Rect r, Str255 string, short center, Boolean state){	FontInfo 	fi;	GrafPtr		myPort;	short 		Height, oldsize, oldfont, oldface;	RGBColor	oldback, oldfore;	PenState 	oldstate;	Pattern		myGray;	GetPort (&myPort);	oldsize = myPort->txSize;	oldfont = myPort->txFont;	oldface = myPort->txFace;	TextFont (1);	TextFace (1);	TextSize (9);	GetFontInfo (&fi);	Height = fi.ascent+fi.descent+fi.leading;	r.top = r.top+(r.bottom-r.top-Height)/2;	r.bottom = r.top+Height;	if (center)		MoveTo (r.left+(r.right-r.left-StringWidth (string))/2,				r.bottom-fi.leading-fi.descent-1);	else		MoveTo (r.left+depthKey+1, r.bottom-fi.leading-fi.descent);	if (HasColor ()) {		GetBackColor (&oldback);		GetForeColor (&oldfore);		GrayForeColor ((state) ? HiliteMain : ForeMain);					GrayBackColor (BackMain);					DrawString (string);		RGBBackColor (&oldback);		RGBForeColor (&oldfore);	} else {		DrawString (string);		if (state) {			GetPenState (&oldstate);			PenNormal ();			InsetRect (&r, depthKey, depthKey);			GetIndPattern (&myGray, 0, 4);			PenPat (&myGray);			PenMode (patBic);			PaintRect (&r);			SetPenState (&oldstate);		}	}	TextFont (oldfont);	TextFace (oldface);	TextSize (oldsize);}static void Draw (ControlHandle	control, short variation){	Rect 			myRect, rect1;	PenState		oldstate;	Boolean 		pressed, hiliteMode;	if (!(*control)->contrlVis) return;	rect1 = myRect = (*control)->contrlRect;	hiliteMode = ((*control)->contrlHilite == 255);	pressed = (((*control)->contrlHilite == inButton) ||				((*control)->contrlHilite == 1));	rect1.top = rect1.top+(rect1.bottom-rect1.top-checkSize)/2;	rect1.bottom = rect1.top + checkSize;	rect1.left += checkOffset;	rect1.right = rect1.left+checkSize;	switch (variation) {		case 0:			Draw3DKey (myRect, depthKey, pressed);			InsetRect (&myRect, depthKey, depthKey);			if (pressed)				OffsetRect (&myRect, 1, 1);			DrawCenterString (myRect, (*control)->contrlTitle, 1, hiliteMode);			break;					case 1:			myRect.left = rect1.right+checkOffset;			Draw3DKey (rect1, 1, true); 			InsetRect (&rect1, 3, 3);			if ((*control)->contrlValue) {				GetPenState (&oldstate);				PenNormal ();				PenSize (2, 1);				MoveTo (rect1.left, rect1.top);				Move (0, (rect1.bottom-rect1.top)/2);				Line (2, (rect1.bottom-rect1.top)/2-1);				LineTo (rect1.right-2, rect1.top);				SetPenState (&oldstate);			}			DrawCenterString (myRect, (*control)->contrlTitle, 0, hiliteMode);			break;		case 2:			myRect.left = rect1.right+checkOffset;			Draw3DCircle (rect1, (*control)->contrlValue); 			DrawCenterString (myRect, (*control)->contrlTitle, 0, hiliteMode);			break;	}}