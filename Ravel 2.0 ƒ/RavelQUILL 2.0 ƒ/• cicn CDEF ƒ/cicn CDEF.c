#include <Controls.h>#include <Icons.h>#define depthKey		2#define checkSize		12#define checkOffset		3enum {	ChunkyDepth = 0x0D60		/*[GLOBAL VAR]  depth of the pixels*/};#define DepthScreen	*(short *)(ChunkyDepth)static Boolean HasColor (void);static void Draw (ControlHandle	control, short variation, short cicnID);pascal long main (short variation, ControlHandle control, short message, long param){	long		returnValue = 0L;	char		state;	Rect 		iRect;	short 		var, cID;	RgnHandle	reg;	GrafPtr		oldport;	CIconHandle	cHandle;		state = HGetState ((Handle) control);	HLock ((Handle) control);	GetPort (&oldport);	iRect = (*control)->contrlRect;	var = (short) GetControlVariant (control);	cID = GetControlValue (control);	switch (message)	{		case initCntl:					cHandle = (CIconHandle) Get1Resource ('cicn', cID);						if (cHandle)			{				(*control)->contrlRect.right = (*control)->contrlRect.left + (*cHandle)->iconPMap.bounds.right;				(*control)->contrlRect.bottom = (*control)->contrlRect.top + (*cHandle)->iconPMap.bounds.bottom;			}						break;					case drawCntl:						SetPort ((*control)->contrlOwner);			Draw (control, var, cID);			break;		case testCntl:						SetPort ((*control)->contrlOwner);			if (((*control)->contrlVis != 0) && 					((*control)->contrlHilite != 255) &&						(PtInRect(*(Point *)&param, &iRect)))				returnValue = kControlButtonPart;			else				returnValue = false;			break;					case calcCRgns:						SetPort ((*control)->contrlOwner);			reg = (RgnHandle) StripAddress ((void *) param);			OpenRgn();			FrameRect (&iRect);			CloseRgn (reg);			break;		case dragCntl:						returnValue = 0;						break;		case calcCntlRgn:						SetPort ((*control)->contrlOwner);			reg = (RgnHandle) param;			OpenRgn();			FrameRect (&iRect);			CloseRgn (reg);			break;		default:						break;	}		HSetState ((Handle) control, state);	SetPort (oldport);	return (returnValue);	}static Boolean HasColor (){	SysEnvRec	myComputer;		SysEnvirons (2, &myComputer);	if (myComputer.hasColorQD && (DepthScreen > 1))		return true;	else		return false;}static void Draw (ControlHandle	control, short variation, short cicnID){//	Rect 			myRect, rect1;//	PenState		oldstate;	Boolean 		pressed, hiliteMode;	CIconHandle		cHandle;	if (!(*control)->contrlVis)		return;	hiliteMode = ((*control)->contrlHilite == kControlInactivePart);	pressed = (((*control)->contrlHilite == kControlButtonPart) ||				((*control)->contrlHilite == kControlLabelPart));	switch (variation)	{		case 0:		if (pressed)			cicnID++;		else			if ((*control)->contrlHilite == 255)				cicnID += 2;		cHandle = GetCIcon (cicnID);//		cHandle = (CIconHandle) Get1Resource ('cicn', cicnID);//		PlotCIconHandle (&(*control)->contrlRect, atNone,//				((*control)->contrlHilite == 255) ? ttLabel3 : ttNone, cHandle);		PlotCIcon (&(*control)->contrlRect, cHandle);		DisposeCIcon (cHandle);		//		Draw3DKey (myRect, depthKey, pressed);//		InsetRect (&myRect, depthKey, depthKey);//		if (pressed)//			OffsetRect (&myRect, 1, 1);//		DrawCenterString (myRect, (*control)->contrlTitle, 1, hiliteMode);		break;	}}