#include <Menus.h>#include <Script.h>#include <ColorPicker.h>#include <Palettes.h>#include <Gestalt.h>#define itemHeight		11enum {	ChunkyDepth = 0x0D60	/*[GLOBAL VAR]  depth of the pixels*/};#define DepthScreen	*(short *)(ChunkyDepth)typedef struct {	short scriptCode;	short langCode;	short iconID;	Str255 Name;} langResStruct, *langResPtr;static void drawItem (MenuHandle menu, Rect *mRect, short itemNo, Boolean inverted);pascal void main (short msg, MenuHandle whichMenu, Rect *menuRect, Point hitPt, short *itemID){	short 		oldfont, oldsize;	GrafPtr		oldPort;		long		oops;		HLock ((Handle) whichMenu);	GetPort (&oldPort);	oldfont = oldPort->txFont;	oldsize = oldPort->txSize;	switch (msg)	{	case mDrawMsg://	DebugStr ("\pmDrawMsg");		{ 			short j;			for (j=1;  j<=CountMItems (whichMenu);  j++)				drawItem (whichMenu, menuRect, j, false);		}		break;	case mChooseMsg://	DebugStr ("\pmChooseMsg");		{			short mouseItem;						if (((*whichMenu)->enableFlags & 1L) != 0)			{				mouseItem = (PtInRect (hitPt, menuRect)) ?							(hitPt.v-menuRect->top)/itemHeight+1 : 0;				if (mouseItem)				{					if (mouseItem != *itemID)					{						drawItem (whichMenu, menuRect, *itemID, false);												oops = 1L << mouseItem;											if (((*whichMenu)->enableFlags & oops) != 0)						{							drawItem (whichMenu, menuRect, mouseItem, true);							*itemID = mouseItem;						}						else							*itemID = 0;					}				}				else				{					if (*itemID)					{						drawItem (whichMenu, menuRect, *itemID, false);						*itemID = 0;					}				}			}		}		break;	case mSizeMsg://	DebugStr ("\pmSizeMsg");		{			short 		itemCount;			itemCount = CountMItems (whichMenu);			(*whichMenu)->menuWidth = 110;			(*whichMenu)->menuHeight= itemHeight*itemCount; 		}		break;	case mPopUpMsg://	DebugStr ("\pmPopUpMsg");		{			short 		itemCount;						itemCount = CountMItems (whichMenu);			menuRect->top = hitPt.h - ((*itemID-1)*itemHeight);						if (menuRect->top < 0)				menuRect->top = 0;						menuRect->left = hitPt.v;						if (menuRect->left < 0)				menuRect->left = 0;						menuRect->right = menuRect->left+110;			menuRect->bottom = menuRect->top+(itemCount*itemHeight);		}		break;	}		TextFont (oldfont);	TextSize (oldsize);	HUnlock ((Handle) whichMenu);}static void SetColors (MenuHandle mh, short itemNo, 		Boolean inverted, Boolean hiliteItem){	short 		menuID, state;	RGBColor	fore, back;	GrafPtr 	grafPort;	GDHandle 	gdh;	MCEntryPtr	mcPtr;	MCEntry		mce;	GetPort (&grafPort);	gdh = GetMaxDevice (&grafPort->portRect);	if ((*(*gdh)->gdPMap)->pixelSize < 2) goto setDefault;	state = 0;	menuID = (*mh)->menuID;	mcPtr = GetMCEntry (menuID, itemNo);	if (!mcPtr) {		mcPtr = GetMCEntry (menuID, 0);		if (!mcPtr) {			state++;			mcPtr = GetMCEntry (0, 0);			if (!mcPtr) 				goto setDefault;		}	}	mce = *mcPtr;	if (state) {		fore = mce.mctRGB3;		back = mce.mctRGB2;	} else {		fore = mce.mctRGB3;		back = mce.mctRGB4;	}	goto doThis;setDefault:				ForeColor (blackColor);	BackColor (whiteColor);	GetBackColor (&back);	GetForeColor (&fore);	doThis:	if (hiliteItem)		GetGray (gdh, &back, &fore);	if (inverted) {		RGBForeColor (&back);		RGBBackColor (&fore);	} else {		RGBForeColor (&fore);		RGBBackColor (&back);	}}static void drawItem (MenuHandle menu, Rect *mRect, short itemNo, Boolean inverted){	short			selChar;	//	, fontID;	Boolean			selected, hasColor, hiliteItem; 	Point 			cursor;	Rect 			itemRect;	//, iconRect;//	Handle 			h, h1;//	langResPtr		p;	Str255			temp;//	long 			num;	SysEnvRec		myComputer;	RGBColor		oldfore, oldback;	long 			gestaltAnswer;	Boolean			system7 = false;		if (((*menu)->enableFlags & 1) == 0)		hiliteItem = true;	else 		hiliteItem = (((*menu)->enableFlags & (1 << itemNo)) == 0);	if (hiliteItem && inverted)		return;	SysEnvirons (2, &myComputer);	hasColor = (myComputer.hasColorQD && (DepthScreen > 1));	if (!Gestalt (gestaltVersion, &gestaltAnswer) ) {		Gestalt (gestaltSystemVersion, &gestaltAnswer);		if( (int)gestaltAnswer >= 0x0700 ) system7 = true;	}	if (hasColor) {		GetForeColor (&oldfore);		GetBackColor (&oldback);		SetColors (menu, itemNo, inverted, hiliteItem);	}	SetPt (&cursor, mRect->left, mRect->top+(itemNo-1)*itemHeight);	GetItemMark (menu, itemNo, &selChar);	selected = (selChar == 0xA5);	//	18	SetRect (&itemRect,  mRect->left, cursor.v,  mRect->right, cursor.v+itemHeight);	EraseRect (&itemRect);	GetMenuItemText (menu, itemNo, temp);	if (temp[1] == '-')	{		MoveTo (mRect->left, cursor.v+itemHeight/2);		LineTo (mRect->right, cursor.v+itemHeight/2);	}	else	{		MoveTo (cursor.h + 10, cursor.v+itemHeight-2);		TextFont (4);		TextSize (9);		DrawString (temp);		if (selected) {			MoveTo (cursor.h+2, cursor.v+itemHeight-2);			DrawChar ((char) 0xA5);		//	18		}	}	if (hasColor) {		RGBForeColor (&oldfore);		RGBBackColor (&oldback);	} else {		if (inverted)			InvertRect (&itemRect);		if (hiliteItem) {			PenState 		oldstate;			Pattern			myGray;			GetPenState (&oldstate);			PenNormal ();			GetIndPattern (&myGray, 0, 4);			PenPat (&myGray);			PenMode (patBic);			PaintRect (&itemRect);			SetPenState (&oldstate);		}	}}