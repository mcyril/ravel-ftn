#include <Sound.h>#include <stdio.h>#include <string.h>#include <Serial.h>#include "PKT.h"#include "Prefs.h"#include "PascalStr.h"#include "Pathes.h"#include "Scheduler.h"#define workPath		Pathes[_homePath-1]		//	working folder for bundling outbound#define outboundPath	Pathes[_outbPath-1]		//	outbound folder#define inboundPath		Pathes[_inbdPath-1]		//	inbound folder#define basePath		Pathes[_basePath-1]		//	base storage folder#define tempPath		Pathes[_tempPath-1]		//	temp folder (fe. for unpacking)#define logPath			Pathes[_logPath-1]		//	log-file pathtypedef struct _old_oneArea {	Str31		areaName;		// Name of area (must be correct for HFS)	short		group;			// Group number	long		areaflags;		// 32-bits	short		useAKA;			// also SEEN-BY is # of address (0 main, >0 AKA)	short		purger;			// # of days for purge	short		numExports;		// Number of exports	short		Export[];		// Exports nodes list} old_areaPrefType, *old_areaPrefPtr, **old_areaPrefHndl;typedef struct _1_oneArea {	Str63		areaName;		// Name of area (must be correct for HFS)	short		group;			// Group number	long		areaflags;		// 32-bits	short		useAKA;			// also SEEN-BY is # of address (0 main, >0 AKA)	short		purger;			// # of days for purge	short		numExports;		// Number of exports	short		Export[];		// Exports nodes list} areaPref1Type, *areaPref1Ptr, **areaPref1Hndl;typedef struct _old_oneGroup {	Str31		groupName;		// Name of Group (any)	long		areaflags;		// 32-bits	short		useAKA;			// also SEEN-BY is # of address (0 main, >0 AKA)	short		purger;			// # of days	short		numExports;		// Number of exports	short		Export[];		// Exports nodes list} old_groupPrefType, *old_groupPrefPtr, **old_groupPrefHndl;homeHndl		homesystem;			//	•	Home system structmailPrefHndl	mailHndl;			//	•	Netmail structshort			AreasNumber;		//	•	Areas structs listareaPrefHndl	*areasHndls;short			GroupsNumber;		//	•	AreaGroups structs listgroupPrefHndl	*groupsHndls;short			NodesNumber;		//	•	Linked Nodes structs listnodePrefHndl	*nodesHndls;routeHndl		Routing;short			eventsNumber;		//	•	Events listeventsHndl		*eventsHndls;behaviorHndl	behavior;			//	•	Unattended behaviors listprefHndl		comm_pref;			//	•	Communications preferencesh_wzoo			wazoo;h_ftsc			ftsc;h_tpt_opt		hydra;h_shfl			shufle;hiddenlinesPtr	*commonhiddens;StringPtr		*commoninits;Str255			mdmInitStr;			//	•	Modem initialization stringStr255			RealName;Str255			ShufflerPathName;Str255			toolName;Str255			lstnr1, lstnr2;Ptr				configStr;long			defaultPort, listenPort;char			SerialDMA;typedef struct _tcp_rec {	long	defaultPort;	long	listenPort;	long	reserved[8];} tcp_rec, *p_tcp_rec, **h_tcp_rec;Boolean ReadPreference (void){	Handle		h, h_new, hhh;	short		prefResNum = OpenRFPerm ( prefFile, 0, fsRdWrPerm );	short		oldResNum = CurResFile ();	Boolean		res = FALSE;	short		i, j, ii;	Str255		temp;	FSSpec		spec;	long		dummy;	short		oldstandard;	StringPtr	ph_num;hiddenlinesPtr	lasthidden;		if ( prefResNum == -1 )				// no pref file - use setup...	{		OSType		rType;		short		rID;		Str255		rName;						if ( Create ( prefFile, 0, 'Ravl', 'PREF' ) )			return false;				CreateResFile ( prefFile );			prefResNum = OpenRFPerm ( prefFile, 0, fsRdWrPerm );		if ( prefResNum == -1 )		{			return false;		}/*				UseResFile (oldResNum);		i = Count1Resources ('TMPL');				for ( j=1; j<=i; j++ )		{			UseResFile (oldResNum);			h = Get1IndResource ( 'TMPL', j );			GetResInfo ( h, &rID, &rType, rName); 			DetachResource (h);						UseResFile (prefResNum);			AddResource ( h, 'TMPL', j, rName );			WriteResource ( h );			ReleaseResource (h);		}*/	}	UseResFile ( prefResNum );	h = Get1Resource ('VERS', 0);	if (h)		oldstandard = **h;	else		oldstandard = 0;		if (oldstandard != 2)		SysBeep (10);		do {				h = Get1Resource ('STR ', 100);				if (h)		{			pStrCopy ( (StringPtr) *h, ShufflerPathName );			ReleaseResource (h);		}		else			ShufflerPathName[0] = 0;		h = Get1Resource ('Real', 0);				if (h)		{			pStrCopy ( (StringPtr) *h, RealName );			ReleaseResource (h);		}		else			RealName[0] = 0;	//•	Get tcp prefs…		h = Get1Resource ('TCP_', 0);				if (h)		{			defaultPort = (*(h_tcp_rec)h)->defaultPort;			listenPort = (*(h_tcp_rec)h)->listenPort;			ReleaseResource (h);		}		else		{			defaultPort = 60179;			listenPort = 60179;		}	//•	Get SerialDMA prefs…		h = Get1Resource ('SDMA', 0);				if (h)		{			SerialDMA = **h;			ReleaseResource (h);		}		else		{			SerialDMA = 0;		}	//•	Get comm. prefs…			h = Get1Resource ('STR ', 1);				if (h)		{			pStrCopy ( (StringPtr) *h, mdmInitStr );			ReleaseResource (h);		}		else		{			pStrCopy ( "\pATZ", mdmInitStr );		}				h = Get1Resource ('STR ', 128);				if (h)		{			pStrCopy ( (StringPtr) *h, toolName );			ReleaseResource (h);		}		else			toolName[0] = 0;		h = Get1Resource ('STR ', 129);				if (h)		{			pStrCopy ( (StringPtr) *h, lstnr1 );			ReleaseResource (h);		}		else			lstnr1[0] = 0;		h = Get1Resource ('STR ', 130);				if (h)		{			pStrCopy ( (StringPtr) *h, lstnr2 );			ReleaseResource (h);		}		else			lstnr2[0] = 0;		h = Get1Resource ('CSTR', 128);		if (h)		{			HLock (h);			configStr = NewPtrClear (GetResourceSizeOnDisk (h));			strcpy (configStr, *h);			ReleaseResource (h);		}		else			configStr = NULL;		comm_pref = (prefHndl) Get1Resource ( 'Pref', 0 );			if (comm_pref && (GetHandleSize ((Handle)comm_pref) == sizeof (prefType)))		{			DetachResource ((Handle)comm_pref);		}		else		{			if (comm_pref)				ReleaseResource ((Handle)comm_pref);					comm_pref = (prefHndl) NewHandleClear ( sizeof (prefType) );						(*comm_pref)->disableEMSI = 0;			(*comm_pref)->disableWaZOO = 0;			(*comm_pref)->auto_scan = 1;			(*comm_pref)->auto_toss = 1;			(*comm_pref)->baud = baud2400;			(*comm_pref)->stop = stop10;			(*comm_pref)->parity = noParity;			(*comm_pref)->data = data8;			(*comm_pref)->hanshake = 0x0104;			(*comm_pref)->isdcd = 0;			pStrCopy ( "\pModem Port", (*comm_pref)->port_name );		}				wazoo = (h_wzoo) Get1Resource ( 'WZoo', 0 );			if (wazoo)		{			DetachResource ((Handle)wazoo);		}		else		{			wazoo = (h_wzoo) NewHandleClear ( sizeof (wzoo) );						(*wazoo)->zedzap = 1;			(*wazoo)->dirzap = 0;			(*wazoo)->janus = 0;			(*wazoo)->hydra = 0;			(*wazoo)->paranoidal_log = 0;			(*wazoo)->accept_freqs_mask = 0L;			(*wazoo)->issue_calls_mask = 0L;			(*wazoo)->accept_calls_mask = 0L;		}				ftsc = (h_ftsc) Get1Resource ( 'FTSC', 0 );		if (ftsc)		{			DetachResource ((Handle)ftsc);						if (!(*wazoo)->hydra)			{				(*ftsc)->xhydra = 0;				(*ftsc)->hydra8 = 0;				(*ftsc)->hydra16 = 0;			}		}		else		{			ftsc = (h_ftsc) NewHandle (sizeof (ftsc01));					(*ftsc)->no_sealink = 0;	//••		lika no_wazoo, etc.?			(*ftsc)->no_resync = 0;		//••			(*ftsc)->no_overdrive = 0;	//••			(*ftsc)->small_window = 0;	//••			(*ftsc)->min_baud = 0;			(*ftsc)->xhydra = 0;			(*ftsc)->hydra8 = 0;			(*ftsc)->hydra16 = 0;		}		hydra = (h_tpt_opt) Get1Resource ( 'TptL', 0 );		if (hydra)		{			DetachResource ((Handle)hydra);		}		else		{			hydra = (h_tpt_opt) NewHandle (sizeof (tpt_opt));					(*hydra)->zmodem32 = 1;			(*hydra)->janus32 = 1;			(*hydra)->hydra32 = 1;			(*hydra)->hydra_esc = 0;			(*hydra)->hydra_hi8 = 0;			(*hydra)->hydra_uue = 0;			(*hydra)->timesyncbounds = 0;			(*hydra)->timesynclink = -1;		}		shufle = (h_shfl) Get1Resource ( 'Shfl', 0 );			if (shufle)		{			DetachResource ((Handle)shufle);						if ((*shufle)->Type2 != 0x0000 &&				(*shufle)->Type2 != 0x0200 &&				(*shufle)->Type2 != 0x0201 &&				(*shufle)->Type2 != 0x02FF &&				(*shufle)->Type2 != 0x0220)				(*shufle)->Type2 = 0x0200;		}		else		{			shufle = (h_shfl) NewHandleClear ( sizeof (t_shfl) );						(*shufle)->Type2 = 0x0200;			(*shufle)->TimeZone = 'TZ';		}		if ( (h = Get1Resource ( 'STR#', PathID )) && !LMGetResErr () )		{					for ( i = 0; i < 8; i++ )			{				GetIndString ( Pathes[i], PathID, i+1 );				Pathes[i][Pathes[i][0]+1] = 0;			}				//•	Check/Create all folders…	/*			for ( i = 0; i < _basePath; i++ )			{				pStrCopy ( Pathes[i], temp );	//			temp[0]--;								if ( FSMakeFSSpec ( 0, 0, temp, &spec ) == fnfErr )				{					if ( DirCreate ( 0, 0, temp, &dummy ) )						return FALSE;				}			}	*/					ReleaseResource (h);		}		else		{			pStrCopy ( "\p:Bundles:",  Pathes[0] );			pStrCopy ( "\p:Temp:",  Pathes[1] );			pStrCopy ( "\p:Inbound:",  Pathes[2] );			pStrCopy ( "\p:Outbound:",  Pathes[3] );			pStrCopy ( "\p:Base:",  Pathes[4] );			pStrCopy ( "\pRavel.log",  Pathes[5] );			pStrCopy ( "\p:Nodelist:",  Pathes[6] );			pStrCopy ( "\p:Freq:",  Pathes[7] );	/*			for ( i = 0; i < _basePath; i++ )			{				pStrCopy ( Pathes[i], temp );	//			temp[0]--;								if ( FSMakeFSSpec ( 0, 0, temp, &spec ) == fnfErr )				{					if ( DirCreate ( 0, 0, temp, &dummy ) )						return FALSE;				}			}	*/	}			//•	Get home system info…			if ( (h = Get1Resource ( homeRes, 0 )) != NULL )		{			DetachResource ( h );//			MoveHHi ( h );//			HLock ( h );		}		else		{			h = NewHandleClear ( sizeof (homeType) );						pStrCopy ( "\pUnnamed System", (*(homeHndl)h)->system );			pStrCopy ( "\pAnonymous", (*(homeHndl)h)->sysop );			pStrCopy ( "\pDeepest Down", (*(homeHndl)h)->location );			pStrCopy ( "\p-Unpublished-", (*(homeHndl)h)->phone );			pStrCopy ( "\p9600", (*(homeHndl)h)->baud );			pStrCopy ( "\pXA,MO", (*(homeHndl)h)->emsi_flags );			(*(homeHndl)h)->mainAddr.ad.zone = 0;			(*(homeHndl)h)->mainAddr.ad.net = 0;			(*(homeHndl)h)->mainAddr.ad.node = 0;			(*(homeHndl)h)->mainAddr.ad.point = 0;			(*(homeHndl)h)->mainAddr.domain[0] = 0;			(*(homeHndl)h)->AKAcount = 0;		}				homesystem = (homeHndl) h;	//•	Get netmail desc…			if ( (h = Get1Resource ( mailRes, 0 )) != NULL )		{			DetachResource ( h );//			MoveHHi ( h );//			HLock ( h );		}		else		{			h = NewHandleClear ( sizeof (mailPrefType) );						pStrCopy ( "\pNETMAIL", (*(mailPrefHndl)h)->mailName );			(*(mailPrefHndl)h)->areaflags = 0L;			(*(mailPrefHndl)h)->useAKA = 0;			(*(mailPrefHndl)h)->purger = 7;		}		mailHndl = (mailPrefHndl) h;	//•	Get areas desc…			AreasNumber = Count1Resources ( areasRes );				if (AreasNumber)		{			areasHndls = (areaPrefHndl *) NewPtr ( AreasNumber * sizeof (Handle) );						for ( i = 1; ; i++ )				if ( (h = Get1Resource ( areasRes, i )) != NULL )				{					switch (oldstandard)					{					case 0:					//	very old, prehistorical standard											h_new = NewHandle (sizeof (areaPrefType) + (*((old_areaPrefHndl) h))->numExports * sizeof (ExpItem));						HLock (h);						HLock (h_new);												pStrCopy ((*((old_areaPrefHndl) h))->areaName, (*((areaPrefHndl) h_new))->areaName);						(*((areaPrefHndl) h_new))->group = (*((old_areaPrefHndl) h))->group;						(*((areaPrefHndl) h_new))->areaflags = (*((old_areaPrefHndl) h))->areaflags;						(*((areaPrefHndl) h_new))->useAKA = (*((old_areaPrefHndl) h))->useAKA;						(*((areaPrefHndl) h_new))->purger = (*((old_areaPrefHndl) h))->purger;						(*((areaPrefHndl) h_new))->numExports = (*((old_areaPrefHndl) h))->numExports;												for (ii=0; ii<(*((areaPrefHndl) h_new))->numExports; ii++)						{							(*((areaPrefHndl) h_new))->Export[ii].Export = (*((old_areaPrefHndl) h))->Export[ii];							(*((areaPrefHndl) h_new))->Export[ii].Diodes = 0;						}												ReleaseResource (h);						HUnlock (h_new);						h = h_new;						break;											case 1:					//	Ravel 0.0d9r08 .. 1.0b standard											h_new = NewHandle (sizeof (areaPrefType) + (*((areaPref1Hndl) h))->numExports * sizeof (ExpItem));						HLock (h);						HLock (h_new);												pStrCopy ((*((areaPref1Hndl) h))->areaName, (*((areaPrefHndl) h_new))->areaName);						(*((areaPrefHndl) h_new))->group = (*((areaPref1Hndl) h))->group;						(*((areaPrefHndl) h_new))->areaflags = (*((areaPref1Hndl) h))->areaflags;						(*((areaPrefHndl) h_new))->useAKA = (*((areaPref1Hndl) h))->useAKA;						(*((areaPrefHndl) h_new))->purger = (*((areaPref1Hndl) h))->purger;						(*((areaPrefHndl) h_new))->numExports = (*((areaPref1Hndl) h))->numExports;												for (ii=0; ii<(*((areaPrefHndl) h_new))->numExports; ii++)						{							(*((areaPrefHndl) h_new))->Export[ii].Export = (*((areaPref1Hndl) h))->Export[ii];							(*((areaPrefHndl) h_new))->Export[ii].Diodes = 0;						}												ReleaseResource (h);						HUnlock (h_new);						h = h_new;						break;											case 2:					//	Ravel 1.0fc modern standard						DetachResource ( h );						break;					}					areasHndls[i-1] = (areaPrefHndl) h;				}				else					break;				if ( i-1 != AreasNumber )				break;		}		else			areasHndls = NULL;	//•	Get groups desc…		GroupsNumber = Count1Resources ( groupsRes );		if (GroupsNumber)		{			groupsHndls = (groupPrefHndl *) NewPtr ( GroupsNumber * sizeof (Handle) );				for ( i = 0; ; i++ )				if ( (h = Get1Resource ( groupsRes, i )) != NULL )				{					switch (oldstandard)					{					case 0:					//	very old, prehistorical standard					case 1:					//	Ravel 0.0d9r08 .. 1.0b standard											h_new = NewHandle (sizeof (groupPrefType) + (*((old_groupPrefHndl) h))->numExports * sizeof (ExpItem));						HLock (h);						HLock (h_new);												pStrCopy ((*((old_groupPrefHndl) h))->groupName, (*((groupPrefHndl) h_new))->groupName);						(*((groupPrefHndl) h_new))->areaflags = (*((old_groupPrefHndl) h))->areaflags;						(*((groupPrefHndl) h_new))->useAKA = (*((old_groupPrefHndl) h))->useAKA;						(*((groupPrefHndl) h_new))->purger = (*((old_groupPrefHndl) h))->purger;						(*((groupPrefHndl) h_new))->numExports = (*((old_groupPrefHndl) h))->numExports;												for (ii=0; ii<(*((groupPrefHndl) h_new))->numExports; ii++)						{							(*((groupPrefHndl) h_new))->Export[ii].Export = (*((old_groupPrefHndl) h))->Export[ii];							(*((groupPrefHndl) h_new))->Export[ii].Diodes = 0;						}												ReleaseResource (h);						HUnlock (h_new);						h = h_new;						break;											case 2:					//	Ravel 1.0fc modern standard						DetachResource ( h );						break;					}					groupsHndls[i] = (groupPrefHndl) h;				}						else					break;								if ( i != GroupsNumber )				break;		}		else			groupsHndls = NULL;	//•	Get nodes desc…		NodesNumber = Count1Resources ( nodesRes );				if (NodesNumber)		{			nodesHndls = (nodePrefHndl *) NewPtr ( NodesNumber * sizeof (Handle) );				for ( i = 0; ; i++ )				if ( (h = Get1Resource ( nodesRes, i )) != NULL )				{					DetachResource ( h );//					MoveHHi ( h );//					HLock ( h );						nodesHndls[i] = (nodePrefHndl) h;				}						else					break;				if ( i != NodesNumber )				break;		}		else			nodesHndls = NULL;			if ((*hydra)->timesyncbounds)		{			if ((*hydra)->timesynclink < 0 || (*hydra)->timesynclink >= NodesNumber)			{				(*hydra)->timesyncbounds = 0;				(*hydra)->timesynclink = -1;			}		}		else			(*hydra)->timesynclink = -1;	//•	Nodes' hidden lines phones and alternative init strings			commonhiddens = (hiddenlinesPtr *) NewPtrClear (sizeof (hiddenlinesPtr) * NodesNumber);		commoninits = (StringPtr *) NewPtrClear (sizeof (Ptr) * NodesNumber);				for (i = 0; i < NodesNumber; i++)		{			h = Get1Resource ( 'STR#', i+1000 );						if (h)			{				HLock (h);					for (ii = 1; ; ii++)				{					ph_num = GetStr (h, ii);										if (!ph_num)					{						break;					}					else					{						if (ii == 1)						{							commonhiddens[i] = (hiddenlinesPtr) NewPtrClear (sizeof (hiddenlines));							lasthidden = commonhiddens[i];						}						else						{							lasthidden->next = (hiddenlinesPtr) NewPtrClear (sizeof (hiddenlines));							lasthidden = lasthidden->next;						}												pStrCopy (ph_num, lasthidden->phone);						lasthidden->phone[lasthidden->phone[0]+1] = 0;												hhh = Get1Resource ('WKtm', ii+i*100+999);						if (hhh)						{							lasthidden->worktime = *((long *) *hhh);							ReleaseResource (hhh);						}						else							lasthidden->worktime = 0;					}				}								ReleaseResource (h);			}				//•	Get Addenum init strings						h = Get1Resource ( 'STR ', i+1000 );						if (h)			{				HLock (h);				commoninits[i] = (StringPtr) NewPtrClear (*((unsigned char *)*h) + 2);				pStrCopy ((StringPtr) *h, commoninits[i]);				ReleaseResource (h);			}		}		//•	Get NetMail routing…				if ( (h = Get1Resource ( routeRes, 0 )) != NULL )		{			DetachResource ( h );//			MoveHHi ( h );//			HLock ( h );		}		else		{			h = NewHandle (sizeof (short));			*((short *)(*h)) = 0;		}				Routing = (routeHndl) h;	//•	Get events desc…		eventsNumber = Count1Resources ( 'Evt ' );		if (eventsNumber)		{			eventsHndls = (eventsHndl *) NewPtr ( eventsNumber * sizeof (Handle) );			if (eventsNumber>32)				break;						for ( i = 0; ; i++ )				if ( (h = Get1Resource ( 'Evt ', i )) != NULL )				{					DetachResource ( h );//					MoveHHi ( h );//					HLock ( h );						eventsHndls[i] = (eventsHndl) h;				}						else					break;				if ( i != eventsNumber )				break;		}			//• Get behaviors		if ( (h = Get1Resource ( 'Evts', 0 )) != NULL )		{			DetachResource ( h );//				MoveHHi ( h );//				HLock ( h );		}		else		{			h = NewHandle (sizeof (short));			*((short *)(*h)) = 0;		}				behavior = (behaviorHndl) h;			res = true;	} while (0);	UseResFile ( oldResNum );	CloseResFile ( prefResNum );	return res;}Boolean	WritePreference (void){	Handle			h;	unsigned char	*hh;		short		oldResNum = CurResFile ();	short		prefResNum = OpenRFPerm ( prefFile, 0, fsRdWrPerm );	Boolean		res = FALSE, done;	short		i, j, k;	Str255		temp;	FSSpec		spec;	long		dummy;		short		completer = 0;		if ( prefResNum == -1 )		return false;	UseResFile ( prefResNum );	h = Get1Resource ('VERS', 0);	if (!h)	{		h = NewHandle (1);		**h = 2;		AddResource ( h, 'VERS', 0, "\p" );		WriteResource (h);		ReleaseResource (h);	}	else	{		**h = 2;		ChangedResource ( h );		WriteResource (h);		ReleaseResource (h);	}	//•	Get comm. prefs…	h = Get1Resource ( 'Pref', 0 );	if (h)	{		RemoveResource (h);		DisposeHandle (h);		UpdateResFile ( prefResNum );	}	AddResource ( (Handle) comm_pref, 'Pref', 0, "\pCommon&Communications" );	WriteResource ( (Handle) comm_pref );	ReleaseResource ( (Handle) comm_pref );	h = Get1Resource ('TCP_', 0);		if (h)	{		RemoveResource (h);		DisposeHandle (h);		UpdateResFile ( prefResNum );	}	h = NewHandle (sizeof (tcp_rec));	(*(h_tcp_rec)h)->defaultPort = defaultPort;	(*(h_tcp_rec)h)->listenPort = listenPort;	AddResource ( h, 'TCP_', 0, "\pTCP" );	WriteResource ( h );	ReleaseResource ( h );	h = Get1Resource ('SDMA', 0);		if (h)	{		RemoveResource (h);		DisposeHandle (h);		UpdateResFile ( prefResNum );	}	h = NewHandleClear (2 * sizeof (long));	**h = SerialDMA;	AddResource ( h, 'SDMA', 0, "\pSerialDMA" );	WriteResource ( h );	ReleaseResource ( h );	h = Get1Resource ( 'STR ', 1 );	if (h)	{		RemoveResource (h);		DisposeHandle (h);		UpdateResFile ( prefResNum );	}	h = NewHandle (mdmInitStr[0] + 1);	pStrCopy (mdmInitStr, (StringPtr) *h);	AddResource ( h, 'STR ', 1, "\pModem init string" );	WriteResource ( h );	ReleaseResource ( h );	h = Get1Resource ( 'STR ', 100 );	if (h)	{		RemoveResource (h);		DisposeHandle (h);		UpdateResFile ( prefResNum );	}	if (ShufflerPathName[0])	{		h = NewHandle (ShufflerPathName[0] + 1);		pStrCopy (ShufflerPathName, (StringPtr) *h);		AddResource ( h, 'STR ', 100, "\pRavelSHUFFLER path" );		WriteResource ( h );		ReleaseResource ( h );	}	h = Get1Resource ( 'CSTR', 128 );	if (h)	{		RemoveResource (h);		DisposeHandle (h);		UpdateResFile ( prefResNum );	}	h = Get1Resource ( 'STR ', 128 );	if (h)	{		RemoveResource (h);		DisposeHandle (h);		UpdateResFile ( prefResNum );	}	h = Get1Resource ( 'STR ', 129 );	if (h)	{		RemoveResource (h);		DisposeHandle (h);		UpdateResFile ( prefResNum );	}	h = Get1Resource ( 'STR ', 130 );	if (h)	{		RemoveResource (h);		DisposeHandle (h);		UpdateResFile ( prefResNum );	}	if (toolName[0])	{		h = NewHandle (toolName[0] + 1);		pStrCopy (toolName, (StringPtr) *h);		AddResource ( h, 'STR ', 128, "\p" );		WriteResource ( h );		ReleaseResource ( h );		if (configStr)		{			h = NewHandle (strlen (configStr) + 1);			strcpy (*h, configStr);			AddResource ( h, 'CSTR', 128, "\p" );			WriteResource ( h );			ReleaseResource ( h );			DisposePtr (configStr);						h = NewHandle (lstnr1[0] + 1);			pStrCopy (lstnr1, (StringPtr) *h);			AddResource ( h, 'STR ', 129, "\p" );			WriteResource ( h );			ReleaseResource ( h );						h = NewHandle (lstnr2[0] + 1);			pStrCopy (lstnr2, (StringPtr) *h);			AddResource ( h, 'STR ', 130, "\p" );			WriteResource ( h );			ReleaseResource ( h );		}	}	h = Get1Resource ( 'Real', 0 );	if (h)	{		RemoveResource (h);		DisposeHandle (h);		UpdateResFile ( prefResNum );	}	if (RealName[0])	{		h = NewHandle (RealName[0] + 1);		pStrCopy (RealName, (StringPtr) *h);		AddResource ( h, 'Real', 0, "\pRealName kludge" );		WriteResource ( h );		ReleaseResource ( h );	}	h = Get1Resource ( 'WZoo', 0 );	if (h)	{		RemoveResource (h);		DisposeHandle (h);		UpdateResFile ( prefResNum );	}	AddResource ( (Handle) wazoo, 'WZoo', 0, "\pWaZoo/ZModem/Session" );	WriteResource ( (Handle) wazoo );	ReleaseResource ( (Handle) wazoo );	h = Get1Resource ( 'FTSC', 0 );	if (h)	{		RemoveResource (h);		DisposeHandle (h);		UpdateResFile ( prefResNum );	}	AddResource ( (Handle) ftsc, 'FTSC', 0, "\pFTS-0001 Session" );	WriteResource ( (Handle) ftsc );	ReleaseResource ( (Handle) ftsc );	h = Get1Resource ( 'TptL', 0 );	if (h)	{		RemoveResource (h);		DisposeHandle (h);		UpdateResFile ( prefResNum );	}	AddResource ( (Handle) hydra, 'TptL', 0, "\pTransport layer options" );	WriteResource ( (Handle) hydra );	ReleaseResource ( (Handle) hydra );	h = Get1Resource ( 'Shfl', 0 );	if (h)	{		RemoveResource (h);		DisposeHandle (h);		UpdateResFile ( prefResNum );	}	AddResource ( (Handle) shufle, 'Shfl', 0, "\pShufler opt." );	WriteResource ( (Handle) shufle );	ReleaseResource ( (Handle) shufle );	h = Get1Resource ( 'STR#', PathID );	if (h)	{		RemoveResource (h);		DisposeHandle (h);		UpdateResFile ( prefResNum );	}		dummy = 2;	for ( i = 0; i < 8; i++ )	{		if (Pathes[i][0])			completer++;			dummy += Pathes[i][0] + 1;	}		h = NewHandleClear (dummy);		*((short *)(*h)) = 8;	hh = (unsigned char *) (*h + 2);		for ( i = 0; i < 8; i++ )	{		pStrCopy ( Pathes[i], hh );		hh += Pathes[i][0] + 1;	}		AddResource ( h, 'STR#', PathID, "\pSystem pathes" );	WriteResource ( h );	ReleaseResource ( h );	//•	Get home system info…	h = Get1Resource ( homeRes, 0 );	if (h)	{		RemoveResource (h);		DisposeHandle (h);		UpdateResFile ( prefResNum );	}		AddResource ( (Handle) homesystem, homeRes, 0, "\pHome system info" );	WriteResource ( (Handle) homesystem );	//•	Get netmail desc…	h = Get1Resource ( mailRes, 0 );	if (h)	{		RemoveResource (h);		DisposeHandle (h);		UpdateResFile ( prefResNum );	}		if ( (*mailHndl)->useAKA > (*homesystem)->AKAcount )		(*mailHndl)->useAKA = 0;							//	drop absent aka to main address	AddResource ( (Handle) mailHndl, mailRes, 0, "\pNetmail description" );	WriteResource ( (Handle) mailHndl );	ReleaseResource ( (Handle) mailHndl );//•	Get areas desc…	for ( i = 1; ; i++ )	{		done = true;			if ( (h = Get1Resource ( areasRes, i )) != NULL )		{			RemoveResource (h);			DisposeHandle (h);			UpdateResFile ( prefResNum );			done = false;		}				if ( i <= AreasNumber )		{			if ( (*areasHndls[i-1])->useAKA > (*homesystem)->AKAcount )				(*areasHndls[i-1])->useAKA = 0;				//	drop absent aka to main address					for ( j=0; j<(*areasHndls[i-1])->numExports; )	//	drop absent exports				if ((*areasHndls[i-1])->Export[j].Export >= NodesNumber)				{					for ( k=j; k<(*areasHndls[i-1])->numExports-1; k++ )						(*areasHndls[i-1])->Export[k] = (*areasHndls[i-1])->Export[k+1];					(*areasHndls[i-1])->numExports--;					SetHandleSize ( (Handle) areasHndls[i-1], sizeof (areaPrefType) +						sizeof (ExpItem) * (*areasHndls[i-1])->numExports );				}				else					j++;							AddResource ( (Handle) areasHndls[i-1], areasRes, i, "\p" );			WriteResource ( (Handle) areasHndls[i-1] );			ReleaseResource ( (Handle) areasHndls[i-1] );			done = false;		}				if (done)			break;	}//•	Get groups desc…	for ( i = 0; ; i++ )	{		done = true;			if ( (h = Get1Resource ( groupsRes, i )) != NULL )		{			RemoveResource (h);			DisposeHandle (h);			UpdateResFile ( prefResNum );			done = false;		}				if ( i < GroupsNumber )		{			if ( (*groupsHndls[i])->useAKA > (*homesystem)->AKAcount )				(*groupsHndls[i])->useAKA = 0;				//	drop absent aka to main address					for ( j=0; j<(*groupsHndls[i])->numExports; )	//	drop absent exports				if ((*groupsHndls[i])->Export[j].Export >= NodesNumber)				{					for ( k=j; k<(*groupsHndls[i])->numExports-1; k++ )						(*groupsHndls[i])->Export[k] = (*groupsHndls[i])->Export[k+1];					(*groupsHndls[i])->numExports--;					SetHandleSize ( (Handle) groupsHndls[i], sizeof (groupPrefType) +						sizeof (ExpItem) * (*groupsHndls[i])->numExports );				}				else					j++;			AddResource ( (Handle) groupsHndls[i], groupsRes, i, "\pEchomail group area description" );			WriteResource ( (Handle) groupsHndls[i] );			ReleaseResource ( (Handle) groupsHndls[i] );			done = false;		}				if (done)			break;	}//•	Get nodes desc…	for ( i = 0; ; i++ )	{		done = true;			if ( (h = Get1Resource ( nodesRes, i )) != NULL )		{			RemoveResource (h);			DisposeHandle (h);			UpdateResFile ( prefResNum );			done = false;		}		if ((h = Get1Resource ( 'STR ', i+1000 )) != NULL)		{			RemoveResource (h);			DisposeHandle (h);			UpdateResFile ( prefResNum );			done = false;		}				if ( i < NodesNumber )		{			if ( (*nodesHndls[i])->yourAka > (*homesystem)->AKAcount )				(*nodesHndls[i])->yourAka = 0;				//	drop absent aka to main address					AddResource ( (Handle) nodesHndls[i], nodesRes, i, "\pLink description" );			WriteResource ( (Handle) nodesHndls[i] );			ReleaseResource ( (Handle) nodesHndls[i] );			done = false;					if (commoninits[i])			{				PtrToHand (commoninits[i], &h, *commoninits[i] + 1);				AddResource ( h, 'STR ', 1000 + i, "\pLink mdm init" );				WriteResource ( h );				ReleaseResource ( h );			}		}				if (done)			break;	}//•	Get NetMail routing…	h = Get1Resource ( routeRes, 0 );	if (h)	{		RemoveResource (h);		DisposeHandle (h);		UpdateResFile ( prefResNum );	}		if (Routing)	{		for (i=0; i<(*Routing)->routes; i++)			if ( (*Routing)->route[i].node >= NodesNumber )				(*Routing)->route[i].node = 0;				//	drop absent node to first node			AddResource ( (Handle) Routing, routeRes, 0, "\pNetmail routing" );		WriteResource ( (Handle) Routing );		ReleaseResource ( (Handle) Routing );		completer++;	}//•	Get events desc…	for ( i = 0; ; i++ )	{		done = true;			if ( (h = Get1Resource ( 'Evt ', i )) != NULL )		{			RemoveResource (h);			DisposeHandle (h);			UpdateResFile ( prefResNum );			done = false;		}				if ( i < eventsNumber )		{			AddResource ( (Handle) eventsHndls[i], 'Evt ', i, "\pEvent description" );			WriteResource ( (Handle) eventsHndls[i] );			ReleaseResource ( (Handle) eventsHndls[i] );			done = false;		}				if (done)			break;	}//• Get behaviors	h = Get1Resource ( 'Evts', 0 );	if (h)	{		RemoveResource (h);		DisposeHandle (h);		UpdateResFile ( prefResNum );	}		if (behavior)	{		for (i=0; i<(*behavior)->countOfBehave; i++)			if ( (*behavior)->behavior[i].mode == 1 && (*behavior)->behavior[i].nodeNum >= NodesNumber )				(*behavior)->behavior[i].nodeNum = 0;	//	drop absent node to first node			AddResource ( (Handle) behavior, 'Evts', 0, "\pEvents behavior" );		WriteResource ( (Handle) behavior );		ReleaseResource ( (Handle) behavior );	}	ReleaseResource ( (Handle) homesystem );	UpdateResFile ( prefResNum );	UseResFile ( oldResNum );	CloseResFile ( prefResNum );	return true;}