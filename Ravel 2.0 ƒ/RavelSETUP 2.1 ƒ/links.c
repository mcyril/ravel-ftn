#include <Sound.h>#include <stdio.h>#include <string.h>#include <serial.h>#include "PatchNewControl.h"//#include "PopUpLib.h"#include "defines.h"#include "PKT.h"#include "PascalStr.h"#include "Prefs.h"#include "PopUpLib.h"#include "Scheduler.h"#include "stringutl.h"typedef struct {	MenuHandle		mHandle;	short			mID;	char			mPrivate;} popupPrivateData;typedef struct _one_hier_item {	struct _one_hier_item	*next;	struct _one_hier_item	*nested;	short		owner;	short		opened;		Str255		name;	Handle		RefCon;} hier_item, *hier_item_p, **hier_item_h;static	hier_item_p	h_list;extern	homeHndl		homesystem;			//	¥	Home system structextern	mailPrefHndl	mailHndl;			//	¥	Netmail structextern	short			AreasNumber;		//	¥	Areas structs listextern	areaPrefHndl	*areasHndls;extern	short			GroupsNumber;		//	¥	AreaGroups structs listextern	groupPrefHndl	*groupsHndls;extern	short			NodesNumber;		//	¥	Linked Nodes structs listextern	nodePrefHndl	*nodesHndls;extern	short			eventsNumber;		//	¥	Events listextern	eventsHndl		*eventsHndls;static	PopUpMenuHandle	linksGroupSet;static	PopUpMenuHandle	linksEventSet, hiddensEventSet;extern	ListHandle		lst;extern	short			semaphore, sweep;extern	short			wasmove;extern	Rect			clickable;extern	hiddenlinesPtr	*commonhiddens;Boolean	ProcessOneLink (nodePrefHndl oneLink, Str255 *initstring);pascal void myldef (short lMessage, Boolean lSelect, Rect *lRect, Cell lCell, short lDataOffset, short lDataLen, ListHandle lHandle);pascal void myLClick (void);static void FullEventsMenu (MenuHandle mh){	short	i;	Str255	t, temp;		for ( i = 0; i < eventsNumber; i++ )	{		NumToString ( i+1, t );				pStrConc (t, "\p, ", t);				print_time ( (*(*eventsHndls[i]))[1].Start, temp );				pStrConc (t, temp, t);		pStrConc (t, "\p - ", t);		print_time ( (*(*eventsHndls[i]))[1].End, temp );		pStrConc (t, temp, t);		AppendMenu ( mh, t );	}}static pascal Boolean hiddensFilter ( DialogPtr theDialog, EventRecord *theEvent, short *itemHit ){	Boolean 	result = false;	Point		localWhere = theEvent->where;	GrafPtr		savePort;	short		initem, part, iType;	Handle		iHandle;	WindowPtr	window;	Cell		oCell, theCell;	short		dataLen;	hier_item_p	celltodraw;	Rect		iRect;	Rect		rView;	switch (theEvent->what)	{	case updateEvt:			EraseRect (&theDialog->portRect);		LUpdate (theDialog->visRgn, lst);		iRect = (*lst)->rView;		InsetRect (&iRect, -1, -1);		FrameRect (&iRect);//		DrawDialog (theDialog);//		result = true;				break;		case keyDown:	case autoKey:			part = theEvent->message & 0x00FF;			if (part == 0x03 || part == 0x0D)		{			*itemHit = 3;			result = true;		}		else			if (part == 0x1B)			{				*itemHit = 4;				result = true;			}		break;		case mouseDown:			switch ( part = FindWindow (theEvent->where, &window) )		{		case inGoAway:						if (TrackGoAway (window, theEvent->where))			{				*itemHit = 4;				result = true;			}			break;		case inContent:					if (window != FrontWindow())			{//				SelectWindow(window);				result = false;			}			else			{				GetPort (&savePort);				SetPort (theDialog);				GlobalToLocal (&localWhere);								initem = FindDialogItem (theDialog, localWhere) + 1;								switch (initem)				{				case 1:									if (theEvent->modifiers & controlKey)					{						SetPt (&theCell, 0, 0);						if (LGetSelect (1, &theCell, lst))						{							GetDialogItem (theDialog, 1, &iType, &iHandle, &iRect);														if (iRect.left != 500)							{								LRect (&rView, theCell, lst);																if (rView.top == iRect.top)								{									HandlePopUp (hiddensEventSet, FullEventsMenu);								}							}						}					}										break;								case 2:										if (LClick (localWhere, theEvent->modifiers, lst))						*itemHit = 3;					else						*itemHit = 2;										result = true;					break;				}				SetPort (savePort);			}						break;		}				break;	}	return result;}static void ProcessHiddens (short link_num){	DialogPtr	linxDlg;	short		iHit, links, markChar;	short		iType, i, j, dummy, dataLen;	Handle		iHandle;	Rect		iRect, rView, rDataBnds, oldClickable;	MenuHandle	mHandle;	ListHandle	oldList;	Str255		temp, d;	long		lll;	addr		tempaddr;		Cell		cellSize, theCell;		GrafPtr		oldPort;	FontInfo		fi;	hiddenlinesPtr	hihi;			oldList = lst;	oldClickable = clickable;	GetPort (&oldPort);		PatchNewControl ();	linxDlg = GetNewDialog ( 556, NULL, (WindowPtr) -1L );	UnPatchNewControl ();	SetPort (linxDlg);	hiddensEventSet = InitPopUp (linxDlg, 560, 1, 1, "\pEvents", 0, FullEventsMenu);	GetDialogItem (linxDlg, 2, &iType, &iHandle, &iRect);	SetRect ( &rDataBnds, 0, 0, 1, 0 );	iRect.right -= 15;	SetPt ( &cellSize, 0, 0 );	TextFont (4);	TextSize (9);	GetFontInfo (&fi);	SetPt ( &cellSize, iRect.right - iRect.left, fi.leading+fi.ascent+fi.descent+2 );	if (cellSize.v < 14)		cellSize.v = 14;		iRect.bottom = iRect.top + ((iRect.bottom - iRect.top) / cellSize.v) * cellSize.v;	SizeWindow (linxDlg, iRect.right+15+1, iRect.bottom+1, true);	MoveWindow (linxDlg, (*((WindowPeek) oldPort)->contRgn)->rgnBBox.right - iRect.right - 15, (*((WindowPeek) oldPort)->contRgn)->rgnBBox.top, true);	ShowWindow (linxDlg);	lst = LNew ( &iRect, &rDataBnds, cellSize, 0, linxDlg, true, false, false, true );	TextFont (1);	TextSize (9);		(*(((DialogPeek) linxDlg)->textH))->txFont = 1;	(*(((DialogPeek) linxDlg)->textH))->txSize = 9;	GetFontInfo (&fi);	(*(((DialogPeek) linxDlg)->textH))->lineHeight = fi.ascent + fi.descent + fi.leading;	(*(((DialogPeek) linxDlg)->textH))->fontAscent = fi.ascent;	clickable = iRect;//	clickable.left += 1;	clickable.right = clickable.left + 6;	InsetRect (&iRect, -1, -1);	FrameRect (&iRect);//	SetPt (&((*lst)->indent), 0, 0);	(*lst)->selFlags = 0x80;//	(*lst)->lClickLoop = NULL;		LSetDrawingMode (false, lst);//	i = 0;	hihi = commonhiddens[link_num];		while (hihi)	{		if (hihi->phone[0])		{			dummy = LAddRow (1, 0x7FFF, lst);			SetPt (&theCell, 0, dummy);			LSetCell (&hihi->phone[1], hihi->phone[0], theCell, lst);		}		hihi = hihi->next;//		i++;	}	dummy = LAddRow (1, 0x7FFF, lst);	//	add empty	SetPt (&theCell, 0, dummy);	LSetCell (&"", 0, theCell, lst);	LSetDrawingMode (true, lst);//	LActivate (true, lst);		LUpdate (linxDlg->visRgn, lst);	GetDialogItem (linxDlg, 1, &iType, &iHandle, &iRect);	SetRect (&iRect, 500, 500, 510, 510);	SetDialogItem (linxDlg, 1, iType, iHandle, &iRect);	InvalRect (&linxDlg->portRect);	do {			ModalDialog ( hiddensFilter, &iHit );		switch (iHit)		{		case 2:					SetPt (&theCell, 0, 0);			if (LGetSelect (1, &theCell, lst))			{				GetDialogItem (linxDlg, 1, &iType, &iHandle, &iRect);								if (iRect.left != 500)				{					LRect (&rView, theCell, lst);										if (rView.top != iRect.top)					{						GetDialogItemText (iHandle, temp);						if (temp[0])						{							LSetCell (&temp[1], temp[0], theCell, lst);													if (theCell.v == (*lst)->dataBounds.bottom)							{								dummy = LAddRow (1, 0x7FFF, lst);	//	add empty								SetPt (&theCell, 0, dummy);								LSetCell (&"", 0, theCell, lst);							}						}												SetRect (&iRect, 500, 500, 510, 510);						SetDialogItem (linxDlg, 1, iType, iHandle, &iRect);						(*((DialogPeek)linxDlg)->textH)->viewRect = iRect;						(*((DialogPeek)linxDlg)->textH)->destRect = iRect;						InvalRect (&linxDlg->portRect);					}				}			}			else			{				GetDialogItem (linxDlg, 1, &iType, &iHandle, &iRect);				if (iRect.left != 500)				{					SetRect (&iRect, 500, 500, 510, 510);					SetDialogItem (linxDlg, 1, iType, iHandle, &iRect);					(*((DialogPeek)linxDlg)->textH)->viewRect = iRect;					(*((DialogPeek)linxDlg)->textH)->destRect = iRect;					InvalRect (&linxDlg->portRect);				}			}//			LUpdate (linxDlg->visRgn, lst);//			DrawDialog (linxDlg);			break;				case 3:					SetPt (&theCell, 0, 0);			if (LGetSelect (1, &theCell, lst))			{				LRect (&rView, theCell, lst);								GetDialogItem (linxDlg, 1, &iType, &iHandle, &iRect);				SetDialogItem (linxDlg, 1, iType, iHandle, &rView);				(*((DialogPeek)linxDlg)->textH)->viewRect = rView;				(*((DialogPeek)linxDlg)->textH)->destRect = rView;				((DialogPeek)linxDlg)->editField = 1;								if (theCell.v == (*lst)->dataBounds.bottom)					SetDialogItemText (iHandle, "\p");				else				{					dataLen = 255;					LGetCell (&temp[1], &dataLen, theCell, lst);					temp[0] = dataLen;					SetDialogItemText (iHandle, temp);				}			}		//			EraseRect (&linxDlg->portRect);			InvalRect (&linxDlg->portRect);//			LUpdate (linxDlg->visRgn, lst);//			DrawDialog (linxDlg);			break;		}	} while (iHit != 4);		if (iHit == 4)	{		}		LDispose (lst);	DisposePopUp (hiddensEventSet);	DisposeDialog (linxDlg);		SetPort (oldPort);	clickable = oldClickable;	lst = oldList;}static void ResyncDefGroupMenu (DialogPtr theDialog, nodePrefHndl oneLink){	short		i, groups;	short		iType, markChar;	Handle		iHandle;	Rect		iRect;	MenuHandle	mHandle;	Str255		temp;			GetDialogItem ( theDialog, linkDefaultGroup, &iType, &iHandle, &iRect );	mHandle = ((popupPrivateData *)(*(*((ControlHandle) iHandle))->contrlData))->mHandle;		groups = CountMItems (mHandle);		for (i=groups; i>0; i--)		DeleteMenuItem (mHandle, i);		groups = 0;		for (i=0; i<GroupsNumber; i++)	{		if ((*linksGroupSet)->statmenu & (1L << (i + 1)))		{			AppendMenu ( mHandle, (*groupsHndls[i])->groupName );			groups++;		}	}		SetControlMinimum ( (ControlHandle) iHandle, (groups) ? 1 : 0 );	SetControlMaximum ( (ControlHandle) iHandle, groups );	SetControlValue ( (ControlHandle) iHandle, (groups) ? 1 : 0 );}static void FullGroupsMenu ( MenuHandle mh ){	short	i;		for ( i = 0; i < GroupsNumber; i++ )		AppendMenu ( mh, (*groupsHndls[i])->groupName );}static pascal Boolean subsFilter ( DialogPtr theDialog, EventRecord *theEvent, short *itemHit ){	Boolean 	result = false;	Point		localWhere = theEvent->where;	GrafPtr		savePort;	short		initem, part;	WindowPtr	window;	Cell		oCell;	short		dataLen;	hier_item_p	celltodraw;	Rect		iRect;	switch (theEvent->what)	{	case updateEvt:			LUpdate (theDialog->visRgn, lst);		iRect = (*lst)->rView;		InsetRect (&iRect, -1, -1);		FrameRect (&iRect);		break;		case keyDown:	case autoKey:			part = theEvent->message & 0x00FF;			if (part == 0x03 || part == 0x0D)		{			*itemHit = 2;			result = true;		}		else			if (part == 0x1B)			{				*itemHit = 3;				result = true;			}		break;		case mouseDown:			switch ( part = FindWindow (theEvent->where, &window) )		{		case inGoAway:						if (TrackGoAway (window, theEvent->where))			{				*itemHit = 3;				result = true;			}			break;		case inContent:					if (window != FrontWindow())			{//				SelectWindow(window);				result = false;			}			else			{				GetPort (&savePort);				SetPort (theDialog);				GlobalToLocal (&localWhere);								initem = FindDialogItem (theDialog, localWhere) + 1;								switch (initem)				{				case 1:										semaphore = false;					sweep = false;					wasmove = -1;					LClick (localWhere, theEvent->modifiers, lst);					if (sweep)		//	Hit triangle					{						oCell = LLastClick (lst);						dataLen = sizeof (hier_item_p);						LGetCell (&celltodraw, &dataLen, oCell, lst);												LSetDrawingMode (false, lst);						switch (celltodraw->opened)						{						case 0:													if (theEvent->modifiers & optionKey)								celltodraw->opened = 5;							else								celltodraw->opened = 4;														break;													default:														if (theEvent->modifiers & optionKey)								celltodraw->opened = 5;							else								celltodraw->opened = 0;							break;						}												LSetCell (&celltodraw, dataLen, oCell, lst);													EraseRect (&(*lst)->rView);						LSetDrawingMode (true, lst);						LUpdate (theDialog->visRgn, lst);						LAutoScroll (lst);					}					result = false;					break;				}				SetPort (savePort);			}						break;		}				break;	}	return result;}static void ProcessSubscribe (short link_num){	DialogPtr	linxDlg;	short		iHit, links, markChar;	short		iType, i, j, dummy;	Handle		iHandle;	Rect		iRect, rDataBnds, oldClickable;	MenuHandle	mHandle;	ListHandle	oldList;	Str255		temp, d;	long		lll;	addr		tempaddr;		Cell		cellSize, theCell;		GrafPtr		oldPort;	FontInfo		fi;	hier_item_p		celltodraw, celltodraw1, celltodraw2;		oldList = lst;	oldClickable = clickable;	GetPort (&oldPort);		PatchNewControl ();	linxDlg = GetNewDialog ( 555, NULL, (WindowPtr) -1L );	UnPatchNewControl ();	SetPort (linxDlg);	GetDialogItem (linxDlg, 1, &iType, &iHandle, &iRect);	SetRect ( &rDataBnds, 0, 0, 1, 0 );	iRect.right -= 15;	SetPt ( &cellSize, 0, 0 );	TextFont (4);	TextSize (9);	GetFontInfo (&fi);	SetPt ( &cellSize, iRect.right - iRect.left, fi.leading+fi.ascent+fi.descent+2 );	if (cellSize.v < 14)		cellSize.v = 14;		iRect.bottom = iRect.top + ((iRect.bottom - iRect.top) / cellSize.v) * cellSize.v;	SizeWindow (linxDlg, iRect.right+15+1, iRect.bottom+1, true);	MoveWindow (linxDlg, (*((WindowPeek) oldPort)->contRgn)->rgnBBox.right - iRect.right - 15, (*((WindowPeek) oldPort)->contRgn)->rgnBBox.top, true);	ShowWindow (linxDlg);	lst = LNew ( &iRect, &rDataBnds, cellSize, 111, linxDlg, true, false, false, true );	TextFont (1);	TextSize (9);		(*(((DialogPeek) linxDlg)->textH))->txFont = 1;	(*(((DialogPeek) linxDlg)->textH))->txSize = 9;	GetFontInfo (&fi);	(*(((DialogPeek) linxDlg)->textH))->lineHeight = fi.ascent + fi.descent + fi.leading;	(*(((DialogPeek) linxDlg)->textH))->fontAscent = fi.ascent;	clickable = iRect;	clickable.left += 1;//	clickable.right = clickable.left + 15;	InsetRect (&iRect, -1, -1);	FrameRect (&iRect);	SetPt (&((*lst)->indent), 0, 0);	(*lst)->selFlags = 0x82;	(*lst)->lClickLoop = myLClick;		h_list = NULL;		for (i = 0; i < AreasNumber; i++)	{		if (!h_list)			h_list = celltodraw = (hier_item_p) NewPtrClear (sizeof (hier_item));		else		{			celltodraw->next = (hier_item_p) NewPtrClear (sizeof (hier_item));			celltodraw = celltodraw->next;		}		celltodraw->owner = 0;		for (j = 0; j < (*areasHndls[i])->numExports; j++)		{			if ((*areasHndls[i])->Export[j].Export == link_num)				break;		}		celltodraw->opened = (j < (*areasHndls[i])->numExports) ?								(((*areasHndls[i])->Export[j].Diodes & LINK_DIODE) ? 5 : 4) : 0;		celltodraw->next = NULL;		pStrCopy ((*areasHndls[i])->areaName, celltodraw->name);				celltodraw->RefCon = (Handle) areasHndls[i];	}	LSetDrawingMode (false, lst);	LAddRow (AreasNumber, 0, lst);		celltodraw = h_list;	i = 0;		while (celltodraw)	{		SetPt (&theCell, 0, i);		LSetCell (&celltodraw, sizeof (hier_item_p), theCell, lst);		celltodraw = celltodraw->next;		i++;	}	LSetDrawingMode (true, lst);		LUpdate (linxDlg->visRgn, lst);	do {			ModalDialog ( subsFilter, &iHit );		} while (iHit != 2 && iHit != 3);		if (iHit == 2)	{		celltodraw = h_list;			i = 0;			while (celltodraw)		{			for (j = 0; j < (*areasHndls[i])->numExports; j++)			{				if ((*areasHndls[i])->Export[j].Export == link_num)					break;			}						if (celltodraw->opened && j < (*areasHndls[i])->numExports)			{	//	¥	subscribed now and was subscribed (update diode needed)					(*areasHndls[i])->Export[j].Diodes = (celltodraw->opened == 5) ? LINK_DIODE : 0;			}			else				if (celltodraw->opened && j == (*areasHndls[i])->numExports)				{	//	¥	subscribed now and was not subscribed									SetHandleSize ((Handle) areasHndls[i],						sizeof (areaPrefType) + ((*areasHndls[i])->numExports + 1) * sizeof (ExpItem));										HLock ((Handle) areasHndls[i]);										for (j = 0; j < (*areasHndls[i])->numExports; j++)					{						if ((*areasHndls[i])->Export[j].Export > link_num)						{							BlockMove (&(*areasHndls[i])->Export[j],								&(*areasHndls[i])->Export[j+1],								sizeof (ExpItem) * ((*areasHndls[i])->numExports - j));							break;						}					}					(*areasHndls[i])->Export[j].Export = link_num;					(*areasHndls[i])->Export[j].Diodes = (celltodraw->opened == 5) ? LINK_DIODE : 0;					(*areasHndls[i])->numExports++;					HUnlock ((Handle) areasHndls[i]);				}				else					if (celltodraw->opened == 0 && j < (*areasHndls[i])->numExports)					{	//	¥	unsubscribed now and was subscribed (unsubscribe needed)							HLock ((Handle) areasHndls[i]);												for (j = 0; j < (*areasHndls[i])->numExports - 1; j++)						{							if ((*areasHndls[i])->Export[j].Export == link_num)							{								BlockMove (&(*areasHndls[i])->Export[j+1],									&(*areasHndls[i])->Export[j],									sizeof (ExpItem) * ((*areasHndls[i])->numExports - j - 1));								break;							}						}												(*areasHndls[i])->numExports--;						HUnlock ((Handle) areasHndls[i]);						SetHandleSize ((Handle) areasHndls[i],							sizeof (areaPrefType) + (*areasHndls[i])->numExports * sizeof (ExpItem));					}		//	¥	do nothing else			celltodraw = celltodraw->next;			i++;		}	}			celltodraw = h_list;		i = 0;		while (celltodraw)	{		celltodraw2 = celltodraw->next;		DisposePtr ((Ptr) celltodraw);		celltodraw = celltodraw2;		i++;	}		LDispose (lst);	DisposeDialog (linxDlg);		SetPort (oldPort);	clickable = oldClickable;	lst = oldList;}static pascal Boolean areaFilter ( DialogPtr theDialog, EventRecord *theEvent, short *itemHit ){	Boolean 	result = false;	Point		localWhere = theEvent->where;	GrafPtr		savePort;	short		initem, part;	WindowPtr	window;	Cell		oCell;	short		dataLen;	hier_item_p	celltodraw;	switch (theEvent->what)	{	case updateEvt:			DrawPopUp (linksGroupSet);		break;	case keyDown:	case autoKey:			part = theEvent->message & 0x00FF;			if (part == 0x03 || part == 0x0D)		{			*itemHit = 1;			result = true;		}		else			if (part == 0x1B)			{				*itemHit = 2;				result = true;			}			else				if (part < 0x20 && part != 8 && part != 9 && part != 0x1c && part != 0x1d)					result = true;		break;		case mouseDown:			switch ( part = FindWindow (theEvent->where, &window) )		{		case inContent:					if (window != FrontWindow())			{//				SelectWindow(window);				result = false;			}			else			{				GetPort (&savePort);				SetPort (theDialog);				GlobalToLocal (&localWhere);								initem = FindDialogItem (theDialog, localWhere) + 1;								switch (initem)				{				case linkGroupsSet:										if (HandlePopUp (linksGroupSet, FullGroupsMenu))					{						(*linksGroupSet)->statmenu ^= 1L << (*linksGroupSet)->theValue;					}					else						result = true;										break;								case linkEvent:										if (HandlePopUp (linksEventSet, FullEventsMenu))					{						(*linksEventSet)->statmenu ^= 1L << (*linksEventSet)->theValue;					}										break;				}								SetPort (savePort);			}						break;		}				break;	}	return result;}Boolean	ProcessOneLink (nodePrefHndl oneLink, Str255 *initstring){	DialogPtr	linxDlg;	short		iHit, links, markChar;	short		iType, i, j, k, dummy;	Handle		iHandle;	Rect		iRect, rDataBnds, oldClickable;	MenuHandle	mHandle;	ListHandle	oldList;	Str255		temp, d;	long		lll;	addr		tempaddr;		Cell		cellSize, theCell;		GrafPtr		oldPort;	FontInfo		fi;	GetPort (&oldPort);		PatchNewControl ();	linxDlg = GetNewDialog ( 501, NULL, (WindowPtr) -1L );	UnPatchNewControl ();		SetPort (linxDlg);	TextFont (1);	TextSize (9);		(*(((DialogPeek) linxDlg)->textH))->txFont = 1;	(*(((DialogPeek) linxDlg)->textH))->txSize = 9;	GetFontInfo (&fi);	(*(((DialogPeek) linxDlg)->textH))->lineHeight = fi.ascent + fi.descent + fi.leading;	(*(((DialogPeek) linxDlg)->textH))->fontAscent = fi.ascent;	//	node name		GetDialogItem ( linxDlg, linkNam, &iType, &iHandle, &iRect );	SetDialogItemText ( iHandle, (*oneLink)->nodeName );	GetDialogItem ( linxDlg, linkUseAKA, &iType, &iHandle, &iRect );	mHandle = ((popupPrivateData *)(*(*((ControlHandle) iHandle))->contrlData))->mHandle;		printaddr ( &(*homesystem)->mainAddr.ad, (char *) &temp[1] );	temp[0] = strlen ( (char *) &temp[1] );	AppendMenu ( mHandle, "\pdum" );	SetMenuItemText ( mHandle, 1, temp );	for ( i = 0; i < (*homesystem)->AKAcount; i++ )	{		printaddr ( &(*homesystem)->AKAAddr[i].ad, (char *) &temp[1] );		temp[0] = strlen ( (char *) &temp[1] );		AppendMenu ( mHandle, "\pdum" );		SetMenuItemText ( mHandle, i+2, temp );	}		SetControlMinimum ( (ControlHandle) iHandle, 1 );	SetControlMaximum ( (ControlHandle) iHandle, (*homesystem)->AKAcount + 1 );	SetControlValue ( (ControlHandle) iHandle, (*oneLink)->yourAka + 1 );	linksGroupSet = InitPopUp (linxDlg, 556, linkGroupsSet, 1, "\p  Groups Set", 0, FullGroupsMenu);	DrawPopUp (linksGroupSet);	linksEventSet = InitPopUp (linxDlg, 558, linkEvent, 1, "\pEvents", 0, FullEventsMenu);	DrawPopUp (linksEventSet);	//	phone	GetDialogItem ( linxDlg, linkPhone, &iType, &iHandle, &iRect );	SetDialogItemText ( iHandle, (*oneLink)->nodePhone );	//	node address		printaddr ( &(*oneLink)->Addr, (char *) &temp[1] );	temp[0] = strlen ( (char *) &temp[1] );	GetDialogItem ( linxDlg, linkAddress, &iType, &iHandle, &iRect );	SetDialogItemText ( iHandle, temp );		//	arcmail pwd		temp[9] = 0;	strncpy ( (char *) &temp[1], (*oneLink)->ArcMail_pwd, 8 );	temp[0] = strlen ( (char *) &temp[1] );	GetDialogItem ( linxDlg, linkArcPwd, &iType, &iHandle, &iRect );	SetDialogItemText ( iHandle, temp );		//	areafix pwd	temp[9] = 0;	strncpy ( (char *) &temp[1], (*oneLink)->AreaFix_pwd, 8 );	temp[0] = strlen ( (char *) &temp[1] );	GetDialogItem ( linxDlg, linkAFixPwd, &iType, &iHandle, &iRect );	SetDialogItemText ( iHandle, temp );		//	session pwd	temp[9] = 0;	strncpy ( (char *) &temp[1], (*oneLink)->Session_pwd, 8 );	temp[0] = strlen ( (char *) &temp[1] );	GetDialogItem ( linxDlg, linkSessPwd, &iType, &iHandle, &iRect );	SetDialogItemText ( iHandle, temp );		//	init string (if any)	GetDialogItem ( linxDlg, linkInit, &iType, &iHandle, &iRect );	SetDialogItemText ( iHandle, *initstring );		//	use compressor		GetDialogItem ( linxDlg, linkCompressor, &iType, &iHandle, &iRect );	SetControlValue ( (ControlHandle) iHandle, (*oneLink)->Compressor + 1 );	//	poll type		GetDialogItem ( linxDlg, linkPollType, &iType, &iHandle, &iRect );	SetControlValue ( (ControlHandle) iHandle, (*oneLink)->Poll + 1 );	//	groups		(*linksGroupSet)->statmenu = 0;	for (i=0; i<(*oneLink)->GroupsNumber; i++)	{		(*linksGroupSet)->statmenu |= 1L << ((*oneLink)->group[i] + 1);	}		ResyncDefGroupMenu (linxDlg, oneLink);		j = 0;	for (i=0; i<GroupsNumber; i++)	{		if ((*linksGroupSet)->statmenu & (1L << (i+1)))		{						if (j == (*oneLink)->group[0])				break;			j++;		}	}			GetDialogItem ( linxDlg, linkDefaultGroup, &iType, &iHandle, &iRect );	SetControlValue ( (ControlHandle) iHandle, j );	//	events		(*linksEventSet)->statmenu = (*oneLink)->evt_mask << 1;	//	flags		GetDialogItem ( linxDlg, linkEMSI, &iType, &iHandle, &iRect );	SetControlValue ( (ControlHandle) iHandle, ((*oneLink)->nodeflags & NODE_NOEMSI) ? 1 : 0 );	GetDialogItem ( linxDlg, linkYooHoo, &iType, &iHandle, &iRect );	SetControlValue ( (ControlHandle) iHandle, ((*oneLink)->nodeflags & NODE_NOYOOHOO) ? 1 : 0 );	GetDialogItem ( linxDlg, linkPackNetMail, &iType, &iHandle, &iRect );	SetControlValue ( (ControlHandle) iHandle, ((*oneLink)->nodeflags & NODE_COMPRESSNETMAIL) ? 1 : 0 );	GetDialogItem ( linxDlg, linkAutoCreate, &iType, &iHandle, &iRect );	SetControlValue ( (ControlHandle) iHandle, ((*oneLink)->nodeflags & NODE_ALLOWAUTOCREATE) ? 1 : 0 );	GetDialogItem ( linxDlg, linkSEAlink, &iType, &iHandle, &iRect );	SetControlValue ( (ControlHandle) iHandle, ((*oneLink)->nodeflags & NODE_NOSEALINK) ? 1 : 0 );	GetDialogItem ( linxDlg, linkZedZip, &iType, &iHandle, &iRect );	SetControlValue ( (ControlHandle) iHandle, ((*oneLink)->nodeflags & NODE_NOZEDZIP) ? 1 : 0 );	GetDialogItem ( linxDlg, linkZedZap, &iType, &iHandle, &iRect );	SetControlValue ( (ControlHandle) iHandle, ((*oneLink)->nodeflags & NODE_NOZEDZAP) ? 1 : 0 );	GetDialogItem ( linxDlg, linkDirZap, &iType, &iHandle, &iRect );	SetControlValue ( (ControlHandle) iHandle, ((*oneLink)->nodeflags & NODE_NODIRZAP) ? 1 : 0 );	GetDialogItem ( linxDlg, linkJanus, &iType, &iHandle, &iRect );	SetControlValue ( (ControlHandle) iHandle, ((*oneLink)->nodeflags & NODE_NOJANUS) ? 1 : 0 );	GetDialogItem ( linxDlg, linkHydra, &iType, &iHandle, &iRect );	SetControlValue ( (ControlHandle) iHandle, ((*oneLink)->nodeflags & NODE_NOHYDRA) ? 1 : 0 );	GetDialogItem ( linxDlg, linkxHydra, &iType, &iHandle, &iRect );	SetControlValue ( (ControlHandle) iHandle, ((*oneLink)->nodeflags & NODE_NOXHYDRA) ? 1 : 0 );	DrawDialog (linxDlg);	do {			ModalDialog ( areaFilter, &iHit );		switch (iHit)		{		case linkOK:						//	node name						GetDialogItem ( linxDlg, linkNam, &iType, &iHandle, &iRect );			GetDialogItemText ( iHandle, temp );			if (!temp[0])			{				SysBeep (10);				iHit = -1;				break;			}			//	node address						GetDialogItem ( linxDlg, linkAddress, &iType, &iHandle, &iRect );			GetDialogItemText ( iHandle, temp );						tempaddr.zone = 0;			tempaddr.net = 0;			tempaddr.node = 0;			tempaddr.point = 0;						temp[temp[0]+1] = 0;			parseaddr (&tempaddr, (char *) &temp[1]);						if (!tempaddr.zone || !tempaddr.net)			{				SysBeep (10);				iHit = -1;				break;			}						//	arcmail pwd						GetDialogItem ( linxDlg, linkArcPwd, &iType, &iHandle, &iRect );			GetDialogItemText ( iHandle, temp );			if (temp[0] > 8)			{				SysBeep (10);				iHit = -1;				break;			}						//	areafix pwd			GetDialogItem ( linxDlg, linkAFixPwd, &iType, &iHandle, &iRect );			GetDialogItemText ( iHandle, temp );						if (temp[0] > 8)			{				SysBeep (10);				iHit = -1;				break;			}			//	session pwd			GetDialogItem ( linxDlg, linkSessPwd, &iType, &iHandle, &iRect );			GetDialogItemText ( iHandle, temp );						if (temp[0] > 8)			{				SysBeep (10);				iHit = -1;				break;			}			break;					case linkEMSI:		case linkPackNetMail:		case linkAutoCreate:		case linkZedZip:		case linkZedZap:		case linkSEAlink:		case linkDirZap:		case linkJanus:		case linkHydra:		case linkxHydra:		case linkYooHoo:					GetDialogItem ( linxDlg, iHit, &iType, &iHandle, &iRect );			dummy = GetControlValue ( (ControlHandle) iHandle );			SetControlValue ( (ControlHandle) iHandle, !dummy );			break;				case linkSubs:						for (j = 0; j < NodesNumber; j++ )				if (oneLink == nodesHndls[j])				{					ProcessSubscribe (j);					break;				}							if (j == NodesNumber)				SysBeep (10);						break;				case linkHidden:					for (j = 0; j < NodesNumber; j++ )				if (oneLink == nodesHndls[j])				{					ProcessHiddens (j);					break;				}							if (j == NodesNumber)				SysBeep (10);						break;				case linkGroupsSet:					ResyncDefGroupMenu (linxDlg, oneLink);			break;		}	} while (iHit != areaOK && iHit != areaCancel);		if (iHit == areaOK)	{		//	node name				GetDialogItem ( linxDlg, linkNam, &iType, &iHandle, &iRect );		GetDialogItemText ( iHandle, (*oneLink)->nodeName );		//	your aka				GetDialogItem ( linxDlg, linkUseAKA, &iType, &iHandle, &iRect );		(*oneLink)->yourAka = GetControlValue ( (ControlHandle) iHandle ) - 1;		//	init string (if any)		GetDialogItem ( linxDlg, linkInit, &iType, &iHandle, &iRect );		GetDialogItemText ( iHandle, *initstring );				//	phone		GetDialogItem ( linxDlg, linkPhone, &iType, &iHandle, &iRect );		GetDialogItemText ( iHandle, (*oneLink)->nodePhone );		//	node address				GetDialogItem ( linxDlg, linkAddress, &iType, &iHandle, &iRect );		GetDialogItemText ( iHandle, temp );		//		tempaddr.zone = 0;//		tempaddr.net = 0;//		tempaddr.node = 0;//		tempaddr.point = 0;				temp[temp[0]+1] = 0;		parseaddr (&(*oneLink)->Addr, (char *) &temp[1]);				//	arcmail pwd				GetDialogItem ( linxDlg, linkArcPwd, &iType, &iHandle, &iRect );		GetDialogItemText ( iHandle, temp );		temp[temp[0]+1] = 0;		strncpy ( (*oneLink)->ArcMail_pwd, (char *) &temp[1] , 8 );				//	areafix pwd		GetDialogItem ( linxDlg, linkAFixPwd, &iType, &iHandle, &iRect );		GetDialogItemText ( iHandle, temp );				temp[temp[0]+1] = 0;		strncpy ( (*oneLink)->AreaFix_pwd, (char *) &temp[1] , 8 );		//	session pwd		GetDialogItem ( linxDlg, linkSessPwd, &iType, &iHandle, &iRect );		GetDialogItemText ( iHandle, temp );				temp[temp[0]+1] = 0;		strncpy ( (*oneLink)->Session_pwd, (char *) &temp[1] , 8 );		//	use compressor				GetDialogItem ( linxDlg, linkCompressor, &iType, &iHandle, &iRect );		(*oneLink)->Compressor = GetControlValue ( (ControlHandle) iHandle ) - 1;		//	poll type				GetDialogItem ( linxDlg, linkPollType, &iType, &iHandle, &iRect );		(*oneLink)->Poll = GetControlValue ( (ControlHandle) iHandle ) - 1;		//	flags				(*oneLink)->nodeflags = 0L;				GetDialogItem ( linxDlg, linkEMSI, &iType, &iHandle, &iRect );		(*oneLink)->nodeflags |= (GetControlValue ( (ControlHandle) iHandle)) ? NODE_NOEMSI : 0;			GetDialogItem ( linxDlg, linkYooHoo, &iType, &iHandle, &iRect );		(*oneLink)->nodeflags |= (GetControlValue ( (ControlHandle) iHandle)) ? NODE_NOYOOHOO : 0;			GetDialogItem ( linxDlg, linkPackNetMail, &iType, &iHandle, &iRect );		(*oneLink)->nodeflags |= (GetControlValue ( (ControlHandle) iHandle)) ? NODE_COMPRESSNETMAIL : 0;			GetDialogItem ( linxDlg, linkAutoCreate, &iType, &iHandle, &iRect );		(*oneLink)->nodeflags |= (GetControlValue ( (ControlHandle) iHandle)) ? NODE_ALLOWAUTOCREATE : 0;		GetDialogItem ( linxDlg, linkSEAlink, &iType, &iHandle, &iRect );		(*oneLink)->nodeflags |= (GetControlValue ( (ControlHandle) iHandle)) ? NODE_NOSEALINK : 0;		GetDialogItem ( linxDlg, linkZedZip, &iType, &iHandle, &iRect );		(*oneLink)->nodeflags |= (GetControlValue ( (ControlHandle) iHandle)) ? NODE_NOZEDZIP : 0;		GetDialogItem ( linxDlg, linkZedZap, &iType, &iHandle, &iRect );		(*oneLink)->nodeflags |= (GetControlValue ( (ControlHandle) iHandle)) ? NODE_NOZEDZAP : 0;		GetDialogItem ( linxDlg, linkDirZap, &iType, &iHandle, &iRect );		(*oneLink)->nodeflags |= (GetControlValue ( (ControlHandle) iHandle)) ? NODE_NODIRZAP : 0;		GetDialogItem ( linxDlg, linkJanus, &iType, &iHandle, &iRect );		(*oneLink)->nodeflags |= (GetControlValue ( (ControlHandle) iHandle)) ? NODE_NOJANUS : 0;		GetDialogItem ( linxDlg, linkHydra, &iType, &iHandle, &iRect );		(*oneLink)->nodeflags |= (GetControlValue ( (ControlHandle) iHandle)) ? NODE_NOHYDRA : 0;		GetDialogItem ( linxDlg, linkxHydra, &iType, &iHandle, &iRect );		(*oneLink)->nodeflags |= (GetControlValue ( (ControlHandle) iHandle)) ? NODE_NOXHYDRA : 0;			//	events			(*oneLink)->evt_mask = (*linksEventSet)->statmenu >> 1;				//	groups				HUnlock ((Handle)oneLink);				SetHandleSize ((Handle)oneLink, sizeof (nodePrefType) + GroupsNumber * sizeof (short));				GetDialogItem ( linxDlg, linkDefaultGroup, &iType, &iHandle, &iRect );		dummy = GetControlValue ((ControlHandle) iHandle) - 1;		j=1;		k=0;		for (i=0; i<GroupsNumber; i++)		{			if ((*linksGroupSet)->statmenu & (1L << (i+1)))			{				(*oneLink)->group[(k==dummy) ? 0 : j++] = i;							k++;			}		}				(*oneLink)->GroupsNumber = k;				SetHandleSize ((Handle)oneLink, sizeof (nodePrefType) + k * sizeof (short));		MoveHHi ((Handle)oneLink);		HLock ((Handle)oneLink);	}	DisposePopUp (linksGroupSet);	DisposePopUp (linksEventSet);		DisposeDialog (linxDlg);		SetPort (oldPort);	return (iHit == linkOK);}