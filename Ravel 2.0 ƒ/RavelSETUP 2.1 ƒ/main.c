#include <Sound.h>#include <stdio.h>#include <string.h>#include <serial.h>#include <CommResources.h>#include <CRMSerialDevices.h>#include <Connections.h>#include <CTBUtilities.h>#include "PatchNewControl.h"//#include "PopUpLib.h"#include "defines.h"#include "PKT.h"#include "PascalStr.h"#include "Prefs.h"//#include "compatible.h"#include "Scheduler.h"#include "stringutl.h"//#include "addresses.h"#include "Pathes.h"Str255			Pathes[8];extern	homeHndl		homesystem;			//	¥	Home system structextern	short			AreasNumber;		//	¥	Areas structs listextern	areaPrefHndl	*areasHndls;extern	short			GroupsNumber;		//	¥	AreaGroups structs listextern	groupPrefHndl	*groupsHndls;extern	short			NodesNumber;		//	¥	Linked Nodes structs listextern	nodePrefHndl	*nodesHndls;extern	prefHndl		comm_pref;			//	¥	Communications preferencesextern	h_tpt_opt		hydra;extern	h_ftsc			ftsc;extern	Str255			mdmInitStr;			//	¥	Modem initialization stringextern	Str255			toolName;extern	Ptr				configStr;extern	char			SerialDMA;extern	StringPtr		*commoninits;static	DialogPtr		Dialog;		ListHandle		lst;short			semaphore, sweep;short			wasmove;Rect			clickable;CIconHandle		triangle[6];typedef struct _one_hier_item {	struct _one_hier_item	*next;	struct _one_hier_item	*nested;	short		owner;	short		opened;		Str255		name;	Handle		RefCon;} hier_item, *hier_item_p, **hier_item_h;typedef struct {	MenuHandle		mHandle;	short			mID;	char			mPrivate;} popupPrivateData;static	short			bauds[12] = {	baud300, baud600, baud1200, baud1800,	baud2400, baud3600, baud4800, baud7200,	baud9600, baud19200, baud38400, baud57600};static	short			stops[3] = {	stop10, stop15, stop20};static	short			parities[3] = {	noParity, oddParity, evenParity	};static	short			datas[4] = {	data5, data6, data7, data8	};static	hier_item_p	h_list;Boolean	ProcessOneGroup (groupPrefHndl oneGroup);Boolean	ProcessOneArea (areaPrefHndl oneArea);Boolean	ProcessOneLink (nodePrefHndl oneLink, Str255 *initstring);void	doCTBSetup (MenuHandle mHandle);void	doCTBEdit (void);void	doTCPSetup (void);pascal void myldef (short lMessage, Boolean lSelect, Rect *lRect, Cell lCell, short lDataOffset, short lDataLen, ListHandle lHandle);pascal void myLClick (void);pascal void myldef (short lMessage, Boolean lSelect, Rect *lRect, Cell lCell,				short lDataOffset, short lDataLen, ListHandle lHandle){	short 		leftDraw, topDraw, k, locked, oldfnt;	FontInfo 	fi;	long		i;	Str255		title, temp;	Point		drawpt;	hier_item_p	celltodraw;	Rect		iRect;		//	if ((lMessage == lInitMsg) || (lMessage == lCloseMsg))//		return;		leftDraw = lRect->left;		//+(*lHandle)->indent.h;	topDraw = lRect->top;		//+(*lHandle)->indent.v;		switch (lMessage)	{	case lInitMsg:			break;		case lCloseMsg:			break;	case lDrawMsg:			SetPort ((*lHandle)->port);		EraseRect (lRect);			if (lDataLen == 4)		{			oldfnt = ((*lHandle)->port)->txFont;			TextFont (4);			TextSize (9);					GetFontInfo (&fi);			SetPt ( &drawpt, leftDraw, topDraw+fi.leading+fi.ascent+2 );//			memcpy ( tmp, *((*lHandle)->cells)+lDataOffset, lDataLen );			memcpy ( &celltodraw, *((*lHandle)->cells)+lDataOffset, sizeof (hier_item_p) );			//			MoveTo (leftDraw + 16, topDraw);//			LineTo (leftDraw + 16, lRect->bottom);			MoveTo ( drawpt.h + 16 + 2, drawpt.v );			DrawString (celltodraw->name);			if (celltodraw->owner == -1)			{				SetRect (&iRect, leftDraw, topDraw+2, leftDraw+16, topDraw+12+2);				PlotCIcon (&iRect, triangle[(celltodraw->nested) ?												((celltodraw->opened == 0) ? 0 : 1) : 2]);/*				if (topDraw != (*lHandle)->rView.top)				{					MoveTo (leftDraw, topDraw);					LineTo (lRect->right, topDraw);				}*/			}			else				if (celltodraw->opened)				{					SetRect (&iRect, leftDraw, topDraw+2, leftDraw+16, topDraw+12+2);					PlotCIcon (&iRect, triangle[celltodraw->opened]);				}			TextFont (oldfnt);		}				if (!lSelect)			break;			case lHiliteMsg:			BitClr ( (Ptr) 0x0938, pHiliteBit);		InvertRect (lRect);		break;	}}static short pos2cell (short pos, Rect *lRect, Rect *bRect, short cHeight){	return bRect->top + ((pos - lRect->top) / cHeight);}static void makeframe (Rect *iRect){	Rect		dRect;//	PenState	penState;	//	GetPenState (&penState);//	PenMode (srcXor);//	PenPat (&qd.gray);		SetRect (&dRect, iRect->left, iRect->bottom-2, iRect->right, iRect->bottom);	InvertRect (&dRect);//	FillRect (&dRect, &qd.gray);//	SetPenState (&penState);}static Boolean myLClicker (void){	Boolean		res = false;	Point		where;	Rect		iRect, lRect, bRect;	short		cHeight, cpos, dataLen;	Cell		theCell, oCell;	long		finished;		RgnHandle	curclip;	hier_item_p	celltodraw;		if (!semaphore)	{		semaphore = true;		res = true;	}	else	{		if ( PtInRect ((*lst)->mouseLoc, &clickable) )			sweep = true;		if (!sweep)		{			oCell = theCell = LLastClick (lst);						if (theCell.v < (*lst)->dataBounds.bottom)			{				dataLen = sizeof (hier_item_p);				LGetCell (&celltodraw, &dataLen, oCell, lst);				if (celltodraw->owner != -1)		//	don't drag high level				{					curclip = NewRgn ();					GetClip (curclip);					ClipRect (&(*lst)->rView);									LRect (&iRect, theCell, lst);					cpos = -1;										while (StillDown ())					{						GetMouse (&where);						if (PtInRect (where, &(*lst)->rView))						{							if (!PtInRect (where, &iRect))							{								cpos = pos2cell (where.v, &(*lst)->rView, &(*lst)->visible, (*lst)->cellSize.v);															if (cpos >= (*lst)->dataBounds.top && cpos < (*lst)->dataBounds.bottom)								{									if (oCell.v != theCell.v)										makeframe (&iRect);																		SetPt (&theCell, 0, cpos);									LRect (&iRect, theCell, lst);																		if (oCell.v != theCell.v)										makeframe (&iRect);								}							}						}						else						{							lRect = (*lst)->rView;							lRect.top -= (*lst)->cellSize.v;							lRect.bottom += (*lst)->cellSize.v;							if (PtInRect (where, &lRect))							{								cpos = pos2cell (where.v, &(*lst)->rView, &(*lst)->visible, (*lst)->cellSize.v);																if (cpos > (*lst)->dataBounds.top && cpos < (*lst)->dataBounds.bottom)								{									if (cpos == theCell.v)										cpos -= 1;																		LScroll (0, cpos - theCell.v, lst);									LRect (&iRect, theCell, lst);									if (oCell.v != theCell.v)										makeframe (&iRect);																		SetPt (&theCell, 0, cpos);									LRect (&iRect, theCell, lst);																		if (oCell.v != theCell.v)										makeframe (&iRect);								}							}						}					}										if (oCell.v != theCell.v)						makeframe (&iRect);					LRect (&iRect, oCell, lst);					if (oCell.v != theCell.v)						makeframe (&iRect);					if (oCell.v != theCell.v)						wasmove = theCell.v;										SetClip (curclip);				}				else					res = true;			}		}	}	return res;}asm pascal void myLClick (void){	jsr		myLClicker	tst.b	d0	rts}static void InitToolbox (void){	MaxApplZone ();	MoreMasters ();	MoreMasters ();	MoreMasters ();	MoreMasters ();	InitGraf ((Ptr) &qd.thePort);	InitFonts ();	InitWindows ();	InitMenus ();	FlushEvents (everyEvent,0);	InitDialogs (0L);	InitCursor ();	InitCRM();	InitCM ();	triangle[0] = GetCIcon (111);	triangle[1] = GetCIcon (112);	triangle[2] = GetCIcon (113);	triangle[3] = GetCIcon (114);	triangle[4] = GetCIcon (115);	triangle[5] = GetCIcon (116);}typedef struct{	short		drvrFlags;		/* dReadEnable, etc */	short		drvrDelay;		/* for periodic actions via SystemTask */	short		drvrEMask;		/* for desk acc only */	short		drvrMenu;		/* for desk acc only */	short		drvrOpen;		/* offset to open routine */	short		drvrPrime;		/* offset to prime routine */	short		drvrCtl;		/* offset to control routine */	short		drvrStatus;		/* offset to status routine */	short		drvrClose;		/* offset to close routine */	unsigned char drvrName[];	/* Pascal string */} DriverHeader;#define	kHandleBased			0x0040	#define	UnitToRef(unitNo)		( -(unitNo) - 1 )static short FindDriverByName (StringPtr pString){	short			refNo;	Byte			oldDriverFlags;	DCtlHandle		driverInfo;	DriverHeader	*driverPtr, **driverHandle;	short			unitNumber;	short			numEntriesInTable;	//	numEntriesInTable = *( (short*)UnitNtryCnt );	numEntriesInTable = LMGetUnitTableEntryCount ();		for ( unitNumber=0; unitNumber<numEntriesInTable; unitNumber++ )	{		refNo = UnitToRef(unitNumber);		driverInfo = GetDCtlEntry(refNo);				if (driverInfo)		{			if ((**driverInfo).dCtlFlags & kHandleBased )			{				driverHandle = (void *)(**driverInfo).dCtlDriver;				if (!driverHandle || !(*driverHandle))					continue;									oldDriverFlags = HGetState((Handle) driverHandle);				HLock((Handle)driverHandle);								if (EqualString(pString, (**driverHandle).drvrName, false, true)) {					HSetState((Handle)driverHandle, oldDriverFlags);					return(refNo);					}								HSetState((Handle)driverHandle, oldDriverFlags);			}			else			{				driverPtr = (void*)(**driverInfo).dCtlDriver;				if ( !driverPtr ) 					continue;									if ( EqualString( pString, driverPtr->drvrName, false, true ) )					return( refNo );			}		}	}		return(0);}//	Create dialog and kill last user-item. Its coordinates (paneRect) are pane positions.static void _InstallDITL (DialogPtr *theDialog, short resID, short *lastID, Rect *paneRect){	short	iType;	Handle	iHandle;			PatchNewControl ();	*theDialog = GetNewDialog ( resID, NULL, (WindowPtr) -1L );	UnPatchNewControl ();	*lastID = CountDITL ( *theDialog );	GetDialogItem ( *theDialog, *lastID, &iType, &iHandle, paneRect );	ShortenDITL ( *theDialog, 1 );	*lastID = CountDITL ( *theDialog );}//	Append pane's DITL to dialog with sys routine. teActive is the first TextEdit box id.static void _AppendDITL (DialogPtr theDialog, short resID, short *lastappendedID, Rect *paneRect){	typedef struct {			Handle			itmHndl;		Rect			itmRect;		char			itmType;		unsigned char	itmData[];	} DITLItem, *pDITLItem, **hDITLItem;	typedef struct {			short		dlgMaxIndex;		DITLItem	DITLItems[];		} ItemList, *pItemList, **hItemList;	short		*IntPtr;	Handle		inDITL;	hItemList	hDITL;	pDITLItem	pItem;	hItemList	hItems;	short		firstItem;	short		newItems, i;	long		sizeHandle, dataSize;	short		err;		//	¥ Get items list to append to exist listÉ//	inDITL = GetResource ( 'DITL', resID + (((DialogPeek) theDialog)->window.refCon & 0xFFFF) );	inDITL = GetResource ( 'DITL', resID );	hDITL = (hItemList) inDITL;	HLock ((Handle) hDITL);//	¥ Process recalc of item's rectsÉ	pItem = (DITLItem *)&((**hDITL).DITLItems);	newItems = (**hDITL).dlgMaxIndex;	for (i = 0; i <= newItems; i++)	{		OffsetRect ( &pItem->itmRect, paneRect->left, paneRect->top );		dataSize = (pItem->itmData[0] + 1) & 0xFFFE;		pItem  = (DITLItem *)(((char *)pItem) +  dataSize + sizeof(DITLItem));	}	HUnlock ((Handle) hDITL);//	¥ Make appendingÉ	PatchNewControl ();	AppendDITL ( theDialog, (Handle) hDITL, overlayDITL );	UnPatchNewControl ();	*lastappendedID = CountDITL (theDialog);	ReleaseResource ((Handle) hDITL);}static pascal Boolean CommonFilterProc (DialogPtr theDialog, EventRecord *theEvent, short *itemHit){	Boolean 	result = false;	Point		localWhere = theEvent->where;	GrafPtr		savePort;	short		initem, part;	WindowPtr	window;	short		pane = (((DialogPeek)theDialog)->window.refCon) & 0xFFFF;	short		item = (((DialogPeek)theDialog)->window.refCon) >> 16;		Boolean		dblClick;	short		iType;	Handle		iHandle;	Rect		iRect;	FontInfo	fi;	if (theEvent->what == mouseDown)	{		switch ( part = FindWindow (theEvent->where, &window) )		{		case inContent:					if (window != FrontWindow())			{				SelectWindow(window);				result = true;			}			else			{				GetPort (&savePort);				SetPort (theDialog);				GlobalToLocal (&localWhere);								initem = FindDialogItem (theDialog, localWhere) + 1;								if (initem == tmpSelectPane)				{				}								SetPort (savePort);			}						break;		}	}/*	else		if (theEvent->what == updateEvt && theDialog == Dialog)		{					GetPort (&savePort);			SetPort (theDialog);//			GetDialogItem (theDialog, tmpSelectPane, &iType, &iHandle, &iRect);//			iRect.right -= 15;//			GetFontInfo (&fi);//			iRect.bottom = iRect.top + ((iRect.bottom - iRect.top) / (*lst)->cellSize.v) * (*lst)->cellSize.v;//			InsetRect (&iRect, -1, -1);//			FrameRect (&iRect);						TextFont (1);			TextSize (9);			SetPort (savePort);			//			result = false;		}*/	return result;}static pascal Boolean ModalAbout ( DialogPtr theDialog, EventRecord *theEvent, short *itemHit ){	Boolean 	result = false;	Point		localWhere = theEvent->where;	GrafPtr		savePort;	short		initem, part;	WindowPtr	window;	short		pane = (((DialogPeek)theDialog)->window.refCon) & 0xFFFF;	short		item = (((DialogPeek)theDialog)->window.refCon) >> 16;		Boolean		dblClick;	switch (theEvent->what)	{	case keyDown:	case autoKey:			part = theEvent->message & 0x00FF;			if (part < 0x20 && part != 8 && part != 9 && part != 0x1c && part != 0x1d)			result = true;		break;		case mouseDown:			switch ( part = FindWindow (theEvent->where, &window) )		{		case inContent:					if (window != FrontWindow())			{				SelectWindow(window);				result = true;			}			else			{				GetPort (&savePort);				SetPort (theDialog);				GlobalToLocal (&localWhere);								initem = FindDialogItem (theDialog, localWhere) + 1;								if (initem > item)				{					initem -= item;				}				else					result = CommonFilterProc (theDialog, theEvent, itemHit);								SetPort (savePort);			}						break;		}				break;	}	return result;}static pascal Boolean ModalAreasGroups ( DialogPtr theDialog, EventRecord *theEvent, short *itemHit ){	Boolean 	result = false;	Point		localWhere = theEvent->where;	GrafPtr		savePort;	short		initem, part, dataLen, i, dummy;	WindowPtr	window;	short		pane = (((DialogPeek)theDialog)->window.refCon) & 0xFFFF;	short		item = (((DialogPeek)theDialog)->window.refCon) >> 16;		Boolean		dblClick;	Cell		theCell, oCell, pCell;	hier_item_p	celltodraw, celltodraw1, celltodraw2, celltodraw3;	short		iType, offset, len;	Handle		iHandle;	Rect		iRect;	FontInfo	fi;	switch (theEvent->what)	{	case keyDown:	case autoKey:			part = theEvent->message & 0x00FF;			if (part < 0x20 && part != 8 && part != 9 && part != 0x1c && part != 0x1d)			result = true;		break;		case mouseDown:			switch ( part = FindWindow (theEvent->where, &window) )		{		case inContent:					if (window != FrontWindow())			{				SelectWindow(window);				result = true;			}			else			{				GetPort (&savePort);				SetPort (theDialog);				GlobalToLocal (&localWhere);								initem = FindDialogItem (theDialog, localWhere) + 1;								if (initem > item)				{					initem -= item;									switch (initem)					{					case agList:						semaphore = false;						sweep = false;						wasmove = -1;						if (LClick (localWhere, theEvent->modifiers, lst))						{							if (!sweep)								*itemHit = agList + item;							else								goto triangle;	//	ignore triangle dblclick						}						else						{						triangle:													*itemHit = -1;							result = true;							if (sweep)		//	Hit triangle							{								oCell = LLastClick (lst);																LGetCellDataLocation (&offset, &len, oCell, lst);																if (offset != -1)								{									dataLen = sizeof (hier_item_p);									LGetCell (&celltodraw, &dataLen, oCell, lst);																		if (celltodraw->owner == -1 && celltodraw->nested)									{										LSetDrawingMode (false, lst);										celltodraw->opened = 1 - celltodraw->opened;										LSetCell (&celltodraw, dataLen, oCell, lst);																				if (celltodraw->opened)		//	open										{											celltodraw1 = celltodraw->nested;																						i = 1;																						while (celltodraw1)											{												dummy = LAddRow (1, oCell.v + i, lst);												SetPt (&theCell, 0, dummy);												dataLen = sizeof (hier_item_p);												LSetCell (&celltodraw1, dataLen, theCell, lst);																								celltodraw1 = celltodraw1->next;												i++;											}										}										else						//	close										{											celltodraw->nested = NULL;											celltodraw1 = NULL;																					SetPt (&theCell, 0, oCell.v + 1);											while (oCell.v + 1 < (*lst)->dataBounds.bottom)											{												dataLen = sizeof (hier_item_p);												LGetCell (&celltodraw2, &dataLen, theCell, lst);																								if (celltodraw2->owner == -1)													break;																								if (!celltodraw1)													celltodraw->nested = celltodraw2;												else													celltodraw1->next = celltodraw2;																									celltodraw2->next = NULL;																								celltodraw1 = celltodraw2;																								LDelRow (1, oCell.v + 1, lst);											}										}																				EraseRect (&(*lst)->rView);										LSetDrawingMode (true, lst);										LUpdate (theDialog->visRgn, lst);										LAutoScroll (lst);									}									else									{										LSetDrawingMode (false, lst);										celltodraw->opened = 3 - celltodraw->opened;										LSetCell (&celltodraw, dataLen, oCell, lst);																					EraseRect (&(*lst)->rView);										LSetDrawingMode (true, lst);										LUpdate (theDialog->visRgn, lst);										LAutoScroll (lst);									}								}							}							else								if (wasmove != -1)				//	was moved								{									LSetDrawingMode (false, lst);									pCell = oCell = LLastClick (lst);																		dataLen = sizeof (hier_item_p);									if (oCell.v > wasmove)									{										LGetCell (&celltodraw, &dataLen, oCell, lst);										LDelRow (1, oCell.v, lst);																				SetPt (&oCell, 0, wasmove);										LGetCell (&celltodraw1, &dataLen, oCell, lst);																				SetPt (&theCell, 0, pCell.v - 1);										LGetCell (&celltodraw2, &dataLen, theCell, lst);																				if (celltodraw2->owner == -1)										{											if (pCell.v < (*lst)->dataBounds.bottom)											{												LGetCell (&celltodraw3, &dataLen, pCell, lst);												if (celltodraw3->owner == -1)													goto emptied1;											}											else											{											emptied1:																							celltodraw2->nested = NULL;												celltodraw2->opened = 0;												LSetCell (&celltodraw2, dataLen, theCell, lst);											}										}																				if (celltodraw1->owner == -1 && !celltodraw1->opened)										{											if (celltodraw1->nested)											{												celltodraw1 = celltodraw1->nested;																								while (celltodraw1->next)													celltodraw1 = celltodraw1->next;																								celltodraw1->next = celltodraw;											}											else											{												celltodraw1->nested = celltodraw;												LSetCell (&celltodraw1, dataLen, oCell, lst);											}											celltodraw->next = NULL;										}										else										{											wasmove = LAddRow (1, wasmove + 1, lst);	//	+ 1 is for add always after											SetPt (&oCell, 0, wasmove);											LSetCell (&celltodraw, dataLen, oCell, lst);										}									}									else									{										LGetCell (&celltodraw, &dataLen, oCell, lst);										LDelRow (1, oCell.v, lst);																				SetPt (&oCell, 0, wasmove - 1);										LGetCell (&celltodraw1, &dataLen, oCell, lst);																				SetPt (&theCell, 0, pCell.v - 1);										LGetCell (&celltodraw2, &dataLen, theCell, lst);																				if (celltodraw2->owner == -1)										{											if (pCell.v < (*lst)->dataBounds.bottom)											{												LGetCell (&celltodraw3, &dataLen, pCell, lst);												if (celltodraw3->owner == -1)													goto emptied2;											}											else											{											emptied2:																							celltodraw2->nested = NULL;												celltodraw2->opened = 0;												LSetCell (&celltodraw2, dataLen, theCell, lst);											}										}																				if (celltodraw1->owner == -1 && !celltodraw1->opened)										{											if (celltodraw1->nested)											{												celltodraw1 = celltodraw1->nested;																								while (celltodraw1->next)													celltodraw1 = celltodraw1->next;																								celltodraw1->next = celltodraw;											}											else											{												celltodraw1->nested = celltodraw;												LSetCell (&celltodraw1, dataLen, oCell, lst);											}											celltodraw->next = NULL;										}										else										{											wasmove = LAddRow (1, wasmove, lst);											SetPt (&oCell, 0, wasmove);											LSetCell (&celltodraw, dataLen, oCell, lst);										}									}																		LSetSelect (true, oCell, lst);									EraseRect (&(*lst)->rView);									LSetDrawingMode (true, lst);									LUpdate (theDialog->visRgn, lst);									LAutoScroll (lst);								}						}						break;					}				}				else					result = CommonFilterProc (theDialog, theEvent, itemHit);								SetPort (savePort);			}						break;		}				break;		case updateEvt:			if (theDialog == Dialog)		{			GetPort (&savePort);			SetPort (theDialog);	//		BeginUpdate (theDialog);			GetDialogItem (theDialog, agList + item, &iType, &iHandle, &iRect);			iRect.right -= 15;			TextFont (4);			GetFontInfo (&fi);			iRect.bottom = iRect.top + ((iRect.bottom - iRect.top) / (*lst)->cellSize.v) * (*lst)->cellSize.v;			TextFont (1);			InsetRect (&iRect, -1, -1);			FrameRect (&iRect);	//		EndUpdate (theDialog);						LUpdate (theDialog->visRgn, lst);			SetPort (savePort);			result = CommonFilterProc (theDialog, theEvent, itemHit);		}				break;	}	return result;}static pascal Boolean ModalAreas ( DialogPtr theDialog, EventRecord *theEvent, short *itemHit ){	Boolean 	result = false;	Point		localWhere = theEvent->where;	GrafPtr		savePort;	short		initem, part, dataLen, i, dummy;	WindowPtr	window;	short		pane = (((DialogPeek)theDialog)->window.refCon) & 0xFFFF;	short		item = (((DialogPeek)theDialog)->window.refCon) >> 16;		Boolean		dblClick;	Cell		theCell, oCell, pCell;	hier_item_p	celltodraw, celltodraw1, celltodraw2, celltodraw3;	short		iType, offset, len;	Handle		iHandle;	Rect		iRect;	FontInfo	fi;	switch (theEvent->what)	{	case keyDown:	case autoKey:			part = theEvent->message & 0x00FF;			if (part < 0x20 && part != 8 && part != 9 && part != 0x1c && part != 0x1d)			result = true;		break;		case mouseDown:			switch ( part = FindWindow (theEvent->where, &window) )		{		case inContent:					if (window != FrontWindow())			{				SelectWindow(window);				result = true;			}			else			{				GetPort (&savePort);				SetPort (theDialog);				GlobalToLocal (&localWhere);								initem = FindDialogItem (theDialog, localWhere) + 1;								if (initem > item)				{					initem -= item;									switch (initem)					{					case aList:						semaphore = false;						sweep = false;						wasmove = -1;						if (LClick (localWhere, theEvent->modifiers, lst))						{							if (!sweep)								*itemHit = aList + item;							else								goto triangle;	//	ignore triangle dblclick						}						else						{						triangle:													*itemHit = -1;							result = true;							if (sweep)		//	Hit triangle							{								oCell = LLastClick (lst);								LGetCellDataLocation (&offset, &len, oCell, lst);																if (offset != -1)								{									dataLen = sizeof (hier_item_p);									LGetCell (&celltodraw, &dataLen, oCell, lst);																		LSetDrawingMode (false, lst);									celltodraw->opened = 3 - celltodraw->opened;									LSetCell (&celltodraw, dataLen, oCell, lst);																			EraseRect (&(*lst)->rView);									LSetDrawingMode (true, lst);									LUpdate (theDialog->visRgn, lst);									LAutoScroll (lst);								}							}							else								if (wasmove != -1)				//	was moved								{									LSetDrawingMode (false, lst);									pCell = oCell = LLastClick (lst);																		dataLen = sizeof (hier_item_p);									if (oCell.v > wasmove)									{										LGetCell (&celltodraw, &dataLen, oCell, lst);										LDelRow (1, oCell.v, lst);																				wasmove = LAddRow (1, wasmove, lst);	//	+ 1 is for add always after										SetPt (&oCell, 0, wasmove);										LSetCell (&celltodraw, dataLen, oCell, lst);									}									else									{										LGetCell (&celltodraw, &dataLen, oCell, lst);										LDelRow (1, oCell.v, lst);										wasmove = LAddRow (1, wasmove, lst);										SetPt (&oCell, 0, wasmove);										LSetCell (&celltodraw, dataLen, oCell, lst);									}																		LSetSelect (true, oCell, lst);									EraseRect (&(*lst)->rView);									LSetDrawingMode (true, lst);									LUpdate (theDialog->visRgn, lst);									LAutoScroll (lst);								}						}						break;					}				}				else					result = CommonFilterProc (theDialog, theEvent, itemHit);								SetPort (savePort);			}						break;		}				break;	case updateEvt:			if (theDialog == Dialog)		{			GetPort (&savePort);			SetPort (theDialog);	//		BeginUpdate (theDialog);			GetDialogItem (theDialog, aList + item, &iType, &iHandle, &iRect);			iRect.right -= 15;			TextFont (4);			GetFontInfo (&fi);			iRect.bottom = iRect.top + ((iRect.bottom - iRect.top) / (*lst)->cellSize.v) * (*lst)->cellSize.v;			TextFont (1);			InsetRect (&iRect, -1, -1);			FrameRect (&iRect);	//		EndUpdate (theDialog);						LUpdate (theDialog->visRgn, lst);			SetPort (savePort);			result = CommonFilterProc (theDialog, theEvent, itemHit);		}				break;	}	return result;}static pascal Boolean ModalLinks ( DialogPtr theDialog, EventRecord *theEvent, short *itemHit ){	Boolean 	result = false;	Point		localWhere = theEvent->where;	GrafPtr		savePort;	short		initem, part, dataLen, i, dummy;	WindowPtr	window;	short		pane = (((DialogPeek)theDialog)->window.refCon) & 0xFFFF;	short		item = (((DialogPeek)theDialog)->window.refCon) >> 16;		Boolean		dblClick;	Cell		theCell, oCell, pCell;	hier_item_p	celltodraw, celltodraw1, celltodraw2, celltodraw3;	short		iType;	Handle		iHandle;	Rect		iRect;	FontInfo	fi;	switch (theEvent->what)	{	case keyDown:	case autoKey:			part = theEvent->message & 0x00FF;			if (part < 0x20 && part != 8 && part != 9 && part != 0x1c && part != 0x1d)			result = true;		break;		case mouseDown:			switch ( part = FindWindow (theEvent->where, &window) )		{		case inContent:					if (window != FrontWindow())			{				SelectWindow(window);				result = true;			}			else			{				GetPort (&savePort);				SetPort (theDialog);				GlobalToLocal (&localWhere);								initem = FindDialogItem (theDialog, localWhere) + 1;								if (initem > item)				{					initem -= item;									switch (initem)					{					case lList:						if (LClick (localWhere, theEvent->modifiers, lst))							*itemHit = lList + item;						else						{							*itemHit = -1;							result = true;						}						break;					}				}				else					result = CommonFilterProc (theDialog, theEvent, itemHit);								SetPort (savePort);			}						break;		}				break;	case updateEvt:			if (theDialog == Dialog)		{			GetPort (&savePort);			SetPort (theDialog);	//		BeginUpdate (theDialog);			GetDialogItem (theDialog, aList + item, &iType, &iHandle, &iRect);			iRect.right -= 15;			TextFont (4);			GetFontInfo (&fi);			iRect.bottom = iRect.top + ((iRect.bottom - iRect.top) / (*lst)->cellSize.v) * (*lst)->cellSize.v;			TextFont (1);			InsetRect (&iRect, -1, -1);			FrameRect (&iRect);	//		EndUpdate (theDialog);						LUpdate (theDialog->visRgn, lst);			SetPort (savePort);			result = CommonFilterProc (theDialog, theEvent, itemHit);		}				break;	}	return result;}typedef struct _pane {	Str255		pane_name;	short		pane_ditl;	short		pane_order;	} t_pane;typedef struct _panes {	short		num_of_panes;	t_pane		pane[];} t_panes, *p_panes, **h_panes;static	h_panes				panes;static	ModalFilterProcPtr	*panes_procs;static void FillPortsMenu (MenuHandle mHndl){	CRMRec			c;	CRMRecPtr		cPtr = &c;	CRMSerialPtr	serialPtr;	c.crmDeviceType = crmSerialDevice;	c.crmDeviceID   = 0;	while (cPtr)	{		cPtr = (CRMRecPtr)CRMSearch((CRMRecPtr)cPtr);				if (cPtr)		{			serialPtr = (CRMSerialPtr)cPtr->crmAttributes;			AppendMenu (mHndl, *(serialPtr->name));			c.crmDeviceID = cPtr->crmDeviceID;		}	}}static ListAndPopUpConstructor ( DialogPtr theDialog ){	short		pane = (((DialogPeek)theDialog)->window.refCon) & 0xFFFF;	short		item = (((DialogPeek)theDialog)->window.refCon) >> 16;	short		iType, i, j, dummy;	Handle		iHandle;	Rect		iRect, rDataBnds;	Point		cellSize, theCell;	Str255		temp;	Str255		tmp;	MenuHandle	mHandle;	long		lll;	hier_item_p	celltodraw, celltodraw1;	FontInfo	fi;		short		procID, err;		TextFont (1);	TextSize (9);	switch (pane)	{	case paneAreasGroups:				GetDialogItem (theDialog, agList + item, &iType, &iHandle, &iRect);		SetRect ( &rDataBnds, 0, 0, 1, 0 );		iRect.right -= 15;		SetPt ( &cellSize, 0, 0 );		TextFont (4);		GetFontInfo (&fi);		SetPt ( &cellSize, iRect.right - iRect.left, fi.leading+fi.ascent+fi.descent+2 );		if (cellSize.v < 14)			cellSize.v = 14;				iRect.bottom = iRect.top + ((iRect.bottom - iRect.top) / cellSize.v) * cellSize.v;		lst = LNew ( &iRect, &rDataBnds, cellSize, 111, theDialog, true, false, false, true );		TextFont (1);		clickable = iRect;		clickable.left += 1;		clickable.right = clickable.left + 15;		InsetRect (&iRect, -1, -1);		FrameRect (&iRect);				SetPt (&((*lst)->indent), 0, 0);		(*lst)->selFlags = 0x82;		(*lst)->lClickLoop = myLClick;				h_list = NULL;				for (i = 1; i <= GroupsNumber; i++)		{			if (!h_list)				h_list = celltodraw = (hier_item_p) NewPtrClear (sizeof (hier_item));			else			{				celltodraw->next = (hier_item_p) NewPtrClear (sizeof (hier_item));				celltodraw = celltodraw->next;			}			celltodraw->owner = -1;			celltodraw->opened = 0;			celltodraw->next = NULL;						pStrCopy ((*groupsHndls[i-1])->groupName, celltodraw->name);						celltodraw->RefCon = (Handle) groupsHndls[i-1];		}				LSetDrawingMode (false, lst);		LAddRow (GroupsNumber, 0, lst);		i = 0;				celltodraw = h_list;				while (celltodraw)		{			SetPt (&theCell, 0, i);			LSetCell (&celltodraw, sizeof (hier_item_p), theCell, lst);			for (j = 0; j < AreasNumber; j++)			{				if ((*areasHndls[j])->group != i)					continue;								if (!celltodraw->nested)					celltodraw->nested = celltodraw1 = (hier_item_p) NewPtrClear (sizeof (hier_item));				else				{					celltodraw1->next = (hier_item_p) NewPtrClear (sizeof (hier_item));					celltodraw1 = celltodraw1->next;				}				celltodraw1->owner = 0;				celltodraw1->opened = ((*areasHndls[j])->areaflags & AREA_PASSTROUGH) ? 3 : 0;				celltodraw1->next = NULL;								pStrCopy ((*areasHndls[j])->areaName, celltodraw1->name);				celltodraw1->RefCon = (Handle) areasHndls[j];			}			celltodraw = celltodraw->next;			i++;		}		LSetDrawingMode (true, lst);				LUpdate (theDialog->visRgn, lst);		break;			case paneAreas:			GetDialogItem (theDialog, aList + item, &iType, &iHandle, &iRect);		SetRect ( &rDataBnds, 0, 0, 1, 0 );		iRect.right -= 15;		SetPt ( &cellSize, 0, 0 );		TextFont (4);		GetFontInfo (&fi);		SetPt ( &cellSize, iRect.right - iRect.left, fi.leading+fi.ascent+fi.descent+2 );		if (cellSize.v < 14)			cellSize.v = 14;				iRect.bottom = iRect.top + ((iRect.bottom - iRect.top) / cellSize.v) * cellSize.v;		lst = LNew ( &iRect, &rDataBnds, cellSize, 111, theDialog, true, false, false, true );		TextFont (1);		clickable = iRect;		clickable.left += 1;		clickable.right = clickable.left + 15;		InsetRect (&iRect, -1, -1);		FrameRect (&iRect);				SetPt (&((*lst)->indent), 0, 0);		(*lst)->selFlags = 0x82;		(*lst)->lClickLoop = myLClick;				h_list = NULL;				for (i = 1; i <= AreasNumber; i++)		{			if (!h_list)				h_list = celltodraw = (hier_item_p) NewPtrClear (sizeof (hier_item));			else			{				celltodraw->next = (hier_item_p) NewPtrClear (sizeof (hier_item));				celltodraw = celltodraw->next;			}			celltodraw->owner = 0;			celltodraw->opened = ((*areasHndls[i-1])->areaflags & AREA_PASSTROUGH) ? 3 : 0;			celltodraw->next = NULL;						pStrCopy ((*areasHndls[i-1])->areaName, celltodraw->name);						celltodraw->RefCon = (Handle) areasHndls[i-1];		}			LSetDrawingMode (false, lst);		LAddRow (AreasNumber, 0, lst);				celltodraw = h_list;		i = 0;				while (celltodraw)		{			SetPt (&theCell, 0, i);			LSetCell (&celltodraw, sizeof (hier_item_p), theCell, lst);			celltodraw = celltodraw->next;			i++;		}		LSetDrawingMode (true, lst);				LUpdate (theDialog->visRgn, lst);		break;	case paneLinks:			GetDialogItem (theDialog, lList + item, &iType, &iHandle, &iRect);		SetRect ( &rDataBnds, 0, 0, 1, 0 );		iRect.right -= 15;		SetPt ( &cellSize, 0, 0 );		TextFont (4);		GetFontInfo (&fi);		SetPt ( &cellSize, iRect.right - iRect.left, fi.leading+fi.ascent+fi.descent+2 );		if (cellSize.v < 14)			cellSize.v = 14;				iRect.bottom = iRect.top + ((iRect.bottom - iRect.top) / cellSize.v) * cellSize.v;		lst = LNew ( &iRect, &rDataBnds, cellSize, 111, theDialog, true, false, false, true );		TextFont (1);		clickable = iRect;		clickable.left += 1;		clickable.right = clickable.left + 15;		InsetRect (&iRect, -1, -1);		FrameRect (&iRect);				SetPt (&((*lst)->indent), 0, 0);		(*lst)->selFlags = 0x82;//		(*lst)->lClickLoop = myLClick;				h_list = NULL;		for (i = 1; i <= NodesNumber; i++)		{			if (!h_list)				h_list = celltodraw = (hier_item_p) NewPtrClear (sizeof (hier_item));			else			{				celltodraw->next = (hier_item_p) NewPtrClear (sizeof (hier_item));				celltodraw = celltodraw->next;			}			celltodraw->owner = 0;			celltodraw->opened = 0;			celltodraw->next = NULL;						pStrCopy ((*nodesHndls[i-1])->nodeName, temp);						pStrConc (temp, "\p (", temp);			printaddr (&(*nodesHndls[i-1])->Addr, (char *) &tmp[1]);			tmp[0] = strlen ((char *) &tmp[1]);			pStrConc (temp, tmp, temp);			pStrConc (temp, "\p)", temp);						pStrCopy (temp, celltodraw->name);			celltodraw->RefCon = (Handle) nodesHndls[i-1];		}			LSetDrawingMode (false, lst);		LAddRow (NodesNumber, 0, lst);				celltodraw = h_list;		i = 0;				while (celltodraw)		{			SetPt (&theCell, 0, i);			LSetCell (&celltodraw, sizeof (hier_item_p), theCell, lst);			celltodraw = celltodraw->next;			i++;		}		LSetDrawingMode (true, lst);				LUpdate (theDialog->visRgn, lst);		break;		case paneComm:			for (i = 0; i < 12; i++)			if ( (*comm_pref)->baud == bauds[i] )				break;				if (i == 12)			i = 0;					i++;				if (SerialDMA)		{			i = 12 + SerialDMA;		}				GetDialogItem ( theDialog, item + commBaud, &iType, &iHandle, &iRect );		SetControlValue ( (ControlHandle) iHandle, i );		for (i = 0; i < 3; i++)			if ( (*comm_pref)->stop == stops[i] )				break;				if (i == 3)			i = 0;					i++;				GetDialogItem ( theDialog, item + commStops, &iType, &iHandle, &iRect );		SetControlValue ( (ControlHandle) iHandle, i );				for (i = 0; i < 3; i++)			if ( (*comm_pref)->parity == parities[i] )				break;				if (i == 3)			i = 0;					i++;				GetDialogItem ( theDialog, item + commParity, &iType, &iHandle, &iRect );		SetControlValue ( (ControlHandle) iHandle, i );		for (i = 0; i < 4; i++)			if ( (*comm_pref)->data == datas[i] )				break;				if (i == 4)			i = 0;					i++;				GetDialogItem ( theDialog, item + commData, &iType, &iHandle, &iRect );		SetControlValue ( (ControlHandle) iHandle, i );				GetDialogItem ( theDialog, item + commHSK, &iType, &iHandle, &iRect );		SetControlValue ( (ControlHandle) iHandle, ((*comm_pref)->hanshake & 0xFF) + 1 );				GetDialogItem ( theDialog, item + commLockPort, &iType, &iHandle, &iRect );		SetControlValue ( (ControlHandle) iHandle, ((*comm_pref)->hanshake & 0x0F00) ? 1 : 0 );				GetDialogItem ( theDialog, item + commTone, &iType, &iHandle, &iRect );		SetControlValue ( (ControlHandle) iHandle, ((*comm_pref)->hanshake & 0xF000) ? 1 : 0 );				GetDialogItem ( theDialog, item + commDCD, &iType, &iHandle, &iRect );		SetControlValue ( (ControlHandle) iHandle, ((*comm_pref)->isdcd & 0x00FF) ? 1 : 0 );				GetDialogItem ( theDialog, item + commSuperDot, &iType, &iHandle, &iRect );		SetControlValue ( (ControlHandle) iHandle, ((*comm_pref)->isdcd & 0xFF00) ? 1 : 0 );						GetDialogItem ( theDialog, item + commPort, &iType, &iHandle, &iRect );		FillPortsMenu (mHandle = ((popupPrivateData *)(*(*((ControlHandle) iHandle))->contrlData))->mHandle);		tmp[0] = 0;		if (toolName[0])		{	//	¥	CommTool already selected&configured					procID = CMGetProcID (toolName);					if (procID == -1)			{	//	¥	CommTool has been removed?				goto asnew;			}		}		else		{	//	¥	No CommTool was selected&confogured	asnew:					err = CRMGetIndToolName (classCM, 1, tmp);			toolName[0] = 0;			configStr = NULL;						if (err != noErr)				tmp[0] = 0;		}		if (toolName[0])		{			SetMenuItemText (mHandle, 1, toolName);		}				if (toolName[0] || tmp[0])			EnableItem (mHandle, 1);		if (FindDriverByName ("\p.ipp"))			EnableItem (mHandle, 2);		SetControlMaximum ((ControlHandle) iHandle, j = CountMenuItems (mHandle));				if ((*comm_pref)->port_name[0] == 0xFF)		{			if (FindDriverByName ("\p.ipp"))				i = 2;			else				i = 4;		}		else			for (i = 4; i <= j; i++)			{				GetMenuItemText (mHandle, i, tmp);				if (!pStrComp ((*comm_pref)->port_name, tmp))					break;			}				if (i > j)			if (!pStrComp ((*comm_pref)->port_name, toolName))				i = 1;			else				i = 4;				SetControlValue ((ControlHandle) iHandle, i);				GetDialogItem ( theDialog, item + commInitString, &iType, &iHandle, &iRect );		SetDialogItemText ( iHandle, mdmInitStr );				if (i != 1 && i != 2)		{			GetDialogItem ( theDialog, item + commCTBSetup, &iType, &iHandle, &iRect );			HiliteControl ((ControlHandle) iHandle, 255);					GetDialogItem ( theDialog, item + commCTBEdit, &iType, &iHandle, &iRect );			HiliteControl ((ControlHandle) iHandle, 255);		}		else			if (i == 2)			{				GetDialogItem ( theDialog, item + commCTBSetup, &iType, &iHandle, &iRect );				SetControlTitle ((ControlHandle) iHandle, "\pTCP Setup");								GetDialogItem ( theDialog, item + commCTBEdit, &iType, &iHandle, &iRect );				HiliteControl ((ControlHandle) iHandle, 255);			}				break;		case paneTransport:			GetDialogItem ( theDialog, item + tptNoResync, &iType, &iHandle, &iRect );		SetControlValue ( (ControlHandle) iHandle, (*ftsc)->no_resync );		GetDialogItem ( theDialog, item + tptNoOverdrive, &iType, &iHandle, &iRect );		SetControlValue ( (ControlHandle) iHandle, (*ftsc)->no_overdrive );		GetDialogItem ( theDialog, item + tptSmallWindow, &iType, &iHandle, &iRect );		SetControlValue ( (ControlHandle) iHandle, (*ftsc)->small_window );		GetDialogItem ( theDialog, item + tptZModem32, &iType, &iHandle, &iRect );		SetControlValue ( (ControlHandle) iHandle, (*hydra)->zmodem32 );		GetDialogItem ( theDialog, item + tptJanus32, &iType, &iHandle, &iRect );		SetControlValue ( (ControlHandle) iHandle, (*hydra)->janus32 );		GetDialogItem ( theDialog, item + tptHydra32, &iType, &iHandle, &iRect );		SetControlValue ( (ControlHandle) iHandle, (*hydra)->hydra32 );		GetDialogItem ( theDialog, item + tptHydraEsc, &iType, &iHandle, &iRect );		SetControlValue ( (ControlHandle) iHandle, (*hydra)->hydra_esc );				GetDialogItem ( theDialog, item + tptHydraUUE, &iType, &iHandle, &iRect );		SetControlValue ( (ControlHandle) iHandle, (*hydra)->hydra_uue );				GetDialogItem ( theDialog, item + tptChat, &iType, &iHandle, &iRect );		SetControlValue ( (ControlHandle) iHandle, (*hydra)->chat );				GetDialogItem ( theDialog, item + tptHydraHigh, &iType, &iHandle, &iRect );		SetControlValue ( (ControlHandle) iHandle, (*hydra)->hydra_hi8 );				GetDialogItem ( theDialog, item + tptHydra8K, &iType, &iHandle, &iRect );		SetControlValue ( (ControlHandle) iHandle, (*ftsc)->hydra8 );		GetDialogItem ( theDialog, item + tptHydra16K, &iType, &iHandle, &iRect );		SetControlValue ( (ControlHandle) iHandle, (*ftsc)->hydra16 );		break;		case paneEMSI:			GetDialogItem ( theDialog, item + emsiLocation, &iType, &iHandle, &iRect );		SetDialogItemText (iHandle, (*homesystem)->location);		GetDialogItem ( theDialog, item + emsiPhone, &iType, &iHandle, &iRect );		SetDialogItemText (iHandle, (*homesystem)->phone);		GetDialogItem ( theDialog, item + emsiBaud, &iType, &iHandle, &iRect );		SetDialogItemText (iHandle, (*homesystem)->baud);		GetDialogItem ( theDialog, item + emsiFlags, &iType, &iHandle, &iRect );		SetDialogItemText (iHandle, (*homesystem)->emsi_flags);		GetDialogItem ( theDialog, item + emsiSyncLink, &iType, &iHandle, &iRect );		mHandle = ((popupPrivateData *)(*(*((ControlHandle) iHandle))->contrlData))->mHandle;				j = 1;		for (i=0; i<NodesNumber; i++)		{			AppendMenu (mHandle, "\pdummy");			printaddr (&(*nodesHndls[i])->Addr, (char *) &tmp[1]);			tmp[0] = strlen ((char *) &tmp[1]);			SetMenuItemText (mHandle, i+3, tmp);			if (i==(*hydra)->timesynclink)				j = i+3;		}		SetControlMinimum ((ControlHandle) iHandle, 1);		SetControlMaximum ((ControlHandle) iHandle, NodesNumber+2);		SetControlValue ((ControlHandle) iHandle, j);		NumToString ((*hydra)->timesyncbounds, tmp);		GetDialogItem ( theDialog, item + emsiSyncBnd, &iType, &iHandle, &iRect );		SetDialogItemText (iHandle, tmp);				break;	}}static Boolean ListAndPopUpDestructor ( DialogPtr theDialog ){	short		pane = (((DialogPeek)theDialog)->window.refCon) & 0xFFFF;	short		item = (((DialogPeek)theDialog)->window.refCon) >> 16;	short		iType, dummy, i, len;	Handle		iHandle;	Rect		iRect;	Str255		temp;	Str255		d;//	ADDR		address;	Cell		theCell;	long		tl, lll;	short		markChar, dataLen;	hier_item_p	celltodraw, celltodraw1, celltodraw2;		MenuHandle	mHandle;	switch (pane)	{	case paneAreasGroups:		i = 0;				LSetDrawingMode (false, lst);		while (i < (*lst)->dataBounds.bottom)		{			SetPt (&theCell, 0, i);			dataLen = sizeof (hier_item_p);			LGetCell (&celltodraw, &dataLen, theCell, lst);				if (celltodraw->owner == -1 && celltodraw->opened)			{				celltodraw1 = NULL;				celltodraw->nested = NULL;				i++;								while (i < (*lst)->dataBounds.bottom)				{					SetPt (&theCell, 0, i);					dataLen = sizeof (hier_item_p);					LGetCell (&celltodraw2, &dataLen, theCell, lst);										if (celltodraw2->owner == -1)						break;										if (!celltodraw1)						celltodraw->nested = celltodraw2;					else						celltodraw1->next = celltodraw2;											celltodraw2->next = NULL;										celltodraw1 = celltodraw2;										LDelRow (1, i, lst);				}		//		if (celltodraw2->owner != -1)		//			i++;			}			else				i++;		}		celltodraw = h_list;				i = 0;				while (celltodraw)		{			if (celltodraw->nested)			{				celltodraw1 = celltodraw->nested;								while (celltodraw1)				{					(*(areaPrefHndl)(celltodraw1->RefCon))->group = i;					(*(areaPrefHndl)(celltodraw1->RefCon))->areaflags &= ~AREA_PASSTROUGH;					(*(areaPrefHndl)(celltodraw1->RefCon))->areaflags |= (celltodraw1->opened) ? AREA_PASSTROUGH : 0;					celltodraw2 = celltodraw1->next;					DisposePtr ((Ptr) celltodraw1);					celltodraw1 = celltodraw2;				}			}			celltodraw2 = celltodraw->next;			DisposePtr ((Ptr) celltodraw);			celltodraw = celltodraw2;			i++;		}				LDispose (lst);		break;	case paneAreas:				if (AreasNumber != (*lst)->dataBounds.bottom)			DebugStr ("\pAreasNumber and List's raws quantity missmatch!");		for (i = 0; i < (*lst)->dataBounds.bottom; i++)		{			SetPt (&theCell, 0, i);			dataLen = sizeof (hier_item_p);			LGetCell (&celltodraw, &dataLen, theCell, lst);			areasHndls[i] = (areaPrefHndl)celltodraw->RefCon;		}			celltodraw = h_list;		i = 0;				while (celltodraw)		{			(*(areaPrefHndl)(celltodraw->RefCon))->areaflags &= ~AREA_PASSTROUGH;			(*(areaPrefHndl)(celltodraw->RefCon))->areaflags |= (celltodraw->opened) ? AREA_PASSTROUGH : 0;			celltodraw2 = celltodraw->next;			DisposePtr ((Ptr) celltodraw);			celltodraw = celltodraw2;			i++;		}				LDispose (lst);		break;	case paneLinks:				celltodraw = h_list;				i = 0;				while (celltodraw)		{			celltodraw2 = celltodraw->next;			DisposePtr ((Ptr) celltodraw);			celltodraw = celltodraw2;			i++;		}				LDispose (lst);		break;	case paneComm:			GetDialogItem ( theDialog, item + commBaud, &iType, &iHandle, &iRect );				i = GetControlValue ( (ControlHandle) iHandle ) - 1;				if (i > 11)		{			SerialDMA = i - 11;			i = 11;		}		else			SerialDMA = 0;				(*comm_pref)->baud = bauds[i];		GetDialogItem ( theDialog, item + commStops, &iType, &iHandle, &iRect );		(*comm_pref)->stop = stops[GetControlValue ( (ControlHandle) iHandle ) - 1];				GetDialogItem ( theDialog, item + commParity, &iType, &iHandle, &iRect );		(*comm_pref)->parity = parities[GetControlValue ( (ControlHandle) iHandle ) - 1];				GetDialogItem ( theDialog, item + commData, &iType, &iHandle, &iRect );		(*comm_pref)->data = datas[GetControlValue ( (ControlHandle) iHandle ) - 1];				GetDialogItem ( theDialog, item + commHSK, &iType, &iHandle, &iRect );		(*comm_pref)->hanshake = GetControlValue ( (ControlHandle) iHandle ) - 1;				GetDialogItem ( theDialog, item + commLockPort, &iType, &iHandle, &iRect );		(*comm_pref)->hanshake |= GetControlValue ( (ControlHandle) iHandle ) << 8;				GetDialogItem ( theDialog, item + commTone, &iType, &iHandle, &iRect );		(*comm_pref)->hanshake |= GetControlValue ( (ControlHandle) iHandle ) << 12;				GetDialogItem ( theDialog, item + commDCD, &iType, &iHandle, &iRect );		(*comm_pref)->isdcd = GetControlValue ( (ControlHandle) iHandle );				GetDialogItem ( theDialog, item + commSuperDot, &iType, &iHandle, &iRect );		(*comm_pref)->isdcd |= (GetControlValue ( (ControlHandle) iHandle )) ? 0x0100 : 0;				GetDialogItem ( theDialog, item + commPort, &iType, &iHandle, &iRect );		mHandle = ((popupPrivateData *)(*(*((ControlHandle) iHandle))->contrlData))->mHandle;		i = GetControlValue ((ControlHandle) iHandle);		GetMenuItemText (mHandle, i, (*comm_pref)->port_name);				if (i == 1)		{			if (!pStrComp ((*comm_pref)->port_name, "\pCTB"))			{				GetMenuItemText (mHandle, 4, (*comm_pref)->port_name);							toolName[0] = 0;				if (configStr)					DisposePtr (configStr);								configStr = NULL;			}		}		else			if (i == 2)			{				(*comm_pref)->port_name[0] = 0xFF;				toolName[0] = 0;				if (configStr)					DisposePtr (configStr);								configStr = NULL;			}			else			{				toolName[0] = 0;				if (configStr)					DisposePtr (configStr);								configStr = NULL;			}				GetDialogItem ( theDialog, item + commInitString, &iType, &iHandle, &iRect );		GetDialogItemText ( iHandle, mdmInitStr );				break;	case paneTransport:		GetDialogItem ( theDialog, item + tptNoResync, &iType, &iHandle, &iRect );		(*ftsc)->no_resync = GetControlValue ( (ControlHandle) iHandle );		GetDialogItem ( theDialog, item + tptNoOverdrive, &iType, &iHandle, &iRect );		(*ftsc)->no_overdrive = GetControlValue ( (ControlHandle) iHandle );		GetDialogItem ( theDialog, item + tptSmallWindow, &iType, &iHandle, &iRect );		(*ftsc)->small_window = GetControlValue ( (ControlHandle) iHandle );		GetDialogItem ( theDialog, item + tptZModem32, &iType, &iHandle, &iRect );		(*hydra)->zmodem32 = GetControlValue ( (ControlHandle) iHandle );		GetDialogItem ( theDialog, item + tptJanus32, &iType, &iHandle, &iRect );		(*hydra)->janus32 = GetControlValue ( (ControlHandle) iHandle );		GetDialogItem ( theDialog, item + tptHydra32, &iType, &iHandle, &iRect );		(*hydra)->hydra32 = GetControlValue ( (ControlHandle) iHandle );		GetDialogItem ( theDialog, item + tptHydraEsc, &iType, &iHandle, &iRect );		(*hydra)->hydra_esc = GetControlValue ( (ControlHandle) iHandle );		GetDialogItem ( theDialog, item + tptHydraHigh, &iType, &iHandle, &iRect );		(*hydra)->hydra_hi8 = GetControlValue ( (ControlHandle) iHandle );		GetDialogItem ( theDialog, item + tptHydraUUE, &iType, &iHandle, &iRect );		(*hydra)->hydra_uue = GetControlValue ( (ControlHandle) iHandle );		GetDialogItem ( theDialog, item + tptChat, &iType, &iHandle, &iRect );		(*hydra)->chat = GetControlValue ( (ControlHandle) iHandle );		GetDialogItem ( theDialog, item + tptHydra8K, &iType, &iHandle, &iRect );		(*ftsc)->hydra8 = GetControlValue ( (ControlHandle) iHandle );		GetDialogItem ( theDialog, item + tptHydra16K, &iType, &iHandle, &iRect );		(*ftsc)->hydra16 = GetControlValue ( (ControlHandle) iHandle );		break;	case paneEMSI:			GetDialogItem ( theDialog, item + emsiLocation, &iType, &iHandle, &iRect );		GetDialogItemText (iHandle, (*homesystem)->location);		GetDialogItem ( theDialog, item + emsiPhone, &iType, &iHandle, &iRect );		GetDialogItemText (iHandle, (*homesystem)->phone);		GetDialogItem ( theDialog, item + emsiBaud, &iType, &iHandle, &iRect );		GetDialogItemText (iHandle, (*homesystem)->baud);		GetDialogItem ( theDialog, item + emsiFlags, &iType, &iHandle, &iRect );		GetDialogItemText (iHandle, (*homesystem)->emsi_flags);		GetDialogItem ( theDialog, item + emsiSyncLink, &iType, &iHandle, &iRect );		i = GetControlValue ((ControlHandle) iHandle);		(*hydra)->timesynclink = (i == 1) ? -1 : i-3;				GetDialogItem ( theDialog, item + emsiSyncBnd, &iType, &iHandle, &iRect );		GetDialogItemText (iHandle, temp);		StringToNum (temp, &lll);		(*hydra)->timesyncbounds = (lll>255)?0:lll;				if (!lll || lll>255)			(*hydra)->timesynclink = -1;			break;	}		return true;}static Boolean ListAndPopUpClick ( DialogPtr theDialog, short iHit ){	short		pane = (((DialogPeek)theDialog)->window.refCon) & 0xFFFF;	short		item = (((DialogPeek)theDialog)->window.refCon) >> 16;	Cell		theCell;	short		iType, dummy;	Handle		iHandle;	Rect		iRect;	Str255		temp, d;//	ADDR		address;	short		groups, defgrp, i, j, k, l, markChar, dataLen;	MenuHandle	mHandle;	long		lll;	Boolean		res = false;//	nodePrefHndl	*nodesHndlsPlus;//	areaPrefHndl	*areasHndlsPlus;	groupPrefHndl	*groupsHndlsPlus;	groupPrefHndl	groupHndlPlus;//	eventsHndl		*eventsHndlsPlus;//	routeHndl		routingHndlsPlus;	StringPtr		*ptr_temp;	Boolean			addena;	hier_item_p		celltodraw, celltodraw1, celltodraw2;			iHit -= item;	switch (pane)	{	case paneAreasGroups:				SetPt ( &theCell, 0, 0 );			if (!LGetSelect (1, &theCell, lst) && iHit != agAddGroup)			break;					celltodraw = h_list;				i = 0;				while (celltodraw)		{			if (celltodraw->nested)			{				celltodraw1 = celltodraw->nested;								while (celltodraw1)				{					(*(areaPrefHndl)(celltodraw1->RefCon))->group = i;					(*(areaPrefHndl)(celltodraw1->RefCon))->areaflags &= ~AREA_PASSTROUGH;					(*(areaPrefHndl)(celltodraw1->RefCon))->areaflags |= (celltodraw1->opened) ? AREA_PASSTROUGH : 0;					celltodraw1 = celltodraw1->next;				}			}			celltodraw = celltodraw->next;			i++;		}		dataLen = sizeof (hier_item_p);		LGetCell (&celltodraw, &dataLen, theCell, lst);				switch (iHit)		{		case agList:			if (celltodraw->owner == -1)			{				ProcessOneGroup ((groupPrefHndl) celltodraw->RefCon);				pStrCopy ((*((groupPrefHndl) celltodraw->RefCon))->groupName, celltodraw->name);			}			else			{				ProcessOneArea ((areaPrefHndl) celltodraw->RefCon);				celltodraw->opened = ((*((areaPrefHndl) celltodraw->RefCon))->areaflags & AREA_PASSTROUGH) ? 3 : 0;				pStrCopy ((*((areaPrefHndl) celltodraw->RefCon))->areaName, celltodraw->name);			}						break;		case agAddGroup:						groupHndlPlus = (groupPrefHndl) NewHandleClear (sizeof (groupPrefType));						if (ProcessOneGroup (groupHndlPlus))			{				if (celltodraw = h_list)				{					while (celltodraw->next)						celltodraw = celltodraw->next;									celltodraw->next = (hier_item_p) NewPtrClear (sizeof (hier_item));					celltodraw = celltodraw->next;				}				else					h_list = celltodraw = (hier_item_p) NewPtrClear (sizeof (hier_item));				celltodraw->owner = -1;				celltodraw->opened = 0;				celltodraw->next = NULL;							pStrCopy ((*groupHndlPlus)->groupName, celltodraw->name);							celltodraw->RefCon = (Handle) groupHndlPlus;								groupsHndlsPlus = (groupPrefHndl *) NewPtrClear (sizeof (Handle) * (GroupsNumber+1));								for (i=0; i<GroupsNumber; i++)					groupsHndlsPlus[i] = groupsHndls[i];								groupsHndlsPlus[i] = groupHndlPlus;								DisposePtr ((Ptr) groupsHndls);								groupsHndls = groupsHndlsPlus;				GroupsNumber++;								LSetSelect (false, theCell, lst);								i = LAddRow (1, 0x7FFF, lst);				SetPt (&theCell, 0, i);				LSetCell (&celltodraw, sizeof (hier_item_p), theCell, lst);				LSetSelect (true, theCell, lst);			}			else				DisposeHandle ((Handle) groupHndlPlus);						break;		case agAddArea:					break;		case agRemove:			if (celltodraw->owner == -1)			{				if (celltodraw->nested)					SysBeep (10);				else				{					celltodraw1 = celltodraw2 = h_list;										i = 0;										while (celltodraw2)					{						if (celltodraw2->owner == -1)						{							if (celltodraw2 == celltodraw)								break;							else								i++;						}						if (celltodraw2 != h_list)								celltodraw1 = celltodraw2;						celltodraw2 = celltodraw2->next;					}										if (celltodraw == h_list)					{						h_list = celltodraw->next;					}					else					{						celltodraw1->next = celltodraw->next;					}										DisposePtr ((Ptr) celltodraw);										groupsHndlsPlus = (groupPrefHndl *) NewPtrClear (sizeof (Handle) * (GroupsNumber-1));										for (j=0, k=0; j<GroupsNumber; j++)						if (j != i)						{							groupsHndlsPlus[k++] = groupsHndls[j];						}										DisposeHandle ((Handle) groupsHndls[i]);					DisposePtr ((Ptr) groupsHndls);										groupsHndls = groupsHndlsPlus;					GroupsNumber--;										for (j=0; j<AreasNumber; j++)						if ((*areasHndls[j])->group > i)							(*areasHndls[j])->group--;												for (j=0; j<NodesNumber; j++)						for (k=0; k<(*nodesHndls[j])->GroupsNumber; )						{							if ((*nodesHndls[j])->group[k] == i)							{								for (l=k+1; l<(*nodesHndls[j])->GroupsNumber; l++)									(*nodesHndls[j])->group[l-1] = (*nodesHndls[j])->group[l];																(*nodesHndls[j])->GroupsNumber--;																SetHandleSize ((Handle) nodesHndls[j], sizeof (nodePrefType) + (*nodesHndls[j])->GroupsNumber*sizeof (short));							}							else							{								if ((*nodesHndls[j])->group[k] > i)									(*nodesHndls[j])->group[k]--;																k++;							}						}											LDelRow (1, theCell.v, lst);				}			}			else			{			}			break;		case agEdit:					if (celltodraw->owner == -1)			{				ProcessOneGroup ((groupPrefHndl) celltodraw->RefCon);				pStrCopy ((*((groupPrefHndl) celltodraw->RefCon))->groupName, celltodraw->name);			}			else			{				ProcessOneArea ((areaPrefHndl) celltodraw->RefCon);				celltodraw->opened = ((*((areaPrefHndl) celltodraw->RefCon))->areaflags & AREA_PASSTROUGH) ? 3 : 0;				pStrCopy ((*((areaPrefHndl) celltodraw->RefCon))->areaName, celltodraw->name);			}						break;		}		break;	case paneAreas:				SetPt ( &theCell, 0, 0 );			if (!LGetSelect ( 1, &theCell, lst))			break;				celltodraw = h_list;				while (celltodraw)		{			(*(areaPrefHndl)(celltodraw->RefCon))->areaflags &= ~AREA_PASSTROUGH;			(*(areaPrefHndl)(celltodraw->RefCon))->areaflags |= (celltodraw->opened) ? AREA_PASSTROUGH : 0;			celltodraw = celltodraw->next;		}				dataLen = sizeof (hier_item_p);		LGetCell (&celltodraw, &dataLen, theCell, lst);				switch (iHit)		{		case aList:			ProcessOneArea ((areaPrefHndl) celltodraw->RefCon);			celltodraw->opened = ((*((areaPrefHndl) celltodraw->RefCon))->areaflags & AREA_PASSTROUGH) ? 3 : 0;			pStrCopy ((*((areaPrefHndl) celltodraw->RefCon))->areaName, celltodraw->name);						break;		case aRemove:			break;		case aEdit:					ProcessOneArea ((areaPrefHndl) celltodraw->RefCon);			celltodraw->opened = ((*((areaPrefHndl) celltodraw->RefCon))->areaflags & AREA_PASSTROUGH) ? 3 : 0;			pStrCopy ((*((areaPrefHndl) celltodraw->RefCon))->areaName, celltodraw->name);			break;		}		break;	case paneLinks:				SetPt ( &theCell, 0, 0 );			if (!LGetSelect ( 1, &theCell, lst))			break;				dataLen = sizeof (hier_item_p);		LGetCell (&celltodraw, &dataLen, theCell, lst);				switch (iHit)		{		case lList:					if (commoninits[theCell.v])				pStrCopy (commoninits[theCell.v], temp);			else				temp[0] = 0;						ProcessOneLink ((nodePrefHndl) celltodraw->RefCon, &temp);			if (temp[0])			{				if (commoninits[theCell.v])				{					DisposePtr ((Ptr)commoninits[theCell.v]);				}				commoninits[theCell.v] = (StringPtr) NewPtrClear (temp[0] + 2);				pStrCopy (temp, commoninits[theCell.v]);			}			else			{				if (commoninits[theCell.v])				{					DisposePtr ((Ptr)commoninits[theCell.v]);					commoninits[theCell.v] = NULL;				}			}						break;		case lAdd:			break;		case lRemove:			break;		case lEdit:			if (commoninits[theCell.v])				pStrCopy (commoninits[theCell.v], temp);			else				temp[0] = 0;						ProcessOneLink ((nodePrefHndl) celltodraw->RefCon, &temp);			if (temp[0])			{				if (commoninits[theCell.v])				{					DisposePtr ((Ptr)commoninits[theCell.v]);				}				commoninits[theCell.v] = (StringPtr) NewPtrClear (temp[0] + 2);				pStrCopy (temp, commoninits[theCell.v]);			}			else			{				if (commoninits[theCell.v])				{					DisposePtr ((Ptr)commoninits[theCell.v]);					commoninits[theCell.v] = NULL;				}			}						break;		}		break;	case paneComm:		switch (iHit)		{		case commLockPort:		case commTone:		case commDCD:		case commSuperDot:			GetDialogItem ( theDialog, item + iHit, &iType, &iHandle, &iRect );			dummy = GetControlValue ( (ControlHandle) iHandle );			SetControlValue ( (ControlHandle) iHandle, !dummy );			break;				case commCTBSetup:					GetDialogItem ( theDialog, item + commPort, &iType, &iHandle, &iRect );			dummy = GetControlValue ( (ControlHandle) iHandle );						if (dummy == 1)			{				GetDialogItem ( theDialog, item + commPort, &iType, &iHandle, &iRect );				doCTBSetup (mHandle = ((popupPrivateData *)(*(*((ControlHandle) iHandle))->contrlData))->mHandle);				SetControlValue ((ControlHandle) iHandle, (toolName[0]) ? 1 : 4);				if (toolName[0])				{					GetDialogItem ( theDialog, item + commCTBSetup, &iType, &iHandle, &iRect );					SetControlTitle ((ControlHandle) iHandle, "\pCTB Setup");					HiliteControl ((ControlHandle) iHandle, 0);									GetDialogItem ( theDialog, item + commCTBEdit, &iType, &iHandle, &iRect );					HiliteControl ((ControlHandle) iHandle, 0);				}				else				{					GetDialogItem ( theDialog, item + commCTBSetup, &iType, &iHandle, &iRect );					SetControlTitle ((ControlHandle) iHandle, "\pCTB Setup");					HiliteControl ((ControlHandle) iHandle, 255);									GetDialogItem ( theDialog, item + commCTBEdit, &iType, &iHandle, &iRect );					HiliteControl ((ControlHandle) iHandle, 255);				}//				UpdateControls (theDialog, theDialog->visRgn);			}			else			{				doTCPSetup ();			}						break;				case commCTBEdit:						if (!configStr)			{				SysBeep (10);				break;			}			else				doCTBEdit ();						break;		case commPort:					GetDialogItem ( theDialog, item + iHit, &iType, &iHandle, &iRect );			dummy = GetControlValue ( (ControlHandle) iHandle );			if (dummy == 1)			{				GetDialogItem ( theDialog, item + commCTBSetup, &iType, &iHandle, &iRect );				SetControlTitle ((ControlHandle) iHandle, "\pCTB Setup");				HiliteControl ((ControlHandle) iHandle, 0);							GetDialogItem ( theDialog, item + commCTBEdit, &iType, &iHandle, &iRect );				HiliteControl ((ControlHandle) iHandle, 0);			}			else				if (dummy == 2)				{					GetDialogItem ( theDialog, item + commCTBSetup, &iType, &iHandle, &iRect );					SetControlTitle ((ControlHandle) iHandle, "\pTCP Setup");					HiliteControl ((ControlHandle) iHandle, 0);									GetDialogItem ( theDialog, item + commCTBEdit, &iType, &iHandle, &iRect );					HiliteControl ((ControlHandle) iHandle, 255);				}				else				{					GetDialogItem ( theDialog, item + commCTBSetup, &iType, &iHandle, &iRect );					HiliteControl ((ControlHandle) iHandle, 255);									GetDialogItem ( theDialog, item + commCTBEdit, &iType, &iHandle, &iRect );					HiliteControl ((ControlHandle) iHandle, 255);				}						break;		}				break;	case paneTransport:		switch (iHit)		{		case tptNoResync:		case tptNoOverdrive:		case tptSmallWindow:		case tptZModem32:		case tptJanus32:		case tptHydra32:		case tptHydraEsc:		case tptHydraUUE:		case tptChat:		case tptHydraHigh:		case tptHydra8K:		case tptHydra16K:			GetDialogItem ( theDialog, item + iHit, &iType, &iHandle, &iRect );			dummy = GetControlValue ( (ControlHandle) iHandle );			SetControlValue ( (ControlHandle) iHandle, !dummy );			break;		}				break;	case paneEMSI:			break;	}	return res;}void main (void){		short			lastID, lastappendedID;	Rect			paneRect;	short			iHit;		short			iCtl, i, dummy;	short			iType, teActive;	Handle			iHandle;	Rect			iRect, rDataBnds;	Point			cellSize;	Cell			theCell;	FontInfo		fi;		Str255			spool;			InitToolbox ();		iHandle = Get1Resource ( 'LDEF', 111 );	*((long *)((*iHandle)+2)) = (long) myldef;		panes = (h_panes) Get1Resource ('Pan#', 128);	if (!panes)		ExitToShell ();		MoveHHi ((Handle) panes);	HLock ((Handle) panes);		panes_procs = (ModalFilterProcPtr *) NewPtrClear ((*panes)->num_of_panes * sizeof (ModalFilterProcPtr));		panes_procs[0] = ModalAbout;	panes_procs[1] = ModalAreasGroups;	panes_procs[2] = ModalAreas;	panes_procs[3] = ModalLinks;		if (!ReadPreference ())		ExitToShell ();		_InstallDITL ( &Dialog, 128, &lastID, &paneRect );	SetPort (Dialog);	TextFont (1);	TextSize (9);	(*(((DialogPeek) Dialog)->textH))->txFont = 1;	(*(((DialogPeek) Dialog)->textH))->txSize = 9;	GetFontInfo (&fi);	(*(((DialogPeek) Dialog)->textH))->lineHeight = fi.ascent + fi.descent + fi.leading;	(*(((DialogPeek) Dialog)->textH))->fontAscent = fi.ascent;	GetDialogItem (Dialog, tmpSelectPane, &iType, &iHandle, &iRect);//	SetControlReference ((ControlHandle) iHandle, ((*panes)->num_of_panes+1) / 2);//	SetControlMaximum ((ControlHandle) iHandle, (*panes)->num_of_panes);	spool[0] = 0;		for (i = 0; i < (*panes)->num_of_panes; i++)	{		pStrConc (spool, (*panes)->pane[i].pane_name, spool);		pStrConc (spool, "\p\xd", spool);	}	SetControlTitle ((ControlHandle) iHandle, spool);	((DialogPeek) Dialog)->window.refCon = ((long) lastID) << 16;	_AppendDITL ( Dialog, (*panes)->pane[0].pane_ditl, &lastappendedID, &paneRect );		ListAndPopUpConstructor ( Dialog );		do {//		ModalDialog ( ModalFilterProc, &iHit );		ModalDialog ( panes_procs[((DialogPeek) Dialog)->window.refCon & 0xFFFF], &iHit );		if (iHit == tmpSelectPane)		{			GetDialogItem (Dialog, tmpSelectPane, &iType, &iHandle, &iRect);			iCtl = GetControlValue ((ControlHandle) iHandle) - 1;					if (iCtl != (((DialogPeek) Dialog)->window.refCon & 0xFFFF))			{				if (ListAndPopUpDestructor ( Dialog ))				{					ShortenDITL ( Dialog, lastappendedID - lastID );					EraseRect (&paneRect);					((DialogPeek) Dialog)->window.refCon = iCtl + (((long) lastID) << 16);					_AppendDITL ( Dialog, (*panes)->pane[iCtl].pane_ditl, &lastappendedID, &paneRect );					ListAndPopUpConstructor ( Dialog );					DrawDialog ( Dialog );					BeginUpdate (Dialog);					UpdateDialog (Dialog, Dialog->visRgn);					EndUpdate (Dialog);				}//				else//				{//					SetControlValue (iHandle, ((DialogPeek) theDialog)->window.refCon & 0xFFFF);//					SysBeep (10);//				}			}		}		else			if (iHit > lastID)			{				iCtl = ((DialogPeek) Dialog)->window.refCon & 0xFFFF;				if (ListAndPopUpClick ( Dialog, iHit ))				{								//	main dialog was disposedÉ								//	_InstallDITL ( &Dialog, 128, &lastID, &paneRect );				//	SetPort (Dialog);				//	SetPt ( &theCell, 0, ((DialogPeek) Dialog)->window.refCon & 0xFFFF );				//	LSetSelect (true, theCell, List);				//	((DialogPeek) Dialog)->window.refCon = iCtl + (((long) lastID) << 16);				//	_AppendDITL ( Dialog, tmplBase, &lastappendedID, &paneRect );									//	ListAndPopUpConstructor ( Dialog );				}			}	} while (iHit != 1 && iHit != 2);	ListAndPopUpDestructor ( Dialog );	DisposeDialog ( Dialog );//	HUnlock ( (Handle) homesystem );		if (iHit == 1)		WritePreference ();}