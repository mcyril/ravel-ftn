//	¥	generalparser.c#include "ravel_ftn.h"#include "generalparser.h"#include <ctype.h>//token_desc	*gTokens = NULL;#pragma mark == Line parser ==#pragma mark -#define	MAXLITERALSIZE	1024static	char	gToken[MAXLITERALSIZE];static longfndtoken (char *from, token_desc *tokens){	long	res = 0;		if (tokens == NULL)		return 0;		while (tokens[res].token_name)		if (!strcasecmp (from, tokens[res].token_name))			return (res + 1);		else			res++;	return 0;}static char *tryliteral(char *p, char *token, long *res){	long i = 0;		p++;	while (*p != 0 && *p != '\"' && (isprint(*p) || (*p & 0x80) != 0) && i < MAXLITERALSIZE-1)	{		if (*p == '\\')		{			p++;			switch (*p)			{			case 'n':	token[i++] = '\n';						p++;						break;			case 'r':	token[i++] = '\r';						p++;						break;			case 't':	token[i++] = '\t';						p++;						break;			case 'b':	token[i++] = '\b';						p++;						break;			case 'f':	token[i++] = '\f';						p++;						break;/*	No new line processing			case '\r':	break;			case '\n':	break;*/			case '\\':	token[i++] = '\\';						p++;						break;			case '\"':	token[i++] = '\"';						p++;						break;			default:	break;			}		}		else		{			token[i++] = *p;			p++;		}	}		if (*p == 0 || *p != '\"' || i >= MAXLITERALSIZE-1 || i == 0)		*res = kERR;	else if (*p == '\"')		token[i] = 0;	else		*res = kERR;	return p;}static char *trynumber(char *p, long *number, long *res){	long i = 0;		*res = kLONGNUMBER;	*number = 0;		while(*p != 0 && isdigit(*p))	{		*number *= 10;		*number += *p - '0';		p++;		i++;	}		if (*number == 0 && i == 1 && *p)		if (*p == 'x')		{			p++;			while(*p != 0 && isxdigit(*p))			{				*number *= 16;				*number += isdigit(*p) ? *p - '0' :							toupper(*p) - 'A' + 10;				p++;			}		}		else if (*p == 'o')		{			p++;			while(*p != 0 && *p >= '0' && *p <= '7')			{				*number *= 8;				*number += *p - '0';				p++;			}		}		else if (*p == 'b')		{			p++;			while(*p != 0 && *p == '0' && *p == '1')			{				*number *= 2;				*number += *p - '0';				p++;			}		}	return p - 1;}static char *trysequence(char *p, char *token, long *res, long enablenums){	long i = 0;	while (*p != 0 &&			 ((enablenums && isalnum (*p)) ||			 (!enablenums && isalpha (*p))) &&			i < MAXLITERALSIZE-1)	{		token[i++] = *p;		p++;	}		if (*p == 0 && i > 0)	{		token[i] = 0;//		p--;	}	else if (i >= MAXLITERALSIZE-1 || i == 0)		*res = kERR;	else		token[i] = 0;		return p - 1;}#ifdef FIDOTECH_ATOMSstatic char *tryaddress(char *p, addr *address, long *res){	*res = kEXTRABITS | kEXTRAISMASK;	address->zone = 0;	address->net = 0;	address->node = 0;	address->point = 0;	if (*p == '*')	{		address->zone = -1;		p++;	}	else		while (isdigit (*p))		{			address->zone *= 10;			address->zone += *p - '0';			p++;		}		if (address->zone == 0 || *p != ':')	{		*res = kERR;//		if (*p == 0)//			p--;	}	else	{		p++;		if (*p == '*')		{			address->net = -1;			p++;		}		else			while (isdigit (*p))			{				address->net *= 10;				address->net += *p - '0';				p++;			}				if (address->net == 0 || *p != '/')		{			*res = kERR;//			if (*p == 0)//				p--;		}		else		{			p++;			if (*p == '*')			{				address->node = -1;				p++;			}			else				while (isdigit (*p))				{					address->node *= 10;					address->node += *p - '0';					p++;				}			//			if (*p == 0)//				p--;//			else				if (*p == '.')				{					p++;					if (*p == '*')					{						address->point = -1;						p++;					}					else						while (isdigit (*p))						{							address->point *= 10;							address->point += *p - '0';							p++;						}//					if (*p == 0)//						p--;				}						if (address->zone != -1 && address->net != -1 && address->node != -1 && address->point != -1)				*res = kEXTRABITS | kEXTRAISADDR;		}	}		return p - 1;}#endifstatic longgetnexttoken (char *str, char **next, char *token, fetched_info *info, token_desc *tokens, token_desc *prefixes){	char	*p = str;	long	res = kEOL;	long	i;	char	temp[2];	while (*p != 0 && isspace (*p))		p++;		switch(*p)	{	case '\0':			return res;		case '\"':		//	literal variant		res = kLITERAL;		p = tryliteral(p, token, &res);		break;			default:				temp[0] = *p;		temp[1] = 0;		i = fndtoken(temp, prefixes);		if (i != 0)		{			res = (*p << 16) | kPREFIXED;			p++;			p = trysequence(p, token, &res, true);			if (res != kERR)			{				i = fndtoken (token, tokens);				res = (i != 0) ?							((i & 0x0000FFFF) | kPREFIXED | res) :							(kPREFIXED | kNOTFOUND | res);			}		}#ifdef FIDOTECH_ATOMS		else		if (*p == '*')		//	possibme mask		{			p = tryaddress(p, &info->address, &res);		}#endif		else		if (isdigit (*p))	//	possible mask or address variant or number		{#ifdef FIDOTECH_ATOMS			char *q = p;						p = tryaddress(p, &info->address, &res);			if (res == kERR)			{				p = q;#endif				p = trynumber(p, &info->number, &res);#ifdef FIDOTECH_ATOMS			}#endif		}		else			if (isalpha (*p))	//	possible token variant			{				p = trysequence(p, token, &res, false);				if (res != kERR)				{					i = fndtoken (token, tokens);					res = (i != 0) ?								((i & 0x00FFFFFF) | kCMDTOKEN) :								(kCMDTOKEN | kNOTFOUND);				}			}			else				res = kERR;		//	something garbage		break;	}	*next = p+1;	return res;}intparseoneline(char *stringtoparse, token_desc *tokens, token_desc *prefixes, void *refcon, parsercallback pcb){	char			*p = stringtoparse;	long			r;	fetched_info	info;	if (tokens == NULL || pcb == NULL)		return 0;		if (*p == ';' || *p == '\n' || *p == '\r')		return 1;	while ((r = getnexttoken (p, &p, gToken, &info, tokens, prefixes)) != kEOL /* && r != kERR */)	{		switch (r & kGPBMASK)		{		case kEXTRABITS:		case kLONGNUMBER:			r = pcb(r, 0, &info, refcon);			break;				case kCMDTOKEN:			info.literal = gToken;			r = pcb(r, tokens[(r & 0x00FFFFFF)-1].extradata, &info, refcon);			break;		case kPREFIXED:			info.literal = gToken;			r = pcb(r, (prefixes != NULL) ? prefixes[(r & 0x0000FFFF)-1].extradata : 0, &info, refcon);			break;				case kERR:			pcb(r, 0, NULL, refcon);			break;		default:			info.literal = gToken;			r = pcb(r, 0, &info, refcon);			break;		}		if (r == kERR)			break;	}	return (r != kERR) ? 1 : 0;}