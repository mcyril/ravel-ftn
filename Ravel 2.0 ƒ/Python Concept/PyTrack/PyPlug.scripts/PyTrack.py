##	PyTrack - universal tracker for RavelSHUFFLER#	v2.0.1##	Copyright © 2002, Cyril Murzin##	Make filepath to config filedef makepath(filepath, filename):	pathlist = filepath.split(":")	pathlist[len(pathlist)-1] = filename	return ":".join(pathlist)#	------------------------------------------------------------------------##	Rule Classes descriptions##	------------------------------------------------------------------------#class RuleNetmail:	def __init__(self):		self.__dict__['fromname'] = None		self.__dict__['fromaddr'] = ftnmask.new("")		self.__dict__['toname'] = None		self.__dict__['toaddr'] = ftnmask.new("")		self.__dict__['fwdaddr'] = ftnaddr.new("")		self.__dict__['fwdarea'] = ""		self.__dict__['storemode'] = 0		self.__dict__['enveloped'] = 0		self.__dict__['drop'] = 0		def matched(self, msg):		if self.fromaddr.validfor(msg.fromaddr) == 0:			return 0		if self.fromname != None:			if not self.fromname.match(msg.fromname):				return 0		if self.toaddr.validfor(msg.toaddr) == 0:			return 0		if self.toname != None:			if not self.toname.match(msg.toname):				return 0				return 1		def selfcheck(self):		found = 0		if self.storemode == 1:			if self.fwdarea != "":				if self.fwdarea.lower() != "badmail" and self.fwdarea.lower() != "dev/null":					found = 0					for area in shuffler.prefs.echoareas:						if area.name.lower() == self.fwdarea.lower():							found = 1							break					if found == 0:						return 2			else:				return 2				return 0			def __str__(self):		accumulate = ""		accumulate = "".join([accumulate, "fromname ", str(self.fromname), "\r"])		accumulate = "".join([accumulate, "fromaddr ", str(self.fromaddr), "\r"])		accumulate = "".join([accumulate, "toname ", str(self.toname), "\r"])		accumulate = "".join([accumulate, "toaddr ", str(self.toaddr), "\r"])		accumulate = "".join([accumulate, "fwdaddr ", str(self.fwdaddr), "\r"])		accumulate = "".join([accumulate, "fwdarea ", self.fwdarea, "\r"])		accumulate = "".join([accumulate, "storemode ", str(self.storemode), "\r"])		accumulate = "".join([accumulate, "enveloped ", str(self.enveloped), "\r"])		accumulate = "".join([accumulate, "drop ", str(self.drop), "\r"])		return accumulateclass RuleEchomail:	def __init__(self):		self.__dict__['area'] = ""		self.__dict__['postarea'] = ""		self.__dict__['fromname'] = None		self.__dict__['fromaddr'] = ftnmask.new("")		self.__dict__['toname'] = None		self.__dict__['enveloped'] = 0		self.__dict__['drop'] = 0			def matched(self, msg):		if self.area != "":			if self.area.lower() != msg.area.lower():				return 0		if self.fromaddr.validfor(msg.fromaddr) == 0:			return 0		if self.fromname != None:			if not self.fromname.match(msg.fromname):				return 0		if self.toname != None:			if not self.toname.match(msg.toname):				return 0				return 1		def selfcheck(self):		found = 0		if self.area != "":			found = 0			for area in shuffler.prefs.echoareas:				if area.name.lower() == self.area.lower():					found = 1					break			if found == 0:				return 1				if self.postarea != "":			if self.postarea.lower() != "badmail" and self.postarea.lower() != "dev/null":				found = 0				for area in shuffler.prefs.echoareas:					if area.name.lower() == self.postarea.lower():						found = 1						break				if found == 0:					return 2		else:			return 2				return 0			def __str__(self):		accumulate = ""		accumulate = "".join([accumulate, "area ", self.area, "\r"])		accumulate = "".join([accumulate, "postarea ", self.postarea, "\r"])		accumulate = "".join([accumulate, "fromname ", str(self.fromname), "\r"])		accumulate = "".join([accumulate, "fromaddr ", str(self.fromaddr), "\r"])		accumulate = "".join([accumulate, "toname ", str(self.toname), "\r"])		accumulate = "".join([accumulate, "enveloped ", str(self.enveloped), "\r"])		accumulate = "".join([accumulate, "drop ", str(self.drop), "\r"])		return accumulate#	Read'n'parse config filedef takecatch(parsed, linenumber):	global netmailfwd	global echomailfwd#	catch netmail [from *:*/*.*|"John Doe"] [for 2:5030/700.1|"John Doe"] and forward|store [enveloped] to 2:5030/700|"INTERCEPTOR" [and drop]#	"t:1t:5[t:4m|l][t:2m|l]t:7t:9|t:10[t:11]t:3a|l[t:7t:8]"	if (parser.fitingrammar(parsed, "t:1t:5[t:4m|l][t:2m|l]t:7t:9|t:10[t:11]t:3a|l[t:7t:8]")):		RN = RuleNetmail()		RN.storemode = 0		for i in range(len(parsed)):			if shuffler.istoken(parsed[i]):				if parsed[i].id == 9:					RN.storemode = 1				elif parsed[i].id == 4:					if shuffler.isstring(parsed[i+1]):						RN.fromname = re.compile(parsed[i+1])					else:						RN.fromaddr = parsed[i+1]#						RN.fromname = re.compile(".*")				elif parsed[i].id == 2:					if shuffler.isstring(parsed[i+1]):						RN.toname = re.compile(parsed[i+1])					else:						RN.toaddr = parsed[i+1]#						RN.toname = re.compile(".*")				elif parsed[i].id == 3:					if RN.storemode == 1 and shuffler.isstring(parsed[i+1]):						RN.fwdarea = parsed[i+1]					elif RN.storemode == 0 and shuffler.ismask(parsed[i+1]):						RN.fwdaddr = parsed[i+1].asaddr()					else:						return 1				elif parsed[i].id == 11:					RN.enveloped = 1				elif parsed[i].id == 8:					RN.drop = 1		netmailfwd.append(RN)				return 0#	catch echomail ["AREANAME"] [from *:*/*.*|"John Doe"] [for "John Doe"|me] and store [enveloped] to "MY_WATCH_CC" [and drop]#	"t:1t:6[l][t:4m|l][t:2l|t:12]t:7t:9t:3l[t:7t:8]"	elif (parser.fitingrammar(parsed, "t:1t:6[l][t:4m|l][t:2l|t:12]t:7t:9[t:11]t:3l[t:7t:8]")):		RE = RuleEchomail()				if shuffler.isstring(parsed[2]):			RE.area = parsed[2]				for i in range(len(parsed)):			if shuffler.istoken(parsed[i]):				if parsed[i].id == 4:					if shuffler.isstring(parsed[i+1]):						RE.fromname = re.compile(parsed[i+1])					else:						RE.fromaddr = parsed[i+1]#						RE.fromname = re.compile('.*')				elif parsed[i].id == 2:					if shuffler.isstring(parsed[i+1]):						RE.toname = re.compile(parsed[i+1])					else:						RE.toname = re.compile("".join(["(?i)", prefs.home.sysop]))				elif parsed[i].id == 3:					RE.postarea = parsed[i+1]				elif parsed[i].id == 11:					RE.enveloped = 1				elif parsed[i].id == 8:					RE.drop = 1		echomailfwd.append(RE)		return 0		else:		return 1def nop(parsed, linenumber):	return 1def readconfig(filepath):	global parser		rules = [("catch", takecatch),			#	1	Keyword of statement for Echomail intercepting			 ("for", nop),					#	2	funny keywords			 ("to", nop),					#	3	...			 ("from", nop),					#	4	...			 ("netmail", nop),				#	5	...			 ("echomail", nop),				#	6	...			 ("and", nop),					#	7			 ("drop", nop),					#	8			 ("store", nop),				#	9			 ("forward", nop),				#	10	Keyword of statement for Netmail forwarding/redirection			 ("enveloped", nop),			#	11			 ("me", nop)]					#	12	parser = cfgparser.new(rules)	filepath = makepath(filepath, "PyTrack.cfg")	linenumber = 0	try:		f = file(name=filepath, mode="r")		while 1:			s = f.readline()			if s == "":				break			linenumber += 1			shuffler.Slice()				#	Comment it to increase performance			ss = parser.parse(s)			if len(ss) > 1:				if shuffler.istoken(ss[0]):					if rules[ss[0].id-1][1](ss,linenumber) != 0:						print "Syntax error (config line: %i)" % linenumber						return 1				else:					print "Syntax error (config line: %i)" % linenumber					return 1		f.close()	except:		print "Unable to open 'PyTrack.cfg' config file"		return 1		return 0def envelopemsgtext(msg):	global gVersion			delm = "-------------------------------------------------------------------------------"	body = "\r".join([delm, " Forwarded by PyTrack, %s, from " % str(shuffler.prefs.home.address)])	if msg.area == "":		body = "".join([body, "Netmail"])	else:		body = "".join([body, "area: %s" % msg.area])	body = "\r".join([body, " From: %-32s %-15s" % (msg.fromname , str(msg.fromaddr))])	body = "\r".join([body, " To:   %-32s %-15s %s" % (msg.toname, str(msg.toaddr), msg.date)])	body = "\r".join([body, " Subj: %-71s" % msg.subject, delm])	lines = msg.text.split("\r")	firstvisible = 0	for i in range(len(lines)):		if lines[i].startswith("\1"):			pass		elif lines[i].startswith("---"):			body = "\r".join([body, lines[i].replace ("---", "-+-", 1)])		elif lines[i].startswith(" * Origin:"):			body = "\r".join([body, lines[i].replace (" * Origin:", " + Origin:", 1)])		else:			if firstvisible == 0:				firstvisible = 1				if lines[i].startswith("AREA:"):					pass				else:					body = "\r".join([body, lines[i]])			else:				body = "\r".join([body, lines[i]])	body = "\r".join([body, delm])	body = "".join([body, "\r\r--- PyTrack/Python/Ravel, v %s\r" % gVersion])	body = "".join([body, " * Origin: %s (%s)\r" % (shuffler.prefs.home.sysname, str(shuffler.prefs.home.address))])	return bodydef processnetmail(msg):		retcode = CONTINUE		for rule in netmailfwd:		if rule.matched(msg):			if rule.storemode == 0:				if rule.enveloped == 0:					newmsg = ftnmsg.new(msg)					newmsg.toaddr = rule.fwdaddr					newmsg.attributes &= ~(MSGHOLD | MSGDIRECT | MSGCRASH)					newmsg.area = ""					shuffler.RouteMessage (newmsg, 0)					del newmsg				else:					newmsg = ftnmsg.new()					newmsg.toaddr = rule.fwdaddr					tname = shuffler.nodelist_getname(rule.fwdaddr)					if tname == None:						newmsg.toname = "SysOp"					else:						newmsg.toname = tname					newmsg.fromaddr = shuffler.prefs.home.address					newmsg.fromname = "PyTrack"					newmsg.subject = "Catched message"					newmsg.text = envelopemsgtext(msg)					newmsg.attributes = MSGPRIVATE					newmsg.area = ""					shuffler.msgbase_prep_msgid(newmsg)					newmsg.date = shuffler.msgbase_ftn_date()					shuffler.RouteMessage (newmsg, 0)					del newmsg			else:				if rule.enveloped == 0:					if rule.fwdarea.lower() != "dev/null":						shuffler.StoreMsgSpecial(msg, rule.fwdarea)				else:					newmsg = ftnmsg.new()					newmsg.toname = shuffler.prefs.home.sysop					newmsg.fromaddr = shuffler.prefs.home.address					newmsg.fromname = "PyTrack"					newmsg.subject = "Catched message"					newmsg.text = envelopemsgtext(msg)					shuffler.msgbase_prep_msgid(newmsg)					newmsg.date = shuffler.msgbase_ftn_date()					if rule.fwdarea.lower() != "dev/null":						shuffler.StoreMsgSpecial(newmsg, rule.fwdarea)					del newmsg			if rule.drop == 1:				retcode = DROPMSG			break		return retcodedef processechomail(msg):		retcode = CONTINUE		for rule in echomailfwd:		if rule.matched(msg):			if rule.enveloped == 0:				if rule.postarea.lower() != "dev/null":					shuffler.StoreMsgSpecial(msg, rule.postarea)			else:				newmsg = ftnmsg.new()				newmsg.toname = shuffler.prefs.home.sysop				newmsg.fromaddr = shuffler.prefs.home.address				newmsg.fromname = "PyTrack"				newmsg.subject = "Catched message"				newmsg.attributes = MSGREAD				newmsg.text = envelopemsgtext(msg)				if rule.postarea.lower() != "dev/null":					shuffler.StoreMsgSpecial(newmsg, rule.postarea)				del newmsg			if rule.drop == 1:				retcode = DROPMSG			break		return retcodedef dumprules(rules):	print rules	for rule in rules:		print str(rule)		print ""def checkrules(rules):	for rule in rules:		res = rule.selfcheck()		if res != 0:			print "Bad rule in:", rules			print str(rule)			if res == 1:				print "Invalid watch echoarea"			else:				print "Invalid post echoarea"			return 0	return 1def entryWelcome(scriptpath):	global gVersion	gVersion = "2.0.1"	global prefs	prefs = shuffler.prefs	global netmailfwd	global echomailfwd	netmailfwd = []	echomailfwd = []	shuffler.SetStatus("Initialize PyTrack")	if readconfig(scriptpath) != 0:		print "Parsing of config failed"		shuffler.SetStatus("")		return FAILED		shuffler.SetStatus("")		if len(netmailfwd) == 0 and len(echomailfwd) == 0:		return FAILED	else:		if len(echomailfwd) == 0:			shuffler.suppress(plugTossMsgEcho)		else:			if checkrules(echomailfwd) == 0:				return FAILED			if len(netmailfwd) == 0:			shuffler.suppress(plugTossMsgMail)			shuffler.suppress(plugTossMsgMailTrs)		else:			if checkrules(netmailfwd) == 0:				return FAILED		return NOERRORdef entryTossMsgMail(msg):#	Netmail forwarding processing	retcode = processnetmail(msg)	return retcodedef entryTossMsgMailTrs(msg):#	Transit Netmail forwarding processing	retcode = processnetmail(msg)	return retcodedef entryTossMsgEcho(msg):#	Echomail processing	retcode = processechomail(msg)	return retcodedef entryCustomNames():	return ["PYTRACK"]	def entryCustomLaunch(s):	if s == "PYTRACK":		print "Simple dump of internal rules:"		dumprules(echomailfwd)		dumprules(netmailfwd)		return NOERROR	return WRONGCALLNAME