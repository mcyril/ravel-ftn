##	ExoTIC - fileecho processor for RavelSHUFFLER#	v2.0.1##	Copyright © 2002, Cyril Murzin##	------------------------------------------------------------------------##	Make filepath to config filedef makepath(filepath, filename):	pathlist = filepath.split(":")	pathlist[len(pathlist)-1] = filename	return ":".join(pathlist)##	------------------------------------------------------------------------##	Config Parsing Part##	------------------------------------------------------------------------#def takepost(parsed, linenumber):	global postarea	if (parser.fitingrammar(parsed, "t:1t:3|l")):		if shuffler.isstring(parsed[1]):			postarea = parsed[1]		elif shuffler.istoken(parsed[1]) and parsed[1].id == 3:			postarea = " "		else:			return 1		return 0	else:		return 1def takebase(parsed, linenumber):	global basepath	if (parser.fitingrammar(parsed, "t:2l")):		basepath = parsed[1]		return 0	else:		return 1def takeareas(parsed, linenumber):	global areaslistpath		if (parser.fitingrammar(parsed, "t:4l")):		areaslistpath = parsed[1]		return 0	else:		return 1def takelinks(parsed, linenumber):	global linkslistpath		if (parser.fitingrammar(parsed, "t:5l")):		linkslistpath = parsed[1]		return 0	else:		return 1def takequarantin(parsed, linenumber):	global quarantine		if (parser.fitingrammar(parsed, "t:6l")):		quarantine = parsed[1]		return 0	else:		return 1def nop(parsed, linenumber):	return 1def readconfig(infilepath):	global parser		rules = [("postnote", takepost),		#	1	keyword of notification area			 ("base", takebase),			#	2	keyword of base path			 ("netmail", nop),				#	3	in netmail note			 ("areaslistpath", takeareas),	#	4	path of areas list			 ("linkslistpath", takelinks),	#	5	path of links list			 ("quarantine", takequarantin)]	#	6	path of quarantine folder	parser = cfgparser.new(rules)	filepath = makepath(infilepath, "ExoTIC.cfg")	linenumber = 0	try:		f = file(name=filepath, mode="r")		while 1:			s = f.readline()			if s == "":				break			linenumber += 1			shuffler.Slice()				#	Comment it to increase performance			ss = parser.parse(s)			if len(ss) > 1:				if shuffler.istoken(ss[0]) and ss[0].id > 0:					if rules[ss[0].id-1][1](ss,linenumber) != 0:						print "Syntax error (config line: %i)" % linenumber						del parser						return 1				else:					print "Syntax error (config line: %i)" % linenumber					del parser					return 1		f.close()	except:		print "Unable to process 'ExoTIC.cfg' config file"		del parser		return 1		del parser	return 0##	------------------------------------------------------------------------##	List of Links file processing part##	------------------------------------------------------------------------#def getlinkpref(ad):	links = shuffler.prefs.links	for link in links:		if link.address == ad:			return link	return Nonedef confidelinks():	global echolinks		for link in echolinks:		lp = getlinkpref(link[0])		if lp == None:			return 1		return 0#	returns information tuple for link if it is prerentdef findlinkdesc(ad):	global echolinks		for link in echolinks:		if link[0] == ad:			return link	return None	#	read links list from filedef readlinks(filepath):	global echolinks	rules = [("autocreate", nop),		#	1	allow autocreate			 ("noimport", nop),			#	2	disallow import from link			 ("noexport", nop)]			#	3	disallow export to link	parser = cfgparser.new(rules)	linenumber = 0	try:		f = file(name=filepath, mode="r")		while 1:			s = f.readline()			if s == "":				break				linenumber += 1			shuffler.Slice()				#	Comment it to increase performance			ss = parser.parse(s)			if len(ss) > 1:				if shuffler.ismask(ss[0]) and ss[0].strong() and shuffler.isstring(ss[1]):					hasautocreate = 0					hasnoimport = 0					hasnoexport = 0										for s in ss:						if shuffler.istoken(s):							if s.id == 1:								hasautocreate = 1							elif s.id == 2:								hasnoimport = 1							elif s.id == 3:								hasnoexport = 1							else:								print "Syntax error (link list line: %i)" % linenumber								del parser								return 1					echolink = (ss[0].asaddr(), ss[1], hasautocreate, hasnoimport, hasnoexport)					echolinks.append(echolink)				else:					print "Syntax error (link list line: %i)" % linenumber					del parser					return 1		f.close()	except:		print "Unable to process list of links file"		del parser		return 1		del parser	return 0##	------------------------------------------------------------------------##	List of Fileecho Areas processing part##	------------------------------------------------------------------------##	returns information tuple for echo if it is prerentdef findechodesc(name):	global echoareas		for area in echoareas:		if area[0].lower() == name.lower():			return area	return Nonedef linksubskribed(echoarea, ad):	for link in echoarea[1]:		if ad == link:			return 1	return 0#	store areas list back to filedef flushareas(filepath):	global echoareas	try:		f = file(name=filepath, mode="w")		for echoarea in echoareas:			strtoout = "".join(["\"", echoarea[0], "\""])			if echoarea[2] != "":				strtoout = "".join([strtoout, " \"", echoarea[2], "\""])			for ad in echoarea[1]:				strtoout = "".join([strtoout, " ", str(ad)])			strtoout = "".join([strtoout, "\n"])			f.writelines([strtoout])		f.close()	except:		print "Unable to write list of areas file"	return 0#	read areas list from filedef readareas(filepath):	global echoareas	rules = [("passthrough", nop)]		#	1	unimplemented keyfeature :->	parser = cfgparser.new(rules)	linenumber = 0	try:		f = file(name=filepath, mode="a")		f.close()		f = file(name=filepath, mode="r")		while 1:			s = f.readline()			if s == "":				break						linenumber += 1			shuffler.Slice()				#	Comment it to increase performance			ss = parser.parse(s)			if len(ss) > 1:				if shuffler.isstring(ss[0]):					linkslist = []					description = ""										for i in range(1, len(ss)):						ad = ss[i]						if shuffler.ismask(ad) and ad.strong():							linkslist.append(ad.asaddr())						elif shuffler.isstring(ad):							description = ad					echoarea = (ss[0], linkslist, description)					echoareas.append(echoarea)				else:					print "Syntax error (link list line: %i)" % linenumber					del parser					return 1		f.close()	except:		print "Unable to process list of areas file"		del parser		return 1	del parser	return 0##	------------------------------------------------------------------------##	TIC Class description##	------------------------------------------------------------------------#class TIC:	def __init__(self):		self.__dict__['name'] = ""		self.__dict__['adesc'] = ""		self.__dict__['origin'] = ftnaddr.new("")		self.__dict__['fromaddr'] = ftnaddr.new("")		self.__dict__['destaddr'] = ftnaddr.new("")		self.__dict__['destname'] = ""		self.__dict__['replaces'] = []		self.__dict__['file'] = ""		self.__dict__['size'] = 0		self.__dict__['desc'] = ""		self.__dict__['ldesc'] = ""		self.__dict__['crc'] = 0		self.__dict__['path'] = []		self.__dict__['seen'] = []		self.__dict__['password'] = ""		def copyself(self):		tic = TIC()		tic.name = self.name		tic.adesc = self.adesc		tic.origin = self.origin		tic.fromaddr = self.fromaddr		tic.destaddr = self.destaddr		tic.destname = self.destname		tic.replaces = self.replaces		tic.file = self.file		tic.size = self.size		tic.desc = self.desc		tic.ldesc = self.ldesc		tic.crc = self.crc		for pt in self.path:			tic.addpath(pt[0], pt[1])		for sn in self.seen:			tic.addseen(sn)		tic.password = self.password		return tic		def addpath(self, addr, string):		pathtuple = (addr, string)		self.path.append(pathtuple)	def addseen(self, addr):		self.seen.append(ftnaddr.new(addr))	def addseensafe(self, addr):		if self.addrinseen(addr):			self.seen.append(ftnaddr.new(addr))	def addrinseen(self, addr):		for ad in self.seen:			if ad == addr:				return 1		return 0	def __str__(self):		global gVersion				accumulate = ""		accumulate = "".join([accumulate, "Area ", self.name, "\n\r"])		if self.adesc != "":			accumulate = "".join([accumulate, "Areadesc ", self.adesc, "\n\r"])		accumulate = "".join([accumulate, "Origin ", str(self.origin), "\n\r"])		accumulate = "".join([accumulate, "From ", str(self.fromaddr), "\n\r"])		accumulate = "".join([accumulate, "Destination ", str(self.destaddr), ", ", self.destname, "\n\r"])		for rp in self.replaces:			accumulate = "".join([accumulate, "Replaces ", rp, "\n\r"])		accumulate = "".join([accumulate, "File ", self.file, "\n\r"])		accumulate = "".join([accumulate, "Size ", str(self.size), "\n\r"])				accumulate = "".join([accumulate, "Desc ", self.desc, "\n\r"])#		descs = self.desc.split("\n\r")#		for desc in descs:#			accumulate = "".join([accumulate, "Desc ", desc.strip(), "\n\r"])		if ldesc != "":			descs = self.ldesc.split("\n\r")			for desc in descs:				accumulate = "".join([accumulate, "LDesc ", desc.strip(), "\n\r"])		accumulate = "".join([accumulate, "Crc ", "%.8X" % self.crc, "\n\r"])		accumulate = "".join([accumulate, "Created by ExoTIC/Python/Ravel for Macintosh, v %s, (c) 2002 Cyril Murzin (2:5030/700)\n\r" % gVersion])		for pt in self.path:			if pt[1] == "":				accumulate = "".join([accumulate, "Path ", str(pt[0]), " \n\r"])			else:				accumulate = "".join([accumulate, "Path ", str(pt[0]), " ", pt[1], "\n\r"])		for sb in self.seen:			accumulate = "".join([accumulate, "Seenby ", str(sb), "\n\r"])		if self.password != "":			accumulate = "".join([accumulate, "Pw ", self.password, "\n\r"])				return accumulate##	------------------------------------------------------------------------##	TIC Parser##	------------------------------------------------------------------------#def ticnop(tic, s, tup): passdef gotarea(tic, s, tup):	name = s.replace (tup[0].name, "", 1)	tic.name = name.strip()def gotadesc(tic, s, tup):	name = s.replace (tup[0].name, "", 1)	tic.adesc = name.strip()def gotorig(tic, s, tup):	tic.origin = tup[1].asaddr()def gotfrom(tic, s, tup):	tic.fromaddr = tup[1].asaddr()def gotdest(tic, s, tup):	tic.destaddr = tup[1].asaddr()	names = s.split(",")	tic.destname = names[1].strip()def gotrepl(tic, s, tup):	name = s.replace (tup[0].name, "", 1)	tic.replaces.append(name.strip())def gotfile(tic, s, tup):	name = s.replace (tup[0].name, "", 1)	tic.file = name.strip()def gotsize(tic, s, tup):	tic.size = tup[1]def gotdesc(tic, s, tup):	if tic.desc == "":		name = s.replace (tup[0].name, "", 1)		tic.desc = name.strip()#	name = s.replace (tup[0].name, "", 1)#	if tic.desc == "":#		tic.desc = name.strip()#	else:#		tic.desc = "".join(tic.desc, "\n\r", name.strip())def gotldesc(tic, s, tup):	name = s.replace (tup[0].name, "", 1)	if tic.ldesc == "":		tic.ldesc = name.strip()	else:		tic.ldesc = "".join(tic.ldesc, "\n\r", name.strip())def gotcrc(tic, s, tup):	name = s.replace (tup[0].name, "", 1)	name = name.strip()#	tic.crc = int(name, 16)		# unusable 'cause of bug in Python	tic.crc = 0	for i in range(len(name)):		uno = int(name[i], 16)		tic.crc = tic.crc * 16 + unodef gotpw(tic, s, tup):	name = s.replace (tup[0].name, "", 1)	tic.password = name.strip()def gotpath(tic, s, tup):	names = s.split(" ", 2)	if len(names) > 2:		tic.addpath(tup[1].asaddr(), names[2].strip())	else:		tic.addpath(tup[1].asaddr(), "")def gotseen(tic, s, tup):	tic.addseen(tup[1].asaddr())def parsetic(filepath):	rules = [("Area", gotarea),			 ("Areadesc", gotadesc),			 ("Origin", gotorig),			 ("From", gotfrom),			 ("Destination", gotdest),			 ("Replaces", gotrepl),			 ("File", gotfile),			 ("Size", gotsize),			 ("Desc", gotdesc),			 ("Ldesc", gotldesc),			 ("Crc", gotcrc),			 ("Created", ticnop),			 ("Path", gotpath),			 ("Seenby", gotseen),			 ("Pw", gotpw)]	parser = cfgparser.new(rules)		theTic = TIC()		f = file(name=filepath, mode="r")	while 1:		s = f.readline()		if s == "":			break		ss = parser.parse(s)		if len(ss) > 0 and ss[0].id > 0:			rules[ss[0].id-1][1](theTic, s, ss)	return theTicdef fileindir(filename, dirpath):	names = os.listdir(dirpath)	names.sort()		for name in names:		if name in (os.curdir, os.pardir): continue		fullname = os.path.join(dirpath, name)		if os.path.islink(fullname): pass		elif os.path.isdir(fullname):			pass		elif shuffler.inwildcard(name.lower(), filename.lower()):			return name	return ""##	------------------------------------------------------------------------##	TIC Processors##	------------------------------------------------------------------------#def resolvetic(basetic, targetpathname, areadesc, tic):	for exportto in areadesc[1]:		basetic.addseensafe(exportto)		polls = [".HLO", ".DLO", ".CLO"]	for exportto in areadesc[1]:		if tic.addrinseen(exportto) != 0:			pass		else:			flopathname = shuffler.get_flo_pathname(exportto, shuffler.prefs.outbound)			flopathnamelist = flopathname.split(":")						namenumber = shuffler.random(0, 16777215, exportto);			floname = flopathnamelist[len(flopathnamelist)-1]						namenumberstr = "ET"			namenumberdivider = 16777216			for i in range(6):				namenumberdivider = namenumberdivider / 16				N = namenumber / namenumberdivider				namenumberstr = "".join([namenumberstr, "%X" % N])				namenumber = namenumber % namenumberdivider						flopathnamelist[len(flopathnamelist)-1] = "".join([namenumberstr, ".TIC"])			linkpref = getlinkpref(exportto)			basetic.destaddr = exportto			basetic.destname = linkpref.name						todesc = findlinkdesc(exportto)			basetic.password = todesc[1]						ticasstr = str(basetic)			ticfilepath = ":".join(flopathnamelist)						try:				f = file(name=ticfilepath, mode="w")				f.write(ticasstr)				f.close()			except:				print "Cannot create/write outbound TIC \"%s\"" % ticfilepath				return 0						floname = "".join([floname, polls[linkpref.polltype]])			flopathnamelist[len(flopathnamelist)-1] = floname			flopathname = ":".join(flopathnamelist)						print "Attach for %s with \"%s\"" % (str(exportto), floname)						try:				f = file(name=flopathname, mode="a")				f.write("+%s\n" % targetpathname)				f.write("-%s\n" % ticfilepath)				f.close()			except:				print "Cannot append to outbound FLO \"%s\"" % flopathname				return 0	return 1def makequarantine(tic, fullname):	global quarantine	srcpathname = "".join([shuffler.prefs.inbound, tic.file])	if quarantine != "":		shuffler.move(srcpathname, quarantine)		shuffler.move(fullname, quarantine)	else:		try:			os.remove(srcpathname)		except:			pass		try:			os.remove(fullname)		except:			passdef processtic(tic, ticname, fullname):	global echoareas#	check validity of From system	if shuffler.IsItMyAddr(tic.destaddr) == 0:		print "TIC named \"%s\" from %s is not for this system, dropped to quarantine." % (ticname, tic.fromaddr)		makequarantine(tic, fullname)		return 0	fromdesc = findlinkdesc(tic.fromaddr)	if fromdesc == None:		print "TIC named \"%s\" arrived from unlisted system %s, dropped to quarantine." % (ticname, tic.fromaddr)		makequarantine(tic, fullname)		return 0	if fromdesc[1].lower() != tic.password.lower():		print "TIC named \"%s\" arrived from system %s - password mismatch, dropped to quarantine." % (ticname, tic.fromaddr)		makequarantine(tic, fullname)		return 0	areadesc = findechodesc(tic.name)	if areadesc == None:		if fromdesc[2] == 1:			linkslist = [tic.fromaddr]			if tic.adesc == "":				areadesc = (tic.name, linkslist, "Autocreated from %s" % str(tic.fromaddr))			else:				areadesc = (tic.name, linkslist, tic.adesc)			echoareas.append(areadesc)			print "No area \"%s\" exists. Autocreated." % tic.name		else:			print "TIC named \"%s\" for area \"%s\"arrived from system %s with disallowed autocreate, dropped to quarantine." % (ticname, tic.name, tic.fromaddr)			makequarantine(tic, fullname)			return 0#	create ExoTIC base catalogue	exoticdirname = basepath	try:		os.mkdir(exoticdirname)	except:		pass#	create ExoTIC fileecho catalogue	echodirname = ":".join([exoticdirname, tic.name])	try:		os.mkdir(echodirname)	except:		pass	name = fileindir(tic.file, shuffler.prefs.inbound)	if name != "":#	kill obsolete files		for mask in tic.replaces:			while 1:				masked = fileindir(mask, echodirname)				if masked != "":					victim = ":".join([echodirname, masked])					try:						os.remove(victim)					except:						print "Unable to remove/move \"%s\" for TIC file \"%s\"" % (masked, ticname)				else:					break#	move file from inbound if possible and kill the old file if exists#	means absense of replaces rules		srcpathname = "".join([shuffler.prefs.inbound, tic.file])		if shuffler.move(srcpathname, echodirname) != 0:			try:				os.remove(srcpathname)			except:				pass			shuffler.move(srcpathname, echodirname)				stattuple = (tic.name, tic.file, tic.desc)		exoticstat.append(stattuple)			else:		print "No file \"%s\" in inbound for TIC file \"%s\"" % (tic.file, ticname)		return 1	print "File \"%s\" moved to area \"%s\" (obsoletes %s)" % (tic.file, tic.name, str(tic.replaces))#	set proper outbound for this file		basetic = tic.copyself()	#	workaround for float overflow in Python 2.2.1	tsf = time.time();	tsf1 = int(tsf / 65536)	tsf2 = int(tsf % 65536)	timestamp = "%.4X%.4X %s" % (tsf1, tsf2, time.ctime(tsf))	basetic.addpath(tic.destaddr, timestamp)	basetic.fromaddr = tic.destaddr	targetpathname = ":".join([echodirname, tic.file])	return resolvetic(basetic, targetpathname, areadesc, tic)def processtics():	global gVersion	global exoticstat	exoticstat = []	inbound = shuffler.prefs.inbound	shuffler.InitProgress(-1)	shuffler.SetStatus("ExoTIC is scanning for inbound TICs")	print "Scanning for inbound TICs"	names = os.listdir(inbound)	names.sort()	istic = re.compile('(?i)^[a-zA-Z0-9_]+.tic$')	for name in names:		shuffler.Slice()		#	Comment it to increase performance		if name in (os.curdir, os.pardir): continue		fullname = os.path.join(inbound, name)		if os.path.islink(fullname): pass		elif os.path.isdir(fullname):			pass		elif istic.match(name):			tic = parsetic(fullname)			if processtic(tic, name, fullname) == 1:				try:					os.remove(fullname)				except:					pass	if len(exoticstat) > 0:		if postarea == " ":			whom = shuffler.prefs.home.sysop.split(" ")[0]		else:			whom = "Anyone who cares"		noticebody = "%s,\r\rThe following files has been arrived to \"%s\" system:\r" % (whom, shuffler.prefs.home.sysname)		while len(exoticstat) > 0:					areaname = exoticstat[0][0]			noticebody = "".join([noticebody, "\rIn area: ", areaname])			areadesc = findechodesc(areaname)			if areadesc != None:				noticebody = "".join([noticebody, " (", areadesc[2], ")\r\r"])			else:				noticebody = "".join([noticebody, "\r\r"])			done = 0			for thing in exoticstat:				if thing[0] == areaname:					noticebody = "".join([noticebody, "     %-20s    %-40s\r" % (thing[1], thing[2])])					done = done + 1			i = 0			while done != 0 and i < len(exoticstat):				if exoticstat[i][0] == areaname:					exoticstat.remove(exoticstat[i])					done = done - 1				else:					i = i - 1		noticebody = "".join([noticebody, "\r\rThank you.\r\r--- ExoTIC/Python/Ravel, v %s\r" % gVersion])		noticebody = "".join([noticebody, " * Origin: %s (%s)\r" % (shuffler.prefs.home.sysname, str(shuffler.prefs.home.address))])#		print noticebody		if postarea != "":			msg = ftnmsg.new()						msg.fromaddr = ftnaddr.new(shuffler.prefs.home.address)			msg.toaddr = ftnaddr.new(shuffler.prefs.home.address)			msg.fromname = "ExoTIC"			msg.subject = "ExoTIC file receiving report."			shuffler.msgbase_prep_msgid(msg)			msg.date = shuffler.msgbase_ftn_date()			msg.text = noticebody			if postarea == " ":				msg.area = ""				msg.toname = shuffler.prefs.home.sysop				msg.attributes = MSGPRIVATE|MSGREAD			else:				msg.attributes = 0				msg.area = postarea				msg.toname = "All"				shuffler.ExportEchoes(msg)				msg.attributes = MSGREAD			shuffler.TmpBaseAdd(msg)			del msg	shuffler.SetStatus("")	shuffler.InitProgress(1)	shuffler.Slice()	return NOERRORdef hatchfile(filepath, inecho):	print "Hatching file \"%s\" in fileecho %s" % (filepath, inecho)	pathlist = filepath.split(":")	filename = pathlist[len(pathlist)-1]		desc = findechodesc(inecho)#	echoarea = (ss[0], linkslist, description)		crc = 0	f = file(name=filepath, mode="rb")	f.seek(0,2)	size = f.tell()	f.close()		tic = TIC()	tic.name = inecho	tic.adesc = desc[2]	tic.origin = shuffler.prefs.home.address	tic.fromaddr = shuffler.prefs.home.address	tic.file = filename	tic.size = size	tic.desc = "Hatched by %s (%s)" % (shuffler.prefs.home.sysname, shuffler.prefs.home.address)	tic.crc = crc#	workaround for float overflow in Python 2.2.1	tsf = time.time();	tsf1 = int(tsf / 65536)	tsf2 = int(tsf % 65536)	timestamp = "%.4X%.4X %s" % (tsf1, tsf2, time.ctime(tsf))	tic.addpath(shuffler.prefs.home.address, timestamp)	tic.addseen(shuffler.prefs.home.address)		return resolvetic(tic, filepath, desc, tic)	##	------------------------------------------------------------------------##	Query Processors##	------------------------------------------------------------------------#def intrudernotice(msg, note):	print note	dummy = ftnaddr.new()	shuffler.StoreMsgSpecial(msg, "BADAREA", dummy, note)	del dummydef connectarea(name, ad, stat):	desc = findechodesc(name.strip())	if desc == None:		stat = "".join([stat, "     %-20s    Not Found\r" % name.strip()])	elif linksubskribed(desc, ad):		stat = "".join([stat, "     %-20s    Already linked\r" % name.strip()])	else:		stat = "".join([stat, "     %-20s    Linked\r" % name.strip()])		desc[1].append(ftnaddr.new(ad))	return statdef disconnectarea(name, ad, stat):	desc = findechodesc(name.strip())	if desc == None:		stat = "".join([stat, "     %-20s    Not Found\r" % name.strip()])	elif linksubskribed(desc, ad) == 0:		stat = "".join([stat, "     %-20s    Not linked\r" % name.strip()])	else:		stat = "".join([stat, "     %-20s    Unlinked\r" % name.strip()])		desc[1].remove(ad)	return statdef sendstatmsg(msg, subj, stat):	statmsg = ftnmsg.new()		statmsg.fromaddr = ftnaddr.new(msg.toaddr)	statmsg.toaddr = ftnaddr.new(msg.fromaddr)	statmsg.fromname = "ExoTIC"	statmsg.toname = msg.fromname	statmsg.subject = subj	statmsg.date = shuffler.msgbase_ftn_date()	statmsg.text = stat	statmsg.area = ""	statmsg.attributes = MSGPRIVATE	shuffler.msgbase_prep_reply(msg, statmsg)	shuffler.msgbase_prep_msgid(statmsg)	shuffler.RouteMessage(statmsg, 0)	del statmsgdef processspecial(command, msg):	global gVersion	global echoareas	subscribed = ""	subj = "Remote control request"	stat = "Dear SysOp,\r\r -------------------------------------------------------------------------\r\r"	command = command.strip()	if command.lower() == "%help":		subj = "ExoTIC help request"		stat = "".join([stat, "%HELP                    Request this help text.\r"])		stat = "".join([stat, "%LIST                    Request a list of areas available to you.\r"])		stat = "".join([stat, "%QUERY                   Request a list of areas to which you are connected.\r"])	elif command.lower() == "%list":		for area in echoareas:			if linksubskribed(area, msg.fromaddr) != 0:				subscribed = "*"			else:				subscribed = " "			stat = "".join([stat, "%s %-20s    %-40s\r" % (subscribed, area[0], area[2])])	elif command.lower() == "%query":		for area in echoareas:			if linksubskribed(area, msg.fromaddr) != 0:				stat = "".join([stat, "  %-20s    %-40s\r" % (area[0], area[2])])	else:		stat = "".join([stat, " Unknown command: %s\r" % command])	stat = "".join([stat, "\r\rThank you.\r\r--- ExoTIC/Python/Ravel, v %s\r" % gVersion])	stat = "".join([stat, " * Origin: %s (%s)\r" % (shuffler.prefs.home.sysname, str(shuffler.prefs.home.address))])	sendstatmsg(msg, subj, stat)	def processquery(msg):	global gVersion	subscriptionchange = 0	controlrequests = 0	stat = "Dear SysOp,\r\r -------------------------------------------------------------------------\r\r"	query = msg.text.split("\r")	for i in range(len(query)):		if query[i].startswith("\1"):			pass		elif query[i].startswith("---"):			break		elif query[i].startswith(" * Origin:"):			break		elif query[i].startswith("%"):#			processspecial(query[i], msg)			controlrequests = 1		elif query[i].startswith("+"):			stat = connectarea(query[i].replace("+", "", 1), msg.fromaddr, stat)			subscriptionchange = 1		elif query[i].startswith("-"):			stat = disconnectarea(query[i].replace("-", "", 1), msg.fromaddr, stat)			subscriptionchange = 1		else:			stat = connectarea(query[i], msg.fromaddr, stat)			subscriptionchange = 1	stat = "".join([stat, "\r\rThank you.\r\r--- ExoTIC/Python/Ravel, v %s\r" % gVersion])	stat = "".join([stat, " * Origin: %s (%s)\r" % (shuffler.prefs.home.sysname, str(shuffler.prefs.home.address))])	#	print stat	if subscriptionchange:		print "Remote %s changes subscribed list" % str(msg.fromaddr)		sendstatmsg(msg, "Change subscribed list.", stat)		if controlrequests:		print "Remote %s makes control request(s)" % str(msg.fromaddr)		for i in range(len(query)):			if query[i].startswith("\1"):				pass			elif query[i].startswith("---"):				break			elif query[i].startswith(" * Origin:"):				break			elif query[i].startswith("%"):				processspecial(query[i], msg)##	------------------------------------------------------------------------##	Shuffler's callbacks##	------------------------------------------------------------------------#def entryWelcome(scriptpath):	global gVersion	gVersion = "2.0.2"	global areaslistpath	areaslistpath = ""	global echoareas	echoareas = []	global linkslistpath	linkslistpath = ""	global echolinks	echolinks = []	global quarantine	quarantine = ""		global postarea	postarea = ""	global basepath	basepath = ""	shuffler.SetStatus("Initialize ExoTIC")	if readconfig(scriptpath) != 0:		print "Parsing of config failed"		shuffler.SetStatus("")		return FAILED	if basepath == "":		print "Undefined base ExoTIC path"		shuffler.SetStatus("")		return FAILED	if quarantine != "":		try:			os.mkdir(quarantine)		except:			pass	if postarea != " ":		thearea = postarea		postarea = ""		for c in shuffler.prefs.echoareas:			if c.name == thearea:				postarea = thearea				break		if postarea == "":			print "Post area %s is not listed" % postarea			shuffler.SetStatus("")			return FAILED		if linkslistpath == "":		print "No list of links defined"		shuffler.SetStatus("")		return FAILED	elif readlinks(linkslistpath) != 0:		print "Parsing of list of links failed"		shuffler.SetStatus("")		return FAILED	elif confidelinks() != 0:		print "List of links contains unknown link address(es)"		shuffler.SetStatus("")		return FAILED	if areaslistpath == "":		print "No list of areas defined"		shuffler.SetStatus("")		return FAILED	elif readareas(areaslistpath) != 0:		print "Parsing of list of areas failed"		shuffler.SetStatus("")		return FAILED	shuffler.SetStatus("")	return NOERRORdef entryTossMsgMail(msg):	toname = msg.toname.lower()	if toname == "allfix" or toname == "filefix" or toname == "exotic":		fromdesc = findlinkdesc(msg.fromaddr)		if fromdesc == None:			print "Request from unlisted address %s" % str(msg.fromaddr)			intrudernotice(msg, "Request from unlisted address")		elif fromdesc[1].lower() != msg.subject.lower():			print "Remote %s requests ExoTIC with invalid password" % str(msg.fromaddr)			intrudernotice(msg, "Request with invalid password")		else:			print "Remote %s requests ExoTIC" % str(msg.fromaddr)			processquery(msg)		return DROPMSG	return NOERRORdef entryPreTossLaunch():	return processtics()def entryPreNetPackLaunch():	return processtics()def entryCustomNames():	return ["HATCH", "EXOTIC"]def entryCustomLaunch(s):	global echoareas	if s == "HATCH":		#		import macfs				lst = []		for echo in echoareas:			lst.append(echo[0])					inecho = PyGUI.doSimpleListDlg(lst)				if inecho >= 0:			thefile = macfs.StandardGetFile()			ttl = thefile[0].as_tuple()			if ttl[2] != "cancelled":				hatchfile(thefile[0].as_pathname(), echoareas[inecho][0])			else:				print "Hatching canceled"		else:			print "Hatching canceled"		return NOERROR		elif s == "EXOTIC":		for echoarea in echoareas:			strtoout = "".join(["\"", echoarea[0], "\""])			if echoarea[2] != "":				strtoout = "".join([strtoout, " \"", echoarea[2], "\""])			for ad in echoarea[1]:				strtoout = "".join([strtoout, " ", str(ad)])			print strtoout		return WRONGCALLNAMEdef entrySuicide():	if areaslistpath != "":		flushareas(areaslistpath)	return NOERROR