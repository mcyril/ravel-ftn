//	¥	PyPlug.c//	PyPlug's main module//		Python API and test main routine#include "PyPlug.h"#include "py_shuffler.h"#pragma mark ¥ PYTRACK_STANDALONE#pragma mark -#if PYTRACK_STANDALONE////	This part of code is for the testing purposes.//	Standalone application simulate Shuffler's host//#include "plug_control_dummy.h"static	PlugEntryDef	thisPlugEntries[32];voidmain(){	long answer;	PyObject *modname, *mod, *mdict, *func, *stringarg, *args, *rslt;	//	Py_Initialize();	PyMac_Initialize();	InitShuffler(create_plug_control());//	__path__	mod = PyImport_ImportModule("ExoTIC");	if (mod)	{		UInt32	callable = RSP_FillEntries(mod, shufflerPlugEntries, thisPlugEntries);				if (callable)		{			mdict = PyModule_GetDict(mod);			InitCertainModule(mdict);	        func = RSP_FindEntry("entryWelcome", thisPlugEntries);			if (func)			{				if (PyCallable_Check(func))				{					rslt = PyObject_CallFunction(func,										"(s)", ":TestMsg.py" /*":Plug-Ins:PyPlug.scripts:TestMsg.py"*/);					if (rslt)					{						answer = PyInt_AsLong(rslt);						Py_XDECREF(rslt);					}					else					{						if (PyErr_Occurred())						{							PyErr_Print();//							PyErr_Clear();						}					}				}			}			Py_XDECREF(mod);		}	}	else	{		if (PyErr_Occurred())		{			PyErr_Print();//			PyErr_Clear();		}	}	DeInitShuffler();//	Py_Finalize();	Py_Exit(0);}#endif#if PYTRACK_SHUFFLERPlugsControlPtr		gPC = NULL;UInt32				gCallable = 0;PyModQueueElt		*gModQueue = NULL;PyModQueueElt		*gCurrentElt = NULL;Boolean				gInitialized = false;FSSpec				gThisPlugSpec;static char			gStr[1024];char				**gInvokeNames = NULL;static void KillInvokeNames(){	if (gInvokeNames != NULL)	{		char **p = gInvokeNames;				while (*p)		{			free(*p);			p++;		}				free(gInvokeNames);	}}static long CountInvokeNames(){	long	res = 0;	if (gInvokeNames != NULL)	{		char **p = gInvokeNames;				while (*p)		{			res++;			p++;		}	}		return res;}static long Py_WriteHandler(char *buf, long count){	int		i, j;	for(i = 0, j = strlen(gStr); i < count && j < 1023; i++)	{		if (!iscntrl(buf[i]) || buf[i] == '\t')		{			if (j == 0)			{				if (gCurrentElt)					strcpy(gStr, gCurrentElt->ModName);				else					strcpy(gStr, "%PY%");				strcat(gStr, " > ");				j = strlen(gStr);			}			gStr[j++] = buf[i];		}		else if (buf[i] == '\r' || buf[i] == '\n')		{			gStr[j] = 0;			gPC->putlog('³', gStr);			j = 0;		}	}		gStr[j] = 0;	if (j == 1023)	{		gPC->putlog('³', gStr);		gStr[0] = 0;	}	return count;}void main (PlugsControlPtr plugcontrol){	Str255			scriptsfolder;	PyObject		*mod, *func, *mdict, *result, *obj;	_finddata_t		ff;	char			temp[256], temp1[256], *ptemp;	PyModQueueElt	*curElt = NULL;	short			oldRes;	long			i, j, len;	long			customRetCode;#if UNIVERSAL_INTERFACES_VERSION < 0x0341	EnterCodeResource ();#endif		gCurrentElt = NULL;	gPC = plugcontrol;	gStr[0] = 0;	oldRes = CurResFile ();	while (plugcontrol->opCode == plugWelcome)	{		if ((plugcontrol->apiRev & 0x8000) == 0 ||			plugcontrol->apiRev < kCurrentPlugAPI)		{			plugcontrol->putlog('!', "<PyPlug> requeres newer version of RavelSHUFFLER");			gCallable = 0;			break;		}		if (FSMakeFSSpec(0, 0, plugcontrol->thisplugPath, &gThisPlugSpec) != noErr)		{			plugcontrol->putlog('!', "<PyPlug> cannot find itself's resources.");			gCallable = 0;			break;		}		srand(time(NULL));				PyMac_SetConsoleHandler(PyMac_DummyReadHandler, Py_WriteHandler, Py_WriteHandler);		PyMac_Initialize();		//	????//		Py_Initialize();		InitShuffler(plugcontrol);				gInitialized = true;		plugcontrol->putlog('=', "<PyPlug " RAVELISA "> Installed");				pStrCopy (plugcontrol->thisplugPath, scriptsfolder);		pStrConc (scriptsfolder, "\p.scripts:", scriptsfolder);		mdict = PySys_GetObject("path");		mod = PyString_FromStringAndSize((char *)&scriptsfolder[1], scriptsfolder[0]);		PyList_Insert(mdict, 0, mod);//		pStrConc (scriptsfolder, "\p*.py", scriptsfolder);				scriptsfolder[scriptsfolder[0]+1] = 0;		if (_findfirst((char *)&scriptsfolder[1], "*.py", &ff) >= 0)			do {							plugcontrol->Slice();								memcpy(temp, ff.name, strlen(ff.name) - 3);				temp[strlen(ff.name) - 3] = 0;							mod = PyImport_ImportModule(temp);				if (mod)				{					if (gModQueue == NULL)					{						gModQueue = (PyModQueueElt *) NewPtrClear (sizeof (PyModQueueElt));						curElt = gModQueue;					}					else					{						curElt->next = (PyModQueueElt *) NewPtrClear (sizeof (PyModQueueElt));						curElt = curElt->next;					}										curElt->next = NULL;									mdict = PyModule_GetDict(mod);					InitCertainModule(mdict);					strcpy(curElt->ModName, temp);					curElt->Callable = RSP_FillEntries(mod, shufflerPlugEntries, curElt->PlugEntries);					strcpy(&temp[1], ff.name);					temp[0] = strlen(ff.name);					pStrConc(scriptsfolder, (StringPtr)temp, curElt->Path);										if ((curElt->Callable & plugWelcome) == 0)					{						curElt->Callable = 0;						sprintf (temp, " Module '%s' failed to loaded: no entryWelcome", curElt->ModName);						plugcontrol->putlog('=', temp);					}					else					{						sprintf (temp, " Module '%s' loaded", curElt->ModName);						plugcontrol->putlog('=', temp);						gCallable |= curElt->Callable;					}				}				else if (PyErr_Occurred())				{					sprintf (temp1, " Module '%s' failed to load", temp);					plugcontrol->putlog('=', temp1);					PyErr_Print();//					PyErr_Clear();				}			} while (_findnext(0, &ff) >= 0);		if ((gCallable & plugWelcome) == 0)			gCallable = 0;				break;	}	plugcontrol->retCode = plugRetContinue;	customRetCode = plugRetWrongCustom;	if ((gCallable & plugcontrol->opCode) != 0)	{		curElt = gModQueue;				while (curElt)		{			if ((curElt->Callable & plugcontrol->opCode) != 0)			{				gCurrentElt = curElt;				switch (plugcontrol->opCode)				{				case plugWelcome:		//	StartUp call of plug-ins. We make order and init. prefs.								        func = RSP_FindEntry("entryWelcome", curElt->PlugEntries);					if (func)					{						mod = PyString_FromStringAndSize((char *)&curElt->Path[1], curElt->Path[0]);						result = PyObject_CallFunction(func, "(O)", mod);						if (result)						{							if (PyInt_Check(result))							{								long retCode = PyInt_AsLong(result);								Py_XDECREF(result);															if (retCode != plugRetNoError)								{									sprintf (temp, " Module '%s' Welcome failed to initialize", curElt->ModName);									plugcontrol->putlog('=', temp);									curElt->Callable = 0;								}							}						}						else if (PyErr_Occurred())						{							sprintf (temp1, " Module '%s' encountered runtime error", curElt->ModName);							plugcontrol->putlog('=', temp1);							PyErr_Print();//							PyErr_Clear();						}						Py_XDECREF(mod);					}					break;								case plugSuicide:							        func = RSP_FindEntry("entrySuicide", curElt->PlugEntries);					if (func)					{						PyObject_CallFunction(func, "()");						if (PyErr_Occurred())						{							sprintf (temp1, " Module '%s' encountered runtime error", curElt->ModName);							plugcontrol->putlog('=', temp1);							PyErr_Print();//							PyErr_Clear();						}					}					break;								case plugTossMsgEcho:	//	On toss echomail message to _this_ system								        func = RSP_FindEntry("entryTossMsgEcho", curElt->PlugEntries);					if (func)					{						mod = PyFtnMsg_Intern(plugcontrol->messageIn, false);						result = PyObject_CallFunction(func, "(O)", mod);						if (result)						{							if (PyInt_Check(result))								plugcontrol->retCode = PyInt_AsLong(result);							Py_XDECREF(result);						}						else if (PyErr_Occurred())						{							sprintf (temp1, " Module '%s' encountered runtime error", curElt->ModName);							plugcontrol->putlog('=', temp1);							PyErr_Print();//							PyErr_Clear();						}						Py_XDECREF(mod);					}					break;								case plugTossMsgEchoExp:	//	On toss echomail message to other system								        func = RSP_FindEntry("entryTossMsgEchoExp", curElt->PlugEntries);					if (func)					{						mod = PyFtnMsg_Intern(plugcontrol->messageIn, false);						result = PyObject_CallFunction(func, "(O)", mod);						if (result)						{							if (PyInt_Check(result))								plugcontrol->retCode = PyInt_AsLong(result);							Py_XDECREF(result);						}						else if (PyErr_Occurred())						{							sprintf (temp1, " Module '%s' encountered runtime error", curElt->ModName);							plugcontrol->putlog('=', temp1);							PyErr_Print();//							PyErr_Clear();						}						Py_XDECREF(mod);					}					break;								case plugTossMsgMail:	//	On toss netmail message to _this_ system			        func = RSP_FindEntry("entryTossMsgMail", curElt->PlugEntries);					if (func)					{						mod = PyFtnMsg_Intern(plugcontrol->messageIn, false);						result = PyObject_CallFunction(func, "(O)", mod);						if (result)						{							if (PyInt_Check(result))								plugcontrol->retCode = PyInt_AsLong(result);							Py_XDECREF(result);						}						else if (PyErr_Occurred())						{							sprintf (temp1, " Module '%s' encountered runtime error", curElt->ModName);							plugcontrol->putlog('=', temp1);							PyErr_Print();//							PyErr_Clear();						}						Py_XDECREF(mod);					}					break;								case plugTossMsgMailTrs:	//	On toss transit netmail message			        func = RSP_FindEntry("entryTossMsgMailTrs", curElt->PlugEntries);					if (func)					{						mod = PyFtnMsg_Intern(plugcontrol->messageIn, false);						result = PyObject_CallFunction(func, "(O)", mod);						if (result)						{							if (PyInt_Check(result))								plugcontrol->retCode = PyInt_AsLong(result);							Py_XDECREF(result);						}						else if (PyErr_Occurred())						{							sprintf (temp1, " Module '%s' encountered runtime error", curElt->ModName);							plugcontrol->putlog('=', temp1);							PyErr_Print();//							PyErr_Clear();						}						Py_XDECREF(mod);					}					break;								case plugPreTossLaunch:								        func = RSP_FindEntry("entryPreTossLaunch", curElt->PlugEntries);					if (func)					{						result = PyObject_CallFunction(func, "()");						if (result)						{							if (PyInt_Check(result))								plugcontrol->retCode = PyInt_AsLong(result);							Py_XDECREF(result);						}						else if (PyErr_Occurred())						{							sprintf (temp1, " Module '%s' encountered runtime error", curElt->ModName);							plugcontrol->putlog('=', temp1);							PyErr_Print();//							PyErr_Clear();						}					}					break;				case plugPreScanLaunch:								        func = RSP_FindEntry("entryPreScanLaunch", curElt->PlugEntries);					if (func)					{						result = PyObject_CallFunction(func, "()");						if (result)						{							if (PyInt_Check(result))								plugcontrol->retCode = PyInt_AsLong(result);							Py_XDECREF(result);						}						else if (PyErr_Occurred())						{							sprintf (temp1, " Module '%s' encountered runtime error", curElt->ModName);							plugcontrol->putlog('=', temp1);							PyErr_Print();//							PyErr_Clear();						}					}					break;				case plugPreNetPackLaunch:								        func = RSP_FindEntry("entryPreNetPackLaunch", curElt->PlugEntries);					if (func)					{						result = PyObject_CallFunction(func, "()");						if (result)						{							if (PyInt_Check(result))								plugcontrol->retCode = PyInt_AsLong(result);							Py_XDECREF(result);						}						else if (PyErr_Occurred())						{							sprintf (temp1, " Module '%s' encountered runtime error", curElt->ModName);							plugcontrol->putlog('=', temp1);							PyErr_Print();//							PyErr_Clear();						}					}					break;				case plugCustomLaunch:								        func = RSP_FindEntry("entryCustomLaunch", curElt->PlugEntries);					if (func)					{						result = PyObject_CallFunction(func, "(s)", plugcontrol->misc.plugInvokeName);						if (result)						{							if (PyInt_Check(result))								customRetCode = PyInt_AsLong(result);							Py_XDECREF(result);						}						else if (PyErr_Occurred())						{							sprintf (temp1, " Module '%s' encountered runtime error", curElt->ModName);							plugcontrol->putlog('=', temp1);							PyErr_Print();//							PyErr_Clear();						}					}					break;				case plugCustomNames:								        func = RSP_FindEntry("entryCustomNames", curElt->PlugEntries);					if (func)					{						result = PyObject_CallFunction(func, "()");						if (result)						{							if (PyList_Check(result))							{								len = PyList_Size(result);								for (i = 0; i < len; i++)								{									obj = PyList_GetItem(result, i);									if (obj && PyString_Check(obj))									{										ptemp = PyString_AsString(obj);										j = CountInvokeNames();										if (gInvokeNames == NULL)											gInvokeNames = malloc(sizeof(char *) * 2);										else											gInvokeNames = realloc(gInvokeNames, sizeof(char *) * (j + 2));																				gInvokeNames[j] = malloc(strlen(ptemp) + 1);										strcpy(gInvokeNames[j], ptemp);										gInvokeNames[j+1] = NULL;									}								}							}							Py_XDECREF(result);						}						else if (PyErr_Occurred())						{							sprintf (temp1, " Module '%s' encountered runtime error", curElt->ModName);							plugcontrol->putlog('=', temp1);							PyErr_Print();//							PyErr_Clear();						}					}					break;				default:				//	We're ignoring all other opCodes (by the way, it's impossible calls)									break;				}			}						if (plugcontrol->retCode != plugRetContinue)				break;			else				if (plugcontrol->opCode == plugCustomLaunch &&					customRetCode == plugRetNoError)						break;							curElt = curElt->next;		}	}	if (gStr[0] != 0)		gPC->putlog('³', gStr);	gCurrentElt = NULL;	if (plugcontrol->opCode == plugWelcome)		plugcontrol->retCode = gCallable;	else if (plugcontrol->opCode == plugCustomLaunch)		plugcontrol->retCode = customRetCode;	else if (plugcontrol->opCode == plugCustomNames && gInvokeNames != NULL)		plugcontrol->misc.names.plugInvokeNames = gInvokeNames;	else if (plugcontrol->opCode == plugSuicide && gInitialized)	{		Py_Finalize();//		DeInitShuffler();		KillInvokeNames();	}	UseResFile(oldRes);#if UNIVERSAL_INTERFACES_VERSION < 0x0341	ExitCodeResource ();	#endif}#endif