//	¥	py_plugparsecfg.c#include "py_plugparsecfg.h"#include "py_plugparser_tkn.h"static voidcfgparser_dealloc(PyCfgParserObject *v){	int	i;	if (v->tokens)	{		i = 0;		while(v->tokens[i].token_name)			DisposePtr(v->tokens[i++].token_name);				DisposePtr((Ptr)v->tokens);	}	if (v->prefixes)	{		i = 0;		while(v->prefixes[i].token_name)			DisposePtr(v->prefixes[i++].token_name);				DisposePtr((Ptr)v->prefixes);	}	PyObject_Del(v);}static intcfgparser_init(PyCfgParserObject *v, PyObject *args, PyObject *kwds){	v->tokens = NULL;	v->prefixes = NULL;	return 0;}static intcfgparsercallback(long tokenclass, long associated_info, fetched_info *info, void *refcon){	PyObject	**tuple = (PyObject **)refcon;	PyObject	*obj = NULL;	switch (tokenclass & kGPBMASK)	{	case kEXTRABITS:		if ((tokenclass & ~kGPBMASK) == kEXTRAISADDR |			(tokenclass & ~kGPBMASK) == kEXTRAISMASK)				obj = (PyObject *)PyFtnMask_NewAddr(&info->address);		break;		case kLITERAL:				obj = PyString_FromString(info->literal);		break;		case kLONGNUMBER:		obj = PyInt_FromLong(info->number);		break;		case kCMDTOKEN:		obj = (PyObject *)PyParsedToken_New(tokenclass & 0x00FFFFFF, 0);		break;		case kERR:	default:				break;	}		if (obj != NULL)	{		long oldsize = PyTuple_Size(*tuple);		_PyTuple_Resize(tuple, oldsize + 1);		Py_XINCREF(obj);		PyTuple_SetItem(*tuple, oldsize, obj);	}		return kOK;}static PyObject *cfgparser_parse(PyCfgParserObject *v, PyObject *arg){	long		res;	PyObject	*tuple;	if (!PyString_Check(arg))		return NULL;	tuple = PyTuple_New(0);	res = parseoneline(PyString_AsString(arg),						v->tokens,						v->prefixes,						&tuple,						cfgparsercallback);		return tuple;}static const char	*patallowed = "tliam[]:1234567890";static const char	*cmpallowed = "tliam[]";static const char	*seqallowed = "tliam";static char *passoneitem(char *pat){	char *p = pat;	if (tolower(*p) == 't' && *(p+1) == ':')	{		p += 2;		while(isdigit(*p))			p++;	}	else		p++;	return p;}static char *passtoendofsequence(char *pat){	char *p = pat;	do {		p = passoneitem(p);		if (*p != '|')	//	Null too			break;		else			p++;	} while (1);	return p;}static char *findinsequence(char *pat, char quest, long tkn, long *good){	char *p = pat;	long k;		*good = 0;		do {		if (*good == 0 && tolower(*p) == quest)		{			if (quest == 't' && *(p+1) == ':')			{				p += 2;								while(isdigit(*p))				{					k *= 10;					k += *p - '0';					p++;				}								if (k == 0)					break;				else if (k == tkn)					*good = 1;			}			else			{				*good = 1;				p++;			}		}		else			p = passoneitem(p);		if (*p != '|')	//	Null too			break;		else			p++;	} while (1);		return p;}static PyObject *cfgparser_matched(PyObject *self, PyObject *args){	PyObject	*tuple, *obj, *tkn;	char		*pattern, *p;	char		quested[128];	long		i, j, llen, bypass, res = 0;	long		faculty;	if (!PyArg_ParseTuple(args, "Os", &tuple, &pattern))		return NULL;		if (!PyTuple_Check(tuple))		return NULL;	llen = PyTuple_Size(tuple);	if (strlen(pattern) > 0 && llen > 0 && llen < 128)	{		p = pattern;		while(*p)			if (strchr(patallowed, tolower(*p)) == NULL)				break;			else				p++;				if (*p == 0)		{			for (i = 0; i < llen; i++)			{				obj = PyTuple_GetItem(tuple, i);				if (obj == NULL)					break;				else if (PyInt_Check(obj))					quested[i] = 'i';				else if (PyString_Check(obj))					quested[i] = 'l';				else if (PyObject_TypeCheck(obj, &PyParserToken_Type))					quested[i] = 't';				else if (PyObject_TypeCheck(obj, &PyFtnMask_Type))					quested[i] = 'm';				else					break;			}						if (i >= llen)			{				quested[i] = 0;								if (strcmp(pattern, quested) == 0)					return PyInt_FromLong(1);								p = pattern;				i = 0;				j = 0;				faculty = false;				bypass = false;				while(*p || quested[i])				{					if (strchr(cmpallowed, tolower(*p)) == NULL)						break;					if (*p == 0)						break;					else if (*p == '[')					{						if (faculty)							break;						j = i;						faculty = true;						p++;					}					else if (bypass)					{						if (*p == ']')						{							bypass = false;							faculty = false;							p++;						}						else							if (tolower(*p) == 't' && *(p+1) == ':')							{								p += 2;								while(isdigit(*p))									p++;							}							else								p++;					}					else if (*p == ']')					{						if (!faculty)							break;						faculty = false;						p++;					}					else if (quested[i] == 0)					{						if (!faculty)							break;						if (tolower(*p) == 't' && *(p+1) == ':')						{							p += 2;							while(isdigit(*p))								p++;						}						else							p++;					}					else if (tolower(*p) != quested[i])					{						if (tolower(*p) == 'a' && quested[i] == 'm')						{							obj = PyTuple_GetItem(tuple, i);							if (obj == NULL)								break;							if (!PyFtnMask_Strong((PyFtnMaskObject *)obj))								break;							p++;							i++;						}						else if (!faculty)							break;						else						{							i = j;							bypass = true;							if (tolower(*p) == 't' && *(p+1) == ':')							{								p += 2;								while(isdigit(*p))									p++;							}							else								p++;						}					}					else					{						if (tolower(*p) == 't' && *(p+1) == ':')						{							long	k = 0, l;							p += 2;														while(isdigit(*p))							{								k *= 10;								k += *p - '0';								p++;							}														if (k == 0)								break;														obj = PyTuple_GetItem(tuple, i);							l = ((PyParserTokenObject *)obj)->token;							if (l != k)							{								if (!faculty)									break;								else								{									i = j;									bypass = true;								}							}							else								i++;						}						else						{							p++;							i++;						}					}				}								res = (*p || quested[i]) ? 0 : 1;			}		}	}		return PyInt_FromLong(res);}static PyMethodDef cfgparsero_methods[] = {	{"parse",	(PyCFunction)cfgparser_parse,	METH_O},	{"fitingrammar",	cfgparser_matched,	METH_VARARGS},	{NULL,		NULL}		/* sentinel */};static PyObject *cfgparser_getattr(PyCfgParserObject *v, char *name){	return Py_FindMethod(cfgparsero_methods, (PyObject *)v, name);}static intcfgparser_setattr(PyCfgParserObject *v, char *name, PyObject *content){	int res = -1;	if(PyInt_Check(content))	{		long val = PyInt_AsLong(content);			}	return res;}static PyObject *cfgparser_new(PyTypeObject *type, PyObject *args, PyObject *kwds){	PyObject			*cool;	PyObject			*elt, *tokens, *prefixes = NULL;	PyCfgParserObject	*res = NULL;	int					llen, i, j, k, lstr;	char				*str;	if (!PyArg_ParseTuple(args, "O|O:cfgparser", &tokens, &prefixes))		return NULL;	if (!PyList_Check(tokens) || (prefixes != NULL && !PyList_Check(prefixes)))		return NULL;		res = PyObject_New(PyCfgParserObject, &PyCfgParser_Type);	if (res != NULL)	{		llen = PyList_Size(tokens);		res->tokens = (token_desc *)NewPtrClear(sizeof(token_desc) * (llen+1));				for (i = 0, j = 0; i < llen; i++)		{			str = NULL;			lstr = -1;			k = -1;			cool = NULL;			elt = PyList_GetItem(tokens, i);			if(PyTuple_Check(elt))			{				if (!PyArg_ParseTuple(elt, "s#|O", &str, &lstr, &cool))					continue;			}			else if(PyString_Check(elt))			{				if (PyString_AsStringAndSize(elt, &str, &lstr) < 0)					continue;			}			else				continue;						if (lstr <= 0)				continue;						res->tokens[j].token_name = NewPtr(lstr+1);			memcpy(res->tokens[j].token_name, str, lstr);			res->tokens[j].token_name[lstr] = 0;			res->tokens[j].extradata = (long)cool;			j++;		}		if (prefixes)		{			llen = PyList_Size(prefixes);			res->prefixes = (token_desc *)NewPtrClear(sizeof(token_desc) * (llen+1));						for (i = 0, j = 0; i < llen; i++)			{				elt = PyList_GetItem(prefixes, i);				if(!PyTuple_Check(elt))					continue;								str = NULL;				lstr = -1;				k = -1;								cool = NULL;				if (!PyArg_ParseTuple(elt, "s#|O", &str, &lstr, &cool))					continue;								if (lstr <= 0)					continue;								res->prefixes[j].token_name = NewPtr(lstr+1);				memcpy(res->prefixes[j].token_name, str, lstr);				res->prefixes[j].token_name[lstr] = 0;				res->prefixes[j].extradata = (long)cool;				j++;			}		}		else			res->prefixes = NULL;	}		return (PyObject *)res;}PyTypeObject PyCfgParser_Type = {	PyObject_HEAD_INIT(&PyType_Type)	0,	"cfgparser",	sizeof(PyCfgParserObject),	0,	(destructor)cfgparser_dealloc,						/* tp_dealloc */	0,					/* tp_print */	(getattrfunc)cfgparser_getattr,						/* tp_getattr */	(setattrfunc)cfgparser_setattr,						/* tp_setattr */	0,					/* tp_compare */	0,					/* tp_repr */	0,					/* tp_as_number */	0,					/* tp_as_sequence */	0,					/* tp_as_mapping */	0,					/* tp_hash */	0,					/* tp_call */	0,					/* tp_str */	0,					/* tp_getattro */	0,					/* tp_setattro */	0,					/* tp_as_buffer */	Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,						/* tp_flags */	0,					/* tp_doc */	0,					/* tp_traverse */	0,					/* tp_clear */	0,					/* tp_richcompare */	0,					/* tp_weaklistoffset */	0,					/* tp_iter */	0,					/* tp_iternext */	0,					/* tp_methods */	0,					/* tp_members */	0,					/* tp_getset */	0,					/* tp_base */	0,					/* tp_dict */	0,					/* tp_descr_get */	0,					/* tp_descr_set */	0,					/* tp_dictoffset */	(initproc)cfgparser_init,						/* tp_init */	0,					/* tp_alloc */	cfgparser_new,		/* tp_new */};static PyObject *meth_cfgparser_new(PyObject *self, PyObject *args){	return cfgparser_new(&PyCfgParser_Type, args, NULL);}static PyMethodDef cfgparser_methods[] = {	{"new",				meth_cfgparser_new,		METH_VARARGS},	{NULL,		NULL}		/* sentinel */};DL_EXPORT(PyObject *)initcfgparser(void){	/* Initialize the type of the new type object here; doing it here	 * is required for portability to Windows without requiring C++. */	PyCfgParser_Type.ob_type = &PyType_Type;	/* Create the module and add the functions */	return Py_InitModule("cfgparser", cfgparser_methods);}