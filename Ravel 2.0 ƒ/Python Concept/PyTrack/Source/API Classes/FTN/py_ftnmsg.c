//	¥	py_ftnmsg.c//	Ext. Python with definition of ftnmsg type#include "py_ftnmsg.h"#include "py_ftnaddr.h"#include <extras.h>static voidftnmsg_dealloc(PyFtnMsgObject *v){	_Py_Dealloc(v->from);	_Py_Dealloc(v->to);	_Py_Dealloc(v->reply);	PyObject_Del(v);}static intftnmsg_init(PyFtnMsgObject *v, PyObject *args, PyObject *kwds){	v->from = NULL;	v->to = NULL;	v->reply = NULL;		v->msg = NULL;	v->owner = false;	return 0;}static PyObject *ftnmsg_getattr(PyFtnMsgObject *v, char *name){	if (strcmp(name, "fromaddr") == 0)	{		Py_XINCREF(v->from);		return v->from;	}	else if (strcmp(name, "toaddr") == 0)	{		Py_XINCREF(v->to);		return v->to;	}	else if (strcmp(name, "replyaddr") == 0)	{		Py_XINCREF(v->reply);		return v->reply;	}	else if (strcmp(name, "fromname") == 0)		return PyString_FromString(v->msg->fromname);	else if (strcmp(name, "toname") == 0)		return PyString_FromString(v->msg->toname);	else if (strcmp(name, "date") == 0)		return PyString_FromString(v->msg->date);	else if (strcmp(name, "subject") == 0)		return PyString_FromString(v->msg->subj);	else if (strcmp(name, "area") == 0)		return PyString_FromString(v->msg->area);	else if (strcmp(name, "text") == 0)	{		long size = GetHandleSize(v->msg->text);		if (size > 0)			size--;		return PyString_FromStringAndSize(*v->msg->text, size);	}	else if (strcmp(name, "attributes") == 0)			return PyInt_FromLong(v->msg->flags);	return NULL;}static intftnmsg_setattr(PyFtnMsgObject *v, char *name, PyObject *content){	int res = -1;	if(PyInt_Check(content))	{		long val = PyInt_AsLong(content);		if (strcmp(name, "attributes") == 0)		{			v->msg->flags = val;			res = 0;		}	}	else if(PyString_Check(content))	{		if (strcmp(name, "text") == 0)		{			Handle h;						h = NewHandleClear(PyString_Size(content) + 1);			if (h)			{				DisposeHandle(v->msg->text);				HLock(h);				//				DebugStr("\pWatch contents");								memcpy(*h, PyString_AsString(content), PyString_Size(content) + 1);				v->msg->text = h;				res = 0;			}		}		else if (strcmp(name, "fromname") == 0)		{			memcpy(v->msg->fromname, PyString_AsString(content), __min(MName-1,PyString_Size(content)));			v->msg->fromname[__min(MName-1,PyString_Size(content))] = 0;			res = 0;		}		else if (strcmp(name, "toname") == 0)		{			memcpy(v->msg->toname, PyString_AsString(content), __min(MName-1,PyString_Size(content)));			v->msg->toname[__min(MName-1,PyString_Size(content))] = 0;			res = 0;		}		else if (strcmp(name, "date") == 0)		{			memcpy(v->msg->date, PyString_AsString(content), __min(MDate-1,PyString_Size(content)));			v->msg->date[__min(MDate-1,PyString_Size(content))] = 0;			res = 0;		}		else if (strcmp(name, "subject") == 0)		{			memcpy(v->msg->subj, PyString_AsString(content), __min(MSubject-1,PyString_Size(content)));			v->msg->subj[__min(MSubject-1,PyString_Size(content))] = 0;			res = 0;		}		else if (strcmp(name, "area") == 0)		{			memcpy(v->msg->area, PyString_AsString(content), __min(255,PyString_Size(content)));			v->msg->area[__min(255,PyString_Size(content))] = 0;			res = 0;		}	}	else if(PyObject_TypeCheck(content, &PyFtnAddr_Type))	{		if (strcmp(name, "fromaddr") == 0)		{			((PyFtnAddrObject *)v->from)->address = ((PyFtnAddrObject *)content)->address;			v->msg->from = ((PyFtnAddrObject *)v->from)->address.ad;			res = 0;		}		else if (strcmp(name, "toaddr") == 0)		{			((PyFtnAddrObject *)v->to)->address = ((PyFtnAddrObject *)content)->address;			v->msg->to = ((PyFtnAddrObject *)v->to)->address.ad;			res = 0;		}		else if (strcmp(name, "replyaddr") == 0)		{			((PyFtnAddrObject *)v->reply)->address = ((PyFtnAddrObject *)content)->address;			v->msg->reply = ((PyFtnAddrObject *)v->reply)->address.ad;			res = 0;		}	}	return res;}static PyFtnMsgObject *ftnmsg_new_ex(void){	PyFtnMsgObject *res = PyObject_New(PyFtnMsgObject, &PyFtnMsg_Type);	if (res != NULL)		PyFtnMsg_Type.tp_init((PyObject *)res, NULL, NULL);	return res;}#if PYTRACK_STANDALONEstatic pktmsg *ftnmsg_clone(pktmsg *m){	pktmsg	*res;	Handle	h;	res = (pktmsg *) NewPtrClear (sizeof (pktmsg));	memcpy(res, m, sizeof(pktmsg));		if (res->text)	{		HandToHand(&res->text);		HLock(res->text);	}	if ( m->seenby.items )	{		res->seenby.items = m->seenby.items;		h = (Handle) m->seenby.nets;	HandToHand (&h);	res->seenby.nets = (short **) h;		h = (Handle) m->seenby.nodes;	HandToHand (&h);	res->seenby.nodes = (short **) h;	}		if ( m->path.items )	{		res->path.items = m->path.items;		h = (Handle) m->path.nets;	HandToHand (&h);	res->path.nets = (short **) h;		h = (Handle) m->path.nodes;	HandToHand (&h);	res->path.nodes = (short **) h;	}		if (m->msgid_str)	{		res->msgid_str = NewPtr (strlen (m->msgid_str) + 1);		strcpy (res->msgid_str, m->msgid_str);	}		if (m->reply_str)	{		res->reply_str = NewPtr (strlen (m->reply_str) + 1);		strcpy (res->reply_str, m->reply_str);	}}#endifstatic PyObject *ftnmsg_new(PyTypeObject *type, PyObject *args, PyObject *kwds){	PyObject		*x = NULL;	PyFtnMsgObject	*res = NULL;	if (type != &PyFtnMsg_Type)		return NULL;	if (args)		if (!PyArg_ParseTuple(args, "|O:ftnmsg", &x))			return NULL;	if (x == NULL)	{		res = ftnmsg_new_ex();				if (res != NULL)		{			res->msg = (pktmsg *) NewPtrClear (sizeof (pktmsg));			res->from = PyFtnAddr_NewAddr(&res->msg->from);			res->to = PyFtnAddr_NewAddr(&res->msg->to);			res->reply = PyFtnAddr_NewAddr(&res->msg->reply);						res->msg->text = NewHandle(0);						res->owner = true;		}	}	else if (PyObject_TypeCheck(x, &PyFtnMsg_Type))	{		res = ftnmsg_new_ex();		if (res != NULL)		{			PyFtnMsgObject *parent = (PyFtnMsgObject *)x;			res->msg = ftnmsg_clone(parent->msg);						res->from = PyFtnAddr_NewAddr(&res->msg->from);			res->to = PyFtnAddr_NewAddr(&res->msg->to);			res->reply = PyFtnAddr_NewAddr(&res->msg->reply);			res->owner = true;		}	}		return (PyObject *)res;}PyTypeObject PyFtnMsg_Type = {	PyObject_HEAD_INIT(&PyType_Type)	0,	"ftnmsg",	sizeof(PyFtnMsgObject),	0,	(destructor)ftnmsg_dealloc,						/* tp_dealloc */	0,					/* tp_print */	(getattrfunc)ftnmsg_getattr,						/* tp_getattr */	(setattrfunc)ftnmsg_setattr,						/* tp_setattr */	0,					/* tp_compare */	0,					/* tp_repr */	0,					/* tp_as_number */	0,					/* tp_as_sequence */	0,					/* tp_as_mapping */	0,					/* tp_hash */	0,					/* tp_call */	0,					/* tp_str */	0,					/* tp_getattro */	0,					/* tp_setattro */	0,					/* tp_as_buffer */	Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,						/* tp_flags */	0,					/* tp_doc */	0,					/* tp_traverse */	0,					/* tp_clear */	0,					/* tp_richcompare */	0,					/* tp_weaklistoffset */	0,					/* tp_iter */	0,					/* tp_iternext */	0,					/* tp_methods */	0,					/* tp_members */	0,					/* tp_getset */	0,					/* tp_base */	0,					/* tp_dict */	0,					/* tp_descr_get */	0,					/* tp_descr_set */	0,					/* tp_dictoffset */	(initproc)ftnmsg_init,						/* tp_init */	0,					/* tp_alloc */	ftnmsg_new,		/* tp_new */};static PyObject *meth_ftnmsg_new(PyObject *self, PyObject *args){	return ftnmsg_new(&PyFtnMsg_Type, args, NULL);}static PyMethodDef ftnmsg_methods[] = {	{"new",		meth_ftnmsg_new,		METH_VARARGS},	{NULL,		NULL}		/* sentinel */};#pragma mark -DL_EXPORT(PyObject *)initftnmsg(void){	/* Initialize the type of the new type object here; doing it here	 * is required for portability to Windows without requiring C++. */	PyFtnMsg_Type.ob_type = &PyType_Type;	/* Create the module and add the functions */	return Py_InitModule("ftnmsg", ftnmsg_methods);}PyObject *PyFtnMsg_New(PyObject *args){	return ftnmsg_new(&PyFtnMsg_Type, args, NULL);}PyObject *PyFtnMsg_Intern(pktmsg *msg, Boolean clone){	PyFtnMsgObject	*res = NULL;	res = ftnmsg_new_ex();	if (res != NULL)	{		res->msg = (clone) ? ftnmsg_clone(msg) : msg;		HLock(res->msg->text);				res->from = PyFtnAddr_NewAddr(&res->msg->from);		res->to = PyFtnAddr_NewAddr(&res->msg->to);		res->reply = PyFtnAddr_NewAddr(&res->msg->reply);		res->owner = clone;	}	return (PyObject *)res;}