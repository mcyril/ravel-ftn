//	¥	py_ftnmask.c//	Ext. Python with definition of ftnmask type#include "py_ftnmask.h"#include "py_ftnaddr.h"static voidftnmask_dealloc(PyFtnMaskObject *v){	PyObject_Del(v);}static intftnmask_compare(PyFtnMaskObject *v, PyFtnMaskObject *w){	if ( v->mask.zone == w->mask.zone &&		 v->mask.net == w->mask.net &&		 v->mask.node == w->mask.node &&		 v->mask.point == w->mask.point )		return 0;	else		return 1;}static intftnmask_print(PyFtnMaskObject *v, FILE *fp, int flags)     /* flags -- not used but required by interface */{	char	temp[128];		fprintf(fp, printmask(&v->mask, temp));	return 0;}static PyObject *ftnmask_repr(PyFtnMaskObject *v){	char	temp[128];	printmask(&v->mask, temp);	return PyString_FromString(temp);}static intftnmask_init(PyFtnMaskObject *v, PyObject *args, PyObject *kwds){	v->mask.zone = -1;	v->mask.net = -1;	v->mask.node = -1;	v->mask.point = -1;	return 0;}static PyObject *ftnmask_validfor(PyFtnMaskObject *v, PyObject *arg){	long res = 0;		if (!PyObject_TypeCheck(arg, &PyFtnAddr_Type))		return NULL;	res = addrInmask(&v->mask, &((PyFtnAddrObject *)arg)->address.ad) ?  1 : 0;	return PyInt_FromLong(res);}intPyFtnMask_Strong(PyFtnMaskObject *v){	long res = 0;		res =  (v->mask.zone > 0 &&			v->mask.net > 0 &&			v->mask.node > 0 &&			v->mask.point >= 0) ?  1 : 0;		return res;}static PyObject *ftnmask_strong(PyFtnMaskObject *v, PyObject *arg){	return PyInt_FromLong(PyFtnMask_Strong(v));}static PyObject *ftnmask_asaddr(PyFtnMaskObject *v, PyObject *arg){	return PyFtnAddr_NewAddr(&v->mask);}static PyMethodDef ftnmasko_methods[] = {	{"validfor",	(PyCFunction)ftnmask_validfor,	METH_O},	{"strong",		(PyCFunction)ftnmask_strong,	METH_NOARGS},	{"asaddr",		(PyCFunction)ftnmask_asaddr,	METH_NOARGS},	{NULL,		NULL}		/* sentinel */};static PyObject *ftnmask_getattr(PyFtnMaskObject *v, char *name){	if (strcmp(name, "zone") == 0)		return PyInt_FromLong(v->mask.zone);	else if (strcmp(name, "net") == 0)		return PyInt_FromLong(v->mask.net);	else if (strcmp(name, "node") == 0)		return PyInt_FromLong(v->mask.node);	else if (strcmp(name, "point") == 0)		return PyInt_FromLong(v->mask.point);	else		return Py_FindMethod(ftnmasko_methods, (PyObject *)v, name);}static intftnmask_setattr(PyFtnMaskObject *v, char *name, PyObject *content){	int res = -1;	if(PyInt_Check(content))	{		long val = PyInt_AsLong(content);				if (strcmp(name, "zone") == 0)		{			v->mask.zone = val;			res = 0;		}		else if (strcmp(name, "net") == 0)		{			v->mask.net = val;			res = 0;		}		else if (strcmp(name, "node") == 0)		{			v->mask.node = val;			res = 0;		}		else if (strcmp(name, "point") == 0)		{			v->mask.point = val;			res = 0;		}	}	return res;}static PyFtnMaskObject *ftnmask_new_ex(void){	PyFtnMaskObject *res = PyObject_New(PyFtnMaskObject, &PyFtnMask_Type);	if (res != NULL)		PyFtnMask_Type.tp_init((PyObject *)res, NULL, NULL);	return res;}static PyFtnMaskObject *ftnmask_new_string(char *string){	PyFtnMaskObject *res = ftnmask_new_ex();	if (res != NULL)	{//		res->mask.point = -1;		parsemask(&res->mask, string);	}	return res;}static PyObject *ftnmask_new(PyTypeObject *type, PyObject *args, PyObject *kwds){	PyObject *x = NULL;	if (type != &PyFtnMask_Type)		return NULL;	if (args)		if (!PyArg_ParseTuple(args, "|O:ftnmask", &x))			return NULL;	if (x == NULL)		return (PyObject *)ftnmask_new_ex();	if (PyString_Check(x))		return (PyObject *)ftnmask_new_string(PyString_AS_STRING(x));	if (PyObject_TypeCheck(x, &PyFtnMask_Type))	{		PyFtnMaskObject *res = ftnmask_new_ex();		if (res != NULL)		{			res->mask = ((PyFtnMaskObject *)x)->mask;		}				return (PyObject *)res;	}	if (PyObject_TypeCheck(x, &PyFtnAddr_Type))	{		PyFtnMaskObject *res = ftnmask_new_ex();		if (res != NULL)		{			res->mask = ((PyFtnAddrObject *)x)->address.ad;		}				return (PyObject *)res;	}		return NULL;}PyTypeObject PyFtnMask_Type = {	PyObject_HEAD_INIT(&PyType_Type)	0,	"ftnmask",	sizeof(PyFtnMaskObject),	0,	(destructor)ftnmask_dealloc,						/* tp_dealloc */	(printfunc)ftnmask_print,						/* tp_print */	(getattrfunc)ftnmask_getattr,						/* tp_getattr */	(setattrfunc)ftnmask_setattr,						/* tp_setattr */	(cmpfunc)ftnmask_compare,						/* tp_compare */	(reprfunc)ftnmask_repr,						/* tp_repr */	0,					/* tp_as_number */	0,					/* tp_as_sequence */	0,					/* tp_as_mapping */	0,					/* tp_hash */	0,					/* tp_call */	0,					/* tp_str */	0,					/* tp_getattro */	0,					/* tp_setattro */	0,					/* tp_as_buffer */	Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,						/* tp_flags */	0,					/* tp_doc */	0,					/* tp_traverse */	0,					/* tp_clear */	0,					/* tp_richcompare */	0,					/* tp_weaklistoffset */	0,					/* tp_iter */	0,					/* tp_iternext */	0,					/* tp_methods */	0,					/* tp_members */	0,					/* tp_getset */	0,					/* tp_base */	0,					/* tp_dict */	0,					/* tp_descr_get */	0,					/* tp_descr_set */	0,					/* tp_dictoffset */	(initproc)ftnmask_init,						/* tp_init */	0,					/* tp_alloc */	ftnmask_new,		/* tp_new */};static PyObject *meth_ftnmask_new(PyObject *self, PyObject *args){	return ftnmask_new(&PyFtnMask_Type, args, NULL);}static PyMethodDef ftnmask_methods[] = {	{"new",		meth_ftnmask_new,		METH_VARARGS},	{NULL,		NULL}		/* sentinel */};#pragma mark -DL_EXPORT(PyObject *)initftnmask(void){	/* Initialize the type of the new type object here; doing it here	 * is required for portability to Windows without requiring C++. */	PyFtnMask_Type.ob_type = &PyType_Type;	/* Create the module and add the functions */	return Py_InitModule("ftnmask", ftnmask_methods);}PyObject *PyFtnMask_New(PyObject *args){	return ftnmask_new(&PyFtnMask_Type, args, NULL);}PyObject *PyFtnMask_NewStr(char *str){	return (PyObject *)ftnmask_new_string(str);}PyObject *PyFtnMask_NewAddr(addr *mask){	PyFtnMaskObject *res = ftnmask_new_ex();	if(res)		res->mask = *mask;	return (PyObject *)res;}