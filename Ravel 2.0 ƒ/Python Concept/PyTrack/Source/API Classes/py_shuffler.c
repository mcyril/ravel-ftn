//	¥	py_shuffler.c#include "py_shuffler.h"#include "guimodule.h"#include "fss_misc.h"//#include <signal.h>#define	PMODE_TOUCH		0#define	PMODE_FORBASE	1#define	PMODE_TRANSIT	2#define	PMODE_PREPNEW	3#pragma mark ¥ Initialize Shuffler entries#pragma mark -PlugEntryDef shufflerPlugEntries[] = {//		Callback installers		{ "entryWelcome", NULL, 0 },		{ "entrySuicide", NULL, 0 },		{ "entryTossMsgEcho", NULL, 0 },		{ "entryTossMsgEchoExp", NULL, 0 },		{ "entryTossMsgMail", NULL, 0 },		{ "entryTossMsgMailTrs", NULL, 0 },		{ "entryScanMsgEcho", NULL, 0 },		{ "entryScanMsgMail", NULL, 0 },		{ "entryCustomLaunch", NULL, 0 },		{ "entryPreTossLaunch", NULL, 0 },		{ "entryPreScanLaunch", NULL, 0 },		{ "entryPreNetPackLaunch", NULL, 0 },		{ "entryNotify", NULL, 0 },		{ "entryCustomNames", NULL, 0 },		{ "entryMisc", NULL, 0 },		{ "entryCompExtr", NULL, 0 },//		Trailer		{ NULL, NULL }};PyObject *RSP_FindEntry(char *name, PlugEntryDef *list){	long	i;	for (i = 0; list[i].name; i++)		if (strcmp(name, list[i].name) == 0)			return list[i].object;		return NULL;}longRSP_FillEntries(PyObject *module, PlugEntryDef *namelist, PlugEntryDef *destlist){	long		i, result = 0;	PyObject	*dict, *func;//	dict = PyModule_GetDict(module);	for (i = 0; namelist[i].name; i++)	{		destlist[i].name = namelist[i].name;		destlist[i].object = NULL;		destlist[i].reserved = 0;        func = PyObject_GetAttrString(module, namelist[i].name);		if (func)		{			if (PyCallable_Check(func))			{				destlist[i].object = func;				result |= 1 << i;			}		}		else		{			PyErr_Clear();		}	}	destlist[i].name = NULL;	//	trailer	if (result & 0x00004000L)		result = (result & ~0x00004000L) | plugMisc;	if (result & 0x00008000L)		result = (result & ~0x00008000L) | plugCompExtr;	return result;}#pragma mark -#pragma mark ¥ Initialize Shuffler utility callbacks#pragma mark -static PyObject *wrap_CallPlugIns(PyObject *self, PyObject *args){	int			result = plugRetNoError;	PyObject	*dict, *module, *func, *rslt;	//	if (!PyArg_ParseTuple(args,"iOi:CallPlugIns",&result))//		return NULL;	return Py_BuildValue("i",result);}static PyObject *wrap_CallNamedPlugIns(PyObject *self, PyObject *args){	int			result = plugRetNoError;	PyObject	*dict, *module, *func, *rslt;	//	if (!PyArg_ParseTuple(args,"s:CallNamedPlugIns",&result))//		return NULL;	return Py_BuildValue("i",result);}static PyObject *wrap_CallArchiverPlugIns(PyObject *self, PyObject *args){	int			result = plugRetNoError;	PyObject	*dict, *module, *func, *rslt;	//	if (!PyArg_ParseTuple(args,"iiiOO:CallArchiverPlugIns",&result))//		return NULL;	return Py_BuildValue("i",result);}static PyObject *wrap_StoreMsgSpecial(PyObject *self, PyObject *args){	PyFtnMsgObject	*msg;	char			*toarea = NULL;	PyFtnAddrObject	*adr = NULL;	char			*reason = NULL;			if (!PyArg_ParseTuple(args,"Os|Os:StoreMsgSpecial", &msg, &toarea, &adr, &reason))		return NULL;		if (msg == NULL)		return NULL;	if (!PyObject_TypeCheck(msg, &PyFtnMsg_Type))		return NULL;		if (adr != NULL)		if (!PyObject_TypeCheck(msg, &PyFtnAddr_Type))			return NULL;#if PYTRACK_SHUFFLER	gPC->add_to_other(msg->msg, toarea, (adr != NULL && adr->address.ad.zone != -1) ? &adr->address.ad : NULL, reason);#endif		Py_INCREF(Py_None);	return Py_None;}static PyObject *wrap_RouteMsg(PyObject *self, PyObject *args){	PyFtnMsgObject	*msg;	int				inTransit;	if (!PyArg_ParseTuple(args,"Oi:RouteMessage",&msg, &inTransit))		return NULL;	if (!PyObject_TypeCheck(msg, &PyFtnMsg_Type))		return NULL;#if PYTRACK_SHUFFLER	gPC->RouteMessage(msg->msg, inTransit);#endif		Py_INCREF(Py_None);	return Py_None;}static PyObject *wrap_ExportEchoes(PyObject *self, PyObject *args){	PyFtnMsgObject	*msg;	PyFtnAddrObject	*add = NULL;	if (!PyArg_ParseTuple(args,"O|O:ExportEchoes",&msg, &add))		return NULL;	if (!PyObject_TypeCheck(msg, &PyFtnMsg_Type))		return NULL;	if (add != NULL && !PyObject_TypeCheck(add, &PyFtnAddr_Type))		return NULL;#if PYTRACK_SHUFFLER	gPC->ExportEchoes(msg->msg, (add != NULL) ? &add->address.ad : NULL);#endif		Py_INCREF(Py_None);	return Py_None;}static PyObject *wrap_ExportEchoesOnlyTo(PyObject *self, PyObject *args){	PyFtnMsgObject	*msg;	PyFtnAddrObject	*fromadd = NULL;	PyFtnAddrObject	*toadd;	if (!PyArg_ParseTuple(args,"OO|O:ExportEchoesOnlyTo",&msg, &toadd, &fromadd))		return NULL;	if (!PyObject_TypeCheck(msg, &PyFtnMsg_Type) ||		!PyObject_TypeCheck(toadd, &PyFtnAddr_Type))		return NULL;	if (fromadd != NULL && !PyObject_TypeCheck(fromadd, &PyFtnAddr_Type))		return NULL;#if PYTRACK_SHUFFLER	gPC->ExportEchoesOnlyTo(msg->msg, (fromadd != NULL) ? &fromadd->address.ad : NULL, &toadd->address.ad);#endif		Py_INCREF(Py_None);	return Py_None;}static PyObject *wrap_IsItMyAddr(PyObject *self, PyObject *args){	long			res = 0;	if (!PyObject_TypeCheck(args, &PyFtnAddr_Type))		return NULL;#if PYTRACK_SHUFFLER	res = (gPC->IsItMyAddr(&((PyFtnAddrObject *)args)->address.ad)) ? 1 : 0;#endif		return PyInt_FromLong(res);}static PyObject *wrap_Slice(PyObject *self){	PyObject *value;#if PYTRACK_SHUFFLER	gPC->Slice();#endif//	PyErr_SetObject(PyExc_KeyboardInterrupt, Py_None);//	Py_XDECREF(Py_None);		Py_INCREF(Py_None);	return Py_None;}static PyObject *wrap_ParseMsg(PyObject *self, PyObject *args){	PyFtnMsgObject	*msg, *msgres;	pktmsg			*outmsg;	int				mode;	if (!PyArg_ParseTuple(args,"iO:ParseMessage", &mode, &msg))		return NULL;		if (msg == NULL)		return NULL;	if (!PyObject_TypeCheck(msg, &PyFtnMsg_Type))		return NULL;	switch (mode)	{	case PMODE_TOUCH:		outmsg = NULL;		break;			case PMODE_FORBASE:	case PMODE_TRANSIT:	case PMODE_PREPNEW:		outmsg = (pktmsg *) NewPtr (sizeof (pktmsg));		break;		default:		return NULL;	}#if PYTRACK_SHUFFLER	gPC->parse_kludges (mode, msg->msg, (outmsg) ? &outmsg : NULL, NULL, NULL, NULL);#endif	if (outmsg)		return PyFtnMsg_Intern(outmsg, false);	else	{		Py_INCREF(Py_None);		return Py_None;	}}static PyObject *wrap_TmpBaseAdd(PyObject *self, PyObject *args){	if (!PyObject_TypeCheck(args, &PyFtnMsg_Type))		return NULL;#if PYTRACK_SHUFFLER	gPC->tmpbase_add(((PyFtnMsgObject *)args)->msg);#endif		Py_INCREF(Py_None);	return Py_None;}static PyObject *wrap_InitProgress(PyObject *self, PyObject *args){	if (!PyInt_Check(args))		return NULL;#if PYTRACK_SHUFFLER	gPC->InitProgress((float)PyInt_AsLong(args));#endif		Py_INCREF(Py_None);	return Py_None;}static PyObject *wrap_DrawProgress(PyObject *self, PyObject *args){	if (!PyInt_Check(args))		return NULL;#if PYTRACK_SHUFFLER	gPC->DrawProgress((float)PyInt_AsLong(args));#endif		Py_INCREF(Py_None);	return Py_None;}static PyObject *wrap_putProgressName(PyObject *self, PyObject *args){	Str255	stemp;	char	*temp;	int		len;	if (!PyString_Check(args))		return NULL;	if (PyString_AsStringAndSize(args, &temp, &len) >= 0)	{		memcpy(&stemp[1], temp, __min(255, len));		stemp[0] = __min(255, len);	#if PYTRACK_SHUFFLER		gPC->putProgressName(stemp);#endif	}		Py_INCREF(Py_None);	return Py_None;}static PyObject *wrap_FlavorMessage(PyObject *self, PyObject *args){	PyFtnMsgObject	*msg;	PyFtnAddrObject	*from;	PyFtnAddrObject	*via;	int				transit;	if (!PyArg_ParseTuple(args,"OOOi:FlavorMessage",&msg, &from, &via, &transit))		return NULL;	if (!PyObject_TypeCheck(msg, &PyFtnMsg_Type) ||		!PyObject_TypeCheck(from, &PyFtnAddr_Type) ||		!PyObject_TypeCheck(via, &PyFtnAddr_Type))		return NULL;#if PYTRACK_SHUFFLER	gPC->FlavorMessage(msg->msg, &from->address.ad, &via->address.ad, transit);#endif		Py_INCREF(Py_None);	return Py_None;}static PyObject *wrap_msgbase_prep_msgid(PyObject *self, PyObject *args){	if (!PyObject_TypeCheck(args, &PyFtnMsg_Type))		return NULL;#if PYTRACK_SHUFFLER	gPC->msgbase_prep_msgid(((PyFtnMsgObject *)args)->msg);#endif		Py_INCREF(Py_None);	return Py_None;}static PyObject *wrap_msgbase_prep_reply(PyObject *self, PyObject *args){	PyObject *original, *destination;	if (!PyArg_ParseTuple(args,"OO:msgbase_prep_reply", &original, &destination))		return NULL;	if (!PyObject_TypeCheck(original, &PyFtnMsg_Type) ||		!PyObject_TypeCheck(destination, &PyFtnMsg_Type))		return NULL;#if PYTRACK_SHUFFLER	gPC->msgbase_prep_reply(((PyFtnMsgObject *)original)->msg, ((PyFtnMsgObject *)destination)->msg);#endif		Py_INCREF(Py_None);	return Py_None;}static PyObject *wrap_msgbase_ftn_date(PyObject *self, PyObject *args){	char			result[256];	int				date = -1;	if (args)		if (!PyArg_ParseTuple(args,"|i:msgbase_ftn_date", &date))			return NULL;#if PYTRACK_SHUFFLER	gPC->msgbase_ftn_date(result, NULL);#endif	return PyString_FromString(result);}static PyObject *wrap_get_flo_pathname(PyObject *self, PyObject *args){	PyFtnAddrObject	*add;	char			*base = NULL;	Str255			pbase, res;	Boolean			result;	if (!PyArg_ParseTuple(args,"O|s:get_flo_pathname", &add, &base))		return NULL;	if (!PyObject_TypeCheck(add, &PyFtnAddr_Type))		return NULL;#if PYTRACK_SHUFFLER	if (base == NULL)		pStrCopy(gPC->Preferences.OutboundPath, pbase);	else	{		strcpy((char *)&pbase[1], base);		pbase[0] = strlen(base);	}	result = gPC->get_flo_pathname(&add->address.ad, pbase, res);	if (!result)#endif		res[0] = 0;	return PyString_FromStringAndSize((char *)&res[1], res[0]);}static PyObject *wrap_bsy_raise(PyObject *self, PyObject *args){	PyFtnAddrObject	*add;	char			*base = NULL;	Str255			pbase;	Boolean			result;	if (!PyArg_ParseTuple(args,"O|s:bsy_raise", &add, &base))		return NULL;	if (!PyObject_TypeCheck(add, &PyFtnAddr_Type))		return NULL;#if PYTRACK_SHUFFLER	if (base == NULL)		pStrCopy(gPC->Preferences.BundlesPath, pbase);	else	{		strcpy((char *)&pbase[1], base);		pbase[0] = strlen(base);	}	result = gPC->bsy_raise(&add->address.ad, pbase);#endif	return PyInt_FromLong((result) ? 1 : 0);}static PyObject *wrap_bsy_check(PyObject *self, PyObject *args){	PyFtnAddrObject	*add;	char			*base = NULL;	Str255			pbase;	Boolean			result;	if (!PyArg_ParseTuple(args,"O|s:bsy_check", &add, &base))		return NULL;	if (!PyObject_TypeCheck(add, &PyFtnAddr_Type))		return NULL;#if PYTRACK_SHUFFLER	if (base == NULL)		pStrCopy(gPC->Preferences.BundlesPath, pbase);	else	{		strcpy((char *)&pbase[1], base);		pbase[0] = strlen(base);	}	result = gPC->bsy_check(&add->address.ad, pbase);#endif	return PyInt_FromLong((result) ? 1 : 0);}static PyObject *wrap_bsy_clear(PyObject *self, PyObject *args){	PyFtnAddrObject	*add;	char			*base = NULL;	Str255			pbase;	if (!PyArg_ParseTuple(args,"O|s:bsy_clear", &add, &base))		return NULL;	if (!PyObject_TypeCheck(add, &PyFtnAddr_Type))		return NULL;#if PYTRACK_SHUFFLER	if (base == NULL)		pStrCopy(gPC->Preferences.BundlesPath, pbase);	else	{		strcpy((char *)&pbase[1], base);		pbase[0] = strlen(base);	}	gPC->bsy_clear(&add->address.ad, pbase);#endif		Py_XINCREF(Py_None);	return Py_None;}static PyObject *wrap_nodelist_getstring(PyObject *self, PyObject *args){	Str255			string;	Boolean			res = false;	if (!PyObject_TypeCheck(args, &PyFtnAddr_Type))		return NULL;#if PYTRACK_SHUFFLER	res = gPC->GetNodeInfo(&((PyFtnAddrObject *)args)->address.ad, string);#endif	if (res)		return PyString_FromStringAndSize((char *)&string[1], string[0]);	else	{		Py_XINCREF(Py_None);		return Py_None;	}}static PyObject *wrap_nodelist_getname(PyObject *self, PyObject *args){	Str255			string;	Boolean			res = false;	if (!PyObject_TypeCheck(args, &PyFtnAddr_Type))		return NULL;#if PYTRACK_SHUFFLER	res = gPC->GetNameFromAddr(&((PyFtnAddrObject *)args)->address.ad, string);#endif	if (res)		return PyString_FromStringAndSize((char *)&string[1], string[0]);	else	{		Py_XINCREF(Py_None);		return Py_None;	}}static PyObject *wrap_nodelist_getinfo(PyObject *self, PyObject *args){	Str255			string;	Boolean			res = false;	if (!PyObject_TypeCheck(args, &PyFtnAddr_Type))		return NULL;#if PYTRACK_SHUFFLER	res = gPC->GetInfoFromAddr(&((PyFtnAddrObject *)args)->address.ad, string);#endif	if (res)		return PyString_FromStringAndSize((char *)&string[1], string[0]);	else	{		Py_XINCREF(Py_None);		return Py_None;	}}#pragma mark -static PyObject *wrap_Move(PyObject *self, PyObject *args){	OSErr	err;	char	*src = NULL, *dst = NULL;	FSSpec	srcspec, dstspec;	if (!PyArg_ParseTuple(args,"ss:move",&src, &dst))		return NULL;	err = _c_path2fss(src, &srcspec);	err = _c_path2fss(dst, &dstspec);		err = FSpCatMove(&srcspec, &dstspec);		return PyInt_FromLong(err);}#pragma mark -static PyObject *tool_istoken(PyObject *self, PyObject *args){	long	res;		res = (PyObject_TypeCheck(args, &PyParserToken_Type)) ? 1 : 0;		return PyInt_FromLong(res);}static PyObject *tool_isaddr(PyObject *self, PyObject *args){	long	res;		res = (PyObject_TypeCheck(args, &PyFtnAddr_Type)) ? 1 : 0;		return PyInt_FromLong(res);}static PyObject *tool_ismask(PyObject *self, PyObject *args){	long	res;		res = (PyObject_TypeCheck(args, &PyFtnMask_Type)) ? 1 : 0;		return PyInt_FromLong(res);}static PyObject *tool_isstring(PyObject *self, PyObject *args){	long	res;		res = (PyString_Check(args)) ? 1 : 0;		return PyInt_FromLong(res);}static PyObject *tool_isint(PyObject *self, PyObject *args){	long	res;		res = (PyInt_Check(args)) ? 1 : 0;		return PyInt_FromLong(res);}static PyObject *tool_inwildcard(PyObject *self, PyObject *args){	long	res;	char	*filename = NULL;	char	*wildcard = NULL;	if (!PyArg_ParseTuple(args,"ss:tool_inwildcard", &filename, &wildcard))		return NULL;		res = _wildcmp(wildcard, filename);		return PyInt_FromLong(res);}#pragma mark -static PyObject *wrap_tricky_suppress(PyObject *self, PyObject *args){	long	res;		if (!PyInt_Check(args))		return NULL;#if PYTRACK_SHUFFLER	if (gCurrentElt)	{		res = PyInt_AsLong(args);		gCurrentElt->Callable &= ~res;	}#endif	Py_INCREF(Py_None);	return Py_None;}static PyObject *wrap_tricky_random(PyObject *self, PyObject *args){	long			res;	long			from, to, range;	PyFtnAddrObject	*address = NULL;	if (!PyArg_ParseTuple(args,"ii|O:random", &from, &to, &address))		return NULL;		if (address != NULL && !PyObject_TypeCheck(address, &PyFtnAddr_Type))		return NULL;		range = to - from;		res = ((UInt32)rand() * range) / RAND_MAX + from;	if (address != NULL)	{		res ^= (address->address.ad.point) ^ (address->address.ad.node);		res ^= (address->address.ad.zone) ^ (address->address.ad.net);	}	return PyInt_FromLong(res);}#pragma mark -static PyMethodDef shufflerCallbacks[] = {//		Shuffler's API Callbacks		{ "CallPlugIns",			(PyCFunction)wrap_CallPlugIns,				METH_VARARGS	},		{ "CallNamedPlugIns",		(PyCFunction)wrap_CallNamedPlugIns,			METH_VARARGS	},		{ "CallArchiverPlugIns",	(PyCFunction)wrap_CallArchiverPlugIns,		METH_VARARGS	},		{ "StoreMsgSpecial",		(PyCFunction)wrap_StoreMsgSpecial,			METH_VARARGS	},		{ "RouteMessage",			(PyCFunction)wrap_RouteMsg,					METH_VARARGS	},		{ "ExportEchoes",			(PyCFunction)wrap_ExportEchoes,				METH_VARARGS	},		{ "ExportEchoesOnlyTo",		(PyCFunction)wrap_ExportEchoesOnlyTo,		METH_VARARGS	},		{ "IsItMyAddr",				(PyCFunction)wrap_IsItMyAddr,				METH_O			},		{ "Slice",					(PyCFunction)wrap_Slice,					METH_NOARGS		},		{ "ParseMessage",			(PyCFunction)wrap_ParseMsg,					METH_VARARGS	},		{ "TmpBaseAdd",				(PyCFunction)wrap_TmpBaseAdd,				METH_O			},		{ "InitProgress",			(PyCFunction)wrap_InitProgress,				METH_O			},		{ "DrawProgress",			(PyCFunction)wrap_DrawProgress,				METH_O			},		{ "SetStatus",				(PyCFunction)wrap_putProgressName,			METH_O			},		{ "FlavorMessage",			(PyCFunction)wrap_FlavorMessage,			METH_VARARGS	},		{ "msgbase_prep_msgid",		(PyCFunction)wrap_msgbase_prep_msgid,		METH_O			},		{ "msgbase_prep_reply",		(PyCFunction)wrap_msgbase_prep_reply,		METH_VARARGS	},		{ "msgbase_ftn_date",		(PyCFunction)wrap_msgbase_ftn_date,			METH_VARARGS	},		{ "get_flo_pathname",		(PyCFunction)wrap_get_flo_pathname,			METH_VARARGS	},		{ "bsy_raise",				(PyCFunction)wrap_bsy_raise,				METH_VARARGS	},		{ "bsy_check",				(PyCFunction)wrap_bsy_check,				METH_VARARGS	},		{ "bsy_clear",				(PyCFunction)wrap_bsy_clear,				METH_VARARGS	},		{ "nodelist_getstring",		(PyCFunction)wrap_nodelist_getstring,		METH_O			},		{ "nodelist_getname",		(PyCFunction)wrap_nodelist_getname,			METH_O			},		{ "nodelist_getinfo",		(PyCFunction)wrap_nodelist_getinfo,			METH_O			},//		os calls helpers		{ "move",					(PyCFunction)wrap_Move,						METH_VARARGS	},//		tricky calls helpers		{"suppress",				(PyCFunction)wrap_tricky_suppress,			METH_O			},		{"random",					(PyCFunction)wrap_tricky_random,			METH_VARARGS	},//		Shuffler's Type helpers		{"istoken",					(PyCFunction)tool_istoken,					METH_O			},		{"isaddr",					(PyCFunction)tool_isaddr,					METH_O			},		{"ismask",					(PyCFunction)tool_ismask,					METH_O			},		{"isstring",				(PyCFunction)tool_isstring,					METH_O			},		{"isint",					(PyCFunction)tool_isint,					METH_O			},		{"inwildcard",				(PyCFunction)tool_inwildcard,				METH_VARARGS	},//		Trailer		{ NULL, NULL }};static	PyObject	*gShufflerModule = NULL;static	PyObject	*gShufflerModDict = NULL;static	PyObject	*gFtnAddrModule = NULL;static	PyObject	*gFtnMaskModule = NULL;static	PyObject	*gFtnMsgModule = NULL;static	PyObject	*gCfgParserModule = NULL;static	PyObject	*gGUIModule = NULL;intInitShuffler(PlugsControl *pc){	PyObject *builtin, *m;		gShufflerModule = Py_InitModule("shuffler", shufflerCallbacks);	if (gShufflerModule == NULL)		return -1;	builtin = PyImport_ImportModule("__builtin__");//	More modules	PyModule_AddObject(builtin, "os", PyImport_ImportModule("os"));	PyModule_AddObject(builtin, "types", PyImport_ImportModule("types"));	PyModule_AddObject(builtin, "time", PyImport_ImportModule("time"));	PyModule_AddObject(builtin, "re", PyImport_ImportModule("re"));	PyModule_AddObject(builtin, "MacOS", PyImport_ImportModule("MacOS"));	PyModule_AddObject(builtin, "macfs", PyImport_ImportModule("macfs"));//	Tricky attributes	PyModule_AddIntConstant(builtin, "plugWelcome", plugWelcome);	PyModule_AddIntConstant(builtin, "plugSuicide", plugSuicide);	PyModule_AddIntConstant(builtin, "plugTossMsgEcho", plugTossMsgEcho);	PyModule_AddIntConstant(builtin, "plugTossMsgEchoExp", plugTossMsgEchoExp);	PyModule_AddIntConstant(builtin, "plugTossMsgMail", plugTossMsgMail);	PyModule_AddIntConstant(builtin, "plugTossMsgMailTrs", plugTossMsgMailTrs);	PyModule_AddIntConstant(builtin, "plugScanMsgEcho", plugScanMsgEcho);	PyModule_AddIntConstant(builtin, "plugScanMsgMail", plugScanMsgMail);	PyModule_AddIntConstant(builtin, "plugCustomLaunch", plugCustomLaunch);	PyModule_AddIntConstant(builtin, "plugPreTossLaunch", plugPreTossLaunch);	PyModule_AddIntConstant(builtin, "plugPreScanLaunch", plugPreScanLaunch);	PyModule_AddIntConstant(builtin, "plugPreNetPackLaunch", plugPreNetPackLaunch);	PyModule_AddIntConstant(builtin, "plugNotify", plugNotify );	PyModule_AddIntConstant(builtin, "plugCustomNames", plugCustomNames );	PyModule_AddIntConstant(builtin, "plugMisc", plugMisc );	PyModule_AddIntConstant(builtin, "plugCompExtr", plugCompExtr);//	Message FTS attributes (flasg)		PyModule_AddIntConstant(builtin, "MSGPRIVATE", MSGPRIVATE);				/*Private message*/	PyModule_AddIntConstant(builtin, "MSGCRASH", MSGCRASH);					/*High priority*/	PyModule_AddIntConstant(builtin, "MSGREAD", MSGREAD);					/*Read by addressee*/	PyModule_AddIntConstant(builtin, "MSGSENT", MSGSENT);					/*Has been sent*/	PyModule_AddIntConstant(builtin, "MSGFILE", MSGFILE);					/*File attached to msg*/	PyModule_AddIntConstant(builtin, "MSGTRANSIT", MSGTRANSIT);				/*In transit*/	PyModule_AddIntConstant(builtin, "MSGORPHAN", MSGORPHAN);				/*Unknown node*/	PyModule_AddIntConstant(builtin, "MSGKILL", MSGKILL);					/*Kill after mailing*/	PyModule_AddIntConstant(builtin, "MSGLOCAL", MSGLOCAL);					/*Message was entered here*/	PyModule_AddIntConstant(builtin, "MSGHOLD", MSGHOLD);					/*Hold for pickup*///	PyModule_AddIntConstant(builtin, "MSGUNUSED", MSGUNUSED);				/*!!*/	PyModule_AddIntConstant(builtin, "MSGFREQ", MSGFREQ);					/*File request*/	PyModule_AddIntConstant(builtin, "MSGRRREQ", MSGRRREQ);					/*Return receipt request !!*/	PyModule_AddIntConstant(builtin, "MSGISRR", MSGISRR);					/*Is return receipt !!*/	PyModule_AddIntConstant(builtin, "MSGAREQ", MSGAREQ);					/*Audit request !!*/	PyModule_AddIntConstant(builtin, "MSGFUPDREQ", MSGFUPDREQ);				/*File update request !!*/	PyModule_AddIntConstant(builtin, "MSGDIRECT", MSGDIRECT);				/*Direct message ¨*/	PyModule_AddIntConstant(builtin, "MSGSCN", MSGSCN);						/*SCN ¨*/	PyModule_AddIntConstant(builtin, "MSGKFS", MSGKFS);						/*KFS ¨*/	PyModule_AddIntConstant(builtin, "MSGCFM", MSGCFM);						/*CFM ¨*///	Parse kludges modes	PyModule_AddIntConstant(builtin, "PMODE_TOUCH", PMODE_TOUCH);	PyModule_AddIntConstant(builtin, "PMODE_FORBASE", PMODE_FORBASE);	PyModule_AddIntConstant(builtin, "PMODE_TRANSIT", PMODE_TRANSIT);	PyModule_AddIntConstant(builtin, "PMODE_PREPNEW", PMODE_PREPNEW);//	Return codes	PyModule_AddIntConstant(builtin, "NOERROR", plugRetNoError);	PyModule_AddIntConstant(builtin, "CONTINUE", plugRetContinue);	PyModule_AddIntConstant(builtin, "DROPMSG", plugRetDropMessage);	PyModule_AddIntConstant(builtin, "WRONGCALLNAME", plugRetWrongCustom);	PyModule_AddIntConstant(builtin, "FAILED", plugFatalArch);	gShufflerModDict = PyModule_GetDict(gShufflerModule);	gFtnAddrModule = initftnaddr();	gFtnMaskModule = initftnmask();	gFtnMsgModule = initftnmsg();	gCfgParserModule = initcfgparser();	gGUIModule = initPyGUI();	m = PyShufflerPref_Create(pc);	PyDict_SetItemString(gShufflerModDict, "prefs", m);	Py_XDECREF(m);		return 0;}voidDeInitShuffler(){	PyObject *m;	m = PyDict_GetItemString(gShufflerModDict, "prefs");	if (m != NULL)	{		PyDict_DelItemString(gShufflerModDict, "prefs");		_Py_Dealloc(m);		//	a.k.a PyShufflerPref_Kill()	}}void InitCertainModule(PyObject *d){	PyObject *m;	PyDict_SetItemString(d, "shuffler", gShufflerModule);	Py_XDECREF(gShufflerModule);	PyDict_SetItemString(d, "ftnaddr", gFtnAddrModule);		Py_XDECREF(gFtnAddrModule);	PyDict_SetItemString(d, "ftnmask", gFtnMaskModule);		Py_XDECREF(gFtnMaskModule);	PyDict_SetItemString(d, "ftnmsg", gFtnMsgModule);		Py_XDECREF(gFtnMsgModule);	PyDict_SetItemString(d, "cfgparser", gCfgParserModule);	Py_XDECREF(gCfgParserModule);	PyDict_SetItemString(d, "PyGUI", gGUIModule);			Py_XDECREF(gGUIModule);}