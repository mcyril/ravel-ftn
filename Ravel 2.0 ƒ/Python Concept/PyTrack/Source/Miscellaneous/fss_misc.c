/*	Copyright (c) 1999 Cyril Moorzin	_findfirst/_findnext					aknowledged from FontLab port-core*/#include <string.h>#include <ctype.h>#include <Script.h>#include <TextUtils.h>#include "fss_misc.h"static void copy_c_to_pascal_str(StringPtr dst, const char * src){	size_t len = strlen(src);		memcpy(&dst[1], &src[0], len);		dst[0] = len;}static void copy_pascal_to_c_str(char * dst, const StringPtr src){	memcpy(&dst[0], &src[1], src[0]);	dst[src[0]] = 0;}static StringPtr c_to_pascal_str(char * src){	size_t len = strlen(src);		memmove(&src[1], &src[0], len);	src[0] = len;		return (StringPtr)src;}static char * pascal_to_c_str(StringPtr src){	size_t len = src[0];	memmove(&src[0], &src[1], len);	src[len] = 0;	return (char *)src;}/* * str_insert_before - insert string 'src' at beginning of string 'dst' */static void str_insert_before(char * dst, const char * src){	/* make room for new string */	memmove (dst+strlen(src), dst, strlen(dst)+1);	/* copy new string in */	memmove (dst, src, strlen (src));}OSErr _c_path2fss(const char * pathName, FSSpecPtr spec){	Str255			pathNameStr;	char			cPathNameStr[256];	char *			fileName;	int				fileNameLen;	HVolumeParam	vpb;	CInfoPBRec		cpb;	OSErr			ioResult, result = noErr;			if (!pathName || !*pathName || strlen(pathName) > 255)		return(bdNamErr);// Extract file name (if any)		strcpy(cPathNameStr, pathName);		fileName = strrchr(cPathNameStr, ':');		if (!fileName++)		fileName = cPathNameStr;		fileNameLen = strlen(fileName);	//	if (!fileNameLen || fileNameLen > sizeof(spec->name) - 1 || *fileName == '.')   hh 10/25/97// Want to allow filenames begining with '.'. 	if (!fileNameLen || fileNameLen > sizeof(spec->name) - 1)		return(bdNamErr);		copy_c_to_pascal_str(spec->name, fileName);// Use PBGetCatInfo to get parID		copy_c_to_pascal_str(pathNameStr, pathName);		cpb.hFileInfo.ioNamePtr = pathNameStr;	cpb.hFileInfo.ioVRefNum = 0;	cpb.hFileInfo.ioFDirIndex = 0;	cpb.hFileInfo.ioDirID = 0;		ioResult = PBGetCatInfoSync((CInfoPBPtr) &cpb);		if (ioResult)	{		if (ioResult != fnfErr)			return(ioResult);		// If file not found, we still need to get parID	// Truncate path name and try again             				if (fileName == cPathNameStr)			*fileName++ = ':';				*fileName = 0;				copy_c_to_pascal_str(pathNameStr, cPathNameStr);				if ((ioResult = PBGetCatInfoSync((CInfoPBPtr) &cpb)) != 0)			return(ioResult);				if (!(cpb.hFileInfo.ioFlAttrib & ioDirMask))		// make sure we got a directory			return(bdNamErr);				spec->parID = cpb.dirInfo.ioDrDirID;				result = fnfErr;	}	else	{		if (cpb.hFileInfo.ioFlAttrib & ioDirMask)				// see if we got a directory			//return(notAFileErr);			result = notAFileErr;							// mm 980416				spec->parID = cpb.hFileInfo.ioFlParID;	}// Use PBHGetVInfo to get vRefNum		copy_c_to_pascal_str(pathNameStr, pathName);		vpb.ioNamePtr = pathNameStr;	vpb.ioVRefNum = 0;	vpb.ioVolIndex = -1;		ioResult = PBHGetVInfoSync((HParmBlkPtr) &vpb);		if (ioResult)		return(ioResult);		spec->vRefNum = vpb.ioVRefNum;		return(result);}OSErr _c_fss2path(const FSSpecPtr spec, char * pathName){	char		dirname[64], delimiter[2] = ":";	OSErr		err = noErr;	CInfoPBRec	cInfoPB;		*pathName = 0;		cInfoPB.dirInfo.ioFDirIndex = -1;	cInfoPB.dirInfo.ioVRefNum = spec->vRefNum;	cInfoPB.dirInfo.ioDrDirID = spec->parID;	cInfoPB.dirInfo.ioNamePtr = (StringPtr)dirname;		while (err == noErr)	{		dirname[0] = 0;		err = PBGetCatInfoSync(&cInfoPB);		if (err)			break;				strcat (pascal_to_c_str((StringPtr)dirname), delimiter);		str_insert_before (pathName, dirname);		if (cInfoPB.dirInfo.ioDrDirID == fsRtDirID)			break;		cInfoPB.dirInfo.ioDrDirID = cInfoPB.dirInfo.ioDrParID;	}		copy_pascal_to_c_str(dirname, spec->name);	strcat (pathName, dirname);		return err;}#define isMaskDone()    ((Boolean)!*mask)#define	EOS				0Boolean _wildcmp (char *mask, char *name){	char	*last;	char	ch;	for(;; mask++, name++)	{		ch = tolower (*name);		if (*mask != '?' && *mask != ch)		break;		if (ch == EOS)		return isMaskDone();	}	if(*mask != '*') return false;	for(;; mask++, name++)	{		while(*mask == '*')		{			last = mask;			mask++;			if(*mask == EOS)				return isMaskDone();		}		ch = tolower (*name);		if(ch == EOS)			return isMaskDone();		if(*mask != '?' && *mask != ch)		{			name -= (size_t)(mask - last) - 1;			mask = last;		}		if (isMaskDone ())			break;//			DebugStr ("\pCall Cyril. Report #0001");	}	return false;}static	char	__search_mask[256];static	FSSpec	__search_spec;static	long	__search_inx;static long scan_one_item (long inx, findfile_dataPtr FindData){	CInfoPBRec	cipbr;							/* local pb */	HFileInfo	*fpb = (HFileInfo *)&cipbr;		/* to pointers */	Str255		filename;	OSErr		rc;	do	{											/* indexing loop */		fpb->ioDirID = __search_spec.parID;		/* must set on each loop */		fpb->ioFDirIndex = inx;		fpb->ioVRefNum = __search_spec.vRefNum;		fpb->ioNamePtr = filename;		filename[0] = 0;		rc = PBGetCatInfoSync (&cipbr);		if (rc) break;							/* exit when no more entries */		if ((fpb->ioFlAttrib & 16) == 0)		{			memcpy (FindData->name, &filename[1], filename[0]);			FindData->name[filename[0]] = 0;			FindData->size = fpb->ioFlLgLen;			FindData->attrib = fpb->ioFlAttrib;			FindData->dwFileType = fpb->ioFlFndrInfo.fdType;			FindData->dwFileFlags = fpb->ioFlFndrInfo.fdFlags;			if (_wildcmp (__search_mask, FindData->name))				break;			else				inx++;		}		else			inx++;	} while (1);	return (rc == noErr) ? ++inx : rc;}long _findfirst(char *filename, char *mask, findfile_dataPtr FindData){	char	filenamecopy[256];	if (filename == NULL)		return -1;	strcpy (filenamecopy, filename);	if (filenamecopy[strlen(filenamecopy)-1] != ':')		strcat (filenamecopy, ":");	strcat (filenamecopy, "!@#$%");	strcpy (__search_mask, mask);	LowercaseText (__search_mask, strlen (__search_mask), smSystemScript);	_c_path2fss (filenamecopy, &__search_spec);	return __search_inx = scan_one_item (1, FindData);}long _findnext (long inx, findfile_dataPtr FindData){	return __search_inx = scan_one_item (__search_inx, FindData);}void _findclose (long inx){}OSErr get_finder_info (FSSpecPtr spec, FInfo *fndrInfo, FXInfo *itsFXInfo, Boolean *isDirectory){	CInfoPBRec cInfo;	memset(&cInfo, 0x00, sizeof(CInfoPBRec));	cInfo.hFileInfo.ioCompletion = NULL;	cInfo.hFileInfo.ioNamePtr = spec->name;	cInfo.hFileInfo.ioVRefNum = spec->vRefNum;	cInfo.hFileInfo.ioFDirIndex = 0;	cInfo.hFileInfo.ioDirID = spec->parID;	PBGetCatInfoSync(&cInfo);		if (cInfo.hFileInfo.ioResult == noErr)	{		*isDirectory = (cInfo.hFileInfo.ioFlAttrib & ioDirMask) != 0;		if (*isDirectory)		{			*fndrInfo = *(FInfo*)&cInfo.dirInfo.ioDrUsrWds;			*itsFXInfo = *(FXInfo*)&cInfo.dirInfo.ioDrFndrInfo;		}		else		{			*fndrInfo = cInfo.hFileInfo.ioFlFndrInfo;			*itsFXInfo = cInfo.hFileInfo.ioFlXFndrInfo;		}	}	return cInfo.hFileInfo.ioResult;}