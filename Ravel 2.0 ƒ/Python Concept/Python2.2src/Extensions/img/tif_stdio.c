#ifndef lintstatic char rcsid[] = "$Header: /ufs/mm/CVSPRIVATE/python/Extensions/img/tif_stdio.c,v 1.7 2000/09/08 10:26:41 jack Exp $";#endif/* * Copyright (c) 1988, 1989, 1990, 1991, 1992 Sam Leffler * Copyright (c) 1991, 1992 Silicon Graphics, Inc. * * Permission to use, copy, modify, distribute, and sell this software and  * its documentation for any purpose is hereby granted without fee, provided * that (i) the above copyright notices and this permission notice appear in * all copies of the software and related documentation, and (ii) the names of * Sam Leffler and Silicon Graphics may not be used in any advertising or * publicity relating to the software without the specific, prior written * permission of Sam Leffler and Silicon Graphics. *  * THE SOFTWARE IS PROVIDED "AS-IS" AND WITHOUT WARRANTY OF ANY KIND,  * EXPRESS, IMPLIED OR OTHERWISE, INCLUDING WITHOUT LIMITATION, ANY  * WARRANTY OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.   *  * IN NO EVENT SHALL SAM LEFFLER OR SILICON GRAPHICS BE LIABLE FOR * ANY SPECIAL, INCIDENTAL, INDIRECT OR CONSEQUENTIAL DAMAGES OF ANY KIND, * OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, * WHETHER OR NOT ADVISED OF THE POSSIBILITY OF DAMAGE, AND ON ANY THEORY OF  * LIABILITY, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE  * OF THIS SOFTWARE. *//* * TIFF Library stdio Routines. */#include "tiffiop.h"#include <unistd.h>#include <stdlib.h>#include <stdio.h>#include <sys/stat.h>/* sigh, mac/cfm68k specific stuff due to bad include files.... */#if defined(__CFM68K__) && !defined(__USING_STATIC_LIBS__)	#pragma import on#endif#ifndef filenoextern int fileno(FILE *);#endif#if defined(__CFM68K__) && !defined(__USING_STATIC_LIBS__)	#pragma import reset#endifstatic tsize_t_tiffReadProc(thandle_t fd, tdata_t buf, tsize_t size){	clearerr((FILE *)fd);	return fread(buf, 1, (size_t) size, (FILE *) fd);}static tsize_t_tiffWriteProc(thandle_t fd, tdata_t buf, tsize_t size){	clearerr((FILE *)fd);	return fwrite(buf, 1, (size_t) size, (FILE *) fd);}static toff_t_tiffSeekProc(thandle_t fd, toff_t off, int whence){	toff_t rv;	FILE *fp = (FILE *)fd;	toff_t oldpos;		oldpos = ftell(fp);	clearerr((FILE *)fd);	if (fseek(fp, (off_t) off, whence) < 0 )		return -1;	rv = ftell(fp);	return rv;}static int_tiffCloseProc(thandle_t fd){	return 0;}static toff_t_tiffSizeProc(thandle_t fd){	struct stat sb;	return (toff_t) (fstat(fileno((FILE *)fd), &sb) < 0 ? 0 : sb.st_size);}static int_tiffMapProc(thandle_t fd, tdata_t* pbase, toff_t* psize){	return (0);}static void_tiffUnmapProc(thandle_t fd, tdata_t base, toff_t size){}/* * Open a TIFF file descriptor for read/writing. */TIFF*TIFFFpOpen(FILE  *fp, const char* name, const char* mode){	TIFF* tif;#ifdef USE_GUSI2	/*	** GUSI 2.0.5 has a problem with readahead that seems to be triggered	** by libtiff's access patterns (first sequential reads then a seek).	** This workaround should mask the problem.	*/	fseek(fp, 0, 2);	fseek(fp, 0, 0);#endif	tif = TIFFClientOpen(name, mode,	    (thandle_t) fp,	    _tiffReadProc, _tiffWriteProc,	    _tiffSeekProc, _tiffCloseProc, _tiffSizeProc,	    _tiffMapProc, _tiffUnmapProc);	if (tif)		tif->tif_fd = fileno(fp);	return (tif);}