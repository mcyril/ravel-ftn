\chapter{Image file modules}This section describes a number of modules that provide a more-or-lessunified interface to reading and writing images in various fileformats.The philosophy used is that an in-core image will always be stored ina format that is convenient to the application, and that conversion from/tothe external format is done upon reading or writing the image.The incore image format defines all attributes of the graphical data:type of pixel (eg. rgb or greyscale), number of bits, direction(top-to-bottom or bottom-to-top), alignment rules, etc. All predefinedimage formats are defined in the module \module{imgformat}.Image file readers and writers usually support only a limited numberof image formats (one or two, usually), that correspond most closelyto the format the data has in the image file. In addition, there areconverters that can be stacked on the readers and writers that convertthe data to/from the internal format wanted. As an example: we want toread a GIF image (which can only be read as 8-bit colormap data) butwe need 32bit RGB data. The code fragment\begin{verbatim}    tmp = imggif.reader('filename.gif')    rdr = imgconvert.stackreader(imgformat.rgb, tmp)\end{verbatim}will allow us to use \var{rdr} to read RGB data.To make life even easier, it is often unnecessary to use theformat-specific modules. The \module{img} module is a generalisedwrapper that will choose the correct reader or writer (based on magicnumbers in the file, or on filename extension). It will also stack theneeded converters to get the incore format you specify.\section{General interface to image file modules}\declaremodule{}{imagefile}\modulesynopsis{General interface to image file modules.}In general each image file module will export the following functions:\begin{funcdesc}{reader}{file}Create a reader for image file \var{file}, which can be a filename oran open file object. The header will beread, and the attributes set accordingly. An imagefile reader objectis returned.\end{funcdesc}\begin{funcdesc}{writer}{file}Create a writer for image file \var{file}, which can be a filename oran open file object. Before calling thewriters \method{write()} method you have to fill in the necessaryattributes (at least \var{width}, \var{height} and \var{format}, andmaybe \var{colormap} as well). An imagefile writer object is returned.\end{funcdesc}\subsection{Imagefile Objects}\label{imagefile-objects}The reader and writer objects have a number of common attributes andmethods. There may be more attributes for readers or writers for agiven file type, these are described in the relevant section.\begin{memberdesc}[imagefile]{width}The width of the image in pixels.\end{memberdesc}\begin{memberdesc}[imagefile]{height}The height of the image in pixels.\end{memberdesc}\begin{memberdesc}[imagefile]{format_choices}A tuple containing all image formats that this reader or writer candirectly support.\end{memberdesc}\begin{memberdesc}[imagefile]{format}The image format that will be used for the incore data upon read orwrite. The user can set this to any of the formats present in\var{format_choices}.\end{memberdesc}\begin{memberdesc}[imagefile]{colormap}For colormap-based file formats, this attribute contains a\code{colormap} object representing the colormap data read from theimage file (or to be written to it).\end{memberdesc}\begin{memberdesc}[imagefile]{__dict__}The full dictionary of attributes of the reader or writer. This can beused to see which attributes the object supports.\end{memberdesc}\begin{methoddesc}[imagefile]{read}{}Read the image data, returning a string. The \var{format} attributedetermines how the return value is structured.\end{methoddesc}\begin{methoddesc}[imagefile]{write}{img}Write the image data from string \var{img}. \var{Img} is interpretedaccording to the image format specified in \var{format}.\end{methoddesc}\section{\module{img} ---         Interface for Reading and Writing Images.}\declaremodule{}{img}\modulesynopsis{Interface for Reading and Writing Images.}This is the module of choice to use for applications where you simplywant to read an image in any format and get it incore in a format thatsuits the application. The reader and writer objects use the interfacedescriped above; the creation routines have a slightly differentinterface, though. The creators raise the \var{unsupported_error}exception when the conversion requested is not available.\begin{funcdesc}{reader}{format, file\optional{, ignoreext}}Create an imagefilereader that will read \code{file} and produceinternal image format \code{format}. If the file is specified by namethe image file type is deduced from the extension (unless the optional\var{ignoreext} argument is non-zero). If this fails the first few bytes of the file are read to determine the type. A readerfor the correct type is then created. If the reader does not directlysupport the requested\code{format} a converter will be stacked. Alternatively, you cansupply \code{None} as \var{format}, and you will get the file readerwithout any stacked converters.\end{funcdesc}\begin{funcdesc}{writer}{format, filename}Create an imagefile writer that will write \var{filename} from animage in internal format \var{format}. The image file writer to useis determined by looking at the extension of the filename. If thewriter does not directly support the requested \var{format} aconverter will be stacked. Again, passing \var{None} will return thefile writer without any stacked converters.\end{funcdesc}\begin{funcdesc}{setquality}{high}Some conversions can be done in high quality or low quality. This iscurrently true for the 24-bit to 8-bit converters, that can use asimple nearest-color search or a Floyd-Steinberg errorcorrection. High quality mode is on by default, but can take a rathersubstantial amount of time, so it can be turned off by calling\code{setquality(0)}. The function returns the old quality setting.Setting the environment variable \var{SETDITHER} is equivalent tocalling \code{setquality(0)} upon importing the module.\end{funcdesc}\begin{funcdesc}{settrace}{on}Calling \method{settrace} with a non-zero argument cause the convertersto print messages explaining how the conversion is done. Settracereturns the old trace setting.\end{funcdesc}Note that \method{setquality} and \method{settrace} actually live in the\module{imgformat} module but are re-exported by \module{img}.\section{imgformat ---	Predefined image formats.}\declaremodule{extension}{imgformat}\modulesynopsis{Predefined image formats.}This module contains a number of predefined image formats, and allowscreation of new ones. You can check image formats for equality,pass them around to other img routines and examine some of theproperties of the format. The formats all describe pictures stored inrow-major, left-to-right, top-to-bottom order, unless otherwise noted.The module defines the following attributes and functions:\begin{excdesc}{error}the exception raised by all img modules. All img modules contain analias to it by the same name.\end{excdesc}\begin{datadesc}{colormap}8-bit colormapped data as a byte array. Eachrow is aligned on a 32-bit boundary. This is the format SGI GLexpects.\end{datadesc}\begin{datadesc}{colormap_b2t}Idem, but ordered bottom-to-top.\end{datadesc}\begin{datadesc}{grey}8-bit greyscale data as a byte array. Rows arealigned on 32-bit boundaries.\end{datadesc}\begin{datadesc}{grey_b2t}Idem, but ordered bottom-to-top.\end{datadesc}\begin{datadesc}{macrgb}Macintosh 24-bit RGB format (which has the colors ordered differentfrom X or SGI format).\end{datadesc}\begin{datadesc}{macrgb16}Macintosh 16-bit (15, actually) RGB format.\end{datadesc}\begin{datadesc}{pbmbitmap}A bitmap with each pixel (bit) stored in a separate byte, in thelow-order bit.\end{datadesc}\begin{datadesc}{rgb}24-bit RGB data or 32-bit RGBA data stored as a long array.The red data is stored in the LSB, the (optional) alphadata in the MSB. This is the SGI GL format.\end{datadesc}\begin{datadesc}{rgb_b2t}Idem, ordered bottom-to-top.\end{datadesc}\begin{datadesc}{rgb8}8-bit 3:3:2 RGB data stored as a byte array. Rows arealigned on 32-bit boundaries. Each pixel has the format RRRBBGGG. Thisis a format supported by some SGI graphics and videoboards.\end{datadesc}\begin{datadesc}{rgb8_b2t}Idem, ordered bottom-to-top.\end{datadesc}\begin{datadesc}{xgrey}Identical to \var{grey} but with 8-bit alignment.\end{datadesc}\begin{datadesc}{xrgb8}Identical to \var{rgb8} but with 8-bit alignment.\end{datadesc}\begin{datadesc}{xcolormap}Identical to \var{colormap}, but with 8-bit alignment.\end{datadesc}%** repeat the following for each function:\begin{funcdesc}{new}{name, descrtext, properties}Create a new image format object. \var{Name} is an identifier underwhich the new format is known, \var{descrtext} argument is a shorttextual description of the format, for instance \code{'SGI 8bit greytop-to-bottom'}, \var{properties} is a dictionary of properties of theformat, see below.\end{funcdesc}Note that defining a new format is useful only if you at least alsosupply a converter-function to/from some known format to the\module{imgconvert} module.The property-dictionary \var{descr} of a format can currently containthe following predefined properties:\code{'size'}, the size in bits of a pixel,\code{'align'}, the alignment of rows, again in bits,\code{'b2t'}, which is non-zero for bottom-to-top orientation,\code{'type'}, the type of pixels (\code{'rgb'}, \code{'grey'},\code{'mapped'} or \code{'packed'}),\code{'comp'}, a list of 2-tuples giving bit-offset (counting from theright end of the pixel) and bitcount per component (grey and mappedformats have one component, rgb has 3 (R, G and B) or 4 (R, G, B andA),\code{'shift'} (\code{packed} only) the bit-position of the low-orderbit of the first pixel in the byte, counting from the left, and\code{'step'} (\code{packed} only) how much to add to \code{shift} toget the bit-position of the low-order bit of the next pixel.Note that two formats are only equal if they compare equal: equalityof the property dictionaries is not enough (there may be hiddenproperties of a format that are not easily described).\section{imgcolormap ---	Support for colormap objects.}\declaremodule{extension}{imgcolormap}\modulesynopsis{Support for colormap objects.}This module contains support for colormap objects. A colormap objectis created by imagefile readers upon reading a colormap-based fileformat (and expected by writers of those). A colormap object can alsobe examined, changed and used to convert colormap data to rgband vice versa. Normally, this module will not be used directly by theuser, \module{img} will provide the calls to it, when needed.\begin{funcdesc}{new}{str}Create a new colormap object. The object mapping is initialized fromthe string \var{str}, which should contain four bytes for each entry(red LSB, MSB ignored, the \var{rgb} pixel format).\end{funcdesc}\begin{funcdesc}{new3}{redstr, greenstr, bluestr}Create a new colormap object. The object mapping is initialized fromthe three strings \var{redstr}, \var{greenstr} and \var{bluestr},which should have the same length.\end{funcdesc}\begin{funcdesc}{fromimage}{data, width, height, format\optional{, maplen}}Create the ``best'' colormap for a given image. Currently, the onlyimage format supported is \var{rgb}. The optional \var{maplen}parameter tells how many entries the colormap should have, the defaultis 256.If the source image contains too many different colors (more that 64K,currently) \var{fromimage} will fail and you should cluster yourcolors. The \var{imgconvert} routines handle this case by using\code{imgop.shuffle} to use components with fewer bits.\end{funcdesc}\subsection{Colormap Objects}\label{colormap-objects}A colormap object cannot change size after creation, so if you want tocreate an empty 256-entry colormap which you can fill later you haveto call \code{imgcolormap.new(chr(0)*4*256)}.Colormap objects partially behave as a sequence of \code{(red, green,blue)} tuples, in that indexing them works (also for assignment) andthat the \code{len()} function works. They do not support slicing andconcatenation, though.They also provide the following methods:\begin{methoddesc}{map}{data, width, srcfmt, dstfmt}Attempts to convert the image \var{data} of image format \var{srcfmt}to an image in format \var{dstfmt}. The \var{width} argument gives thewidth of the image. Currently the only supported conversions are from\var{colormap} or \var{xcolormap} to \var{rgb} and from \var{colormap_b2t} to\var{rgb_b2t}.\end{methoddesc}\begin{methoddesc}[colormap]{map8}{data}Convert an 8-bit image to another 8-bit image (using the ``red'' entryin the colormap).\end{methoddesc}\begin{methoddesc}[colormap]{getmacmapdata}{}Return the colormap as a string in Macintosh-format: 4 2-byte integersper entry, specifying index, red, green and blue values.\end{methoddesc}\begin{methoddesc}[colormap]{dither}{data, width, height, format\optional{, floyd}}Dither a 24-bit RGB image to an 8-bit image using this colormap. Theoptional \var{floyd} parameter can be set non-zero to useFloyd-Steinberg error diffusion. This can be rather expensive in CPUusage. \end{methoddesc}\section{imgop ---	Image Operations}\declaremodule{extension}{imgop}\modulesynopsis{Image Operations.}This module contains some useful operations on images. It is expectedthat it will eventually replace the \module{imageop} module, when it hasacquired all the needed functionality.\begin{funcdesc}{shuffle}{data, width, height, srcfmt, dstfmt}Shuffle bits around in pixels. The format of \var{data} is describedby \var{srcfmt}, the result is the image in format \var{dstfmt}. Foreach pixel, \var{shuffle} extracts each component and inserts it inthe destination pixel. Components are truncated or extended in ameaningful way when needed, so converting 8-bit RGB data to 24-bitworks as expected. This routine can also do stride-conversion, so itcan also be used to convert 4-byte aligned formats to 1-byte alignedformats and vice versa.\end{funcdesc}\begin{funcdesc}{dither}{data, width, height, srcfmt, dstfmt}Dither greyscale data to a bitmap using an order-8 ordered dither. Thesource format can be either \var{grey} or \var{xgrey}, the destinationformat must be \var{pbmbitmap}. Note that future implementations mayuse a different dither algorithm, possibly selected with an optionalargument.\end{funcdesc}\begin{funcdesc}{unpack}{data, width, height, srcfmt, dstfmt}Unpack data that packs multiple pixels in a byte. Source format shouldhave a single component only, and have an integral number of pixels ina byte (so unpacking 3 5-bit pixels stored in a word will not work).\end{funcdesc}\section{imggif ---	Support for GIF files.}\declaremodule{extension}{imggif}\modulesynopsis{Support for GIF files.}This module supports reading and writing GIF files. It will read bothGIF87 and GIF89 files and writes GIF87 files unless transparency isused. Many GIF featuresare only partially supported, like non-square pixels (where you haveto do the conversion to square pixels yourself).Reading interlaced files is supported, writing is not. Onlythe first image from a GIF file can be read, and writing alwayscreates a GIF file with a single image.GIF reader/writer objects define the following attributes, aside fromthe ones described in the general imagefile reader/writer interface:\begin{memberdesc}[imggifobject]{top}Top offset of the image, as read from the GIF image header.\end{memberdesc}\begin{memberdesc}[imggifobject]{left}Left offset of the image, as read from the GIF image header.\end{memberdesc}\begin{memberdesc}[imggifobject]{aspect}The aspect ratio of the image. An aspect ratio of 0 or 49 means thepixels are square.\end{memberdesc}\begin{memberdesc}[imggifobject]{transparent}The colormap index of the color to be treated as transparent. For areader object, this attribute will not exist if transparency was notused in the input file. Similarly, a writer will write anon-transparent file unless this attribute is set.\end{memberdesc}\section{imgpbm ---	Support for PBM files.}\declaremodule{extension}{imgpbm}\modulesynopsis{Support for PBM files.}This module supports reading and writing PBMPLUS bitmapimages. Images are read from (and written to) PBM files.Both the ASCII and the binary variants of the files aresupported.PGM objects define the \var{width}, \var{height}, \var{format} and\var{format_choices} attributes from the general interface. PBMwriters support one extra attribute:\begin{memberdesc}[imgpbmwriter]{forceplain}An integer flag. When set, the PBM file will be written in ASCII.\end{memberdesc}\section{imgpgm ---	Support for PGM files.}\declaremodule{extension}{imgpgm}\modulesynopsis{Support for PGM files.}This module supports reading and writing PBMPLUS greyscaleimages. Images are read from either PGM or PBM files and written toPGM files. Both the ASCII and the binary variants of the files aresupported.PGM objects define the \var{width}, \var{height}, \var{format} and\var{format_choices} attributes from the general interface. PGMwriters support one extra attribute:\begin{memberdesc}[imgpgmwriter]{forceplain}An integer flag. When set, the PGM file will be written in ASCII.\end{memberdesc}\section{imgppm ---	Support for PPM files.}\declaremodule{extension}{imgppm}\modulesynopsis{Support for PPM files.}This module supports reading and writing PBMPLUS colorimages. Images are read from either PPM, PGM or PBM files and written toPPM files. Both the ASCII and the binary variants of the files aresupported.PPM objects define the \var{width}, \var{height}, \var{format} and\var{format_choices} attributes from the general interface. PGMwriters support one extra attribute:\begin{memberdesc}[imgppmwriter]{forceplain}An integer flag. When set, the PPM file will be written in ASCII.\end{memberdesc}\section{imgpng ---	Support for PNG files.}\declaremodule{extension}{imgpng}\modulesynopsis{Support for PNG files.}This module supports reading and writing Portable Network Graphicsimages. Images are read and written in their ``native'' format, withsome adaptations (greyscale pixels are extended to 8 bits on read, etc)PPM objects define the \var{width}, \var{height}, \var{format},\var{format_choices} and (for colormapped images) \var{colormap}attributes from the general interface. \section{imgtiff ---	Support for TIFF files.}\declaremodule{extension}{imgtiff}\modulesynopsis{Support for TIFF files.}This module supports reading and writing of TIFF files. Currentlyfiles with photometric tags of \code{minisblack}, \code{miniswhite}and \code{rgb} are supported. Conversion of these formats from and toincore image formats \code{rgb}, \code{rgb_b2t}, \code{grey} and\code{grey_b2t} is handled. This is not according to the philosophysketched above and may change.Many of the more obscure TIFF tag types are ignored upon input, soreading files that contain them may not always produce the correctimages. TIFF files are always written with orientation top-left,fillorder msb-to-lsb and LZW compression.\section{imgjpeg ---	Support for JPEG files.}\declaremodule{extension}{imgjpeg}\modulesynopsis{Support for JPEG files.}This module supports reading and writing of JPEG files. formats\code{rgb} and \code{grey} are supported. Of the zillions of optionsthat the IJG JPEG library supports one is accessible:\begin{memberdesc}[imgjpegwriter]{quality}In writer objects, this integer can be set to a value between 1 and100 to denote at which quality level the jpeg file should becoded. Low numbers give grainy images but small files. A quality below25 results in a file that may not be portable.\end{memberdesc}{\em Note:}This module does not work if the SGI Compression Library isconfigured into python (by including the python \var{cl} module). Inthat case, it is replaced by a module written in Python providing thesame functionality by using the \var{cl} module.\section{imgsgi ---	Support for SGI RGB files.}\declaremodule{extension}{imgsgi}\modulesynopsis{Support for SGI RGB files.}This module supports SGI image files. It supports \code{grey}, \code{xgrey},\code{rgb8}, \code{xrgb8}, and \code{rgb} (both with and without alpha channel)format files, and their \code{_b2t} equivalents.Writer objects have two special attributes:\begin{memberdesc}[imgsgiwriter]{rle}An integer flag, defaulting to 1. When set, causes the file to bewritten using RLE compression. When clear the data is written verbatim.\end{memberdesc}\begin{memberdesc}[imgsgiwriter]{rgba}An integer flag, defaulting to 0. When set causes the alpha channel tobe saved to the file, otherwise only the RGB data is saved.  This hasonly effect for \code{rgb} format files.\end{memberdesc}\begin{memberdesc}[imsgsgiobject]{name}A string attribute.  This is the name of the image as found in theimage file itself.  When not set on writing, the name defaults to ``noname''.  On reading, when there is no name in the image file, no\code{name} attribute is created.\end{memberdesc}\section{imgpict ---	Support for Macintosh PICT files.}\declaremodule{extension}{imgpict}\modulesynopsis{Support for Macintosh PICT files.}This module supports writing Macintosh PICT files, from \code{macrgb}images. It does not support reading PICT files yet.\section{Credits}A lot of the code in these modules was taken from other sources. Allcode is freely distributable. See the source files for completecopyright notices and attributions.\section{To be done}This section lists some of the things that need to be done, in noparticular order.The tiff module should support colormapped tiff files, and maybe a fewother things as well.Most modules are not yet coded efficiently. Also, they do not alwaysprovide full support for the features of the image file formatsinvolved.