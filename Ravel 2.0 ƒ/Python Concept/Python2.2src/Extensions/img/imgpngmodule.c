/***********************************************************Copyright 1991, 1992, 1993, 1994 by Stichting Mathematisch Centrum,Amsterdam, The Netherlands.						All Rights ReservedPermission to use, copy, modify, and distribute this software and its documentation for any purpose and without fee is hereby granted, provided that the above copyright notice appear in all copies and thatboth that copyright notice and this permission notice appear in supporting documentation, and that the names of Stichting MathematischCentrum or CWI not be used in advertising or publicity pertaining todistribution of the software without specific, written prior permission.STICHTING MATHEMATISCH CENTRUM DISCLAIMS ALL WARRANTIES WITH REGARD TOTHIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY ANDFITNESS, IN NO EVENT SHALL STICHTING MATHEMATISCH CENTRUM BE LIABLEFOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGESWHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN ANACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUTOF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.******************************************************************//* png objects */#include "Python.h"#include "import.h"#include "png.h"#include <setjmp.h>/* Macro for error handling */#define PNGERROR(self) setjmp(self->my_png_struct.jmpbuf)#define SETPNGERRHANDLING(self) \	if ( PNGERROR(self) ) {\		PyErr_SetString(errobject, "PNG library signalled an error");\		return 0; }		/* XXXX change this to the image formats we support */static PyObject *format_rgb, *format_xgrey, *format_xmap;extern PyObject *getimgformat();		/* Get format by name */static PyObject *(*makecolormap)();	/* Routine to make a colormap */typedef struct {	PyObject_HEAD	PyObject	*dict;		/* Attributes dictionary */	PyObject	*fileobj;	/* the python file */	int		is_reader;	/* TRUE if this is a reader */	char		*filename;	/* filename of the image file */	FILE		*fp;		/* open file */	png_struct	my_png_struct;	/* The png reader/writer */	png_info	my_info_struct;	/* Information about the file */        PyObject	*reader_fmt;	/* Remember reader format */} pngobject;static PyObject *errobject;staticforward PyTypeObject Pngtype;#define is_pngobject(v)			((v)->ob_type == &Pngtype)static PyObject *mymkcolormap(pngmap, ncolors)     png_colorp pngmap;     int ncolors;{     long *map;     int i;     PyObject *rv;     if ( (map=(long *)malloc(ncolors*sizeof(long))) == NULL ) {       PyErr_NoMemory();       return NULL;     }     for(i=0; i<ncolors; i++) {       map[i] = (pngmap[i].red & 0xff) |	        (pngmap[i].green & 0xff) << 8 |	        (pngmap[i].blue & 0xff) << 16;     }     rv = makecolormap(map, ncolors);     free(map);     return rv;}static char doc_png[] =	"This object can be used to read/write pngimage files.\n"	"The 'width', 'height' and 'format' attributes give info about the\n"	"image data read (or to be written)";/* Routine to easily obtain C data from the dict python data */intpngselfattr(self, name, fmt, ptr, wanterr)	pngobject *self;	char *name;	char *fmt;	void *ptr;	int wanterr;{	PyObject *obj;	char errbuf[100];	obj = PyDict_GetItemString(self->dict, name);	if ( obj == NULL ) {		if ( wanterr ) {			sprintf(errbuf, "Required attribute '%s' not set", name);			PyErr_SetString(errobject, errbuf);			return 0;		} else {			PyErr_Clear();			return 0;		}	}	if ( !PyArg_Parse(obj, fmt, ptr) ) {		if ( !wanterr )			PyErr_Clear();		return 0;	}	return 1;}/* Routine to easily insert integer into dictionary */pngsetintattr(self, name, value)	pngobject *self;	char *name;	int value;{	PyObject *obj;	int rv;	obj = PyInt_FromLong(value);	rv = PyDict_SetItemString(self->dict, name, obj);	Py_DECREF(obj);	return rv;}static pngobject *newpngobject(){	pngobject *xp;	xp = PyObject_NEW(pngobject, &Pngtype);	if (xp == NULL)		return NULL;	xp->dict = PyDict_New();	xp->filename = NULL;	xp->fp = NULL;	xp->fileobj = NULL;	/* Initialize fields to sensible values */	png_info_init(&xp->my_info_struct);	return xp;}static intinitpngreader(self, name, fileobj)	pngobject *self;	char *name;	PyObject *fileobj;{	char *name_copy;	PyObject *format;	SETPNGERRHANDLING(self);	if( (name_copy=malloc(strlen(name)+1)) == NULL ) {		PyErr_NoMemory();		return 0;	}	strcpy(name_copy, name);	self->filename = name_copy;	self->is_reader = 1;	png_read_init(&self->my_png_struct);		if (fileobj) {		self->fileobj = fileobj;		Py_INCREF(fileobj);		self->fp = PyFile_AsFile(fileobj);	}	else		self->fp = fopen(name, "rb");	if ( self->fp == NULL ) {		PyErr_SetFromErrno(errobject);		return 0;	}		png_init_io(&self->my_png_struct, self->fp);	png_read_info(&self->my_png_struct, &self->my_info_struct);	/* We support a few formats and let libpng handle conversion	** to those:	**	*/	/* expand grayscale images to the full 8 bits */	if (self->my_info_struct.color_type == PNG_COLOR_TYPE_GRAY &&	    self->my_info_struct.bit_depth < 8)	  png_set_expand(&self->my_png_struct);	/* tell libpng to strip 16 bit/color files down to 8 bits/color */	if (self->my_info_struct.bit_depth == 16)	  png_set_strip_16(&self->my_png_struct);#if 0	/* shift the pixels down to their true bit depth */	if (self->my_info_struct.valid & PNG_INFO_sBIT &&	    self->my_info_struct.bit_depth > self->my_info_struct.sig_bit)	  png_set_shift(&self->my_png_struct, &(self->my_info_struct.sig_bit));#endif	/* pack multiple pixels with bit depths of 1, 2, and 4 into bytes	   (useful only for paletted and grayscale images) */	if (self->my_info_struct.bit_depth < 8)	  png_set_packing(&self->my_png_struct);	/* add a filler byte to RGB files (before or after each RGB triplet) */	if (self->my_info_struct.color_type == PNG_COLOR_TYPE_RGB)	  png_set_filler(&self->my_png_struct, 0, PNG_FILLER_AFTER);	/* turn on rgb to bgr mapping */	if (self->my_info_struct.color_type == PNG_COLOR_TYPE_RGB ||	    self->my_info_struct.color_type == PNG_COLOR_TYPE_RGB_ALPHA)	  png_set_bgr(&self->my_png_struct);	/* Update the info values and compute palette (if needed) */	png_read_update_info(&self->my_png_struct, &self->my_info_struct);		/* XXXX set format and format_choices correctly */	pngsetintattr(self, "width", self->my_info_struct.width);	pngsetintattr(self, "height", self->my_info_struct.height);	if ( self->my_info_struct.color_type == PNG_COLOR_TYPE_RGB )	  format = format_rgb;	else if ( self->my_info_struct.color_type == PNG_COLOR_TYPE_RGB_ALPHA )	  format = format_rgb;	else if ( self->my_info_struct.color_type == PNG_COLOR_TYPE_GRAY )	  format = format_xgrey;	else if ( self->my_info_struct.color_type == PNG_COLOR_TYPE_PALETTE ) {	  format = format_xmap;	  PyDict_SetItemString(self->dict, "colormap",	      mymkcolormap(self->my_info_struct.palette,			   self->my_info_struct.num_palette));	} else {	  PyErr_SetString(errobject, "Unknown color_type in png file");	  return 0;	}		PyDict_SetItemString(self->dict, "format", format);	PyDict_SetItemString(self->dict, "format_choices",			     Py_BuildValue("(O)", format));	self->reader_fmt = format;	if( PyErr_Occurred() )		return 0;	return 1;}static intinitpngwriter(self, name, fileobj)	pngobject *self;	char *name;	PyObject *fileobj;{	char *name_copy;	SETPNGERRHANDLING(self);	if( (name_copy=malloc(strlen(name)+1)) == NULL ) {		PyErr_NoMemory();		return 0;	}	strcpy(name_copy, name);	self->filename = name_copy;	self->is_reader = 0;	png_write_init(&self->my_png_struct);		if (fileobj) {		self->fileobj = fileobj;		Py_INCREF(fileobj);		self->fp = PyFile_AsFile(fileobj);	}	else		self->fp = fopen(name, "wb");	if ( self->fp == NULL ) {		PyErr_SetFromErrno(errobject);		return 0;	}		png_init_io(&self->my_png_struct, self->fp);		/* XXXX set format and format_choices correctly */	PyDict_SetItemString(self->dict, "format", format_rgb);	PyDict_SetItemString(self->dict, "format_choices",			     Py_BuildValue("OOO", format_rgb, format_xgrey,					   format_xmap));	if( PyErr_Occurred())		return 0;	return 1;}/* png methods */static voidpng_dealloc(xp)	pngobject *xp;{	Py_XDECREF(xp->dict);	if( xp->filename )		free(xp->filename);	if ( xp->is_reader )		png_read_destroy(&xp->my_png_struct, &xp->my_info_struct,				 (png_info *)0);	else		png_write_destroy(&xp->my_png_struct);	if (xp->fp) {		fflush(xp->fp);		if (xp->fileobj == NULL)			fclose(xp->fp);	}	Py_XDECREF(xp->fileobj);	/* XXXX Free other allocated things here */	PyMem_DEL(xp);}static char doc_read[] = "Read the actual image data as a string";static PyObject *png_read(self, args)	pngobject *self;	PyObject *args;{	PyObject *fmt;	char *data;	long rowbytes, height, i;	unsigned char **row_pointers=NULL;	PyObject *rv=NULL;	if ( PNGERROR(self) )	  goto out;		if (!PyArg_ParseTuple(args,""))		return NULL;	if (!self->is_reader) {		PyErr_SetString(errobject, "Cannot read() from writer object");		return NULL;	}	/* XXXX Get format (and other args), check, read data, return it */	if ( !pngselfattr(self, "format", "O", (void *) &fmt, 1) )		return NULL;	if ( fmt != self->reader_fmt ) {	  PyErr_SetString(errobject, "Incorrect format for this png file");	  return NULL;	}	png_read_update_info(&self->my_png_struct, &self->my_info_struct);	rowbytes = self->my_info_struct.rowbytes;	height = self->my_info_struct.height;		if ( (rv=PyString_FromStringAndSize("", rowbytes*height)) == NULL )	  goto out;	data = PyString_AsString(rv);		if ( (row_pointers=(unsigned char **)malloc(height*sizeof(char **))) == NULL )	  goto out;		for(i=0; i<height; i++)	  row_pointers[i] = (unsigned char *)data + i*rowbytes;	png_read_image(&self->my_png_struct, row_pointers);			return rv;out1:	PyErr_SetString(errobject, "Png library singalled an error");out:	if ( row_pointers )	  free(row_pointers);	Py_XDECREF(rv);	return NULL;	  }static char doc_write[] = "Write the image data";static PyObject *png_write(self, args)	pngobject *self;	PyObject *args;{	char *data;	int datalen;	int w, h;		if (!PyArg_ParseTuple(args, "s#", &data, &datalen))		return NULL;	if (self->is_reader) {		PyErr_SetString(errobject, "Cannot write() to reader object");		return NULL;	}	/* XXXX Get args from self->dict and write the data */	if ( !pngselfattr(self, "width", "i", (void *) &w, 1) ||		 !pngselfattr(self, "height", "i", (void *) &h, 1) )		return NULL;	if( w*h != datalen ) {		PyErr_SetString(errobject, "Incorrect datasize");		return NULL;	}	Py_INCREF(Py_None);	return Py_None;}static struct PyMethodDef png_methods[] = {	{"read",	(PyCFunction)png_read,	1,	doc_read},	{"write",	(PyCFunction)png_write, 1,	doc_write},	{NULL,		NULL}			/* sentinel */};static PyObject *png_getattr(xp, name)	pngobject *xp;	char *name;{	PyObject *v;			if (xp->dict != NULL) {		if ( strcmp(name, "__dict__") == 0 ) {			Py_INCREF(xp->dict);			return xp->dict;		}		if ( strcmp(name, "__doc__") == 0 ) {			return PyString_FromString(doc_png);		}		v = PyDict_GetItemString(xp->dict, name);		if (v != NULL) {			Py_INCREF(v);			return v;		}	}	return Py_FindMethod(png_methods, (PyObject *)xp, name);}static intpng_setattr(xp, name, v)	pngobject *xp;	char *name;	PyObject *v;{	if (xp->dict == NULL) {		xp->dict = PyDict_New();		if (xp->dict == NULL)				return -1;	}	if (v == NULL) {		int rv = PyDict_DelItemString(xp->dict, name);		if (rv < 0)			PyErr_SetString(PyExc_AttributeError,				"delete non-existing imgpng attribute");		return rv;	}	else		return PyDict_SetItemString(xp->dict, name, v);}static PyTypeObject Pngtype = {	PyObject_HEAD_INIT(&PyType_Type)	0,				/*ob_size*/	"imgpng",			/*tp_name*/	sizeof(pngobject),		/*tp_basicsize*/	0,				/*tp_itemsize*/	/* methods */	(destructor)png_dealloc,	/*tp_dealloc*/	0,				/*tp_print*/	(getattrfunc)png_getattr,	/*tp_getattr*/	(setattrfunc)png_setattr,	/*tp_setattr*/	0,				/*tp_compare*/	0,				/*tp_repr*/	0,				/*tp_as_number*/	0,				/*tp_as_sequence*/	0,				/*tp_as_mapping*/	0,				/*tp_hash*/};static char doc_newreader[] = "Create reader for file passed as arg";static PyObject *png_newreader(self, args)	PyObject *self;	PyObject *args;{	char *filename;	pngobject *obj;	PyObject *fileobj = NULL;			if (!PyArg_ParseTuple(args, "s", &filename)) {	    PyErr_Clear();	    if (!PyArg_ParseTuple(args, "O!", &PyFile_Type, &fileobj))	        return NULL;	    filename = "<open file>";	}	if ((obj = newpngobject()) == NULL)		return NULL;	if ( !initpngreader(obj, filename, fileobj) ) {		Py_DECREF(obj);		return NULL;	}	return (PyObject *)obj;}static char doc_newwriter[] = "Create writer for file passed as arg";static PyObject *png_newwriter(self, args)	PyObject *self;	PyObject *args;{	char *filename;	pngobject *obj;	PyObject *fileobj = NULL;			if (!PyArg_ParseTuple(args, "s", &filename)) {	    PyErr_Clear();	    if (!PyArg_ParseTuple(args, "O!", &PyFile_Type, &fileobj))	        return NULL;	    filename = "<open file>";	}	if ((obj = newpngobject()) == NULL)		return NULL;	if ( !initpngwriter(obj, filename, fileobj) ) {		Py_DECREF(obj);		return NULL;	}	return (PyObject *)obj;}/* List of functions defined in the module */static struct PyMethodDef png_module_methods[] = {	{"reader",	png_newreader,	1,	doc_newreader},	{"writer",	png_newwriter,	1,	doc_newwriter},	{NULL,		NULL}			/* sentinel */};/* Initialization function for the module (*must* be called initimgpng) */static char doc_imgpng[] = "Boilerplate for image file access modules";voidinitimgpng(){	PyObject *m, *d, *x, *o, *formatmodule, *formatdict;	/* Create the module and add the functions */	m = Py_InitModule("imgpng", png_module_methods);	/* Add some symbolic constants to the module */	d = PyModule_GetDict(m);	x = PyString_FromString(doc_imgpng);	PyDict_SetItemString(d, "__doc__", x);	/* Get supported formats */	if ((formatmodule = PyImport_ImportModule("imgformat")) == NULL)		Py_FatalError("imgpng depends on imgformat");	if ((formatdict = PyModule_GetDict(formatmodule)) == NULL)		Py_FatalError("imgformat has no dict");	errobject = PyDict_GetItemString(formatdict,"error");	format_rgb = PyDict_GetItemString(formatdict,"rgb");	format_xmap = PyDict_GetItemString(formatdict,"xcolormap");	format_xgrey = PyDict_GetItemString(formatdict,"xgrey");	/* Get pointer to colormap-creation routine. NOTE: this is a hack */	if ((formatmodule = PyImport_ImportModule("imgcolormap")) == NULL)	    Py_FatalError("imggif depends on imgcolormap");	if ((formatdict = PyModule_GetDict(formatmodule)) == NULL)	    Py_FatalError("imgcolormap has no dict");	o = PyDict_GetItemString(formatdict, "_C_newmap");	(void)PyArg_Parse(o, "l", (long *)&makecolormap);		/* Check for errors */	if (format_rgb == NULL || format_xmap == NULL || format_xgrey == NULL	    || PyErr_Occurred())		Py_FatalError("can't initialize module imgpng");}