/***********************************************************Copyright 1991, 1992, 1993, 1994 by Stichting Mathematisch Centrum,Amsterdam, The Netherlands.                        All Rights ReservedPermission to use, copy, modify, and distribute this software and its documentation for any purpose and without fee is hereby granted, provided that the above copyright notice appear in all copies and thatboth that copyright notice and this permission notice appear in supporting documentation, and that the names of Stichting MathematischCentrum or CWI not be used in advertising or publicity pertaining todistribution of the software without specific, written prior permission.STICHTING MATHEMATISCH CENTRUM DISCLAIMS ALL WARRANTIES WITH REGARD TOTHIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY ANDFITNESS, IN NO EVENT SHALL STICHTING MATHEMATISCH CENTRUM BE LIABLEFOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGESWHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN ANACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUTOF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.******************************************************************//*** This module is only half-finished, really.** It reads the jpeg file immedeately upon opening it, mainly because there** is no official interface to the jpeg library that allows you to read** the header first and the rest of the data later.** Also, it does not provide any access to all sorts of jpeg parameters,** like quality, etc.*/#include <stdio.h>#ifdef __cplusplusextern "C" {#endif#include "jpeglib.h"#ifdef __cplusplus}#endif/* undefine these so that we don't get warnings about redefining them */#undef HAVE_PROTOTYPES#undef HAVE_STDDEF_H#undef HAVE_STDLIB_H#include <setjmp.h>static jmp_buf setjmp_buffer;/* Jpeg objects */#include "Python.h"#ifdef macintosh#include "macglue.h"#endif/* XXXX change this to the image formats we support */static PyObject *format_rgb, *format_xgrey;extern PyObject *getimgformat();	/* Get format by name */typedef struct {	PyObject_HEAD	PyObject	*dict;			/* Attributes dictionary */	PyObject	*fileobj;		/* The Python file object */	int		is_reader;		/* TRUE if this is a reader */	struct	jpeg_compress_struct	cinfo;	/* Compressor info struct (writer) */	struct	jpeg_decompress_struct	dinfo;	/* Decompressor info struct (reader) */	struct	jpeg_error_mgr		jerr;	/* Error handler */	FILE	*jpegfile;			/* The jpeg input or output file */	int	opened_jpegfile_ourselves;	/* True if we opened jpegfile */	/* Add other (user-invisible) data here */} jpegobject;static PyObject *errobject;staticforward PyTypeObject Jpegtype;#define is_jpegobject(v)		((v)->ob_type == &Jpegtype)static char doc_jpeg[] = "This object reads or writes a JPEG file.\n"	"The 'width', 'height' and 'format' attributes describe the data.\n"	"In writer objects you can set 'quality' to a value from 0-100";/* Jpeg error handling. */static voidimgjpeg_error_exit (j_common_ptr cinfo){  char buffer[JMSG_LENGTH_MAX];  /* Create the message */  (*cinfo->err->format_message) (cinfo, buffer);  PyErr_SetString(errobject, buffer);  longjmp(setjmp_buffer, 1);	/* return control to outer routine */}/* Routine to easily obtain C data from the dict python data */static intjpegselfattr(jpegobject *self, char *name, char *fmt, void *ptr, int wanterr){    PyObject *obj;    char errbuf[100];    obj = PyDict_GetItemString(self->dict, name);    if ( obj == NULL ) {	if ( wanterr ) {	    sprintf(errbuf, "Required attribute '%s' not set", name);	    PyErr_SetString(errobject, errbuf);	    return 0;	} else {	    PyErr_Clear();	    return 0;	}    }    if ( !PyArg_Parse(obj, fmt, ptr) ) {	if ( !wanterr )	    PyErr_Clear();	return 0;    }    return 1;}/* Routine to easily insert integer into dictionary */static intjpegsetintattr(jpegobject *self, char *name, int value){    PyObject *obj;    int rv;    obj = PyInt_FromLong(value);    rv = PyDict_SetItemString(self->dict, name, obj);    Py_DECREF(obj);    return rv;}static jpegobject *newjpegobject(){	jpegobject *xp;	xp = PyObject_NEW(jpegobject, &Jpegtype);	if (xp == NULL)		return NULL;	xp->dict = PyDict_New();	xp->jpegfile = NULL;	xp->opened_jpegfile_ourselves = 0;	xp->fileobj = NULL;	xp->is_reader = -1;	return xp;}static intinitjpegreader(jpegobject *self, char *name, FILE *filep){    int w, h;            self->is_reader = 1;    /* Setup decompressor struct and override error handler */    self->dinfo.err = jpeg_std_error(&self->jerr);    self->dinfo.err->error_exit = imgjpeg_error_exit;    jpeg_create_decompress(&self->dinfo);        if ( setjmp(setjmp_buffer) ) {	/* An error occurred, message already set correctly  */	return 0;    }    /* Specify the source */    if (filep)    	self->jpegfile = filep;    else if ( (self->jpegfile = fopen(name, "rb")))    	self->opened_jpegfile_ourselves = 1;    else {	PyErr_SetFromErrno(PyExc_IOError);	return 0;    }    jpeg_stdio_src(&self->dinfo, self->jpegfile);        /* Read the header and store the info in the attributes */    jpeg_read_header(&self->dinfo, TRUE);        w = self->dinfo.image_width;    h = self->dinfo.image_height;    jpegsetintattr(self, "width", w);    jpegsetintattr(self, "height", h);    if ( self->dinfo.jpeg_color_space == JCS_GRAYSCALE ) {	PyDict_SetItemString(self->dict, "format", format_xgrey);	PyDict_SetItemString(self->dict, "format_choices", Py_BuildValue("(O)", format_xgrey));    } else {	PyDict_SetItemString(self->dict, "format", format_rgb);	PyDict_SetItemString(self->dict, "format_choices", Py_BuildValue("(OO)", format_rgb,			format_xgrey));    }    return 1;}static intinitjpegwriter(jpegobject *self, char *name, FILE *filep){            self->is_reader = 0;    /* Setup compressor struct and override error handler */    self->cinfo.err = jpeg_std_error(&self->jerr);    self->cinfo.err->error_exit = imgjpeg_error_exit;    jpeg_create_compress(&self->cinfo);        if ( setjmp(setjmp_buffer) ) {	/* An error occurred, message already set correctly  */	return 0;    }    /* Specify the source */    if ( filep )    	self->jpegfile = filep;    else {    	if ((self->jpegfile = fopen(name, "wb")))    	    self->opened_jpegfile_ourselves = 1;	else {	    PyErr_SetFromErrno(PyExc_IOError);	    return 0;    	}#ifdef macintosh        PyMac_setfiletype(name, '????', 'JPEG');#endif    }    jpeg_stdio_dest(&self->cinfo, self->jpegfile);        PyDict_SetItemString(self->dict, "format", format_rgb);    PyDict_SetItemString(self->dict, "format_choices",	       Py_BuildValue("(OO)", format_rgb, format_xgrey));    if( PyErr_Occurred())	return 0;    return 1;}/* Jpeg methods */static voidjpeg_dealloc(jpegobject *xp){	if ( xp->is_reader == 0 ) {		jpeg_destroy_compress(&xp->cinfo);	} else if ( xp->is_reader == 1 ) {		jpeg_destroy_decompress(&xp->dinfo);	}	Py_XDECREF(xp->dict);	Py_XDECREF(xp->fileobj);	xp->is_reader = -1;	if ( xp->jpegfile && xp->opened_jpegfile_ourselves) {		fclose(xp->jpegfile);		xp->jpegfile = NULL;	}	PyMem_DEL(xp);}static char doc_read[] = "Return the data read by this object";static PyObject *jpeg_read(jpegobject *self, PyObject *args){	PyObject *rv = NULL;	unsigned char *rowbuf = NULL;	unsigned long pixel, *pixelptr;	int busy = 0;	PyObject *fmt;	int wantgrey;	JSAMPROW row_pointer[1];	int w, h, i;		if (!PyArg_ParseTuple(args,""))		return NULL;	if (!self->is_reader) {	    PyErr_SetString(errobject, "Cannot read() from writer object");	    return NULL;	}	if ( !jpegselfattr(self, "format", "O", (void *) &fmt, 1) )	    return NULL;	wantgrey = fmt == format_xgrey;		if ( setjmp(setjmp_buffer) ) {		/* An error occurred, message already set correctly  */		goto out;	}		if ( wantgrey )		self->dinfo.out_color_space = JCS_GRAYSCALE;	else		self->dinfo.out_color_space = JCS_RGB;		jpeg_start_decompress(&self->dinfo);	busy = 1;	w = self->dinfo.output_width;	h = self->dinfo.output_height;		if ( wantgrey ) {		if ((rv = PyString_FromStringAndSize(NULL, w*h)) == NULL )			goto out;		row_pointer[0] = (unsigned char *)PyString_AsString(rv);		while ( self->dinfo.output_scanline < self->dinfo.output_height) {			(void) jpeg_read_scanlines(&self->dinfo, row_pointer, 1);			row_pointer[0] += w;		}	} else {		if ((rv = PyString_FromStringAndSize(NULL, w*h*4)) == NULL )			goto out;		if ((rowbuf = (unsigned char *) malloc(w*3)) == NULL ) {			PyErr_NoMemory();			goto out;		}		row_pointer[0] = rowbuf;		pixelptr = (unsigned long *)PyString_AsString(rv);		while ( self->dinfo.output_scanline < h) {			(void) jpeg_read_scanlines(&self->dinfo, row_pointer, 1);			for(i=0; i<w*3; i+= 3) {				pixel = rowbuf[i] | (rowbuf[i+1]<<8) | (rowbuf[i+2]<<16);				*pixelptr++ = pixel;			}		}		free(rowbuf);	}	jpeg_finish_decompress(&self->dinfo);			return rv;out:	if ( busy ) 		jpeg_abort_decompress(&self->dinfo);	if ( rowbuf )		free(rowbuf);	Py_XDECREF(rv);	return NULL;	}static char doc_write[] = "Write data to the JPEG file";static PyObject *jpeg_write(jpegobject *self, PyObject *args){	unsigned char *data;	int datalen;	unsigned char *rowbuf = NULL, *dataptr;	unsigned long pixel, *pixelptr;	int busy = 0;	PyObject *fmt;	int wantgrey;	JSAMPROW row_pointer[1];	int w, h, rowlen, size, i, quality, restart_interval;		if (!PyArg_ParseTuple(args, "s#", &data, &datalen))		return NULL;	if (self->is_reader) {		PyErr_SetString(errobject, "Cannot write() to reader object");		return NULL;	}	/* XXXX Get args from self->dict and interpret */	if ( !jpegselfattr(self, "width", "i", (void *) &w, 1) ||	     !jpegselfattr(self, "height", "i", (void *) &h, 1) ||	     !jpegselfattr(self, "format", "O", (void *) &fmt, 1) )		return NULL;	if ( fmt == format_rgb ) {		rowlen = w;		wantgrey = 0;		size = w*h*4;	} else if ( fmt == format_xgrey ){		rowlen = w;		wantgrey = 1;		size = rowlen*h;	} else {		PyErr_SetString(errobject, "Unsupported image format");		return NULL;	}	if( size != datalen ) {		PyErr_SetString(errobject, "Incorrect datasize");		return NULL;	}	if ( !wantgrey ) {		/* Allocate auxiliary buffer for 3-byte to 4-byte rgb conversion */		if ((rowbuf = (unsigned char *) malloc(w*3)) == NULL ) {			PyErr_NoMemory();			goto out;		}		row_pointer[0] = rowbuf;		pixelptr = (unsigned long *)data;	} else {		row_pointer[0] = data;	}		/* Setup compressor parameters */	if ( setjmp(setjmp_buffer) ) {		/* An error occurred */		goto out;	}	self->cinfo.image_width = w;	self->cinfo.image_height = h;	if ( wantgrey ) {		self->cinfo.input_components = 1;		self->cinfo.in_color_space = JCS_GRAYSCALE;	} else {		self->cinfo.input_components = 3;		self->cinfo.in_color_space = JCS_RGB;	}	jpeg_set_defaults(&self->cinfo);	quality = 0;	(void) jpegselfattr(self, "quality", "i", (void *) &quality, 0);	if (quality)		jpeg_set_quality(&self->cinfo, quality, 0);	restart_interval = 0;	jpegselfattr(self, "restart_interval", "i", (void *) &restart_interval, 0);	if (restart_interval)		self->cinfo.restart_interval = restart_interval;		jpeg_start_compress(&self->cinfo, TRUE);	busy = 1;	if ( wantgrey ) {		while (self->cinfo.next_scanline < h) {			(void) jpeg_write_scanlines(&self->cinfo, row_pointer, 1);			row_pointer[0] += w;		}	} else {		while (self->cinfo.next_scanline < h) {			/* Convert to 3-byte rgb */			dataptr = rowbuf;			for(i=0; i<w; i++) {				pixel = *pixelptr++;				*dataptr++ = (pixel & 0xff);				*dataptr++ = ((pixel>>8) & 0xff);				*dataptr++ = ((pixel>>16) & 0xff);			}			/* and write */			(void) jpeg_write_scanlines(&self->cinfo, row_pointer, 1);		}	}	jpeg_finish_compress(&self->cinfo);	Py_INCREF(Py_None);	return Py_None;out:	if ( busy ) 		jpeg_abort_compress(&self->cinfo);	if ( rowbuf )		free(rowbuf);	return NULL;}static char doc_copy[] = "Copy from JPEG reader";static PyObject *jpeg_copy(jpegobject *self, PyObject *args){	jpegobject *rdr;	PyObject *fmt;	jvirt_barray_ptr *src_coef_arrays, *dst_coef_arrays;	int quality, restart_interval;	if (!PyArg_ParseTuple(args, "O!", &Jpegtype, (PyObject *) &rdr))		return NULL;	if (!rdr->is_reader) {		PyErr_SetString(errobject, "Argument must be JPEG reader");		return NULL;	}	if (self->is_reader) {		PyErr_SetString(errobject, "Object must be JPEG writer");		return NULL;	}	if (!jpegselfattr(self, "format", "O", (void *) &fmt, 1))		return NULL;	src_coef_arrays = jpeg_read_coefficients(&rdr->dinfo);	jpeg_copy_critical_parameters(&rdr->dinfo, &self->cinfo);	dst_coef_arrays = src_coef_arrays;	quality = 0;	(void) jpegselfattr(self, "quality", "i", (void *) &quality, 0);	if (quality)		jpeg_set_quality(&self->cinfo, quality, 0);	restart_interval = 0;	jpegselfattr(self, "restart_interval", "i", (void *) &restart_interval, 0);	if (restart_interval)		self->cinfo.restart_interval = restart_interval;	jpeg_write_coefficients(&self->cinfo, dst_coef_arrays);	jpeg_finish_compress(&self->cinfo);	Py_INCREF(Py_None);	return Py_None;}static struct PyMethodDef jpeg_methods[] = {	{"read",	(PyCFunction)jpeg_read,		1,	doc_read},	{"write",	(PyCFunction)jpeg_write,	1,	doc_write},	{"copy",	(PyCFunction)jpeg_copy,		1,	doc_copy},	{NULL,		NULL}		/* sentinel */};static PyObject *jpeg_getattr(jpegobject *xp, char *name){        PyObject *v;		if (xp->dict != NULL) {	        if ( strcmp(name, "__dict__") == 0 ) {		        Py_INCREF(xp->dict);			return xp->dict;		}       		if ( strcmp(name, "__doc__") == 0 ) {		        return PyString_FromString(doc_jpeg);		}		v = PyDict_GetItemString(xp->dict, name);		if (v != NULL) {			Py_INCREF(v);			return v;		}	}	return Py_FindMethod(jpeg_methods, (PyObject *)xp, name);}static intjpeg_setattr(jpegobject *xp, char *name, PyObject *v){	if (xp->dict == NULL) {		xp->dict = PyDict_New();		if (xp->dict == NULL)			return -1;	}	if (v == NULL) {		int rv = PyDict_DelItemString(xp->dict, name);		if (rv < 0)			PyErr_SetString(PyExc_AttributeError,			        "delete non-existing imgjpeg attribute");		return rv;	}	else		return PyDict_SetItemString(xp->dict, name, v);}static PyTypeObject Jpegtype = {	PyObject_HEAD_INIT(&PyType_Type)	0,			/*ob_size*/	"imgjpeg",		/*tp_name*/	sizeof(jpegobject),	/*tp_basicsize*/	0,			/*tp_itemsize*/	/* methods */	(destructor)jpeg_dealloc, /*tp_dealloc*/	0,			/*tp_print*/	(getattrfunc)jpeg_getattr, /*tp_getattr*/	(setattrfunc)jpeg_setattr, /*tp_setattr*/	0,			/*tp_compare*/	0,			/*tp_repr*/	0,			/*tp_as_number*/	0,			/*tp_as_sequence*/	0,			/*tp_as_mapping*/	0,			/*tp_hash*/};static char doc_newreader[] = "Return an object that reads a JPEG file.\n"	"Note that the actual data is read upon creation of the object.";static PyObject *jpeg_newreader(PyObject *self, PyObject *args){        char *filename;	jpegobject *obj;	PyObject *fileobj = NULL;	FILE *fp = NULL;	if (!PyArg_ParseTuple(args, "s", &filename)) {	    PyErr_Clear();	    if (!PyArg_ParseTuple(args, "O!", &PyFile_Type, &fileobj))	        return NULL;	    fp = PyFile_AsFile(fileobj);	    filename = "<open file>";	}		if ((obj = newjpegobject()) == NULL)	    return NULL;	if ( !initjpegreader(obj, filename, fp) ) {	    Py_DECREF(obj);	    return NULL;	}	if (fileobj) {		Py_INCREF(fileobj);		obj->fileobj = fileobj;	}	return (PyObject *)obj;}static char doc_newwriter[] =	"Return an object that creates the JPEG file passed as argument";static PyObject *jpeg_newwriter(PyObject *self, PyObject *args){        char *filename;	jpegobject *obj;	PyObject *fileobj = NULL;	FILE *fp = NULL;		if (!PyArg_ParseTuple(args, "s", &filename)) {	    PyErr_Clear();	    if (!PyArg_ParseTuple(args, "O!", &PyFile_Type, &fileobj))	        return NULL;	    fp = PyFile_AsFile(fileobj);	    filename = "<open file>";	}		if ((obj = newjpegobject()) == NULL)	    return NULL;	if ( !initjpegwriter(obj, filename, fp) ) {	    Py_DECREF(obj);	    return NULL;	}	Py_XINCREF(fileobj);	obj->fileobj = fileobj;	return (PyObject *)obj;}/* List of functions defined in the module */static struct PyMethodDef jpeg_module_methods[] = {	{"reader",	jpeg_newreader,	1,	doc_newreader},	{"writer",	jpeg_newwriter,	1,	doc_newwriter},	{NULL,		NULL}		/* sentinel */};/* Initialization function for the module (*must* be called initimgjpeg) */static char doc_imgjpeg[] =  "Module that reads and writes JPEG image files";#ifdef __cplusplusextern "C"#endif#ifdef _WINDOWS__declspec(dllexport)#endifvoidinitimgjpeg(){	PyObject *m, *d, *x, *formatmodule, *formatdict;	/* Create the module and add the functions */	m = Py_InitModule("imgjpeg", jpeg_module_methods);	/* Add some symbolic constants to the module */	d = PyModule_GetDict(m);	x = PyString_FromString(doc_imgjpeg);	PyDict_SetItemString(d, "__doc__", x);	/* Get supported formats */	if ((formatmodule = PyImport_ImportModule("imgformat")) == NULL)	    Py_FatalError("imgjpeg depends on imgformat");	if ((formatdict = PyModule_GetDict(formatmodule)) == NULL)	    Py_FatalError("imgformat has no dict");	errobject = PyDict_GetItemString(formatdict,"error");	format_rgb = PyDict_GetItemString(formatdict,"rgb");	format_xgrey = PyDict_GetItemString(formatdict, "xgrey");	/* Check for errors */	if (PyErr_Occurred())		Py_FatalError("can't initialize module imgjpeg");}