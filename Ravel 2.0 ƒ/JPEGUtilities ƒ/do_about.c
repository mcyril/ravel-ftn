#include <QDOffscreen.h>#include <string.h>#include <stdio.h>//#include "Ravel_FTN.h"#include "ravel_msg_base.h"#include "Ravel_Prefs.h"//#include "Preferences.h"#include "do_about.h"#include "JPEGUtilities.h"#include "key.h"static	long		slicer;static	Rect		scrRect,					ofsRect,					txtRect;static	GWorldPtr	gMyOffG,					sMyOffG,					tMyOffG;static	Handle		showTextHandle;static	char		*showTextPtr;static	FontInfo	fInfo;static	short		hgt, secondslicer;static	short		gOptions;enum {	uppModalProcInfo = kPascalStackBased		 | RESULT_SIZE(SIZE_CODE(sizeof(Boolean)))		 | STACK_ROUTINE_PARAMETER(1, SIZE_CODE(sizeof(Ptr)))		 | STACK_ROUTINE_PARAMETER(2, SIZE_CODE(sizeof(Ptr)))		 | STACK_ROUTINE_PARAMETER(3, SIZE_CODE(sizeof(Ptr)))};static pascal Boolean MyScroller ( DialogPtr theDialog, EventRecord *theEvent, short *itemHit ){	Boolean 	result = false;	CGrafPtr	currPort;	GDHandle	currDev;	RgnHandle	updateRgn;	char		temp[128];	unsigned long		resvd;			SetPort (theDialog);		switch (theEvent->what)	{	case mouseDown:				*itemHit = 1;		result = true;		break;		case keyDown:	case autoKey:			*itemHit = 1;		result = true;		break;			case updateEvt:			if (!slicer)		{			slicer++;			MoveTo (340, 25);#ifndef LITE			DrawString ("\pVer. " RAVELVERS " " RAVELISA);#else			DrawString ("\pVer. " RAVELVERS);#endif			if (gOptions & optionKey)			{				MoveTo (340, 35);#ifndef LITE				if (gOptions & controlKey)				{#ifdef PROTECTED					sprintf (&temp[1], "[%.8lX-%.4X]", keys.oldcrc, keys.oldcs);#else					sprintf (&temp[1], "[00000000-0000]");#endif					temp[0] = strlen (&temp[1]);					DrawString ((StringPtr) temp);				}				else#endif					DrawString ("\p[" __DATE__ "]");			}			secondslicer = hgt;		}		else		{			slicer++;						if (slicer > 600)			{				slicer = 601;								GetGWorld ( &currPort, &currDev );				if (!(secondslicer--))				{					SetGWorld ( tMyOffG, nil );										SetPort ( (GrafPtr) tMyOffG );					MoveTo (txtRect.left, txtRect.bottom - fInfo.descent - fInfo.leading);					//					p = txt;					while (*showTextPtr && *showTextPtr != 0x0D)					{						if (*showTextPtr == '±')						{							switch (*(showTextPtr+1))							{							case 'b':	TextFace (bold);		break;							case 'u':	TextFace (underline);	break;							case 'i':	TextFace (italic);		break;							case 'p':	TextFace (0);			break;							}														showTextPtr++;						}						else						{//							*p = *showTextPtr;//							p++;													DrawChar (*showTextPtr);						}												showTextPtr++;					}//					*p = 0;					if (*showTextPtr)						showTextPtr++;					else					{						slicer = 0;						showTextPtr = *showTextHandle;					}					//					DrawText (txt, 0, strlen (txt));										SetGWorld (currPort, currDev);									secondslicer = hgt;				}								SetPort ( (GrafPtr) gMyOffG );				CopyBits ( (BitMap *) (*(sMyOffG->portPixMap)), (BitMap *) (*(gMyOffG->portPixMap)),									&ofsRect, &ofsRect, srcCopy, nil);				CopyBits ( (BitMap *) (*(tMyOffG->portPixMap)), (BitMap *) (*(gMyOffG->portPixMap)),									&ofsRect, &ofsRect, srcOr, nil);				SetPort ( (GrafPtr) theDialog );								Delay (1, &resvd);				CopyBits ( (BitMap *) (*(gMyOffG->portPixMap)), &((GrafPtr)theDialog)->portBits,									&ofsRect, &scrRect, srcCopy, nil);				SetGWorld ( tMyOffG, nil );				SetPort ( (GrafPtr) tMyOffG );								ScrollRect (&txtRect, 0, -1, updateRgn = NewRgn());				DisposeRgn (updateRgn);								SetGWorld (currPort, currDev);			}			else				Delay (1, &resvd);		}				result = true;		break;	}	return result;}void do_splash (DialogPtr *doom){//	OSErr			myErr;//	long			lgFeature;//	Handle			h;//	PicHandle		PictHandle;	CIconHandle		aCIcon;	Rect			iRect;/*	myErr = Gestalt (gestaltQuickTimeVersion, &lgFeature);	if ((myErr != noErr) || (lgFeature < 0x0200) || (*((short *) 0x0D60) == 1))*/	if (*((short *) 0x0D60) == 1)		*doom = GetNewDialog ( 201, NULL, (WindowPtr) -1L );	else		*doom = GetNewDialog ( 2000, NULL, (WindowPtr) -1L );		SetPort (*doom);	DrawDialog (*doom);	aCIcon = GetCIcon (#if defined(powerc) || defined(__powerc)		257#else		256#endif	);		SetRect (&iRect,	(*doom)->portRect.left + 10,						(*doom)->portRect.bottom - 42,						(*doom)->portRect.left + 42,						(*doom)->portRect.bottom - 10);							PlotCIcon (&iRect, aCIcon);/*	if ((myErr == noErr) && (lgFeature >= 0x0200) && (*((short *) 0x0D60) != 1))	{		h = Get1Resource ('JPEG', 2000);				if (h)		{			PictHandle = WrapJPEG (h);						if (PictHandle)			{				DrawPicture (PictHandle, &((*doom)->portRect));				DisposeHandle ((Handle)PictHandle);			}			//			DrawJPEG (h, &((*doom)->portRect), &((*doom)->portRect), srcCopy);			ReleaseResource (h);		}	}*/}void do_about (short options){	DialogPtr		doom;	GrafPtr			oldGraf;	CGrafPtr		currPort;	GDHandle		currDev;	short			i;#if defined(powerc) || defined(__powerc)	UniversalProcPtr	uupMyProc;	uupMyProc = NewRoutineDescriptor ((ProcPtr) MyScroller, uppModalProcInfo, GetCurrentISA ());#endif	gOptions = options;	GetPort ( &oldGraf );	do_splash (&doom);	ForeColor(blackColor);	TextFont (4);	TextSize (9);	TextFace (bold);	GetFontInfo (&fInfo);	hgt = fInfo.ascent + fInfo.descent + fInfo.leading;		GetGWorld ( &currPort, &currDev );	SetRect (&scrRect, 240, 10, 485, 310);	SetRect (&ofsRect, 0, 0, scrRect.right-scrRect.left, scrRect.bottom-scrRect.top);	txtRect = ofsRect;	txtRect.bottom += hgt;	//	¥	MIXER	WORLD	NewGWorld ( &gMyOffG, (*((short *) 0x0D60) == 1)? 1 : 8, &ofsRect, nil, nil, 0 );	SetGWorld ( gMyOffG, nil );	SetPort ( (GrafPtr) gMyOffG );	ForeColor(blackColor);	TextFont (4);	TextSize (9);	TextFace (0);	EraseRect (&ofsRect);//	¥	TEXT	WORLD	NewGWorld ( &tMyOffG, 1, &txtRect, nil, nil, 0 );	SetGWorld ( tMyOffG, nil );	SetPort ( (GrafPtr) tMyOffG );	ForeColor(blackColor);	TextFont (4);	TextSize (9);	TextFace (0);	EraseRect (&txtRect);//	¥	SAVED	WORLD	NewGWorld ( &sMyOffG, (*((short *) 0x0D60) == 1)? 1 : 8, &ofsRect, nil, nil, 0 );	SetGWorld ( sMyOffG, nil );	SetPort ( (GrafPtr) sMyOffG );	ForeColor(blackColor);	TextFont (4);	TextSize (9);	TextFace (0);	CopyBits ( &((GrafPtr)doom)->portBits, (BitMap *) (*(sMyOffG->portPixMap)),						&scrRect, &ofsRect, srcCopy, nil);	SetGWorld (currPort, currDev);	SetPort (doom);	showTextHandle = Get1Resource ('TEXT', 128);	HLock (showTextHandle);	showTextPtr = *showTextHandle;	slicer = 0;		do {#if defined(powerc) || defined(__powerc)			ModalDialog (uupMyProc, &i);#else			ModalDialog (MyScroller, &i);#endif	} while ( i != 1 );	SetPort ( oldGraf );	DisposeDialog ( doom );	ReleaseResource (showTextHandle);	DisposeGWorld (gMyOffG);	DisposeGWorld (sMyOffG);	DisposeGWorld (tMyOffG);#if defined(powerc) || defined(__powerc)	DisposeRoutineDescriptor (uupMyProc);#endif}