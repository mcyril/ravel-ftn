#include <Sound.h>#include <stdio.h>#include <string.h>#include <ctype.h>#include "PascalStr.h"#define h_uuenc(c)         (((c) & 0x3f) + '!')#define h_uudec(c)         (((c) - '!') & 0x3f)static unsigned short	r;			// R-factor for encryption/decription									// r = 55665;typedef struct _addr {	short		zone, net, node, point;	} addr; /*********************************************************** *															* *	Get Adobe's encoded byte and decode it by Adobe 		* *					encryption algorythm					* *															* ***********************************************************/static unsigned char DeCoding ( unsigned char code ){	unsigned char			newCode;		newCode = ( code ^ ( r >> 8 ) );		r = ( code + r ) * 52845 + 22719;		return newCode;} /* End of CodingEnc */	 /*********************************************************** *															* *	Get byte and endecode it by Adobe's algorythm			* *															* ***********************************************************/static unsigned char EnCoding ( unsigned char code ){	unsigned char			newCode;		newCode = ( code ^ ( r >> 8 ) );		r = ( newCode + r ) * 52845 + 22719;		return newCode;} /* End of EnCodingEnc */	static short parseaddr (addr *f, char *s){	short	a,b=0,c=0,r;			do {				if ( sscanf ( s+b, "%d", &a ) !=1 )			break;		for ( ; isdigit (s[b]); b++ );				if ( s[b] == ':' )			f->zone=a;		else			if ( s[b] == '/' )				f->net=a;			else				if ( s[b] == '.' )				{					f->node=a;					c=1;				}				else					if ( s[b] == '@' || s[b] <= ' ' )					{						if ( c==1 )							f->point=a;						else							f->node=a;						break;					}		b++;		} while(1);		r=b;		if( s[b] == '@' )	{		for ( a = b+1; s[a] > ' '; a++ );			r=a;	}		return r;}void main (void){	DialogPtr	myDlg;	short		dItem, i, j, k;	long		rc, scrapOffset;		unsigned long	crc;		Rect		iRect;	Handle		iHandle;	short		iType, cs;		Str255		keyStr, keyName, keyAddress;	Str255		temp;	addr		keyAddr;		char		keyBin[129], *p, *q;			InitGraf((Ptr) &qd.thePort);	InitFonts();	InitWindows();	InitDialogs(nil);	InitCursor();		MaxApplZone ();		myDlg = GetNewDialog ( 128, NULL, (WindowPtr) -1L );	DrawDialog ( myDlg );	do {			ModalDialog ( NULL, &dItem );		switch (dItem)		{		case 1:			//	register?//			GetDItem ( myDlg, 4, &iType, &iHandle, &iRect);//			GetIText ( iHandle, keyStr );//			if (keyStr[0] != 96)//			{//				SysBeep (10);//				dItem = 0;//				break;//			}			GetDialogItem ( myDlg, 5, &iType, &iHandle, &iRect);			GetDialogItemText ( iHandle, keyName );			if (!keyName[0] || keyName[0] < 5 || keyName[0] > 36)			{				SysBeep (10);				dItem = 0;				break;			}						GetDialogItem ( myDlg, 6, &iType, &iHandle, &iRect);			GetDialogItemText ( iHandle, keyAddress );			if (!keyAddress[0])			{				SysBeep (10);				dItem = 0;				break;			}			else			{				keyAddress[keyAddress[0]+1] = 0;								keyAddr.zone = keyAddr.net = keyAddr.node = keyAddr.point = 0;				parseaddr (&keyAddr, (char *) &keyAddress[1]);				if (!(keyAddr.zone && keyAddr.net && keyAddr.node))				{					SysBeep (10);					dItem = 0;					break;				}			}						crc = 0L;			for (i=1; i<=keyName[0]; i++)			{				crc += keyName[i] * 678L;				crc = (crc << 3) | (crc >> 29);			}						crc +=	(((unsigned long)(keyAddr.zone & 0xFF))) |					(((unsigned long)(keyAddr.net & 0xFF)) << 8) |					(((unsigned long)(keyAddr.node & 0xFF)) << 16) |					(((unsigned long)(keyAddr.point & 0xFF)) << 24);						for (i=1; i<=96; i++)				keyStr[i] = Random () & 0xFF;						pStrCopy ( "\pRavel #", keyStr );		//	7			temp[0] = 4;			temp[1] = (crc >> 24) & 0xFF;			temp[2] = (crc >> 16) & 0xFF;			temp[3] = (crc >> 8) & 0xFF;			temp[4] = crc & 0xFF;						pStrConc (keyStr, temp, keyStr);			pStrConc (keyStr, "\p:", keyStr);			pStrConc (keyStr, keyName, keyStr);			keyStr[keyStr[0]+1] = 0;						cs = i = ~((crc&0xFFFF) ^ (crc / 359));						keyStr[keyStr[0]+2] = i >> 8;			keyStr[keyStr[0]+3] = i & 0xFF;			keyStr[keyStr[0]+4] = 0;				//	address				keyStr[keyStr[0]+5] = keyAddr.zone >> 8;			keyStr[keyStr[0]+6] = keyAddr.zone & 0xFF;						keyStr[keyStr[0]+7] = keyAddr.net >> 8;			keyStr[keyStr[0]+8] = keyAddr.net & 0xFF;						keyStr[keyStr[0]+9] = keyAddr.node >> 8;			keyStr[keyStr[0]+10] = keyAddr.node & 0xFF;						keyStr[keyStr[0]+11] = keyAddr.point >> 8;			keyStr[keyStr[0]+12] = keyAddr.point & 0xFF;						r = keyAddr.zone + keyAddr.net + keyAddr.node + keyAddr.point;			for (i=1; i<=96; i++)				keyStr[i] = EnCoding (keyStr[i]);						q = keyBin+1;			p = (char *) &keyStr[1];			for (k = 96 ; k >= 3; p += 3, k -= 3)			{				*q++ = h_uuenc(p[0] >> 2);				*q++ = h_uuenc(((p[0] << 4) & 0x30) | ((p[1] >> 4) & 0x0f));				*q++ = h_uuenc(((p[1] << 2) & 0x3c) | ((p[2] >> 6) & 0x03));				*q++ = h_uuenc(p[2] & 0x3f);			}						keyBin[0] = 128;			GetDialogItem ( myDlg, 4, &iType, &iHandle, &iRect);			SetDialogItemText ( iHandle, (StringPtr) keyBin );						ZeroScrap ();						pStrCopy ( keyName, keyStr );			pStrConc ( keyStr, "\p, ", keyStr );			pStrConc ( keyStr, keyAddress, keyStr );						sprintf ( (char *) &temp[1], " (%lX-%X)\xD", crc, cs );			temp[0] = strlen ((char *) &temp[1]);			pStrConc ( keyStr, temp, keyStr );			pStrConc ( keyStr, "\p\xD", keyStr );			temp[0] = 32;			BlockMove ( &keyBin[32*0+1], &temp[1], 32 );			pStrConc ( keyStr, temp, keyStr );			pStrConc ( keyStr, "\p\xD", keyStr );						BlockMove ( &keyBin[32*1+1], &temp[1], 32 );			pStrConc ( keyStr, temp, keyStr );			pStrConc ( keyStr, "\p\xD", keyStr );									BlockMove ( &keyBin[32*2+1], &temp[1], 32 );			pStrConc ( keyStr, temp, keyStr );			pStrConc ( keyStr, "\p\xD", keyStr );			BlockMove ( &keyBin[32*3+1], &temp[1], 32 );			pStrConc ( keyStr, temp, keyStr );			pStrConc ( keyStr, "\p\xD", keyStr );						PutScrap ( keyStr[0], 'TEXT', &keyStr[1] );			dItem = 0;						break;					case 2:			//	cancel					break;					case 3:			//	get from scrap								break;		}	} while ( dItem != 1 && dItem != 2 );/*	if ( dItem == 1 )	{			// Try to generate KeyÉ                    for ( ; len >= 3; in += 3, len -= 3) {                        *out++ = h_uuenc(in[0] >> 2);                        *out++ = h_uuenc(((in[0] << 4) & 0x30) | ((in[1] >> 4) & 0x0f));                        *out++ = h_uuenc(((in[1] << 2) & 0x3c) | ((in[2] >> 6) & 0x03));                        *out++ = h_uuenc(in[2] & 0x3f);                    }                    if (len > 0) {                       *out++ = h_uuenc(in[0] >> 2);                       *out++ = h_uuenc(((in[0] << 4) & 0x30) | ((in[1] >> 4) & 0x0f));                       if (len == 2)                          *out++ = h_uuenc((in[1] << 2) & 0x3c);		q = keyBin;		p = (char *) &keyStr[1];				for (i = 0; i < 128; i += 4, p += 4)		{			*q++ = (char) ((h_uudec(p[0]) << 2) | (h_uudec(p[1]) >> 4));			*q++ = (char) ((h_uudec(p[1]) << 4) | (h_uudec(p[2]) >> 2));			*q++ = (char) ((h_uudec(p[2]) << 6) | h_uudec(p[3]));		}	}*/exit:	DisposeDialog ( myDlg );}