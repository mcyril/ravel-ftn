#include <stdio.h>#include <string.h>#include <ctype.h>#include "PascalStr.h"#define h_uuenc(c)         (((c) & 0x3f) + '!')#define h_uudec(c)         (((c) - '!') & 0x3f)static unsigned short	r;			// R-factor for encryption/decription									// r = 55665;typedef struct _addr {	short		zone, net, node, point;	} addr; /*********************************************************** *															* *	Get Adobe's encoded byte and decode it by Adobe 		* *					encryption algorythm					* *															* ***********************************************************/static unsigned char DeCoding ( unsigned char code ){	unsigned char			newCode;		newCode = ( code ^ ( r >> 8 ) );		r = ( code + r ) * 52845 + 22719;		return newCode;} /* End of CodingEnc */	static short parseaddr (addr *f, char *s){	short	a,b=0,c=0,r;			do {				if ( sscanf ( s+b, "%d", &a ) !=1 )			break;		for ( ; isdigit (s[b]); b++ );				if ( s[b] == ':' )			f->zone=a;		else			if ( s[b] == '/' )				f->net=a;			else				if ( s[b] == '.' )				{					f->node=a;					c=1;				}				else					if ( s[b] == '@' || s[b] <= ' ' )					{						if ( c==1 )							f->point=a;						else							f->node=a;						break;					}		b++;		} while(1);		r=b;		if( s[b] == '@' )	{		for ( a = b+1; s[a] > ' '; a++ );			r=a;	}		return r;}void main (void){	DialogPtr	myDlg;	short		dItem, i, j, k;	Handle		keyHandle;	long		rc, scrapOffset;		Rect		iRect;	Handle		iHandle;	short		iType;		Str255		keyStr, keyName, keyAddress;	Str255		oldName;	addr		keyAddr;		unsigned long	oldcrc, crc;	short			oldcs, cs;		unsigned char		keyBin[96], *p, *q;			InitGraf((Ptr) &qd.thePort);	InitFonts();	InitWindows();	InitDialogs(nil);	InitCursor();		MaxApplZone ();		keyHandle = NewHandle( 0 );		/* allocate 0-length data area */	myDlg = GetNewDialog ( 128, NULL, (WindowPtr) -1L );	DrawDialog ( myDlg );	do {			ModalDialog ( NULL, &dItem );		switch (dItem)		{		case 1:			//	register?			GetDItem ( myDlg, 4, &iType, &iHandle, &iRect);			GetIText ( iHandle, keyStr );			if (keyStr[0] < 128 || keyStr[0] > 200)			{				SysBeep (10);				dItem = 0;				break;			}			else			{							k = keyStr[0];				keyStr[0] = 0;				for (i = 1, j = 1; i <= k; i++)					if (keyStr[i] >= 33 && keyStr[i] <= 96)					{						keyStr[j++] = keyStr[i];						keyStr[0]++;					}								if (keyStr[0] != 128)				{					SysBeep (10);					dItem = 0;					break;				}			}			GetDItem ( myDlg, 5, &iType, &iHandle, &iRect);			GetIText ( iHandle, keyName );			if (!keyName[0])			{				SysBeep (10);				dItem = 0;				break;			}						GetDItem ( myDlg, 6, &iType, &iHandle, &iRect);			GetIText ( iHandle, keyAddress );			if (!keyAddress[0])			{				SysBeep (10);				dItem = 0;				break;			}			else			{				keyAddress[keyAddress[0]+1] = 0;								keyAddr.zone = keyAddr.net = keyAddr.node = keyAddr.point = 0;				parseaddr (&keyAddr, (char *) &keyAddress[1]);				if (!(keyAddr.zone && keyAddr.net && keyAddr.node))				{					SysBeep (10);					dItem = 0;					break;				}			}						break;					case 2:			//	cancel					break;					case 3:			//	get from scrap					rc = GetScrap ( keyHandle, 'TEXT', &scrapOffset );			if ( rc >= 128 && rc <= 200)			{				BlockMove ( *keyHandle, &keyStr[1], rc );				keyStr[0] = rc;				GetDItem ( myDlg, 4, &iType, &iHandle, &iRect);				SetIText ( iHandle, keyStr );			}						break;		}	} while ( dItem != 1 && dItem != 2 );		if ( dItem == 1 )	{			// Try to generate KeyÉ/*                    for ( ; len >= 3; in += 3, len -= 3) {                        *out++ = h_uuenc(in[0] >> 2);                        *out++ = h_uuenc(((in[0] << 4) & 0x30) | ((in[1] >> 4) & 0x0f));                        *out++ = h_uuenc(((in[1] << 2) & 0x3c) | ((in[2] >> 6) & 0x03));                        *out++ = h_uuenc(in[2] & 0x3f);                    }                    if (len > 0) {                       *out++ = h_uuenc(in[0] >> 2);                       *out++ = h_uuenc(((in[0] << 4) & 0x30) | ((in[1] >> 4) & 0x0f));                       if (len == 2)                          *out++ = h_uuenc((in[1] << 2) & 0x3c);*/		q = keyBin;		p = &keyStr[1];				for (i = 0; i < 128; i += 4, p += 4)		{			*q++ = (char) ((h_uudec(p[0]) << 2) | (h_uudec(p[1]) >> 4));			*q++ = (char) ((h_uudec(p[1]) << 4) | (h_uudec(p[2]) >> 2));			*q++ = (char) ((h_uudec(p[2]) << 6) | h_uudec(p[3]));		}				r = keyAddr.zone + keyAddr.net + keyAddr.node + keyAddr.point;		for (i=0; i<96; i++)			keyBin[i] = DeCoding (keyBin[i]);				crc = 0L;		for (i=1; i<=keyName[0]; i++)		{			crc += keyName[i] * 666;			crc = (crc << 3) | (crc >> 29);		}				crc +=	((keyAddr.zone & 0xFF)) |				((keyAddr.net & 0xFF) << 8) |				((keyAddr.node & 0xFF) << 16) |				((keyAddr.point & 0xFF) << 24);		cs = ((crc&0xFFFF) ^ (crc / 359));				oldcrc  = (unsigned long) keyBin[10];		oldcrc |= (unsigned long) keyBin[9] << 8;		oldcrc |= (unsigned long) keyBin[8] << 16;		oldcrc |= (unsigned long) keyBin[7] << 24;				strcpy ( (char *) &oldName[1], (char *) &keyBin[12] );			oldName[0] = strlen ((char *) &oldName[1]);				oldcs = (keyBin[12+oldName[0]+1] << 8) | keyBin[12+oldName[0]+2];				if (crc != oldcrc)			SysBeep (10);		if (oldcs+1+cs)		{			SysBeep (10);			SysBeep (10);		}				if (pStrComp (oldName, keyName))		{			SysBeep (10);			SysBeep (10);			SysBeep (10);		}	}exit:	DisposDialog ( myDlg );}