#include <string.h>DialogPtr		dlg;ListHandle		lst;Rect			ListGlobe;short			semaphore;static void InitToolbox(){	MaxApplZone ();	MoreMasters ();	MoreMasters ();	MoreMasters ();	MoreMasters ();	InitGraf ((Ptr) &qd.thePort);	InitFonts ();	InitWindows ();	InitMenus ();	FlushEvents (everyEvent,0);	InitDialogs (0L);	InitCursor ();}static pascal Boolean ModalFilterProc ( DialogPtr theDialog, EventRecord *theEvent, short *itemHit ){	Boolean 	result = false;	Point		localWhere = theEvent->where;	GrafPtr		savePort;	short		initem, part;	WindowPtr	window;		switch (theEvent->what)	{	case mouseDown:			switch ( part = FindWindow (theEvent->where, &window) )		{		case inContent:					if (window == FrontWindow())			{				GetPort (&savePort);				SetPort (theDialog);				GlobalToLocal (&localWhere);								initem = FindDialogItem (theDialog, localWhere) + 1;								if (initem == 3)				{					if ( PtInRect (localWhere, &ListGlobe) )					{						semaphore = true;					}					else					{						semaphore = false;					}					LClick ( localWhere, theEvent->modifiers, lst );					result = true;					*itemHit = 3;				}								SetPort (savePort);			}						break;		}				break;	}	return result;}#define	cLeftOffset	2static pascal void myldef (short lMessage, Boolean lSelect, Rect *lRect, Cell lCell,				short lDataOffset, short lDataLen, ListHandle lHandle){	short 		leftDraw, topDraw, k, locked;	FontInfo 	fi;	long		i;	Str255		title, temp;	Point		drawpt;	char		tmp[128];				if ((lMessage == lInitMsg) || (lMessage == lCloseMsg))		return;		leftDraw = lRect->left+(*lHandle)->indent.h;	topDraw = lRect->top+(*lHandle)->indent.v;		switch (lMessage)	{	case lDrawMsg:			SetPort ((*lHandle)->port);		EraseRect (lRect);			if (lDataLen != 0)		{			GetFontInfo (&fi);			SetPt ( &drawpt, leftDraw+cLeftOffset, topDraw+fi.leading+fi.ascent );			memcpy ( tmp, *((*lHandle)->cells)+lDataOffset, lDataLen );						if (tmp[0])			{				MoveTo ( drawpt.h, drawpt.v );				DrawChar ( 'Ã' );			}			MoveTo ( drawpt.h + 6*2 + 2, drawpt.v + 2 );			LineTo ( drawpt.h + 6*2 + 2, topDraw );			MoveTo ( drawpt.h + 6*3 + 2, drawpt.v );			DrawText ( tmp, 1, lDataLen - 1 );		}				if (!lSelect)			break;			case lHiliteMsg:			BitClr ( (Ptr) 0x0938, pHiliteBit);		InvertRect (lRect);		break;	}}static pascal void myLClick (void){	static	short	trgr = 0xAAAA;	if ( PtInRect ((*lst)->mouseLoc, &ListGlobe) )	{//		SysBeep (10);		semaphore = true;	}	else	{		semaphore = false;	}	trgr = ~trgr;}void main (void){	short		iType;	Handle		iHandle;	Rect		iRect, rDataBnds;	short		iHit, dummy, i;	Point		cellSize, theCell;	Str31		temp;	OSType		rType;	short		rID, ii;		InitToolbox ();	iHandle = Get1Resource ( 'LDEF', 1111 );	*((long *)((*iHandle)+2)) = (long) myldef;		dlg = GetNewDialog (1111, NULL, (WindowPtr) -1L);	SetPort (dlg);	GetDItem ( dlg, 3, &iType, &iHandle, &iRect );	SetRect ( &rDataBnds, 0, 0, 1, 0 );	iRect.right -= 15;	SetPt ( &cellSize, 0, 0 );	lst = LNew ( &iRect, &rDataBnds, cellSize, 1111, dlg, true, false, false, true );	ListGlobe = iRect;	ListGlobe.left += 1;	ListGlobe.right = ListGlobe.left + 15;	InsetRect (&iRect, -1, -1);	FrameRect (&iRect);		(*lst)->selFlags = 0x82;//	(*lst)->lClickLoop = myLClick;		iHit = CountResources ('FOND');		for (i = 1; i <= iHit; i++)	{//		NumToString (i, temp);		dummy = LAddRow ( 1, 0x7FFF, lst );		SetPt ( &theCell, 0, dummy );		SetResLoad (false);		iHandle = GetIndResource ('FOND',i);		GetResInfo (iHandle, &rID, &rType, temp);		SetResLoad (true);		iType = temp[0];		temp[0] = 0;		LSetCell ( temp, iType + 1, theCell, lst );		}		semaphore = false;	do {			ModalDialog (ModalFilterProc, &iHit);				switch (iHit)		{		case 3:					if (semaphore)			{				theCell = LLastClick (lst);								iType = 31;				LGetCell ( temp, &iType, theCell, lst);								temp[0] = 1 - temp[0];				LSetCell ( temp, iType, theCell, lst );				LRect( &iRect, theCell, lst );				InvalRect( &iRect );				LUpdate( (*lst)->port->visRgn , lst );				semaphore = false;			}						break;				case 4:					for (ii = 0; ii < (*lst)->dataBounds.bottom; ii++)			{				SetPt (&theCell, 0, ii);								iType = 31;				LGetCell ( temp, &iType, theCell, lst);								temp[0] = 1;				LSetCell ( temp, iType, theCell, lst );			}							LUpdate( (*lst)->port->visRgn , lst );			break;				case 5:				for (ii = 0; ii < (*lst)->dataBounds.bottom; ii++)			{				SetPt (&theCell, 0, ii);								iType = 31;				LGetCell ( temp, &iType, theCell, lst);								temp[0] = 0;				LSetCell ( temp, iType, theCell, lst );			}							LUpdate( (*lst)->port->visRgn , lst );			break;		}			} while (iHit != 1);	DisposDialog (dlg);}