#include <string.h>#include <Icons.h>DialogPtr		dlg;ListHandle		lst;Rect			clickable;short			semaphore, sweep;short			wasmove;CIconHandle		triangle[3];typedef struct _one_hier_item {	struct _one_hier_item	*next;	struct _one_hier_item	*nested;	short		owner;	short		opened;		Str255		name;	Handle		RefCon;} hier_item, *hier_item_p, **hier_item_h;static	hier_item_p	h_list;static void InitToolbox(){	MaxApplZone ();	MoreMasters ();	MoreMasters ();	MoreMasters ();	MoreMasters ();	InitGraf ((Ptr) &qd.thePort);	InitFonts ();	InitWindows ();	InitMenus ();	FlushEvents (everyEvent,0);	InitDialogs (0L);	InitCursor ();}static pascal Boolean ModalFilterProc ( DialogPtr theDialog, EventRecord *theEvent, short *itemHit ){	Boolean 	result = false;	Point		localWhere = theEvent->where;	GrafPtr		savePort;	short		initem, part, dataLen, i, dummy;	WindowPtr	window;	Cell		theCell, oCell, pCell;	hier_item_p	celltodraw, celltodraw1, celltodraw2, celltodraw3;	switch (theEvent->what)	{	case mouseDown:			switch ( part = FindWindow (theEvent->where, &window) )		{		case inContent:					if (window == FrontWindow())			{				GetPort (&savePort);				SetPort (theDialog);				GlobalToLocal (&localWhere);								initem = FindDialogItem (theDialog, localWhere) + 1;								if (initem == 3)				{					semaphore = false;					sweep = false;					wasmove = -1;					if (LClick (localWhere, theEvent->modifiers, lst))					{						if (!sweep)							*itemHit = 3;						else							goto triangle;	//	ignore triangle dblclick					}					else					{					triangle:											*itemHit = -1;						result = true;						if (sweep)		//	Hit triangle						{							oCell = LLastClick (lst);							dataLen = sizeof (hier_item_p);							LGetCell (&celltodraw, &dataLen, oCell, lst);														if (celltodraw->owner == -1 && celltodraw->nested)							{								LSetDrawingMode (false, lst);								celltodraw->opened = 1 - celltodraw->opened;								LSetCell (&celltodraw, dataLen, oCell, lst);																if (celltodraw->opened)		//	open								{									celltodraw1 = celltodraw->nested;																		i = 1;																		while (celltodraw1)									{										dummy = LAddRow (1, oCell.v + i, lst);										SetPt (&theCell, 0, dummy);										dataLen = sizeof (hier_item_p);										LSetCell (&celltodraw1, dataLen, theCell, lst);																				celltodraw1 = celltodraw1->next;										i++;									}								}								else						//	close								{									celltodraw->nested = NULL;									celltodraw1 = NULL;																	SetPt (&theCell, 0, oCell.v + 1);									while (oCell.v + 1 < (*lst)->dataBounds.bottom)									{										dataLen = sizeof (hier_item_p);										LGetCell (&celltodraw2, &dataLen, theCell, lst);																				if (celltodraw2->owner == -1)											break;																				if (!celltodraw1)											celltodraw->nested = celltodraw2;										else											celltodraw1->next = celltodraw2;																					celltodraw2->next = NULL;																				celltodraw1 = celltodraw2;																				LDelRow (1, oCell.v + 1, lst);									}								}																EraseRect (&(*lst)->rView);								LSetDrawingMode (true, lst);								LUpdate (dlg->visRgn, lst);								LAutoScroll (lst);							}						}						else							if (wasmove != -1)				//	was moved							{								LSetDrawingMode (false, lst);								pCell = oCell = LLastClick (lst);																dataLen = sizeof (hier_item_p);								if (oCell.v > wasmove)								{									LGetCell (&celltodraw, &dataLen, oCell, lst);									LDelRow (1, oCell.v, lst);																		SetPt (&oCell, 0, wasmove);									LGetCell (&celltodraw1, &dataLen, oCell, lst);																		SetPt (&theCell, 0, pCell.v - 1);									LGetCell (&celltodraw2, &dataLen, theCell, lst);																		if (celltodraw2->owner == -1)									{										if (pCell.v < (*lst)->dataBounds.bottom)										{											LGetCell (&celltodraw3, &dataLen, pCell, lst);											if (celltodraw3->owner == -1)												goto emptied1;										}										else										{										emptied1:																					celltodraw2->nested = NULL;											celltodraw2->opened = 0;											LSetCell (&celltodraw2, dataLen, theCell, lst);										}									}																		if (celltodraw1->owner == -1 && !celltodraw1->opened)									{										if (celltodraw1->nested)										{											celltodraw1 = celltodraw1->nested;																						while (celltodraw1->next)												celltodraw1 = celltodraw1->next;																						celltodraw1->next = celltodraw;										}										else										{											celltodraw1->nested = celltodraw;											LSetCell (&celltodraw1, dataLen, oCell, lst);										}										celltodraw->next = NULL;									}									else									{										wasmove = LAddRow (1, wasmove + 1, lst);	//	+ 1 is for add always after										SetPt (&oCell, 0, wasmove);										LSetCell (&celltodraw, dataLen, oCell, lst);									}								}								else								{									LGetCell (&celltodraw, &dataLen, oCell, lst);									LDelRow (1, oCell.v, lst);																		SetPt (&oCell, 0, wasmove - 1);									LGetCell (&celltodraw1, &dataLen, oCell, lst);																		SetPt (&theCell, 0, pCell.v - 1);									LGetCell (&celltodraw2, &dataLen, theCell, lst);																		if (celltodraw2->owner == -1)									{										if (pCell.v < (*lst)->dataBounds.bottom)										{											LGetCell (&celltodraw3, &dataLen, pCell, lst);											if (celltodraw3->owner == -1)												goto emptied2;										}										else										{										emptied2:																					celltodraw2->nested = NULL;											celltodraw2->opened = 0;											LSetCell (&celltodraw2, dataLen, theCell, lst);										}									}																		if (celltodraw1->owner == -1 && !celltodraw1->opened)									{										if (celltodraw1->nested)										{											celltodraw1 = celltodraw1->nested;																						while (celltodraw1->next)												celltodraw1 = celltodraw1->next;																						celltodraw1->next = celltodraw;										}										else										{											celltodraw1->nested = celltodraw;											LSetCell (&celltodraw1, dataLen, oCell, lst);										}										celltodraw->next = NULL;									}									else									{										wasmove = LAddRow (1, wasmove, lst);										SetPt (&oCell, 0, wasmove);										LSetCell (&celltodraw, dataLen, oCell, lst);									}								}																LSetSelect (true, oCell, lst);								EraseRect (&(*lst)->rView);								LSetDrawingMode (true, lst);								LUpdate (dlg->visRgn, lst);								LAutoScroll (lst);							}					}				}								SetPort (savePort);			}						break;		}				break;	}	return result;}static pascal void myldef (short lMessage, Boolean lSelect, Rect *lRect, Cell lCell,				short lDataOffset, short lDataLen, ListHandle lHandle){	short 		leftDraw, topDraw, k, locked;	FontInfo 	fi;	long		i;	Str255		title, temp;	Point		drawpt;	hier_item_p	celltodraw;	Rect		iRect;		//	if ((lMessage == lInitMsg) || (lMessage == lCloseMsg))//		return;		leftDraw = lRect->left;		//+(*lHandle)->indent.h;	topDraw = lRect->top;		//+(*lHandle)->indent.v;		switch (lMessage)	{	case lInitMsg:			triangle[0] = GetCIcon (111);		triangle[1] = GetCIcon (112);		triangle[2] = GetCIcon (113);		break;		case lCloseMsg:			DisposeCIcon (triangle[0]);		DisposeCIcon (triangle[1]);		DisposeCIcon (triangle[2]);		break;	case lDrawMsg:			SetPort ((*lHandle)->port);		EraseRect (lRect);			if (lDataLen == 4)		{			GetFontInfo (&fi);			SetPt ( &drawpt, leftDraw, topDraw+fi.leading+fi.ascent+2 );//			memcpy ( tmp, *((*lHandle)->cells)+lDataOffset, lDataLen );			memcpy ( &celltodraw, *((*lHandle)->cells)+lDataOffset, sizeof (hier_item_p) );			//			MoveTo (leftDraw + 16, topDraw);//			LineTo (leftDraw + 16, lRect->bottom);			MoveTo ( drawpt.h + 16 + 2, drawpt.v );			DrawString (celltodraw->name);			if (celltodraw->owner == -1)			{				SetRect (&iRect, leftDraw, topDraw+2, leftDraw+16, topDraw+12+2);				PlotCIcon (&iRect, triangle[(celltodraw->nested) ?												((celltodraw->opened == 0) ? 0 : 1) : 2]);//				if (lDataOffset)//				{					MoveTo (leftDraw, topDraw);					LineTo (lRect->right, topDraw);//				}			}		}				if (!lSelect)			break;			case lHiliteMsg:			BitClr ( (Ptr) 0x0938, pHiliteBit);		InvertRect (lRect);		break;	}}static short pos2cell (short pos, Rect *lRect, Rect *bRect, short cHeight){	return bRect->top + ((pos - lRect->top) / cHeight);}static void makeframe (Rect *iRect){	Rect		dRect;//	PenState	penState;	//	GetPenState (&penState);//	PenMode (srcXor);//	PenPat (&qd.gray);		SetRect (&dRect, iRect->left, iRect->bottom-2, iRect->right, iRect->bottom);	InvertRect (&dRect);//	FillRect (&dRect, &qd.gray);//	SetPenState (&penState);}static Boolean myLClicker (void){	Boolean		res = false;	Point		where;	Rect		iRect, lRect, bRect;	short		cHeight, cpos, dataLen;	Cell		theCell, oCell;	long		finished;		RgnHandle	curclip;	hier_item_p	celltodraw;		if (!semaphore)	{		semaphore = true;		res = true;	}	else	{		if ( PtInRect ((*lst)->mouseLoc, &clickable) )			sweep = true;		if (!sweep)		{			oCell = theCell = LLastClick (lst);						if (theCell.v < (*lst)->dataBounds.bottom)			{				dataLen = sizeof (hier_item_p);				LGetCell (&celltodraw, &dataLen, oCell, lst);				if (celltodraw->owner != -1)		//	don't drag high level				{					curclip = NewRgn ();					GetClip (curclip);					ClipRect (&(*lst)->rView);									LRect (&iRect, theCell, lst);					cpos = -1;										while (StillDown ())					{						GetMouse (&where);						if (PtInRect (where, &(*lst)->rView))						{							if (!PtInRect (where, &iRect))							{								cpos = pos2cell (where.v, &(*lst)->rView, &(*lst)->visible, (*lst)->cellSize.v);															if (cpos >= (*lst)->dataBounds.top && cpos < (*lst)->dataBounds.bottom)								{									if (oCell.v != theCell.v)										makeframe (&iRect);																		SetPt (&theCell, 0, cpos);									LRect (&iRect, theCell, lst);																		if (oCell.v != theCell.v)										makeframe (&iRect);								}							}						}						else						{							lRect = (*lst)->rView;							lRect.top -= (*lst)->cellSize.v;							lRect.bottom += (*lst)->cellSize.v;							if (PtInRect (where, &lRect))							{								cpos = pos2cell (where.v, &(*lst)->rView, &(*lst)->visible, (*lst)->cellSize.v);																if (cpos > (*lst)->dataBounds.top && cpos < (*lst)->dataBounds.bottom)								{									if (cpos == theCell.v)										cpos -= 1;																		LScroll (0, cpos - theCell.v, lst);									LRect (&iRect, theCell, lst);									if (oCell.v != theCell.v)										makeframe (&iRect);																		SetPt (&theCell, 0, cpos);									LRect (&iRect, theCell, lst);																		if (oCell.v != theCell.v)										makeframe (&iRect);								}							}						}					}										if (oCell.v != theCell.v)						makeframe (&iRect);					LRect (&iRect, oCell, lst);					if (oCell.v != theCell.v)						makeframe (&iRect);					if (oCell.v != theCell.v)						wasmove = theCell.v;										SetClip (curclip);				}				else					res = true;			}		}	}	return res;}asm static pascal void myLClick (void){	jsr		myLClicker	tst.b	d0	rts}void main (void){	hier_item_p	celltodraw, celltodraw1;	FontInfo 	fi;	short		iType;	Handle		iHandle;	Rect		iRect, rDataBnds;	short		iHit, dummy, i, j;	Point		cellSize, theCell;	Str31		temp;	OSType		rType;	short		rID, ii;		InitToolbox ();	iHandle = Get1Resource ( 'LDEF', 111 );	*((long *)((*iHandle)+2)) = (long) myldef;		dlg = GetNewDialog (1111, NULL, (WindowPtr) -1L);	SetPort (dlg);	TextFont (4);	TextSize (9);	GetDialogItem ( dlg, 3, &iType, &iHandle, &iRect );	SetRect ( &rDataBnds, 0, 0, 1, 0 );	iRect.right -= 15;	GetFontInfo (&fi);	SetPt ( &cellSize, iRect.right - iRect.left, fi.leading+fi.ascent+fi.descent+2 );		if (cellSize.v < 14)		cellSize.v = 14;		iRect.bottom = iRect.top + ((iRect.bottom - iRect.top) / cellSize.v) * cellSize.v;		lst = LNew ( &iRect, &rDataBnds, cellSize, 111, dlg, true, false, false, true );	clickable = iRect;	clickable.left += 1;	clickable.right = clickable.left + 15;	InsetRect (&iRect, -1, -1);	FrameRect (&iRect);		SetPt (&((*lst)->indent), 0, 0);	(*lst)->selFlags = 0x82;	(*lst)->lClickLoop = myLClick;		iHit = CountResources ('FOND');	h_list = NULL;		for (i = 1; i <= iHit; i++)	{		if (!h_list)			h_list = celltodraw = (hier_item_p) NewPtrClear (sizeof (hier_item));		else		{			celltodraw->next = (hier_item_p) NewPtrClear (sizeof (hier_item));			celltodraw = celltodraw->next;		}		celltodraw->owner = -1;		celltodraw->opened = 0;		celltodraw->next = NULL;				SetResLoad (false);		iHandle = GetIndResource ('FOND',i);		GetResInfo (iHandle, &rID, &rType, celltodraw->name);		SetResLoad (true);	}		celltodraw = h_list;		LSetDrawingMode (false, lst);	LAddRow (iHit, 0, lst);	i = 0;		while (celltodraw)	{		SetPt (&theCell, 0, i);		LSetCell (&celltodraw, sizeof (hier_item_p), theCell, lst);		for (j = 0; j < i; j++)		{			if (!celltodraw->nested)				celltodraw->nested = celltodraw1 = (hier_item_p) NewPtrClear (sizeof (hier_item));			else			{				celltodraw1->next = (hier_item_p) NewPtrClear (sizeof (hier_item));				celltodraw1 = celltodraw1->next;			}			celltodraw1->owner = 0;			celltodraw1->opened = 0;			celltodraw1->next = NULL;						NumToString (j, celltodraw1->name);		}		celltodraw = celltodraw->next;		i++;	}	LSetDrawingMode (true, lst);		LUpdate (dlg->visRgn, lst);	do {			ModalDialog (ModalFilterProc, &iHit);				switch (iHit)		{		case 3:						SysBeep (10);			break;		}			} while (iHit != 1);	DisposeDialog (dlg);}