// ===========================================================================//	CMyDiskListBox.h			©1994 Jan Bruyndonckx All rights reserved.//	v1.0 18/6/94////	A hierarchical demo listbox: displays the files on a volume (with icons)//// ===========================================================================#include <files.h>#include <string.h>#include <strings.h>#include <lists.h>#include <resources.h>#include "UMemoryMgr.h"#include "CMyDiskListBox.h"//----------------------------------------------------------------------------typedef enum {		// our list can contain volumes, folders and files	tag_disk,	tag_folder,	tag_file} DiskTags ;#if defined(powerc) #pragma options align=mac68k#endiftypedef struct {	TwistDownHeader	hd ;	long			refNum ;	char			vRefNum ;		// yes, it should go in a byteÉ	Byte			tag ;	char			name[2] ;} DiskListRec, *DiskListPtr ;#if defined(powerc) #pragma options align=reset#endifconst Size DiskListRecSize = sizeof (DiskListRec)-2 ;	// don't count the name field//----------------------------------------------------------------------------// Creation methodsCMyDiskListBox* CMyDiskListBox::CreateFromStream(LStream *inStream){  return (new CMyDiskListBox(inStream));}CMyDiskListBox::CMyDiskListBox (LStream *inStream) : CTwistDownListBox (inStream){ Cell cell = { -1, 0 } ;  ExpandElement (cell) ;}//----------------------------------------------------------------------------// Override this method from LPane.  So we get notified when the window gets wider,// and we can adapt our cell width accordingly.void CMyDiskListBox::ResizeFrameBy (Int16 inWidthDelta, Int16 inHeightDelta,									Boolean inRefresh){   (*mMacListH)->cellSize.h += inWidthDelta ;  inherited::ResizeFrameBy (inWidthDelta, inHeightDelta, inRefresh) ;}//----------------------------------------------------------------------------// Expand an element from the list.  This triggers a directory search and inserts// the items in the list.  For the top-level: get all the volumes.void CMyDiskListBox::ExpandElement (const Cell theCell){ short				error, i;   Cell				cell = theCell ;  Byte				buffer[100] ;  DiskListPtr		thisTwist = (DiskListPtr) GetCellPtr (theCell) ;  DiskListPtr		anElement = (DiskListPtr) buffer ;    if (thisTwist == NULL)						// this function is first called -> top level = volumes  	{   	  for (i = 1 ; ; i++)	  	{ HParamBlockRec	block ;	  			  block.volumeParam.ioNamePtr  = (StringPtr) anElement->name;	//	the nameÉ		  block.volumeParam.ioVRefNum  = 0;					//	0 means use ioVolIndex		  block.volumeParam.ioVolIndex = i;		  error = ::PBHGetVInfoSync (&block);			  if (error)		  	break ;			  ::PtoCstr ((StringPtr) anElement->name) ;		  anElement->tag		= tag_disk ;		  anElement->vRefNum	= block.volumeParam.ioVRefNum ;		  anElement->refNum		= fsRtDirID ;	  	  anElement->hd.indent  = 0 ;	  	  anElement->hd.flags   = kHasSubList ; 		  		  cell.v = ::LAddRow (1, 32000, mMacListH) ;  	  	  ::LSetCell (anElement, sizeof (DiskListRec) - 2 + strlen((char*) anElement->name), cell, mMacListH) ;  	  	}  	  return ;  	}  	  short	vRefNum = thisTwist->vRefNum ;  long  parID	= thisTwist->refNum ;  short indent  = thisTwist->hd.indent+1 ;    for (i = 1, cell.v++ ; ; i++, cell.v++)    { CInfoPBRec	block;          block.dirInfo.ioNamePtr   = (StringPtr) anElement->name ;      block.dirInfo.ioVRefNum   = vRefNum;      block.dirInfo.ioFDirIndex = i;      block.dirInfo.ioDrDirID   = parID;      error = ::PBGetCatInfoSync (&block) ;      if (error)    	break ;			  ::PtoCstr ((StringPtr) anElement->name) ;	  anElement->vRefNum	= vRefNum ;  	  anElement->hd.indent  = indent ;	  if ((block.dirInfo.ioFlAttrib & 0x10) != 0)	// is a directory	 	{ anElement->tag		= tag_folder ;		  anElement->refNum		= block.dirInfo.ioDrDirID ;	  	  anElement->hd.flags   = kHasSubList ;	 	}	  else											// is a file	 	{ anElement->tag		= tag_file ;		  anElement->refNum		= 0 ;	  	  anElement->hd.flags   = 0 ;	 	}	 		  cell.v = ::LAddRow (1, cell.v, mMacListH) ;  	  ::LSetCell (anElement, sizeof (DiskListRec) - 2 + strlen((char*) anElement->name), cell, mMacListH) ;    }}//----------------------------------------------------------------------------static void PlotSICN (Rect *rect, Handle sicnList)// Draw the icon for a list element{ GrafPtr	port ;  char		saveState = ::HGetState ((Handle) h) ;  ::HLock ((Handle) h) ;  BitMap	srcBits = { *sicnList, 2, { 0, 0, 16, 16 }};	// baseAddr, rowBytes, bounds  ::GetPort (&port) ;  ::CopyBits (&srcBits, &(*port).portBits,   			  &srcBits.bounds, rect,   			  srcCopy, NULL) ;  			    ::HSetState ((Handle) h, saveState) ;}//----------------------------------------------------------------------------// Be lazy and get the little icons from the System file.  If I'd design my own,// I'd make them a little smaller and use Geneva 9 for the textconst short sicnID[] = {	-3995,		//	tag_disk	-3999,		//	tag_folder,	-4000		//	tag_file} ;void CMyDiskListBox::DrawTwistedElement (const Rect *lRect, 									   const TwistDownRecPtr lElement,									   const short lDataLen)									   // Draw contents of a single list element, including icon.{ Point	pen ;  ::GetPen (&pen) ;  Handle h = ::GetResource ('SICN', sicnID[DiskListPtr(lElement)->tag]) ;  if (h != NULL)    { Rect box = { lRect->top-2, pen.h, lRect->top+16-2, pen.h+16 } ;      ::PlotSICN (&box, h) ;    }    ::Move (21, 0) ;  ::DrawText (DiskListPtr(lElement)->name, 0, lDataLen-DiskListRecSize) ;}//----------------------------------------------------------------------------