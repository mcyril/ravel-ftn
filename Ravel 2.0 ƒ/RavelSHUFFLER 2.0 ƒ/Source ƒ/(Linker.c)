#include "PKT.h"#include "Prefs.h"#include "AreaUtils.h"//#include "BaseManager.h"#include "Linker.h"#include "log.h"extern	short				AreasNumber;		//	¥	Areas structs listtypedef struct _chainer {	long	msgid;	addr	msgaddr;	long	replyid;	addr	replyaddr;		long	prev;	long	next;	} chainerType, *chainerPtr, **cainerHndl;void	DoSlice (void);void	InitProgress ( float );void	DrawProgress ( long );void MsgLink ( void ){	short			i, j, k, ii, next;	indexAtomType	Atom;	cainerHndl		chainer;	long			amm;			putlog ( lgNOPE, "Building threads." );		for ( i = 0; i <= AreasNumber; i++ )	{		DoSlice ();//		putlog ( lgNOPE, "Process base #%d", i );					if ( OpenBase ( i ) != i )			return;				if ( amm = GetNumOfMessages () )		{			chainer = (cainerHndl) NewHandle ( sizeof (chainerType) * GetNumOfMessages () );			HLock ( (Handle) chainer );						j = 0;						InitProgress ( (float) amm * 4 );			while ( ReadMessageAtom ( j, &Atom ) )			{				if (!(j & 7))					DoSlice ();				DrawProgress (j);				(*chainer)[j].msgid = Atom.msgID;				(*chainer)[j].msgaddr = Atom.from;				(*chainer)[j].replyid = Atom.repID;				(*chainer)[j].replyaddr = Atom.reply;								(*chainer)[j].prev = -1;				(*chainer)[j].next = -1;							j++;			}						if ( j == GetNumOfMessages () )			{//				InitProgress ( (float) amm );				for ( j = 0; j < GetNumOfMessages (); j++ )				{					if (!(j & 7))						DoSlice ();					DrawProgress (j+amm);								if ( (*chainer)[j].replyid )						for ( ii = 0; ii < j; ii++ )							if ( (*chainer)[ii].msgid == (*chainer)[j].replyid &&									cmp2addrs ( &(*chainer)[ii].msgaddr, &(*chainer)[j].replyaddr ) )							{								(*chainer)[ii].next = j;								(*chainer)[j].prev = ii;								break;							}				}			/*				for ( j = 0; j < GetNumOfMessages (); j++ )					if ( (*chainer)[j].next != -1 )					{						next = (*chainer)[j].next;						k = j;												for ( ii=j+1; ii <  next; ii++ )							if ( (*chainer)[ii].prev == j )							{								(*chainer)[k].next = ii;								(*chainer)[next].prev = ii;								(*chainer)[ii].next = next;								(*chainer)[ii].prev = k;								k = ii;							}					}			*/			//				InitProgress ( (float) amm );				for ( j = 0; j < GetNumOfMessages (); j++ )				{					if (!(j & 7))						DoSlice ();					DrawProgress (j+2*amm);								for ( k = j+1; k < GetNumOfMessages (); k++ )						if ( (*chainer)[k].prev == j )						{							for ( ii = k+1; ii < GetNumOfMessages (); ii++ )								if ( (*chainer)[ii].prev == j )									(*chainer)[ii].prev = k;							break;						}				}								for ( j = GetNumOfMessages () - 1; j > 0; j-- )					if ( (*chainer)[j].prev != -1 )						(*chainer)[(*chainer)[j].prev].next = j;			//				InitProgress ( (float) amm );				for ( j = 0; j < GetNumOfMessages (); j++ )				{					if (!(j & 7))						DoSlice ();					DrawProgress (j+3*amm);					ReadMessageAtom ( j, &Atom );										Atom.BaseReplyTo = (*chainer)[j].prev;					Atom.BaseNextReply = (*chainer)[j].next;										WriteMessageAtom ( j, &Atom );				}			}			else				putlog ( lgALRT, "Number of messages in base #%d mismatch.", i );		}//		else//			putlog ( lgNOPE, "Base #%d is empty", i );				CloseBase ();	}}