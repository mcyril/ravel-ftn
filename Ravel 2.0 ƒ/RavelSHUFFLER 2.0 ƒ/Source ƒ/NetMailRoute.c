#include <stdio.h>#include <string.h>#include "ravel_msg_base.h"#include "ravel_tmp_base.h"//#include "Ravel_FTN.h"#include "Ravel_Prefs.h"#include "AreaUtils.h"#include "NetMailRoute.h"#include "log.h"#include "pktparse.h"//#include "BaseManager.h"#include "Flavor.h"#include "stringutl.h"#include "statistic.h"extern	homeHndl		homesystem;			//	¥	Home system structextern	mailPrefHndl	mailHndl;			//	¥	Netmail structextern	short			AreasNumber;		//	¥	Areas structs listextern	areaPrefHndl	*areasHndls;extern	short			GroupsNumber;		//	¥	AreaGroups structs listextern	groupPrefHndl	*groupsHndls;extern	short			NodesNumber;		//	¥	Linked Nodes structs listextern	nodePrefHndl	*nodesHndls;extern	short			wdWorkRefNum;		//	¥	WD for bundles spoolingÉvoid RouteMessage ( pktmsg *m, Boolean inTransit ){	addr		tempaddr, tempaddr1;	short		r;	pktmsg		*m2nd;	short		tempref;	Str31		tempStr;	char		temp1[64], temp2[64];		short		survie;	putlog ( lgNOPE, "NetMail %s(%s) to %s(%s)%s",				m->fromname, printaddr ( &m->from, temp1 ),				m->toname, printaddr ( &m->to, temp2 ),				(inTransit) ? "/transit" : "" );	if (m->flags & (MSGHOLD | MSGDIRECT | MSGCRASH))	//	message has flavor	{		if (inTransit)									//	message in transit		{			r = LookForLinkNumber (&m->to);					if (r == -1)								//	no described links			{				tempaddr = m->to;				tempaddr.point = 0;							if (m->flags & MSGCRASH)					m->flags &= ~(MSGHOLD | MSGDIRECT);				else					if (m->flags & MSGDIRECT)						m->flags &= ~(MSGHOLD | MSGCRASH);					else					{						putlog (lgALRT, "Bad flavored transit NetMail. Store in BADMAIL.");						add_to_other (m, "BADMAIL", NULL, "Bad flavored transit NetMail.");						return;					}							FlavorMessage (m, &(*homesystem)->mainAddr.ad, &tempaddr, inTransit);			}			else										//	have a link for this msg			{				m->flags &= ~(MSGHOLD | MSGDIRECT | MSGCRASH);				tempaddr = ((*nodesHndls[r])->yourAka) ?					(*homesystem)->AKAAddr[(*nodesHndls[r])->yourAka-1].ad : (*homesystem)->mainAddr.ad;				switch ((*nodesHndls[r])->Poll)				{				case 0:	m->flags |= MSGHOLD;	break;				case 1:	m->flags |= MSGDIRECT;	break;				case 2:	m->flags |= MSGCRASH;	break;				}								FlavorMessage (m, &tempaddr, &m->to, inTransit);			}		}		else											//	new message from base		{			r = LookForLinkNumber (&m->to);					if (r == -1)								//	no described links			{				tempaddr = m->to;								if (m->flags & MSGCRASH)					tempaddr.point = 0;								FlavorMessage (m, &m->from, &tempaddr, inTransit);			}			else			{				tempaddr = m->to;				tempaddr1 = ((*nodesHndls[r])->yourAka) ?					(*homesystem)->AKAAddr[(*nodesHndls[r])->yourAka-1].ad : (*homesystem)->mainAddr.ad;								if (m->flags & MSGCRASH)					tempaddr.point = 0;								FlavorMessage (m, &tempaddr1, &tempaddr, inTransit);			}		}				Stat.NetMailDirected++;	}	else	{		if ( (r = FindRouteToN ( &m->to )) == -1 )		{			putlog ( lgALRT, "Orphan NetMail (check routing, please). Store in BADMAIL." );			add_to_other (m, "BADMAIL", NULL, "Orphan NetMail.");			return;		}				tempaddr = ((*nodesHndls[r])->yourAka) ?			(*homesystem)->AKAAddr[(*nodesHndls[r])->yourAka-1].ad : (*homesystem)->mainAddr.ad;				FlavorMessage (m, &tempaddr, &(*nodesHndls[r])->Addr, inTransit);	}}