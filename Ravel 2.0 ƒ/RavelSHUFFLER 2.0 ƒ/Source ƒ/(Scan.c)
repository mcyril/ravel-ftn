#include <stdio.h>#include <string.h>#include <Folders.h>#include "ravel_msg_base.h"#include "Prefs.h"#include "PascalStr.h"#include "myEnv.h"#include "log.h"#include "Toss.h"#include "Scan.h"#include "Utils.h"#include "PKTUtils.h"#include "stringutl.h"#include "AreaUtils.h"#include "NetMailRoute.h"#include "Attaches.h"#include "Exports.h"#include "Pathes.h"#include "Flavor.h"#include "Plug-Ins.h"#include "statistic.h"extern	homeHndl		homesystem;			//	е	Home system structextern	mailPrefHndl	mailHndl;			//	е	Netmail structextern	short			AreasNumber;		//	е	Areas structs listextern	areaPrefHndl	*areasHndls;extern	short			GroupsNumber;		//	е	AreaGroups structs listextern	groupPrefHndl	*groupsHndls;extern	short			NodesNumber;		//	е	Linked Nodes structs listextern	nodePrefHndl	*nodesHndls;extern	short			wdWorkRefNum;		//	е	WD for bundles spooling╔extern	statistic		Stat;extern	short	type2plus;void	DoSlice (void);void	InitProgress ( float );void	DrawProgress ( long );/****************************************************												   **	Process	Inbound	folder - look for bundles.	   **	Make netmail routing						   **	Make echo area tossing						   **	(in	other level	process	uplinks	& downlinks)   **												   ****************************************************/void Scan (void){	long			i, j, amm, ii, nm;	pktmsg 			*m;	msgbase_atom	Atom;	short			tempref, iErr;	short			zero2, ix, jx;	Str255			tempStrSrc;	pktheader		*p;	addr			tempaddr;	DateTimeRec		dtr;	long			counter;//	е	Process with incoming bundles╔ (aka TOSS)	putlog ( lgATTN, "Activate Scanning." );//ееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееее//	е	Prepare data structures for int. use.//	е	Create all outbounds bundle templates for each listed node.	wdWorkRefNum = myOpenWD ( workPath );	//ееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееее//е Scan netmail	if ( msgbase_open (NETMAIL, true) == NETMAIL )	{		amm = msgbase_getnummsg ();		if (amm && msgbase_getdirty ())		{			msgbase_setdirty (0);			InitProgress ( (float) amm );			for ( j=0; ; j++ )			{				DoSlice ();				DrawProgress (j);					if ( msgbase_read_atom ( j, &Atom ) )				{					if ( (Atom.flags & MSGLOCAL) != 0 && (Atom.flags & MSGSENT) == 0 )					{						msgbase_read_message ( j, &m, READMODE_REPLY | READMODE_TEXT );						Atom.flags |= MSGSENT;						msgbase_write_atom ( j, &Atom );						if ( !CallPlugIns (plugScanMsgMail, m) )						{							m->flags &= ~(MSGLOCAL | MSGSENT | MSGREAD);							ResolveMessage ( m, NULL, FALSE );						}												FreePktMsg (m);						if (Atom.flags & MSGKILL)						{							nm = msgbase_getnummsg ();														if ((Atom.base_flags & ATOM_LOCKED) == 0)							{								Atom.base_flags = ATOM_DELETED;								msgbase_write_atom ( j, &Atom );								nm--;								msgbase_setnummsg ( nm );								j--;															if ( nm <= msgbase_getlastread () )									msgbase_setlastread (nm-1);							}						}											nokill:;										}				}				else					break;			}			msgbase_close (CLOSE_UPDATE);		}		else			msgbase_close (CLOSE_ONLY);	}//ееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееее	p = (pktheader *) NewPtr ( sizeof (pktheader) );		if ( !wdWorkRefNum )	{		putlog ( lgALRT, "Cannot open bundles folder." );		return;	}		for ( i = 1; i <= NodesNumber; i++ )			//	i < 0 -> Netmail	{												//	i > 0 -> ArcMail		ii = i - 1;				NumToString ( i, tempStrSrc );				iErr = Create ( tempStrSrc, wdWorkRefNum, 'Ravl', 'PKT ' );			if ( iErr && iErr != dupFNErr )		{			putlog ( lgALRT, "Cannot create temp bundles file." );			myCloseWD ( wdWorkRefNum );			return;		}				FSOpen ( tempStrSrc, wdWorkRefNum, &tempref );			SetEOF ( tempref, 0 );		tempaddr = ((*(nodesHndls[ii]))->yourAka) ?			(*homesystem)->AKAAddr[(*(nodesHndls[ii]))->yourAka-1].ad : (*homesystem)->mainAddr.ad;		p->from.zone = tempaddr.zone;		p->from.net = tempaddr.net;		p->from.node = tempaddr.node;		p->from.point = tempaddr.point;		p->to.zone = (*(nodesHndls[ii]))->Addr.zone;		p->to.net = (*(nodesHndls[ii]))->Addr.net;		p->to.node = (*(nodesHndls[ii]))->Addr.node;		p->to.point = (*(nodesHndls[ii]))->Addr.point;		GetTime ( &dtr );		p->year = dtr.year;		p->month = dtr.month;		p->day = dtr.day;		p->hour = dtr.hour;		p->min = dtr.minute;		p->sec = dtr.second;							for ( j = 0; j < 8; j++ )			if ( !(p->passwd[j] = (*(nodesHndls[ii]))->ArcMail_pwd[j]) )				break;						for ( ; j < 9; j++ )			p->passwd[j] = 0;		p->pkttype = type2plus;		AddPKTHeadToPKTFile ( tempref, p );			FSClose ( tempref );	}		DisposePtr ( (Ptr) p );		//ееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееее//е Scan echoes	for ( i = 1; i <= AreasNumber; i++ )		if ( OpenBase ( i ) == i )		{			amm = GetNumOfMessages ();						if (amm && GetDirtyFlag ())			{				SetDirtyFlag (0);				InitProgress ( (float) amm );				for ( j=0; ; j++ )				{						DoSlice ();					DrawProgress (j);							if ( ReadMessageAtom ( j, &Atom ) )					{						if ( (Atom.flags & MSGLOCAL) != 0 && (Atom.flags & MSGSENT) == 0 )						{							ReadMessage ( j, &m );							Atom.flags |= MSGSENT;							WriteMessageAtom ( j, &Atom );							if ( !CallPlugIns (plugScanMsgEcho, m) )							{								m->flags &= ~(MSGLOCAL | MSGSENT | MSGREAD);								Stat.EchoMesages++;								ExportEchoes ( m, NULL );							}														FreePktMsg (m);						}					}					else						break;				}			}						CloseBase ();		}	InitProgress (1.0);//ееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееее//	е	Prepare data structures for ext. appls.	for ( i = 1; i <= NodesNumber; i++ )			//	i < 0 -> Netmail	{												//	i > 0 -> ArcMail		ii = i - 1;				NumToString ( i, tempStrSrc );				FSOpen ( tempStrSrc, wdWorkRefNum, &tempref );		GetEOF ( tempref, &counter );				if ( counter == sizeof (struct _pkthdr) )		{			FSClose ( tempref );			FSDelete ( tempStrSrc, wdWorkRefNum );	//		putlog ( lgNOPE, "Outbound for %ldth link is empty. Bundle has been killed.", ii );		}		else		{	//	е	Append zero.zero trailer to packet to terminate it.						zero2 = 0;			GetEOF ( tempref, &counter );			SetFPos ( tempref, fsFromStart, counter );						counter = 2;			FSWrite ( tempref, &counter, &zero2 );			FSClose ( tempref );				//	е	Move & rename to outbound + create attach			ResolveArcMailToNode ( i, tempStrSrc );		}	}	myCloseWD ( wdWorkRefNum );//ееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееее}