#include <stdio.h>#include <stdlib.h>#include <string.h>#include <ctype.h>#include "ravel_msg_base.h"//#include "PKT.h"#include "Prefs.h"#include "key.h"#include "PKTUtils.h"#include "Utils.h"#include "myEnv.h"#include "stringutl.h"#include "log.h"extern	Str255	RealName;extern	Str63	MacModel;extern	short	timezone;			// е Time Zone number.static char	*mnt[12] = { "Jan", "Feb", "Mar",						 "Apr", "May", "Jun",						 "Jul", "Aug", "Sep",						 "Oct", "Nov", "Dec" };/************************************************************														   **	Read PKT header	from opened	file and dismantle it to   **	internal dynamical structures						   **														   ************************************************************/pktheader *GetPktHeader ( short fp ){	pktheader	*p;	short		a;	struct _pkthdr		packet;	struct _pkthdr39	*pkt0039;	struct _pkthdr45	*pkt0045;		long		counter;			counter = sizeof (struct _pkthdr);	FSRead ( fp, &counter, &packet );	if ( counter != sizeof (struct _pkthdr) )		return NULL;	if ( endshort (packet.ver) != 2 )	{		putlog (lgALRT, "Bad PKT version (%d)", endshort (packet.ver));		return NULL;	}		p = (pktheader *) NewPtrClear ( sizeof (pktheader) );		p->from.point =		0;		//	-1;;	p->from.node =		0;		//	-1;;	p->from.zone =		0;		//	-1;;	p->from.net =		0;		//	-1;;	p->to.point =		0;		//	-1;;	p->to.node =		0;		//	-1;;	p->to.zone =		0;		//	-1;;	p->to.net =			0;		//	-1;;	//	е	In all PKT's is here		p->from.node =	endshort (packet.orig_node);	p->to.node =	endshort (packet.dest_node);	p->from.net =	endshort (packet.orig_net);	p->to.net =		endshort (packet.dest_net);	p->passwd[8]=0; 	for ( a=0; a<8; a++ )		if (packet.password[a] && packet.password[a] != ' ')			p->passwd[a] = packet.password[a];		else			p->passwd[a] = 0;		if (endshort (packet.rate) == 2)	{//	е	Type 2.2 Packet (FSC-0045)			p->pkttype = 0x0220;		pkt0045 = (struct _pkthdr45 *) &packet;			p->from.zone = endshort (pkt0045->orig_zone);		p->from.point = endshort (pkt0045->orig_point);		p->to.zone = endshort (pkt0045->dest_zone);		p->to.point = endshort (pkt0045->dest_point);		p->year = 0;		p->month = 0;		p->day = 0;		p->hour = 0;		p->min = 0;		p->sec = 0;		p->productCode = (unsigned short) pkt0045->product;		p->productRev = (unsigned short) pkt0045->serial;	}	else	{//	е	Type 2 Pakcet (ariations)			pkt0039 = (struct _pkthdr39 *) &packet;			p->year = endshort (pkt0039->year);		p->month = endshort (pkt0039->month);		p->day = endshort (pkt0039->day);		p->hour = endshort (pkt0039->hour);		p->min = endshort (pkt0039->minute);		p->sec = endshort (pkt0039->second);		if ((endshort ((pkt0039->CapWord) & 0x7F7F) == ((pkt0039->CapValid) & 0x7F7F)) &&			(((pkt0039->CapValid) & 0x0001) == 0x0001))		{//	е	Type 2 or Type 2+ Packet					p->pkttype = 0x0200;//	е	FSC-0039////	Code Name - Uses QOrg/QDstZone Orig/DestZone Orig/DestPoint//	---- ----------- ------------- ------------- --------------//	0x0C  FrontDoor  Reads/Updates      Yes           Yes//	0x1A  DBridge        ?????          Yes           Yes//	0x45  XRS        Reads/Updates      Yes           Yes//	0x29  QMail           Yes          ?????      Not point-aware//	0x35  ZMailQ          Yes          ?????      Not point-aware//	0x3F  TosScan    Reads/Updates      Yes           Yes			p->from.zone = endshort (pkt0039->orig_zone);			p->to.zone = endshort (pkt0039->dest_zone);			p->from.point = endshort (pkt0039->orig_point);			p->to.point = endshort (pkt0039->dest_point);			p->productCode = (pkt0039->product_hi << 8) | pkt0039->product_low;			p->productRev = (pkt0039->prod_rev_hi << 8) | pkt0039->prod_rev_low;						if (p->productCode == 0x0029 ||				p->productCode == 0x0035)			{				p->pkttype = 0x0201;					//	Overwrite to QMail Type 2				p->from.zone = endshort (pkt0039->qm_orig_zone);				p->to.zone = endshort (pkt0039->qm_dest_zone);				p->from.point = 0;				p->to.point = 0;			}			else			{				if (p->from.net == -1 && p->from.point != 0)				{		//	е	Type 2+	Overwrite orig_net							p->pkttype = 0x02FF;					p->from.net = endshort (pkt0039->auxnet);				}			}		}		else		{			p->pkttype = 0x0000;		//	FTS-0001					p->from.zone = endshort (packet.orig_zone);			p->to.zone = endshort (packet.dest_zone);			p->from.point = 0;			p->to.point = 0;//			p->from.point = packet.orig_point;//			p->to.point = packet.dest_point;			p->productCode = (unsigned short) packet.product;			p->productRev = (unsigned short) packet.serial;		}	}	return p;}/************************************************************														   **				Dispose PKT header from memory			   **														   ************************************************************/void FreePktHeader ( pktheader *p ){	DisposePtr ( (Ptr) p );}//ееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееее/************************************************************														   **  Making chained list of PATH & SEEN-BY from char string  **														   ************************************************************/void dokfalist ( juncted *kf, char *s ){	int		lastnet=-1;	int		a, b;		if ( !kf->nets )	kf->nets = (short **) NewHandle (0);	if ( !kf->nodes )	kf->nodes = (short **) NewHandle (0);		for ( a=0; s[a] != 0 && s[a] != '\xD'; )	{//		while ( s[a] == ' ' || s[a] == '\t' )//			a++;		while ( !isdigit (s[a]) && s[a] != '-' && s[a] != 0 && s[a] != '\xD')			a++;					if (s[a] == 0 || s[a] == '\xD')			break;				b = atoi (s+a);//		sscanf ( s+a, "%d", &b );		while ( isdigit (s[a]) || s[a] == '-')			a++;		if(s[a]=='/')		{			lastnet = b;			a++;			b = atoi (s+a);//			sscanf ( s+a, "%d", &b );			while ( isdigit (s[a]) || s[a] == '-')				a++;		}		kf->items++;				SetHandleSize ( (Handle) kf->nets, (long) ((unsigned short) kf->items) * sizeof(short) );		SetHandleSize ( (Handle) kf->nodes, (long) ((unsigned short) kf->items) * sizeof(short) );				(*kf->nets)[kf->items-1] = lastnet;		(*kf->nodes)[kf->items-1] = b;				while ( s[a]==' ' || s[a]=='\t' )			a++;	}}/************************************************************														   **  				Is address in PATH & SEEN-BY ?			   **														   ************************************************************/Boolean iskfalist ( juncted *kf, addr *f ){	short		a;	for ( a = 0; a < kf->items; a++ ) 		if ( (*kf->nets)[a] == f->net && (*kf->nodes)[a] == f->node )			return TRUE;	return FALSE;}void addkfalist ( juncted *kf, addr *f, short sbmode ){	short		a, b;	if ( !kf->nets )	kf->nets = (short **) NewHandle (0);	if ( !kf->nodes )	kf->nodes = (short **) NewHandle (0);		if(!sbmode)									// е Not need sorting for ^aPATH (append)	{ 		if ( kf->items != 0 )			if ( (*kf->nets)[kf->items-1] == f->net && (*kf->nodes)[kf->items-1] == f->node ) 				return; 		 		a=kf->items;	}	else										// е SEEN-BY must be major-sorted (look for mediana)		for ( a=0; a < kf->items; a++ )		{			if ( (*kf->nets)[a] >= f->net )			{				if ( (*kf->nodes)[a] > f->node )		break; 				if ( (*kf->nodes)[a] == f->node )		return;			}		}		kf->items++;		SetHandleSize ( (Handle) kf->nets, kf->items * sizeof(short) );	SetHandleSize ( (Handle) kf->nodes, kf->items * sizeof(short) );		for ( b = kf->items-1; b > a; b-- )	{		(*kf->nets)[b] = (*kf->nets)[b-1];		(*kf->nodes)[b] = (*kf->nodes)[b-1];	}		(*kf->nets)[a] = f->net;	(*kf->nodes)[a] = f->node;}/*void initkfalist ( juncted *new, juncted *old ){	new->items = (old) ? (old->items) : 0;		if ( old && old->items != 0 )	{		new->nodes = (short **) NewHandle ( new->items*sizeof(short) );		memcpy ( *new->nodes, *old->nodes, new->items*sizeof(short) );		new->nets = (short **) NewHandle ( new->items*sizeof(int) );		memcpy ( *new->nets, *old->nets, new->items*sizeof(short) );	}	else	{		new->nodes = NULL;		new->nets = NULL;	}}*/void freekfalist ( juncted *kf ){	if ( kf->nets )		DisposeHandle ( (Handle) kf->nets );		if ( kf->nodes )		DisposeHandle ( (Handle) kf->nodes );}char **printkfalist(char *tag, juncted *kf ){	char	**mbuf = NULL;	char	s[128], tm[64];	short	a, b, c, nalloc;	if ( kf->items == 0 ) 		return mbuf;	mbuf = NewHandle (1);	**mbuf = 0;		nalloc = 0;	b = 0;		for ( a=0; a < kf->items; a++ )	{		s[b] = 0;				if ( b == 0 )			sprintf ( tm, "%s%d/%d", tag, (*kf->nets)[a], (*kf->nodes)[a] );		else			if ( a==0 )				sprintf ( tm, "%d/%d", (*kf->nets)[a], (*kf->nodes)[a] );			else				if ( (*kf->nets)[a] != (*kf->nets)[a-1] )					sprintf ( tm, "%d/%d", (*kf->nets)[a], (*kf->nodes)[a] ); 				else					sprintf ( tm, "%d", (*kf->nodes)[a] );		if ( strlen ( s ) + strlen ( tm ) < 75 )		{			for ( c = 0; tm[c] != 0; c++ )				s[b++] = tm[c];				s[b++] = ' ';			s[b] = 0;		}		else		{			if ( b != 0 )				if ( s[b-1] == ' ' )					s[--b] = 0;	 	 		s[b++] = '\xD';	 		s[b] = 0;				nalloc += strlen (s) +1;				SetHandleSize ( mbuf, nalloc );			strcat ( *mbuf, s );			b=0;			a--;		}	}	if ( b != 0 )	{		if ( s[b-1] == ' ' )			s[--b] = 0;			s[b++] = '\xD';		s[b] = 0;			nalloc += strlen (s) + 1;				SetHandleSize ( mbuf, nalloc );				strcat ( *mbuf, s );	}	return mbuf;}//ееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееее/************************************************************														   **		Kill trashing 0x0A from message text body		   **														   ************************************************************/void KillDelimiters ( char  ***txt ){	char	*src, *dst;	char	**h;	long	len;			h = NewHandle ( GetHandleSize ( *txt ) );		src = **txt;	dst = *h;	len = 0L;		do  {		if ( *src != 0x0A )		{			len++;			*(dst++) = *(src++);		}			} while ( *src );		*dst = 0;	SetHandleSize ( h, len+1 );	DisposeHandle ( *txt );	*txt = h;}/******************************************										 **	Get	next message from open file.	 **	Translate it into internal format.	 **										 ******************************************/pktmsg *GetPktMsg ( short fp, pktheader *ph ){	pktmsg		*p;	FTS1PKTMSG	Msg;	long		counter;	char		date[32],				to[64],				from[64],				subj[128];	Handle		h;			counter = sizeof (FTS1PKTMSG);	FSRead ( fp, &counter, &Msg );			if ( counter != sizeof (FTS1PKTMSG) )	{//		if (counter == 2 && Msg.Version == 0)		if (Msg.Version == 0)			return ((pktmsg *) -1);		else			return NULL;	}		p = (pktmsg *) NewPtr ( sizeof(pktmsg) );	if ( !p )		return NULL;	p->fromname[0] =	0;	p->from.point =		0;		//	-1;	p->from.node =		0;		//	-1;	p->from.net =		0;		//	-1;	p->toname[0] =		0;	p->to.point =		0;		//	-1;	p->to.node =		0;		//	-1;	p->to.net =			0;		//	-1;	p->from.zone =		ph->from.zone;	p->to.zone =		ph->to.zone;	p->reply.zone =		0;		//	-1;	p->reply.point =	0;		//	-1;	p->reply.node =		0;		//	-1;	p->reply.net =		0;		//	-1;	p->flags =			0;	p->date[0] =		0;	p->subj[0] =		0;	p->text =			NULL;	p->area[0] =		0;		p->seenby.items =	0;	p->path.items =		0;		p->seenby.nets =	NULL;	p->seenby.nodes =	NULL;	p->path.nets =		NULL;	p->path.nodes =		NULL;	p->storedtime = 0;	if ( endshort (Msg.Version) != 2 )	{		putlog (lgALRT, "Bad message version (%d) inside PKT. Flush to rest.", endshort (Msg.Version));		DisposePtr ( (Ptr) p );		if ( !GetASCIIZ ( fp, date, MDate ) ||			 !GetASCIIZ ( fp, to, MName ) ||			 !GetASCIIZ ( fp, from, MName ) ||			 !GetASCIIZ ( fp, subj, MSubject ) )			return NULL;		h = (char **) NewHandle ( 0 );		if ( !GetMSGText ( fp, h ) )			return NULL;					DisposeHandle (h);		return NULL;	}	p->from.node =		endshort (Msg.OrigNode);	p->to.node =		endshort (Msg.DestNode);	p->from.net =		endshort (Msg.OrigNet);	p->to.net =			endshort (Msg.DestNet);	p->flags =			((long)(endshort (Msg.Attr))) & 0x0000FFFFL;	if ( !GetASCIIZ ( fp, date, MDate ) ||		 !GetASCIIZ ( fp, to, MName ) ||		 !GetASCIIZ ( fp, from, MName ) ||		 !GetASCIIZ ( fp, subj, MSubject ) )	{		DisposePtr ( (Ptr) p );		return NULL;	}		p->text = (char **) NewHandle ( 0 );		if ( !GetMSGText ( fp, p->text ) )	{		DisposeHandle ( p->text );		DisposePtr ( (Ptr) p );		return NULL;	}	strcpy ( p->date, date );	strcpy ( p->toname, to );	strcpy ( p->fromname, from );	strcpy ( p->subj, subj );	NewParseKludges ( 0, p, NULL, NULL, NULL, NULL );	p->flags &= ~(MSGLOCAL | MSGSENT | MSGREAD);	return p;}/************************************************************														   **				 Dispose message from memory			   **														   ************************************************************/void FreePktMsg ( pktmsg *p ){	if ( p )	{		if ( p->seenby.nets )	DisposeHandle ( (Handle) p->seenby.nets );		if ( p->seenby.nodes )	DisposeHandle ( (Handle) p->seenby.nodes );		if ( p->path.nets )		DisposeHandle ( (Handle) p->path.nets );		if ( p->path.nodes )	DisposeHandle ( (Handle) p->path.nodes );		if ( p->text )			DisposeHandle ( p->text );		if ( p->msgid_str )		DisposePtr ( p->msgid_str );		if ( p->reply_str )		DisposePtr ( p->reply_str );				DisposePtr ( (Ptr) p );	}}/************************************************************														   **    Add message to opened PKT file message from memory	   **														   ************************************************************/void AddMessageToPKTFile ( short pktRefNum, pktmsg *m, addr *from ){	FTS1PKTMSG		Msg;	long			counter;	unsigned short	tmp;				GetEOF ( pktRefNum, &counter );	SetFPos ( pktRefNum, fsFromStart, counter );	//	е Write MSG header.		Msg.Version		= endshort (0x0002);	Msg.OrigNode	= endshort (m->from.node);	Msg.DestNode	= endshort (m->to.node);	Msg.OrigNet		= endshort (m->from.net);	Msg.DestNet		= endshort (m->to.net);		tmp				= m->flags;	Msg.Attr		= endshort (tmp);		Msg.Cost		= 0;		counter = sizeof (FTS1PKTMSG);	FSWrite ( pktRefNum, &counter, &Msg );	counter = strlen ( m->date ) + 1;	FSWrite ( pktRefNum, &counter, m->date );	counter = strlen ( m->toname ) + 1;	FSWrite ( pktRefNum, &counter, m->toname );	counter = strlen ( m->fromname ) + 1;	FSWrite ( pktRefNum, &counter, m->fromname );	counter = strlen ( m->subj ) + 1;	FSWrite ( pktRefNum, &counter, m->subj );//	е Write msg body text	counter = GetHandleSize ( m->text );		if (counter != strlen (*m->text) + 1)		putlog (lgALRT, "Internal massage's text size mismatch (%ld н %ld)! Call Cyril╔", counter, strlen (*m->text));		FSWrite ( pktRefNum, &counter, *m->text );}void AddPKTHeadToPKTFile ( short pktRefNum, pktheader *p ){	struct _pkthdr		packet;	struct _pkthdr39	*pkt0039;	struct _pkthdr45	*pkt0045;	long		counter;	short		a;//	putlog (lgALRT, "MAKING %.4X", p->pkttype);	memset ((char *) &packet, 0, sizeof (struct _pkthdr));	packet.ver = endshort (2);	packet.orig_zone = endshort (p->from.zone);	packet.dest_zone = endshort (p->to.zone);		packet.orig_net = endshort (p->from.net);	packet.dest_net = endshort (p->to.net);	packet.orig_node = endshort (p->from.node);	packet.dest_node = endshort (p->to.node);	for ( a=0; a<8; a++ )		packet.password[a] = p->passwd[a];	switch (p->pkttype)	{	case 0x0000:		//	FTS-0001	case 0x0200:		//	Type 2	case 0x02FF:		//	Type 2+	case 0x0201:		//	QMail			packet.year = endshort (p->year);		packet.month = endshort (p->month-1);		packet.day = endshort (p->day);		packet.hour = endshort (p->hour);		packet.minute = endshort (p->min);		packet.second = endshort (p->sec);		packet.orig_zone = endshort (p->from.zone);		packet.dest_zone = endshort (p->to.zone);		packet.product = PRODUCT_LO_E;		packet.serial = MAJOR_VRS;		if (p->pkttype == 0x0000)			break;			pkt0039 = (struct _pkthdr39 *) &packet;			pkt0039->orig_point = endshort (p->from.point);		pkt0039->dest_point = endshort (p->to.point);		pkt0039->orig_zone = endshort (p->from.zone);		pkt0039->dest_zone = endshort (p->to.zone);		pkt0039->product_low = PRODUCT_LO_E;		pkt0039->product_hi = PRODUCT_HI_E;		pkt0039->prod_rev_hi = MAJOR_VRS;		pkt0039->prod_rev_low = MINOR_VRS;		if (p->pkttype == 0x02FF)		{			pkt0039->CapWord = endshort (0x0001);			pkt0039->CapValid = 0x0001;			if (p->from.point != 0)			{				packet.orig_net = -1;				pkt0039->auxnet = endshort (p->from.net);			}		}		else		{			pkt0039->CapWord = 0;			pkt0039->CapValid = 0;		}				if (p->pkttype != 0x0201)			break;		pkt0039->orig_point = 0;		pkt0039->dest_point = 0;				pkt0039->qm_orig_zone = endshort (p->from.zone);		pkt0039->qm_dest_zone = endshort (p->to.zone);			break;		case 0x0220:		//	Type 2.2						//	Put screw upto Domains.			pkt0045 = (struct _pkthdr45 *) &packet;		pkt0045->orig_point = endshort (p->from.point);		pkt0045->dest_point = endshort (p->to.point);		pkt0045->orig_zone = endshort (p->from.zone);		pkt0045->dest_zone = endshort (p->to.zone);		pkt0045->subver = endshort (2);		break;	}	counter = sizeof (struct _pkthdr);	FSWrite ( pktRefNum, &counter, &packet );/*	FTS1PKTHDR	Header;	long		counter;	short		a;	Header.OrigNode =	endshort (p->from.node);	Header.DestNode =	endshort (p->to.node);	Header.Year =		endshort (p->year);	Header.Month =		endshort (p->month);	Header.Day =		endshort (p->day);	Header.Hour =		endshort (p->hour);	Header.Minute =		endshort (p->min);	Header.Second =		endshort (p->sec);	Header.Rate =		0;	Header.Version =	endshort ( 0x0002 );		Header.OrigNet =	(type2plus) ? (( p->from.point ) ? -1 : endshort (p->from.net)) : endshort (p->from.net);	Header.AuxNet =		(type2plus) ? (( p->from.point ) ? endshort (p->from.net) : 0) : 0;		Header.DestNet =	endshort (p->to.net);	for ( a=0; a<8; a++ )		Header.Password[a] = p->passwd[a];	Header.QMOrigZone =	Header.OrigZone =	endshort (p->from.zone);	Header.QMDestZone =	Header.DestZone =	endshort (p->to.zone);//	Header.CWValidate =	(type2plus) ? 0x0001 : 0;			// Type 2+ ?//	Header.CWCapWord =	(type2plus) ? endshort ( 0x0001 ) : 0;	Header.CWValidate =	0x0001;			// Type 2+	Header.CWCapWord =	endshort ( 0x0001 );	Header.PCodeHi =	PRODUCT_HI_E;	Header.PCodeLo =	PRODUCT_LO_E;	Header.PRevMajor =	MAJOR_VRS;	Header.PRevMinor =	MINOR_VRS;	Header.OrigPoint =	endshort (p->from.point);	Header.DestPoint =	endshort (p->to.point);	Header.LongData =	0;	counter = sizeof (FTS1PKTHDR);	FSWrite ( pktRefNum, &counter, &Header );*/}/************************************************************														   **  Parse message text for kludges & full addenum internal  **	           	message's structures					   **														   ************************************************************/static	Ptr		tempBuffer;typedef struct _kludge {	char	kl[16];	short	klen;	} kludge;static	kludge	kludges[] = {	"AREA:", 5,				//	0								"SEEN-BY:", 8,			//	1								"\1PATH:", 6,			//	2								"\1FMPT", 5,			//	3								"\1TOPT", 5,			//	4								"\1INTL", 5,			//	5								"\1MSGID: ", 8,			//	6								"\1FLAGS: ", 8,			//	7								"\1CHRS: ", 7,			//	8								"\1SEEN-BY:", 9,		//	9								"\1PID: ", 6,			//	10								"\1Via ", 5,			//	11								"\1REPLY: ", 8,			//	12								"\1REPLYTO: ", 10,		//	13								"\1REPLYTO ", 9,		//	14								" * Origin: ", 11,		//	15								"\1FLAGS ", 7,			//	16								"", 0							};short LookForKL ( char *beg ){	short		i;		for ( i = 0; ; i++ )		if ( !kludges[i].klen )			return -1;		else			if ( !strncmp ( beg, kludges[i].kl, kludges[i].klen ) )				return i;}//	е	mode://	е		0	-	1st msg touch. Make internal form (full all fields in _pktmsg_). Rewrite.//	е		1	-	For posting in base (kill kludges). Duplicate.//	е		2	-	For posting in outbound (add new seen & path kludges). Duplicate.//	е		3	-	For post in outbound new message (add all kludges from _pktmsg_). Duplicate.//	е					(for creation we suppose that pktmsg exist but empty)void NewParseKludges ( short mode, pktmsg *m, pktmsg **d, juncted *newseen,							juncted *newpath, addr *currentAka ){	char			*src, *dst;	Handle			spool, h;	long			TextLen, ParaLen;	short			i, r;	long			addenum;	addr			a_temp;	unsigned long	secs;	char			temp1[64];	Handle			hVia = NULL;	long			viaPos;	DateTimeRec		dtr;	Boolean			firstvisible, isarcmail;			switch (mode)	{	case 0:	case 1:	addenum = 0;	break;	case 2:	case 3: addenum = 2048;	break;	}		HLock ( m->text );	src = *m->text;		spool = NewHandleClear ( GetHandleSize (m->text) + addenum );	HLock ( spool );	dst = *spool;		if (mode == 0)					//	е Init free seen-by	{		m->seenby.items =	0;		m->seenby.nets =	NULL;		m->seenby.nodes =	NULL;				m->path.items =	0;		m->path.nets =		NULL;		m->path.nodes =		NULL;				m->storedtime =		0;				m->reply.zone =		0;		m->reply.net =		0;		m->reply.node =		0;		m->reply.point =	0;				m->replyid =		0;		m->msgid =			0;				m->area[0] =		0;	}	else	{		if ( m->seenby.items )		{			(*d)->seenby.items = m->seenby.items;			h = (Handle) m->seenby.nets;	HandToHand (&h);	(*d)->seenby.nets = (short **) h;			h = (Handle) m->seenby.nodes;	HandToHand (&h);	(*d)->seenby.nodes = (short **) h;		}		else		{			(*d)->seenby.items = 0;			(*d)->seenby.nets = NULL;			(*d)->seenby.nodes = NULL;		}				if ( m->path.items )		{			(*d)->path.items = m->path.items;			h = (Handle) m->path.nets;	HandToHand (&h);	(*d)->path.nets = (short **) h;			h = (Handle) m->path.nodes;	HandToHand (&h);	(*d)->path.nodes = (short **) h;		}		else		{			(*d)->path.items = 0;			(*d)->path.nets = NULL;			(*d)->path.nodes = NULL;		}				strcpy ( (*d)->date, m->date );		strcpy ( (*d)->subj, m->subj );		strcpy ( (*d)->area, m->area );		strcpy ( (*d)->fromname, m->fromname );		(*d)->from = m->from;		strcpy ( (*d)->toname, m->toname );		(*d)->to = m->to;		(*d)->reply = m->reply;		(*d)->storedtime = m->storedtime;				(*d)->msgid = m->msgid;		(*d)->replyid = m->replyid;		(*d)->flags = m->flags & (MSGPRIVATE | MSGCRASH |									MSGFILE | MSGUNUSED |									MSGRRREQ | MSGISRR | MSGAREQ | 0xFFFF0000L);	}		tempBuffer = NewPtr ( 0x8000L );		TextLen = 0;		if ( mode == 3 )			//	е	Deflorate new message :-E~	{		//	е	Insert AreaName AREA:AREANAME\n		if ( (*d)->area[0] )		{			sprintf ( tempBuffer, "AREA:%s\xD", (*d)->area );			strcpy ( dst, tempBuffer );						i = strlen (tempBuffer);			dst += i;			TextLen += i;		}//	е	Insert INTL... to<->from		if ( !(*d)->area[0] )		{			sprintf ( tempBuffer, "\1INTL %d:%d/%d %d:%d/%d\xD",				(*d)->to.zone, (*d)->to.net, (*d)->to.node,				(*d)->from.zone, (*d)->from.net, (*d)->from.node );				strcpy ( dst, tempBuffer );				i = strlen (tempBuffer);			dst += i;			TextLen += i;		}	//	е	Insert to point		if ( !(*d)->area[0] && (*d)->to.point )		{			sprintf ( tempBuffer, "\1TOPT %d\xD", (*d)->to.point );				strcpy ( dst, tempBuffer );				i = strlen (tempBuffer);			dst += i;			TextLen += i;		}//	е	Insert from point		if ( !(*d)->area[0] && (*d)->from.point )		{			sprintf ( tempBuffer, "\1FMPT %d\xD", (*d)->from.point );				strcpy ( dst, tempBuffer );				i = strlen (tempBuffer);			dst += i;			TextLen += i;		}//	е	Set ^aMSGID		sprintf ( tempBuffer, "\1MSGID: %s %.8lX\xD",			printaddr ( &(*d)->from, temp1 ), (*d)->msgid );			strcpy ( dst, tempBuffer );		i = strlen (tempBuffer);		dst += i;		TextLen += i;	//	е	Set ^aREPLY		if ( (*d)->replyid )		{			if (((*d)->flags & 0x80000000L) != 0)				sprintf ( tempBuffer, "\1REPLY: %s %.8lX\xD",					printaddr ( &(*d)->reply, temp1 ), (*d)->replyid );			else				sprintf ( tempBuffer, "\1REPLY: %s %.8lx\xD",					printaddr ( &(*d)->reply, temp1 ), (*d)->replyid );			strcpy ( dst, tempBuffer );			i = strlen (tempBuffer);			dst += i;			TextLen += i;		}	//	е	Insert flags		if (!(*d)->area[0] && ((*d)->flags & 0x7FFF0000L))		{			sprintf ( tempBuffer, "\1FLAGS %s\xD",					flags_to_string ((*d)->flags & 0x7FFF0000L, temp1 ) );				strcpy ( dst, tempBuffer );				i = strlen (tempBuffer);			dst += i;			TextLen += i;		}//	е	Insert PID#ifdef PUBLIC_BETA		sprintf ( tempBuffer, "\1PID: " RAVELNAME " " RAVELVERS " PUBLIC_BETA\xD" );#else#ifdef PROTECTOR		sprintf ( tempBuffer, "\1PID: " RAVELNAME " " RAVELVERS " %lX-%X\xD", keys.oldcrc, keys.oldcs );#else		sprintf ( tempBuffer, "\1PID: " RAVELNAME " " RAVELVERS " UNREGISTERED\xD" );#endif#endif		strcpy ( dst, tempBuffer );			i = strlen (tempBuffer);		dst += i;		TextLen += i;		//	е	Insert fuzz		sprintf ( tempBuffer, "\1Macintosh %#s\xD", MacModel );			strcpy ( dst, tempBuffer );			i = strlen (tempBuffer);		dst += i;		TextLen += i;//	е	Insert RealName				if (RealName[0])		{			sprintf ( tempBuffer, "\1RealName: %s\xD", &RealName[1] );			strcpy ( dst, tempBuffer );			i = strlen (tempBuffer);			dst += i;			TextLen += i;		}	}	firstvisible = true;	isarcmail = false;	while ( 1 )	{			for ( ParaLen = 0; (ParaLen < 0x8000L) && (*src != 0 && *src != 0x0D); )													// е Read 32K (max) paragraph			if ( *src != 0x0A && *src != 0x8D )				tempBuffer[ParaLen++] = *(src++);	// е Store all except LFs & soft LFs			else				src++;								// е Skip bad chars				if ( ParaLen == 0x8000 )					// е Ambigous big paragraph (>32K)...			break;				if ( *src )		{			tempBuffer[ParaLen++] = *(src++);			tempBuffer[ParaLen] = 0;		}//		else//			break;				if ( ParaLen != 0 )							// е Process paragraph		{			switch ( mode )			{			case 0:		//	е	1st touch╔							switch ( LookForKL ( tempBuffer ) )		// е Process Kludges				{	/*AREA*/	case 0:		if (firstvisible)							{								exstrcpy ( m->area, tempBuffer+5 );								firstvisible = false;								isarcmail = true;							}							break;								/*SEEN*/	case 1:		if (isarcmail)							{								dokfalist ( &(m->seenby), tempBuffer+8 );							}							break;								/*PATH*/	case 2:		if (isarcmail)							{								dokfalist ( &(m->path), tempBuffer+6 );							}														break;								/*FMPT*/	case 3:		if (!isarcmail)							{								long	l_l;																sscanf(tempBuffer+6, "%ld", &l_l);								m->from.point = l_l;								break;							}	/*TOPT*/	case 4:		if (!isarcmail)							{								long	l_l;																sscanf(tempBuffer+6, "%ld", &l_l);								m->to.point = l_l;								break;							}	/*INTL*/	case 5:		if (!isarcmail)							{								long	l_1, l_2, l_3, l_4, l_5, l_6;																sscanf(tempBuffer+6, "%ld:%ld/%ld %ld:%ld/%ld",													&l_1, &l_2, &l_3, &l_4, &l_5, &l_6);//								sscanf(tempBuffer+6, "%d:%d/%d %d:%d/%d", &(m->to.zone),//													&(m->to.net), &(m->to.node), &(m->from.zone),//													&(m->from.net), &(m->from.node));								m->to.zone = l_1;								m->to.net = l_2;								m->to.node = l_3;								m->from.zone = l_4;								m->from.net = l_5;								m->from.node = l_6;								break;							}	/*MSGID*/	case 6:		r = parseaddr ( &(m->from), tempBuffer+8 );							sscanf ( tempBuffer+8+r, "%lX", &(m->msgid) );														for (i=0; ; i++)							{								if (*(tempBuffer+8+r+i) == 0x0D ||									*(tempBuffer+8+r+i) == 0x00)									break;																if (*(tempBuffer+8+r+i) >= 'A' &&									*(tempBuffer+8+r+i) <= 'F')								{									m->flags |= 0x80000000L;									break;								}							}														break;	/*REPLY*/	case 12:	r = parseaddr ( &(m->reply), tempBuffer+8 );							sscanf ( tempBuffer+8+r, "%lX", &(m->replyid) );/*							for (i = 8+r; i < 8+r+8; i++)							{								if (tempBuffer[i] >= 'A' && tempBuffer[i] <= 'F')								{									m->flags |= 0x80000000L;									break;								}							}*/														break;	/*FLAGS*/	case 7:		m->flags |= string_to_flags ( tempBuffer+8 ); break;	/*FLAGS*/	case 16:	m->flags |= string_to_flags ( tempBuffer+7 ); break;	/*CHRC*/	case 8:		ParaLen = 0; break;	/*SEEN*/	case 9:		if (isarcmail)							{								dokfalist ( &(m->seenby), tempBuffer+9 );								for (i=1; tempBuffer[i-1]; i++ )			// е kill ^a									tempBuffer[i-1] = tempBuffer[i];								ParaLen--;							}							break;	/*REPLYTO*/	case 13:	r = parseaddr ( &(m->from), tempBuffer+10 ); break;	/*REPLYTO*/	case 14:	r = parseaddr ( &(m->from), tempBuffer+9 ); break;	/*Origin*/	case 15:	if (!isarcmail)								break;														for (i = ParaLen-1; i >= 0; i--)								if (tempBuffer[i] == '(')									break;														if (i >= 0)							{								i++;								while (!isdigit (tempBuffer[i]) && tempBuffer[i] != ')' && tempBuffer[i] != 0x0D)									i++;																if (isdigit (tempBuffer[i]))								{									m->from.zone = 0;									m->from.net = 0;									m->from.node = 0;									m->from.point = 0;									r = parseaddr ( &(m->from), tempBuffer+i );								}							}							break;											default:	if (*tempBuffer != 1)								firstvisible = false;							break;				}								break;							case 1:		//	е	prepare for base╔							switch ( LookForKL ( tempBuffer ) )		// е Process Kludges				{	/*AREA*/	case 0:	ParaLen = 0; break;	/*SEEN*/	case 1:	/*PATH*/	case 2:	/*FMPT*/	case 3:	/*TOPT*/	case 4:	/*INTL*/	case 5:	/*MSGID*/	case 6:	/*FLAGS*/	case 7:	/*CHRC*/	case 8:	/*SEEN*/	case 9:	/*Via*/		case 11:	/*REPLY*/	case 12:	/*FLAGS*/	case 16:				default:	break;				}				break;							case 2:		//	е	prepare for next transaction╔							switch ( LookForKL ( tempBuffer ) )		// е Process Kludges				{	/*AREA*/	case 0:		break;	/*SEEN*/	case 1:	/*PATH*/	case 2:		ParaLen = 0; break;	/*FMPT*/	case 3:	/*TOPT*/	case 4:	/*INTL*/	case 5:	/*MSGID*/	case 6:	/*FLAGS*/	case 7:	/*FLAGS*/	case 16:	/*CHRC*/	case 8:		break;	/*SEEN*/	case 9:		ParaLen = 0; break;	/*Via*/		case 11:	//	е Catch Vias for future substitution...														if ( m->area[0] )								break;														if ( hVia )							{								viaPos = GetHandleSize ( hVia );								SetHandleSize ( hVia, viaPos + ParaLen );							}							else							{								viaPos = 0;								hVia = NewHandle ( ParaLen );							}														memcpy ( *hVia + viaPos, tempBuffer, ParaLen );							ParaLen = 0;														break;					default:	break;				}								break;							case 3:		//	е	introduce message in big crazy world	/*			switch ( LookForKL ( tempBuffer ) )		// е Process Kludges				{	/*PID*		case 10:	//	е	Insert TID after PID												sprintf ( tr, "\1TID: RavelECHO 0.0d1\xD" );							strcat ( tempBuffer, tr );							ParaLen = strlen ( tempBuffer );														break;									default:	break;				}		*/				break;			}				//	е	Copy-copy-copy╔						if ( ParaLen )							// е If kludge not killed			{										// е Store paragraph				memcpy ( dst, tempBuffer, ParaLen );								dst += ParaLen;				TextLen += ParaLen;					// + 1;								if ( !*src )					break;							// е NULL terminated...			}			else									// е If kludge killed				if ( !*src )					break;		}		else		{			if ( !*src )				break;								// е NULL terminated...			TextLen += 1;							//	20.04.97 this line swapped													//	after break for null body?		}													// е Next paragraph...	}//	е	make 2 & 3 modes with seen-by & path + add ^aVia	*(dst++) = 0;	TextLen++;	switch ( mode )	{	case 2:	case 3:			dst--;		tempBuffer[0] = 0;		if ( m->area[0] )		{			if ( newseen )					//	Need addenum seen-by?			{				for ( i = 0; i < newseen->items; i++ )				{					a_temp.net = (*newseen->nets)[i];					a_temp.node = (*newseen->nodes)[i];					addkfalist ( &(*d)->seenby, &a_temp, 1 );				}			}						if ( (*d)->seenby.items )		//	Anyway staore old seen-by.. if any.			{				if ( (h = printkfalist ( "SEEN-BY: ", &(*d)->seenby )) != NULL )				{					strcat ( tempBuffer, *h );					DisposeHandle ( h );				}			}									if ( newpath )					//	Need addenum path?			{				for ( i = 0; i < newpath->items; i++ )				{					a_temp.net = (*newpath->nets)[i];					a_temp.node = (*newpath->nodes)[i];					addkfalist ( &(*d)->path, &a_temp, 0 );				}			}						if ( (*d)->path.items )		//	Anyway store old path.. if any.			{				if ( (h = printkfalist ( "\1PATH: ", &(*d)->path )) != NULL )				{					strcat ( tempBuffer, *h );					DisposeHandle ( h );				}			}									if ( tempBuffer[0] )			{				strcpy ( dst, tempBuffer );								viaPos = strlen ( tempBuffer );				TextLen += viaPos;				dst += viaPos;			}		}		else		{			if ( hVia )			{				if ( *dst )					DebugStr ( "\pStrange incrementation╔" );								viaPos = GetHandleSize ( hVia );				memcpy ( dst, *hVia, viaPos );								TextLen += viaPos;				dst += viaPos;								DisposeHandle ( hVia );			}			GetTime ( &dtr );			if (timezone)				sprintf ( dst, "\1Via %s @%.4d%.2d%.2d.%.2d%.2d%.2d.00.UTC%+d " SHUFFLERNAME " " RAVELVERS "\xD",						printaddr ( currentAka, tempBuffer ),						dtr.year, dtr.month, dtr.day, dtr.hour, dtr.minute, dtr.second, timezone );			else				sprintf ( dst, "\1Via %s @%.4d%.2d%.2d.%.2d%.2d%.2d.00.UTC " SHUFFLERNAME " " RAVELVERS "\xD",						printaddr ( currentAka, tempBuffer ),						dtr.year, dtr.month, dtr.day, dtr.hour, dtr.minute, dtr.second );			TextLen += strlen ( dst );		}				break;		default:			break;	}		DisposePtr ( tempBuffer );		HUnlock ( spool );	SetHandleSize ( spool, TextLen );		if ( mode == 0 )	{		DisposeHandle ( m->text );		m->text = spool;	}	else	{		(*d)->text = spool;	}}long GetMSGID (void){	static	long	msgid = 0;	if (!msgid)		msgid = (LMGetTime () << 7) + (LMGetTicks () & 0x0000003FL);	else		msgid++;	return msgid;}