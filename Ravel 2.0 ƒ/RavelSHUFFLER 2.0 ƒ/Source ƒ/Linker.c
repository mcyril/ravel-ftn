#include "ravel_msg_base.h"//#include "Ravel_FTN.h"#include "Ravel_Prefs.h"#include "AreaUtils.h"#include "pktparse.h"#include "Linker.h"#include "log.h"extern	short			AreasNumber;		//	¥	Areas structs listextern	areaPrefHndl	*areasHndls;typedef struct _chainer {	long	flag;	long	msgid;	addr	msgaddr;	long	msgidcrc;		long	replyid;	addr	replyaddr;	long	replycrc;		long	prev;	long	next;	} chainerType, *chainerPtr, **cainerHndl;void	DoSlice (void);void	InitProgress ( float );void	DrawProgress ( long );void	putProgressName (Str255 name);void MsgLink ( void ){	short			i, j, k, ii, next;	msgbase_atom	Atom;	cainerHndl		chainer;	long			amm;				for ( i = 0; i <= AreasNumber; i++ )	{		if (i > 0 && ((*areasHndls[i-1])->areaflags & AREA_PASSTROUGH))			continue;		putProgressName ((i) ? (*areasHndls[i-1])->areaName : "\pNetMail");		DoSlice ();		if ( msgbase_open (i, true) == i )		{			if (amm = msgbase_getnummsg ())			{				chainer = (cainerHndl) NewHandle ( sizeof (chainerType) * msgbase_getnummsg () );				HLock ( (Handle) chainer );								InitProgress ( (float) amm * 4 );							for (j=0; j<amm; j++)				{					if (!msgbase_read_atom ( j, &Atom ))						break;									if (!(j & 7))					{						DoSlice ();					}										DrawProgress (j);					(*chainer)[j].flag = Atom.base_flags;										(*chainer)[j].msgid = Atom.msgid_num;					(*chainer)[j].msgaddr = Atom.from;					(*chainer)[j].msgidcrc = Atom.msgid_crc;										(*chainer)[j].replyid = Atom.reply_num;					(*chainer)[j].replyaddr = Atom.reply;					(*chainer)[j].replycrc = Atom.reply_crc;										(*chainer)[j].prev = -1;					(*chainer)[j].next = -1;				}				if (j != amm)				{					putlog ( lgALRT, "Number of messages in base %#s mismatch.", (i) ? (*areasHndls[i-1])->areaName : "\pNetMail");					msgbase_setnummsg (j);					DisposeHandle ((Handle) chainer);				}				else				{					for ( j = 0; j < amm; j++ )					{						if (!(j & 7))						{							DrawProgress (j+amm);							DoSlice ();						}										if ( (*chainer)[j].replyid )							for ( ii = 0; ii < j; ii++ )								if (((*chainer)[j].flag & ATOM_REPLY) && ((*chainer)[ii].flag & ATOM_MSGID))								{									if (((*chainer)[j].flag & ATOM_NONFTNREPLY) && ((*chainer)[ii].flag & ATOM_NONFTNMSGID))									{										if ((*chainer)[ii].msgidcrc == (*chainer)[j].replycrc)										{											(*chainer)[ii].next = j;											(*chainer)[j].prev = ii;											break;										}									}									else										if (!((*chainer)[j].flag & ATOM_NONFTNREPLY) && !((*chainer)[ii].flag & ATOM_NONFTNMSGID))										{											if ( (*chainer)[ii].msgid == (*chainer)[j].replyid &&													cmp2addrs ( &(*chainer)[ii].msgaddr, &(*chainer)[j].replyaddr ) )											{												(*chainer)[ii].next = j;												(*chainer)[j].prev = ii;												break;											}										}								}					}									for ( j = 0; j < amm; j++ )					{						if (!(j & 7))						{							DrawProgress (j+2*amm);							DoSlice ();						}						for ( k = j+1; k < amm; k++ )							if ( (*chainer)[k].prev == j )							{								for ( ii = k+1; ii < amm; ii++ )									if ( (*chainer)[ii].prev == j )										(*chainer)[ii].prev = k;								break;							}					}										for ( j = amm - 1; j > 0; j-- )						if ( (*chainer)[j].prev != -1 )							(*chainer)[(*chainer)[j].prev].next = j;										for ( j = 0; j < amm; j++ )					{						if (!(j & 7))						{							DrawProgress (j+3*amm);							DoSlice ();						}						msgbase_read_atom ( j, &Atom );												Atom.msg_reply_prev = (*chainer)[j].prev;						Atom.msg_reply_next = (*chainer)[j].next;												msgbase_write_atom ( j, &Atom );					}				}				DisposeHandle ((Handle) chainer);			}			msgbase_close (CLOSE_UPDATE);		}	}	InitProgress (1.0);}