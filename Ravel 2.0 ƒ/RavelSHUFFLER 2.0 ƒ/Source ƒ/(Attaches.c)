#include <stdio.h>#include <string.h>#include "PKT.h"#include "Prefs.h"#include "PKTUtils.h"#include "PascalStr.h"#include "Attaches.h"#include "Pathes.h"#include "stringutl.h"#include "ZipIt.h"#include "Plug-Ins.h"#include "Flavor.h"#include "log.h"									extern	homeHndl		homesystem;			//	•	Home system structextern	mailPrefHndl	mailHndl;			//	•	Netmail structextern	short			AreasNumber;		//	•	Areas structs listextern	areaPrefHndl	*areasHndls;extern	short			GroupsNumber;		//	•	AreaGroups structs listextern	groupPrefHndl	*groupsHndls;extern	short			NodesNumber;		//	•	Linked Nodes structs listextern	nodePrefHndl	*nodesHndls;extern	short			wdWorkRefNum;		//	•	WD for bundles spooling…extern	Boolean			ZipItExist;static	char	*pollModes[3] = { ".HLO", ".DLO", ".CLO" };static	char	*ValidExt[7] = { "SU", "MO", "TU", "TH", "WE", "FR", "SA" };extern	char 	*arcs[31];extern	long	MaxArcSize;static long get_file_len (StringPtr fname){	FileParam	pb;		pb.ioCompletion = NULL;	pb.ioVRefNum = 0;	pb.ioFVersNum = 0;	pb.ioFDirIndex = 0;	pb.ioNamePtr = fname;		PBGetFInfoSync ((ParmBlkPtr) &pb);		return pb.ioFlLgLen;}void ResolveArcMailToNode ( short nodenum, StringPtr nameBundle ){	pktmsg		*m;	char		bb;	char		tmp[256];	char		tmp1[256];	char		tmp2[128];	short		iErr, src, dst;	DateTimeRec	dtr;	Str255		temp1;	FSSpec		specSrc, specDst, spec;	long		module, ioCounter;	addr		nodeaddr;	char		r_buf[512];			iErr = FSMakeFSSpec ( wdWorkRefNum, 0, nameBundle, &specSrc );		sprintf ( (char *) &temp1[1], "%.8lX.PKT", LMGetTicks () );	temp1[0] = strlen ( (char *) &temp1[1] );	FSpRename ( &specSrc, temp1 );	pStrCopy ( temp1, specSrc.name );	nodenum--;	nodeaddr = (*(nodesHndls[nodenum]))->Addr;	m = (pktmsg *) NewPtrClear ( sizeof (pktmsg) );		switch ((*(nodesHndls[nodenum]))->Poll)	{	case 0: m->flags = MSGHOLD;		break;	case 1: m->flags = MSGDIRECT;	break;	case 2: m->flags = MSGCRASH;	break;	}	CreateFoldersChain ( m, &nodeaddr, NULL, &tmp[1], false );	tmp[0] = strlen (&tmp[1]);		if ((*(nodesHndls[nodenum]))->Compressor)	{	//•	Compressed arcmail for this link described			GetTime ( &dtr );		for (bb = '0'; bb <= '9'; bb++)		{			strcpy (&tmp1[1], &tmp[1]);			if (nodeaddr.point)				sprintf ( tmp2, "%.8lX.%s%c", -((long) nodeaddr.point), ValidExt[dtr.dayOfWeek-1], bb );			else				sprintf ( tmp2, "%.8lX.%s%c", -(((long) nodeaddr.net << 16) + (long) nodeaddr.node), ValidExt[dtr.dayOfWeek-1], bb );						strcat (&tmp1[1], tmp2);			tmp1[0] = strlen (&tmp1[1]);			iErr = FSMakeFSSpec ( 0, 0, (StringPtr) tmp1, &spec );			if (iErr == fnfErr)			{	//•	No such file - create new							module = 1 << ((*(nodesHndls[nodenum]))->Compressor - 1);				if (CallArchiverPlugIns (	true,					//	compress											false,					//	not append											module,					//	compressor											&specSrc,				//	what compress											NULL,					//	ignore											(StringPtr) tmp1		//	archive name										) != plugRetContinue)				{					putlog (lgALRT, "No such compressor (%s). Compression fault.",						arcs[(*(nodesHndls[nodenum]))->Compressor - 1]);					goto do_uncompressed;				}				CreateFoldersChain ( m, &nodeaddr, &tmp1[1], &tmp[1], true );//				tmp[0] = strlen (&tmp[1]);				goto done;			}			else			{	//•	File existed							if (get_file_len ((StringPtr) tmp1) > MaxArcSize)	//	long file					continue;				else					goto append_to_bb;			}		}			append_to_bb:			module = 1 << ((*(nodesHndls[nodenum]))->Compressor - 1);		if (CallArchiverPlugIns (	true,							//	compress									true,							//	append									module,							//	compressor									&specSrc,						//	what compress									NULL,							//	ignore									(StringPtr) tmp1				//	archive name								) != plugRetContinue)		{			putlog (lgALRT, "No such compressor (%s). Compression fault.",				arcs[(*(nodesHndls[nodenum]))->Compressor - 1]);			goto do_uncompressed;		}		done:		FSpDelete ( &specSrc );	}	else	{	//•	Unompressed arcmail for this link described (bad deal)		do_uncompressed:;		//•	Pointing destination folder			iErr = FSMakeFSSpec ( 0, 0, (StringPtr) tmp, &specDst );	//•	Pointing destination unique (certain) name		if (nodeaddr.point)			sprintf ( (char *) &temp1[1], "%.8lX.PKT", 0xAAAAAAAAL - ((long) nodeaddr.point) );		else			sprintf ( (char *) &temp1[1], "%.8lX.PKT", 0xAAAAAAAAL - (((long) nodeaddr.net << 16) + (long) nodeaddr.node) );				//•	Rename to certain name			temp1[0] = strlen ( (char *) &temp1[1] );		FSpRename ( &specSrc, temp1 );		pStrCopy ( temp1, specSrc.name );	//•	Pointing destination unique (certain) namepath		strcpy (&tmp1[1], &tmp[1]);		strcat (&tmp1[1], (char *) &temp1[1]);		tmp1[0] = strlen (&tmp1[1]);	//•	Move bundle & make/append attach file		if ( (iErr = FSpCatMove ( &specSrc, &specDst )) != noErr )		{			if ( iErr == dupFNErr )			{	//•	Destination unique (certain) name exists - append to PKT				strcpy (&tmp1[1], &tmp[1]);				strcat (&tmp1[1], (char *) &temp1[1]);				tmp1[0] = strlen (&tmp1[1]);				iErr = FSMakeFSSpec ( 0, 0, (StringPtr) tmp1, &spec );				if ( iErr )				{					putlog ( lgALRT, "Cannot transfer bundle to outbound" );				}				else				{					if (FSpOpenDF ( &specSrc, fsRdPerm, &src))					{						putlog ( lgALRT, "Cannot transfer bundle to outbound" );						goto bad_deal;					}									if (FSpOpenDF ( &spec, fsRdWrPerm, &dst))					{						FSClose (src);						putlog ( lgALRT, "Cannot transfer bundle to outbound" );						goto bad_deal;					}					SetFPos (src, fsFromStart, sizeof (struct _pkthdr));					SetFPos (dst, fsFromLEOF, -2);										do {												ioCounter = 512L;						FSRead (src, &ioCounter, r_buf);						FSWrite (dst, &ioCounter, r_buf);										} while (ioCounter);										FSClose (src);					FSClose (dst);										FSpDelete ( &specSrc );				}			}			else			{				putlog ( lgALRT, "Cannot transfer bundle to outbound" );			}				bad_deal:;				}		else		{	//•	Destination unique (certain) name not exists - do new PKT (was moved)					CreateFoldersChain ( m, &nodeaddr, &tmp1[1], &tmp[1], true );		}	}	FreePktMsg ( m );}/*void ResolveArcMailToNode ( short nodenum, StringPtr nameBundle ){	FILE			*attFile;	FSSpec			specSrc, specDst;	addr			nodeaddr;	Str255			temp1;	Str15			attFName;	Str255			tempZone, tempPoint, temp;	Str255			temp10;	long			dummy;	short			iErr;	FInfo			fndrInfo;	DateTimeRec		dtr;	short			a;		short			source_r, destination_r;	long			ioCounter, module;	char			r_buf[512];		//	•	Get source bundle location…	nodenum--;	iErr = FSMakeFSSpec ( wdWorkRefNum, 0, nameBundle, &specSrc );	//	•	Export to this node…		nodeaddr = (*(nodesHndls[nodenum]))->Addr;	//	•	Creation or finding zonal subfolder…	sprintf ( (char *) &temp1[1], "Zone_%.4X:", nodeaddr.zone );	temp1[0] = strlen ( (char *) &temp1[1] );		pStrConc ( outboundPath, temp1, tempZone );		if ( (iErr = FSMakeFSSpec ( 0, 0, tempZone, &specDst )) == fnfErr )	{		if ( DirCreate ( 0, 0, tempZone, &dummy ) )		{			putlog ( lgALRT, "Cannot create zonal folder %s", &temp1[1] );			return;		}		iErr = FSMakeFSSpec ( 0, 0, tempZone, &specDst );	}												// • specDst - FSSpec of appr. zonal ƒ.//	•	Destination node is point?		if ( nodeaddr.point != 0 )	{	//	•	Creation or finding point subfolder…		sprintf ( (char *) &temp1[1], "%.4X%.4X.PTS:", nodeaddr.net, nodeaddr.node );		temp1[0] = strlen ( (char *) &temp1[1] );				pStrConc ( tempZone, temp1, tempPoint );				if ( (iErr = FSMakeFSSpec ( 0, 0, tempPoint, &specDst )) == fnfErr )		{			if ( DirCreate ( 0, 0, tempPoint, &dummy ) )			{				putlog ( lgALRT, "Cannot create point folder %s", &temp1[1] );				return;			}				iErr = FSMakeFSSpec ( 0, 0, tempPoint, &specDst );		}												// • specDst - FSSpec of appr. point ƒ.			//	•	Generate attachment filename for Point ƒ				sprintf ( (char *) &attFName[1], "%.8lX%s", (long) nodeaddr.point, pollModes[(*(nodesHndls[nodenum]))->Poll] );		attFName[0] = strlen ( (char *) &attFName[1] );		}	else	{		//	•	Generate attachment filename for Zonal ƒ				sprintf ( (char *) &attFName[1], "%.4X%.4X%s",					nodeaddr.net, nodeaddr.node, pollModes[(*(nodesHndls[nodenum]))->Poll] );		attFName[0] = strlen ( (char *) &attFName[1] );			}	sprintf ( (char *) &temp1[1], "%.8lX.PKT", LMGetTicks () );	temp1[0] = strlen ( (char *) &temp1[1] );	FSpRename ( &specSrc, temp1 );	pStrCopy ( temp1, specSrc.name );	if ((*(nodesHndls[nodenum]))->Compressor)	{//	•	Compress/Append to archive.		pStrConc ( (nodeaddr.point == 0) ? tempZone : tempPoint, attFName, temp );		temp[temp[0]+1] = 0;		attFile = fopen ( (char *) &temp[1], "r" );		if (attFile)		{					temp10[0] = 0;		//	•	Attaches list already exist, try parse it and append to existant archive//	•	or create new archive and append attach							while ( fscanf ( attFile, "%[\x20-\x7e]\n", &temp1[1] ) != EOF )			{				temp1[0] = strlen ( (char *) &temp1[1] );				temp1[1] = temp1[0] - 1;				memcpy (&temp10[0], &temp1[1], temp1[0]);						iErr = GetFInfo ( temp10, 0, &fndrInfo );				if(!iErr && fndrInfo.fdCreator == 'ZIP ' )	//	Validate creator…				{					for (a=0;a<7;a++)						//	Validate DOS extension…						if ( !strncasecmp ( (char *) &temp10[temp10[0] - 2], ValidExt[a], 2) )							break;						if(a!=7)					{//	•	Found valid arcmail file append to it with ZipIt//	DebugStr ("\pGo from here...");//						MakeCompression ( temp10, &specSrc );						module = 1 << ((*(nodesHndls[nodenum]))->Compressor - 1);						if (CallArchiverPlugIns (true, true, module, &specSrc, NULL, temp10) != plugRetContinue)							putlog (lgALRT, "No such compressor (%s). Compression fault.", arcs[(*(nodesHndls[nodenum]))->Compressor - 1]);//long CallArchiverPlugIns (Boolean Compress, Boolean Append, long Method, FSSpecPtr srcSpec, FSSpecPtr dstSpec, StringPtr ArchName);												FSpDelete ( &specSrc );												break;					}				}								temp10[0] = 0;			}						fclose (attFile);						if ( !temp10[0] )			{//	•	No arcmail present in attaches - create and append				goto MakeNewArcMail;			}		}		else		{//	•	No attaches present - create and append				MakeNewArcMail:			GetTime ( &dtr );			sprintf ( (char *) &temp1[1], "%.8lX.%s0", -LMGetTicks (), ValidExt[dtr.dayOfWeek-1] );			temp1[0] = strlen ( (char *) &temp1[1] );			pStrConc ( (nodeaddr.point == 0) ? tempZone : tempPoint, temp1, temp10 );			temp10[temp10[0]+1] = 0;			//			MakeNewCompression ( temp10, &specSrc );			module = 1 << ((*(nodesHndls[nodenum]))->Compressor - 1);			if (CallArchiverPlugIns (true, false, module, &specSrc, NULL, temp10) != plugRetContinue)				putlog (lgALRT, "No such compressor (%s). Compression fault.", arcs[(*(nodesHndls[nodenum]))->Compressor - 1]);//long CallArchiverPlugIns (Boolean Compress, Boolean Append, long Method, FSSpecPtr srcSpec, FSSpecPtr dstSpec, StringPtr ArchName);					pStrConc ( (nodeaddr.point == 0) ? tempZone : tempPoint, attFName, temp );			temp[temp[0]+1] = 0;			attFile = fopen ( (char *) &temp[1], "a" );			fprintf ( attFile, "-%s\n", &temp10[1] );			fclose ( attFile );					FSpDelete ( &specSrc );		}	}	else	{		pStrConc ( (nodeaddr.point == 0) ? tempZone : tempPoint, attFName, temp );		temp[temp[0]+1] = 0;		attFile = fopen ( (char *) &temp[1], "r" );		if (attFile)		{					temp10[0] = 0;//	•	Attaches list already exist, try parse it and append to existant packet//	•	or move new packet and append attach			while ( fscanf ( attFile, "%[\x20-\x7e]\n", &temp1[1] ) != EOF )			{				temp1[0] = strlen ( (char *) &temp1[1] );				temp1[1] = temp1[0] - 1;				memcpy (&temp10[0], &temp1[1], temp1[0]);								iErr = GetFInfo ( temp10, 0, &fndrInfo );				if(!iErr && fndrInfo.fdCreator == 'Ravl' )	//	Validate creator…				{					if(!strncasecmp ( (char *) &temp10[temp10[0] - 3], ".PKT", 4))					{						if (FSOpen (temp10, 0, &destination_r))						{							temp10[0] = 0;							continue;						}												if (FSpOpenDF ( &specSrc, fsRdPerm, &source_r))						{							FSClose (source_r);//							temp10[0] = 0;							break;						}												SetFPos (source_r, fsFromStart, sizeof (FTS1PKTHDR));						SetFPos (destination_r, fsFromLEOF, -2);												do {														ioCounter = 512L;							FSRead (source_r, &ioCounter, r_buf);							FSWrite (destination_r, &ioCounter, r_buf);												} while (ioCounter);												FSClose (source_r);						FSClose (destination_r);												FSpDelete ( &specSrc );												break;					}				}				temp10[0] = 0;			}			fclose (attFile);						if ( !temp10[0] )			{//	•	No netmail present in attaches - create and append				goto MakeNewNetMail;			}		}		else		{					MakeNewNetMail://	•	Move bundle & make/append attach file			while ( (iErr = FSpCatMove ( &specSrc, &specDst )) != noErr )				if ( iErr == dupFNErr )				{					Delay ( 2, &dummy );							sprintf ( (char *) &temp1[1], "%.8lX.PKT", LMGetTicks () );					temp1[0] = strlen ( (char *) &temp1[1] );										FSpRename ( &specSrc, temp1 );					pStrCopy ( temp1, specSrc.name );				}				else				{					putlog ( lgALRT, "Cannot transfer bundle to outbound" );					break;				}						pStrCopy ( specSrc.name, temp1 );			if (!iErr)			{				pStrConc ( (nodeaddr.point == 0) ? tempZone : tempPoint, temp1, temp10 );				temp10[temp10[0]+1] = 0;								pStrConc ( (nodeaddr.point == 0) ? tempZone : tempPoint, attFName, temp );				temp[temp[0]+1] = 0;				specSrc.name[specSrc.name[0]+1] = 0;								attFile = fopen ( (char *) &temp[1], "a" );				fprintf ( attFile, "-%s\n", &temp10[1] );				fclose ( attFile );			}		}	}}*/