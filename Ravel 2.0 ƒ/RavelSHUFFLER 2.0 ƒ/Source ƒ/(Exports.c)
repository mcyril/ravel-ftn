#include <stdio.h>#include <string.h>#include "PKT.h"#include "Prefs.h"#include "AreaUtils.h"#include "Exports.h"#include "log.h"#include "PKTUtils.h"//#include "BaseManager.h"#include "statistic.h"extern	homeHndl		homesystem;			//	¥	Home system structextern	mailPrefHndl	mailHndl;			//	¥	Netmail structextern	short			AreasNumber;		//	¥	Areas structs listextern	areaPrefHndl	*areasHndls;extern	short			GroupsNumber;		//	¥	AreaGroups structs listextern	groupPrefHndl	*groupsHndls;extern	short			NodesNumber;		//	¥	Linked Nodes structs listextern	nodePrefHndl	*nodesHndls;extern	short			wdWorkRefNum;		//	¥	WD for bundles spoolingÉvoid ExportEchoes ( pktmsg *m, addr *from ){	juncted		newpath;	juncted		newseen;		addr		tempaddr, exportaddr;	short		ar, i, r;	pktmsg		*m2nd;	short		tempref;	Str31		tempStr;		addr		**ExportTo;	short		ExportsTo;	//	Stat.EchoMesages++;	ar = LookForAreaNumber ( m->area );		if (ar == -1)	{		putlog ( lgALRT, "Area %s not found", m->area );		return;	}		ar--;		tempaddr = ((*areasHndls[ar])->useAKA) ?							// seen-by/path		(*homesystem)->AKAAddr[(*areasHndls[ar])->useAKA-1].ad : (*homesystem)->mainAddr.ad;	ExportsTo = 0;		for ( i=0; i<(*areasHndls[ar])->numExports; i++ )	{		r = (*areasHndls[ar])->Export[i];		exportaddr = (*nodesHndls[r])->Addr;							// export-to address		if ( from != NULL && cmp2addrs ( from, &exportaddr ) )			// no route-back			continue;		if ( exportaddr.point == 0 &&			 (from != NULL || iskfalist ( &m->seenby, &exportaddr )) )	// no seened nodes route			continue;			ExportsTo++;				// make route for another nodes & my points (other points is side effected)				if ( ExportsTo == 1 )			ExportTo = (addr **) NewHandle ( 0L );			SetHandleSize ( (Handle) ExportTo, sizeof (addr)*ExportsTo );			(*ExportTo)[ExportsTo-1] = exportaddr;		}		if ( ExportsTo == 0 )	{//		putlog ( lgATTN, "Can't route message anywhere!" );		return;	}			newpath.items = 1;											// add my addr as path	newpath.nets = (short **) NewHandle ( sizeof (short) );	newpath.nodes = (short **) NewHandle ( sizeof (short) );	**newpath.nets = tempaddr.net;	**newpath.nodes = tempaddr.node;	newseen.items = ExportsTo;	newseen.nets = (short **) NewHandle ( (ExportsTo+1) * sizeof (short) );	newseen.nodes = (short **) NewHandle ( (ExportsTo+1) * sizeof (short) );	for ( i = 0; i < ExportsTo; i++ )				// add export addrs as pathes	{		(*newseen.nets)[i] = (*ExportTo)[i].net;		(*newseen.nodes)[i] = (*ExportTo)[i].node;	}		if ( from == NULL )					// local must have seen-by	{		newseen.items++;		(*newseen.nets)[ExportsTo] = tempaddr.net;		(*newseen.nodes)[ExportsTo] = tempaddr.node;	}		m2nd = (pktmsg *) NewPtr ( sizeof (pktmsg) );	NewParseKludges ( (from != NULL) ? 2 : 3, m, &m2nd, &newseen, &newpath, &tempaddr );	for ( i=0; i<(*areasHndls[ar])->numExports; i++ )	{		r = (*areasHndls[ar])->Export[i];		exportaddr = (*nodesHndls[r])->Addr;							// export-to address			NumToString ( r+1, tempStr );				if ( FSOpen ( tempStr, wdWorkRefNum, &tempref ) )		{			putlog ( lgALRT, "Bundle for %d failed in transit mail.", r );						DisposeHandle ( (Handle) newpath.nets );			DisposeHandle ( (Handle) newpath.nodes );						DisposeHandle ( (Handle) newseen.nets );			DisposeHandle ( (Handle) newseen.nodes );						FreePktMsg ( m2nd );						return;		}			m2nd->to = exportaddr;		AddMessageToPKTFile ( tempref, m2nd, NULL );			FSClose ( tempref );	}		DisposeHandle ( (Handle) newpath.nets );	DisposeHandle ( (Handle) newpath.nodes );		DisposeHandle ( (Handle) newseen.nets );	DisposeHandle ( (Handle) newseen.nodes );		FreePktMsg ( m2nd );}