#include <stdio.h>#include <string.h>#include <Folders.h>#include "PKT.h"#include "Prefs.h"#include "PascalStr.h"#include "myEnv.h"#include "log.h"#include "Toss.h"#include "Utils.h"#include "PKTUtils.h"#include "stringutl.h"#include "AreaUtils.h"#include "BaseManager.h"#include "NetMailRoute.h"#include "Attaches.h"#include "Exports.h"#include "ZipIt.h"#include "Plug-Ins.h"#include "statistic.h"#define	slProducts		5#include "Pathes.h"extern	homeHndl		homesystem;			//	•	Home system structextern	mailPrefHndl	mailHndl;			//	•	Netmail structextern	short			AreasNumber;		//	•	Areas structs listextern	areaPrefHndl	*areasHndls;extern	short			GroupsNumber;		//	•	AreaGroups structs listextern	groupPrefHndl	*groupsHndls;extern	short			NodesNumber;		//	•	Linked Nodes structs listextern	nodePrefHndl	*nodesHndls;extern	short			wdWorkRefNum;		//	•	WD for bundles spooling…extern	Boolean			StuffItExist;extern	Boolean			ZipItExist;static	char	*ValidExt[7] = { "mo", "tu", "th", "we", "fr", "sa", "su" };static	char 	*arcs[5] = { "ZIP", "ARC", "LZH", "ZOO", "ARJ" };static	char 	*pkttypes[3] = { "FTS-0001", "2.0", "2+" };void DoSlice (void);void ResolveMessage ( pktmsg *m, addr *from, Boolean toss )			//	m				-	message struct			//	from			-	from packet address			//	toss			-	TRUE if tossing, else scanning{//	addr		tempaddr;	short		aNum, kk;	char		temp1[64], temp2[64];	pktmsg		*m2nd;	if ( toss )					// • COPY TO BASE, BUILD OUTBOUND FROM INBOUND	{		if (!m->area[0])	// • NetMail message arrived		{			if ( IsItMyAddr ( &m->to ) )		// • If my - place it (netmail) in base!			{//				putlog ( lgNOPE, "NetMail %s to %s (store to base)",//							printaddr ( &m->from, temp1 ), printaddr ( &m->to, temp2 ) );//				putlog ( lgNOPE, "from %s to %s (FLAGS: %s)",//							m->fromname, m->toname, flags_to_string ( m->flags, temp1 ) );												Stat.NetMailMesages++;								if ( !CallPlugIns (plugTossMsgMail, m) )				{					if ( OpenBase ( 0 ) != 0 )					{						putlog ( lgALRT, "Internal NETMAIL opening fault." );						return;					}										m2nd = (pktmsg *) NewPtr ( sizeof (pktmsg) );					NewParseKludges ( 1, m, &m2nd, NULL, NULL, NULL );					//	•	Store message as Received						m2nd->flags |= MSGREAD;						AppendMessage ( m2nd );					FreePktMsg ( m2nd );				}								CloseBase ();			}			else								// • In transit! Route It!			{//				putlog ( lgNOPE, "NetMail %s to %s (in transit)",//							printaddr ( &m->from, temp1 ), printaddr ( &m->to, temp2 ) );				//				putlog ( lgNOPE, "from %s to %s (FLAGS: %s)",//							m->fromname, m->toname, flags_to_string ( m->flags, temp1 ) );								Stat.NetMailDirected++;					if ( !CallPlugIns (plugTossMsgMailTrs, m) )					RouteMessage ( m, TRUE );		// • Route transit message...			}		}		else				// • EchoMail message arrived		{			aNum = LookForAreaNumber ( m->area );						Stat.EchoMesages++;			//			putlog ( lgNOPE, "EchoMail in packet from %s (store in base?)",//						printaddr ( from, temp1 ) );		//			putlog ( lgNOPE, "Message from %s",//						printaddr ( &m->from, temp1 ) );			//			putlog ( lgNOPE, "from %s to %s (FLAGS: %s)",//						m->fromname, m->toname, flags_to_string ( m->flags, temp1 ) );//			putlog ( lgNOPE, "Area %s processing.", m->area );			if ( aNum == -1 )	// • Area absent			{		//	•	Check autocreate				putlog ( lgALRT, "Area %s not exist.", m->area );				for (kk = 0; kk < NodesNumber; kk++)					if ( cmp2addrs ( &(*nodesHndls[kk])->Addr, from ) )						break;								if (kk == NodesNumber || !((*nodesHndls[kk])->nodeflags & NODE_ALLOWAUTOCREATE) || !(*nodesHndls[kk])->GroupsNumber)				{		//	•	Can't autocreate - no such link or existent link has disabled autocreate option							putlog ( lgALRT, "Post it to BADMAIL (%s is unknown link or has disabled autocreate or group not present)", printaddr (from, temp1) );										if ( OpenBase ( BADAREA ) != BADAREA )					{						putlog ( lgALRT, "Internal BADMAIL opening fault." );						return;					}										AppendMessage ( m );										CloseBase ();					return;				}				else				{					areaPrefHndl	*areasHndlsNew;					short			qq;					Boolean			was;					short			prefResNum = OpenResFile ( prefFile );					short			oldResNum = CurResFile ();														areasHndlsNew = (areaPrefHndl *) NewPtr ( (AreasNumber+1) * sizeof (Handle) );										for (qq = 0; qq < AreasNumber; qq++)						areasHndlsNew[qq] = areasHndls[qq];										DisposPtr ( (Ptr) areasHndls );					areasHndls = areasHndlsNew;										areasHndls[AreasNumber] = (areaPrefHndl) NewHandle (sizeof (areaPrefType) +							(*groupsHndls[(*nodesHndls[kk])->group[0]])->numExports * sizeof (short));			//		MoveHHi ((Handle) areasHndls[AreasNumber]);			//		HLock ((Handle) areasHndls[AreasNumber]);									(*areasHndls[AreasNumber])->areaflags = (*groupsHndls[(*nodesHndls[kk])->group[0]])->areaflags;					(*areasHndls[AreasNumber])->group = (*nodesHndls[kk])->group[0];					(*areasHndls[AreasNumber])->useAKA = (*groupsHndls[(*nodesHndls[kk])->group[0]])->useAKA;					(*areasHndls[AreasNumber])->purger = (*groupsHndls[(*nodesHndls[kk])->group[0]])->purger;					(*areasHndls[AreasNumber])->numExports = (*groupsHndls[(*nodesHndls[kk])->group[0]])->numExports;									was = false;					for (qq = 0; qq < (*areasHndls[AreasNumber])->numExports; qq++)						if ( kk == ((*areasHndls[AreasNumber])->Export[qq] = (*groupsHndls[(*nodesHndls[kk])->group[0]])->Export[qq] ) )							was = true;										if (!was)					{						SetHandleSize ( (Handle) areasHndls[AreasNumber], sizeof (areaPrefType) +									((*groupsHndls[(*nodesHndls[kk])->group[0]])->numExports+1) * sizeof (short) );						(*areasHndls[AreasNumber])->Export[qq] = kk;					}										strcpy ( (char *) &(*areasHndls[AreasNumber])->areaName[1], m->area );					(*areasHndls[AreasNumber])->areaName[0] = strlen ( m->area );					AreasNumber++;					aNum = AreasNumber;										UseResFile (prefResNum);					AddResource ( (Handle) areasHndls[AreasNumber-1], areasRes, AreasNumber, "\pAutocreated…" );					WriteResource ( (Handle) areasHndls[AreasNumber-1] );					UpdateResFile (prefResNum);										DetachResource ( (Handle) areasHndls[AreasNumber-1] );					MoveHHi ((Handle) areasHndls[AreasNumber-1]);					HLock ((Handle) areasHndls[AreasNumber-1]);					UseResFile (oldResNum);					CloseResFile (prefResNum);					putlog ( lgATTN, "Area %s has been autocreated from %s", m->area, printaddr (from, temp1) );				}			}//	•		Check back address			for (kk=0; kk<(*areasHndls[aNum-1])->numExports; kk++)				if ( cmp2addrs ( &(*nodesHndls[(*areasHndls[aNum-1])->Export[kk]])->Addr, from ) )					break;						if (kk == (*areasHndls[aNum-1])->numExports)			{				putlog ( lgALRT, "Area %s not exist in export list of this node. Post it to BADMAIL", m->area );								if ( OpenBase ( BADAREA ) != BADAREA )				{					putlog ( lgALRT, "Internal BADMAIL opening fault." );					return;				}								AppendMessage ( m );								CloseBase ();				return;			}			// • Area present									if ( !CallPlugIns (plugTossMsgEcho, m) )			{				if ( OpenBase ( aNum ) != aNum )				{					putlog ( lgALRT, "Internal %s opening fault.", m->area );					return;				}					if ( !((*areasHndls[aNum-1])->areaflags & AREA_PASSTROUGH) )				{					m2nd = (pktmsg *) NewPtr ( sizeof (pktmsg) );					NewParseKludges ( 1, m, &m2nd, NULL, NULL, NULL );					//	•	Store message as Received							m2nd->flags |= MSGREAD;							AppendMessage ( m2nd );					FreePktMsg ( m2nd );				}				else					Stat.PassThrough++;									CloseBase ();			}						if ( !CallPlugIns (plugTossMsgEchoExp, m) )				ExportEchoes ( m, from );		}	}	else						// • BUILD OUTBOUND FROM BASE	{		if (!m->area[0])	// • NetMail message arrived		{			Stat.NetMailMesages++;			if ( IsItMyAddr ( &m->to ) )		// • If my - place it (netmail) in base!			{				putlog ( lgALRT, "NetMail to myself! Dropped..." );				return;			}			else								// • Out! Route It!			{//				putlog ( lgNOPE, "NetMail %s to %s (in transit)",//							printaddr ( &m->from, temp1 ), printaddr ( &m->to, temp2 ) );				//				putlog ( lgNOPE, "from %s to %s (FLAGS: %s)",//							m->fromname, m->toname, flags_to_string ( m->flags, temp1 ) );								RouteMessage ( m, FALSE );		// • Route my message...			}		}		else				// • EchoMail message outer		{			ExportEchoes ( m, from );		}	}}void ProcessPacket ( StringPtr fname, short fvref ){	short			fp;			// operating file	pktheader		*p;	pktmsg			*m;	char			tmp[64], temp1[64], temp2[64];	long			size;	unsigned short	t;			fname[fname[0]+1] = 0;	if ( FSOpen ( fname, fvref, &fp ) )	{		putlog ( lgALRT, "Inbound file %s not found.", &fname[1] );		return;	}		Stat.Packets++;		GetEOF ( fp, &size );		p = GetPktHeader ( fp );	if ( !p )	{		putlog ( lgALRT, "%s Bad packet or packet type. Ignoring.", &fname[1] );		return;	}		t = p->productCode;	if ( t > 0x00FF )	{		GetIndString ( (StringPtr) tmp, slProducts, 1 );		t = 0;	}	else		GetIndString ( (StringPtr) tmp, slProducts, t+1 );		tmp[tmp[0]+1] = 0;	//	putlog ( lgNOPE, "" );	putlog ( lgATTN, "%s from %s to %s (%s %d.%d [#%.4X], %s)", &fname[1],								printaddr ( &p->from, temp1 ),								printaddr ( &p->to, temp2 ),								&tmp[1], p->productRev >> 8, p->productRev & 0xFF, 								t, pkttypes[p->pkttype] );		while (1)	{				DoSlice ();		m = GetPktMsg ( fp, p );			if( !m )			break;		ResolveMessage ( m, &(p->from), TRUE );		// TRUE mean - Tossing		FreePktMsg (m);	}	FreePktHeader (p);	FSClose ( fp );}/*********************************************************														**	Process	number of packets from one arcmail bundle	**														*********************************************************/void ScanPackets ( StringPtr dir ){	short			mdir;						// working directory reference number…	CInfoPBRec		cipbr;						/* local pb */	HFileInfo		*fpb = (HFileInfo *)&cipbr;	/* to pointers */	short			rc, idx;	Str32			filename;	Boolean			alldone;			dir[dir[0]+1] = 0;	if ( ( mdir = myOpenWD ( dir ) ) == 0 )	{		putlog ( lgALRT, "Unable to open directory %s", &dir[1] );		return;	}	fpb->ioNamePtr = filename;	fpb->ioVRefNum = mdir;// • Killing loop...	do {		alldone = TRUE;		DoSlice ();			for ( idx=1; TRUE; idx++)		{											/* indexing loop */			fpb->ioDirID = 0L;						/* must set on each loop */			fpb->ioFDirIndex = idx;			filename[0] = 0;						rc = PBGetCatInfo( &cipbr, FALSE );			if (rc) break;							/* exit when no more entries */				if ( !(fpb->ioFlAttrib & 16) )			{										/* not folder */				filename[filename[0]+1] = 0;								if ( filename[0] > 4 &&					 !strcasecmp ( (char *) &filename[filename[0]-3], ".PKT" ) )				{					ProcessPacket ( filename, mdir );					FSDelete ( filename, mdir );					alldone = FALSE;					break;				}			}		}	} while (!alldone);		myCloseWD ( mdir );}/*****************************************************************																**	This function must decompress "fname" file (any	archiver)	**																*****************************************************************/void ProcessArchive ( StringPtr fname, short fwdRefNum ){//	Must be decompression here!	typedef struct {			FSSpec		*source;		FSSpec		*destination;				Boolean		One;		Boolean		Two;		Boolean		Tri;		Boolean		For;			} SEParam;			pascal short (*SEngEntry)( SEParam *par1, FSSpec *par2 );	FSSpec		fromSpec, toSpec, temp;	short		iErr, wdRefNum, vRefNum, EngResFile, oldRes, arcmail, module = 0;	long		dirID;	Handle		h;	SEParam		sep;	char		buf[8];	Str255		tempStr;				fname[fname[0]+1] = 0;	iErr = FSOpen ( fname, fwdRefNum, &arcmail );	if (iErr)		return;		dirID = 8;	FSRead ( arcmail, &dirID, buf );	FSClose ( arcmail );		if (strncmp(buf,"PK",2) == 0)		module = 3;			//	unzip;	if (*buf == 0x1a)					module = 4;			//	unarc;	if (strncmp(buf+2,"-l",2) == 0)		module = 5;			//	unlzh;	if (strncmp(buf,"ZOO",3) == 0)		module = 6;			//	unzoo;	if (strncmp(buf,"`\352",2) == 0)	module = 7;			//	unarj;		if (module > 4)	{		putlog ( lgATTN, "Unpacking %s impossible. (%s) is absent.", &fname[1], arcs[module-3] );		return;	}	else		if ( !module )		{			putlog ( lgATTN, "Unpacking %s impossible. Unknown archiver used.", &fname[1] );			return;		}	putlog ( lgATTN, "Unpacking: %s (%s)", &fname[1], arcs[module-3] );	iErr = FSMakeFSSpec ( fwdRefNum, 0, fname, &fromSpec );	if (iErr)		return;		pStrCopy ( tempPath, tempStr );	tempStr[0]--;		iErr = FSMakeFSSpec ( 0, 0, tempStr, &toSpec );	if (iErr)		return;	if (!StuffItExist)	{		if (module == 3)		{	//		FInfo		fndrInfo;				//		FSpGetFInfo ( &fromSpec, &fndrInfo );	//		fndrInfo.fdType = fndrInfo.fdCreator = 'ZIP ';	//		FSpSetFInfo ( &fromSpec, &fndrInfo );					MakeDecompression ( &fromSpec, &toSpec );		}	}	else	{		iErr = FindFolder ( kOnSystemDisk, kExtensionFolderType, kDontCreateFolder, &vRefNum, &dirID );		if (iErr)			return;				iErr = OpenWD ( vRefNum, dirID, 'Cyrl', &wdRefNum );		if (iErr)			return;				EngResFile = OpenRFPerm ( "\pStuffIt Engine™", wdRefNum, fsRdPerm );				if ( EngResFile != -1 )		{			oldRes = CurResFile ();			UseResFile ( EngResFile );						h = Get1Resource ( 'Eng ', module );	// for ZIP == #3			if (h)									//     ARC == #4			{							HLock ( h );				(char *) SEngEntry = StripAddress ( *h );								sep.source = &fromSpec;				sep.destination = &toSpec;								sep.One = FALSE;					// Create folder				sep.Two = FALSE; 					// Kill original				sep.Tri = FALSE;					// I dunno		//		sep.For = FALSE;								iErr = SEngEntry ( &sep, &temp );								ReleaseResource ( h );			}						UseResFile ( oldRes );						CloseResFile ( EngResFile );		}				CloseWD ( wdRefNum );	}}/*******************************************************													  **	Searching dir for arcmail &	packets				  **	(arcmail will be decompressed into temp	folder)	  **	Process	it										  **													  *******************************************************/void ScanBundles (StringPtr dir){	short			mdir;						// working directory reference number…	CInfoPBRec		cipbr;						/* local pb */	HFileInfo		*fpb = (HFileInfo *)&cipbr;	/* to pointers */	short			rc, idx;	Str32			filename;	Boolean			alldone;		int		a;	dir[dir[0]+1] = 0;	if ( ( mdir = myOpenWD ( dir ) ) == 0 )	{		putlog ( lgALRT, "Unable to open directory %s", &dir[1] );		return;	}	fpb->ioNamePtr = filename;	fpb->ioVRefNum = mdir;// • Killing loop...	do {		alldone = TRUE;		DoSlice ();				for ( idx=1; TRUE; idx++)		{											/* indexing loop */			fpb->ioDirID = 0L;						/* must set on each loop */			fpb->ioFDirIndex = idx;			filename[0] = 0;						rc = PBGetCatInfo( &cipbr, FALSE );			if (rc) break;							/* exit when no more entries */				if ( !(fpb->ioFlAttrib & 16) && filename[0] == 12 )			{										/* not folder */				if ( fpb->ioFlFndrInfo.fdType != '.PKT' )					continue;								filename[filename[0]+1] = 0;								for (a=0;a<7;a++) 					if ( !strncasecmp ( (char *) &filename[10], ValidExt[a], 2) )						break;				if(a!=7)				{		//			MakeBackup(tmp);										Stat.Archives++;										ProcessArchive ( filename, mdir ); 					ScanPackets ( tempPath );					alldone = FALSE;					FSDelete ( filename, mdir );				}				else				{					if ( !strcasecmp ( (char *) &filename[filename[0]-3], ".PKT" ) )					{		//				MakeBackup(tmp);						ProcessPacket ( filename, mdir );						alldone = FALSE;						FSDelete ( filename, mdir );					}				}			}		}	} while (!alldone);		myCloseWD ( mdir );}/****************************************************												   **	Process	Inbound	folder - look for bundles.	   **	Make netmail routing						   **	Make echo area tossing						   **	(in	other level	process	uplinks	& downlinks)   **												   ****************************************************/void Toss (void){	short			tempref, iErr, i, j, ii;	short			zero2;	Str255			tempStrSrc;	pktheader		*p;	addr			tempaddr;	DateTimeRec		dtr;	long			counter;//	•	Process with incoming bundles… (aka TOSS)	putlog ( lgATTN, "Activate Tossing." );//••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••//	•	Prepare data structures for int. use.//	•	Create all outbounds bundle templates for each listed node.	wdWorkRefNum = myOpenWD ( workPath );		p = (pktheader *) NewPtr ( sizeof (pktheader) );		if ( !wdWorkRefNum )	{		putlog ( lgALRT, "Cannot open bundles folder." );		return;	}		for ( i = -NodesNumber; i <= NodesNumber; i++ )			//	i < 0 -> Netmail	{														//	i > 0 -> ArcMail		if (!i)			continue;		ii = ((i<0) ? -i : i) - 1;				NumToString ( i, tempStrSrc );				iErr = Create ( tempStrSrc, wdWorkRefNum, 'Ravl', 'PKT ' );			if ( iErr && iErr != dupFNErr )		{			putlog ( lgALRT, "Cannot create temp bundles file." );			myCloseWD ( wdWorkRefNum );			return;		}				FSOpen ( tempStrSrc, wdWorkRefNum, &tempref );			SetEOF ( tempref, 0 );				tempaddr = ((*(nodesHndls[ii]))->yourAka) ?			(*homesystem)->AKAAddr[(*(nodesHndls[ii]))->yourAka-1].ad : (*homesystem)->mainAddr.ad;		p->from.zone = tempaddr.zone;		p->from.net = tempaddr.net;		p->from.node = tempaddr.node;		p->from.point = tempaddr.point;		p->to.zone = (*(nodesHndls[ii]))->Addr.zone;		p->to.net = (*(nodesHndls[ii]))->Addr.net;		p->to.node = (*(nodesHndls[ii]))->Addr.node;		p->to.point = (*(nodesHndls[ii]))->Addr.point;		GetTime ( &dtr );		p->year = dtr.year;		p->month = dtr.month;		p->day = dtr.day;		p->hour = dtr.hour;		p->min = dtr.minute;		p->sec = dtr.second;		for ( j = 0; j < 8; j++ )			if ( !(p->passwd[j] = (*(nodesHndls[ii]))->ArcMail_pwd[j]) )				break;						for ( ; j < 9; j++ )			p->passwd[j] = ' ';		AddPKTHeadToPKTFile ( tempref, p );			FSClose ( tempref );	}		DisposPtr ( (Ptr) p );		//••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••	ScanBundles ( inboundPath );	// • Search for all incomings//••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••//	•	Prepare data structures for ext. appls.	for ( i = -NodesNumber; i <= NodesNumber; i++ )			//	i < 0 -> Netmail	{														//	i > 0 -> ArcMail		if (!i)			continue;		ii = ((i<0) ? -i : i) - 1;				NumToString ( i, tempStrSrc );				FSOpen ( tempStrSrc, wdWorkRefNum, &tempref );		GetEOF ( tempref, &counter );				if ( counter == sizeof (FTS1PKTHDR) )		{			FSClose ( tempref );			FSDelete ( tempStrSrc, wdWorkRefNum );	//		putlog ( lgNOPE, "Outbound for %dth link is empty. Bundle has been killed.", ii );		}		else		{//	•	Append zero.zero trailer to packet to terminate it.						zero2 = 0;			GetEOF ( tempref, &counter );			SetFPos ( tempref, fsFromStart, counter );						counter = 2;			FSWrite ( tempref, &counter, &zero2 );			FSClose ( tempref );			//	•	Move & rename to outbound + create attach			ResolveArcMailToNode ( i, tempStrSrc );		}	}	myCloseWD ( wdWorkRefNum );//••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••}