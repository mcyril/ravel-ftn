#include "PKT.h"#include "Prefs.h"//#include "BaseManager.h"#include "PKTUtils.h"#include "Purge.h"#include "log.h"extern	short			AreasNumber;		//	е	Areas structs listextern	areaPrefHndl	*areasHndls;extern	mailPrefHndl	mailHndl;			//	е	Netmail structvoid DoSlice (void);void	InitProgress ( float );void	DrawProgress ( long );void Purge (void){	unsigned long	nowis, addon;	long			i, j;	indexAtomType	Atom;	 	putlog ( lgNOPE, "Marking expired messages." );	GetDateTime ( &nowis );//ееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееее	if ( OpenBase (NETMAIL) == NETMAIL )	{		addon = 60L*60L*24L*(*mailHndl)->purger;		for ( j=0; ; )			if (ReadMessageAtom ( j, &Atom ) )			{				if ( (((unsigned long) Atom.storedTime) + addon) < nowis &&					!(Atom.deleted & 0x8000) )				{					Atom.deleted = 1;					Atom.BaseReplyTo = -1;					Atom.BaseNextReply = -1;					WriteMessageAtom ( j, &Atom );					SetNumOfMessages ( GetNumOfMessages () - 1 );				}				else				{					Atom.BaseReplyTo = -1;					Atom.BaseNextReply = -1;					WriteMessageAtom ( j, &Atom );					j++;				}			}			else				break;				SetLastRead ( (GetLastRead () >= GetNumOfMessages ()) ?											((GetNumOfMessages ()) ? GetNumOfMessages ()-1 : 0) :												GetLastRead () );		CloseBase ();	}	// е Scan echoes	for ( i = 1; i <= AreasNumber; i++ )		if ( OpenBase ( i ) == i )		{			addon = 60L*60L*24L*(*areasHndls[i-1])->purger;			for ( j=0; ; )				if (ReadMessageAtom ( j, &Atom ) )				{					if ( (((unsigned long) Atom.storedTime) + addon) < nowis &&						!(Atom.deleted & 0x8000) )					{						Atom.deleted = 1;						Atom.BaseReplyTo = -1;						Atom.BaseNextReply = -1;						WriteMessageAtom ( j, &Atom );						SetNumOfMessages ( GetNumOfMessages () - 1 );					}					else					{						Atom.BaseReplyTo = -1;						Atom.BaseNextReply = -1;						WriteMessageAtom ( j, &Atom );						j++;					}				}				else					break;						SetLastRead ( (GetLastRead () >= GetNumOfMessages ()) ?												((GetNumOfMessages ()) ? GetNumOfMessages ()-1 : 0) :													GetLastRead () );			CloseBase ();		}	if ( OpenBase (BADAREA) == BADAREA )	{		addon = 60L*60L*24L*3L;		for ( j=0; ; )			if (ReadMessageAtom ( j, &Atom ) )			{				if ( (((unsigned long) Atom.storedTime) + addon) < nowis &&					!(Atom.deleted & 0x8000) )				{					Atom.deleted = 1;					WriteMessageAtom ( j, &Atom );					SetNumOfMessages ( GetNumOfMessages () - 1 );				}				else					j++;			}			else				break;		SetLastRead ( (GetLastRead () >= GetNumOfMessages ()) ?											((GetNumOfMessages ()) ? GetNumOfMessages ()-1 : 0) :												GetLastRead () );		CloseBase ();	}//ееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееее}void Pack (void){	indexAtomType	Atom;	pktmsg			*m;	long			i, j, amm;			putlog ( lgNOPE, "Removing deleted messages." );//ееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееее	if ( OpenBase (NETMAIL) == NETMAIL )	{		amm = GetNumOfMessages ();				if (amm)			InitProgress ( (float) amm );			CreateAndOpenTMP ();				for ( j=0; ; j++ )		{			DoSlice ();						if (amm)				DrawProgress (j);			if (ReadMessage ( j, &m ) )			{				AppendTMPMessage (m);				FreePktMsg (m);			}			else				break;		}				CloseBase ();		RecloseTMP ();				OpenBase (NETMAIL);		SetNumOfMessages (j);		CloseBase ();	}	// е Scan echoes	for ( i = 1; i <= AreasNumber; i++ )		if ( OpenBase ( i ) == i )		{			amm = GetNumOfMessages ();						if (amm)				InitProgress ( (float) amm );				CreateAndOpenTMP ();			for ( j=0; ; j++)			{				DoSlice ();								if (amm)					DrawProgress (j);				if (ReadMessage ( j, &m ) )				{					AppendTMPMessage (m);					FreePktMsg (m);				}				else					break;			}						CloseBase ();			RecloseTMP ();			OpenBase (i);			SetNumOfMessages (j);			CloseBase ();		}	if ( OpenBase (BADAREA) == BADAREA )	{		amm = GetNumOfMessages ();				if (amm)			InitProgress ( (float) amm );			CreateAndOpenTMP ();		for ( j=0; ; j++ )		{			DoSlice ();						if (amm)				DrawProgress (j);			if (ReadMessage ( j, &m ) )			{				AppendTMPMessage (m);				FreePktMsg (m);			}			else				break;		}				CloseBase ();		RecloseTMP ();		OpenBase (BADAREA);		SetNumOfMessages (j);		CloseBase ();	}//ееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееее}void Undel (void){	indexAtomType	Atom;	pktmsg			*m;	long			i, j;			putlog ( lgNOPE, "Restoring deleted messages." );//ееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееее	DoSlice ();	if ( OpenBase (NETMAIL) == NETMAIL )	{		UndeleteAll ();		CloseBase ();	}	// е Scan echoes	for ( i = 1; i <= AreasNumber; i++ )		if ( OpenBase ( i ) == i )		{			DoSlice ();			UndeleteAll ();			CloseBase ();		}	if ( OpenBase (BADAREA) == BADAREA )	{		UndeleteAll ();		CloseBase ();	}//ееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееее}