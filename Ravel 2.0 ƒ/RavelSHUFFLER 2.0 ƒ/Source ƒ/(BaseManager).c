#include <string.h>#include <stdio.h>#include "PKT.h"#include "Prefs.h"#include "AreaUtils.h"#include "BaseManager.h"#include "Pathes.h"#include "Utils.h"#include "myEnv.h"#include "PascalStr.h"#include "stringutl.h"									extern	homeHndl		homesystem;			//	¥	Home system structextern	mailPrefHndl	mailHndl;			//	¥	Netmail structextern	short			AreasNumber;		//	¥	Areas structs listextern	areaPrefHndl	*areasHndls;extern	short			GroupsNumber;		//	¥	AreaGroups structs listextern	groupPrefHndl	*groupsHndls;extern	short			NodesNumber;		//	¥	Linked Nodes structs listextern	nodePrefHndl	*nodesHndls;static	short	storeddeleted;static	long	BaseReplyTo;static	long	BaseNextReply;static	short	CurrentBaseNumber;static	Str255	CurrentArea;static	short	wdBaseVRef;static	short	CBIndexRef;static	short	CBHeadRef;static	short	CBTextRef;static	baseHndl			HBase;//static	baseIndexHeaderType	HeaderBase;void putProgressName (Str255 name);void DoSlice (void);//	¥ Prepare mesage basesBoolean InitBase (void){	CurrentBaseNumber = -1;		wdBaseVRef = myOpenWD ( basePath );	return ( wdBaseVRef != 0 );}//	¥ Dispose mesage basesBoolean DisposBase (void){	if ( CurrentBaseNumber != -1 )		return FALSE;		myCloseWD ( wdBaseVRef );	return TRUE;}Boolean BaseAjust (void){	short		i;		for ( i = 1; i <= AreasNumber; i++ )		if ( OpenBase ( i ) != i )			return FALSE;		else			CloseBase ();	if ( OpenBase ( BADAREA ) != BADAREA )		return FALSE;	else		CloseBase ();	if ( OpenBase ( NETMAIL ) != NETMAIL )		return FALSE;	else		CloseBase ();	return TRUE;}/*Boolean ReadBaseHeader (void){	short	iErr;	long	counter;		SetFPos ( CBIndexRef, fsFromStart, 0 );	counter = sizeof (baseIndexHeaderType);	iErr = FSRead ( CBIndexRef, &counter, &HeaderBase );	return ( iErr == 0 ) ? sizeof (baseIndexHeaderType) == counter : FALSE;}Boolean WriteBaseHeader (void){	short	iErr;	long	counter;		SetFPos ( CBIndexRef, fsFromStart, 0 );	counter = sizeof (baseIndexHeaderType);	iErr = FSWrite ( CBIndexRef, &counter, &HeaderBase );	return ( iErr == 0 ) ? sizeof (baseIndexHeaderType) == counter : FALSE;}*///	¥ Open message base # AreaNumber//	¥ Return AreaNumber if success or number of opened base//	¥ Return -1 if error occured due opening baseshort OpenBase ( short AreaNumber ){	short		iErr, ii;	Str255		CBIndexName, CBHeadName, CBTextName, sss;	long		indexSize, ccc;				DoSlice ();	if ( CurrentBaseNumber != -1 )		return CurrentBaseNumber;		if ( AreaNumber > AreasNumber )		return -1;		switch ( AreaNumber )	{		case BADAREA:	pStrCopy ( "\pBADMAIL", CurrentArea );								break;		case NETMAIL:	pStrCopy ( "\pNETMAIL", CurrentArea );								break;		default:		pStrCopy ( (*areasHndls[AreaNumber-1])->areaName, CurrentArea );	break;	}		putProgressName (CurrentArea);		CurrentArea[CurrentArea[0]+1] = 0;		if (CurrentArea[0] > 16)	{		pStrCopy ( CurrentArea, CBIndexName );				ccc = 0L;		for (ii=0; ii < CBIndexName[0]; ii++)		{			ccc += CBIndexName[ii];			ccc = (ccc << 1) | (ccc >> 31);		}		sprintf ((char *) &CBIndexName[17], "%.8lX", ccc);		CBIndexName[0] = strlen ((char *) &CBIndexName[1]);				pStrConc ( CBIndexName, "\p.HEAD", CBHeadName );		pStrConc ( CBIndexName, "\p.TEXT", CBTextName );		pStrConc ( CBIndexName, "\p.INDEX", CBIndexName );	}	else	{		pStrConc ( CurrentArea, "\p.INDEX", CBIndexName );		pStrConc ( CurrentArea, "\p.HEAD", CBHeadName );		pStrConc ( CurrentArea, "\p.TEXT", CBTextName );	}		if ( (iErr = FSOpen ( CBIndexName, wdBaseVRef, &CBIndexRef )) != noErr )		if ( iErr == fnfErr )		{			baseIndexHeaderType	HeaderBase;			long				counter;								iErr = Create ( CBIndexName, wdBaseVRef, 'Ravl', 'BasI' );			if ( iErr )				return -1;							iErr = FSOpen ( CBIndexName, wdBaseVRef, &CBIndexRef );			if ( iErr )				return -1;							memset ( &HeaderBase, 0, sizeof (baseIndexHeaderType) );						HeaderBase.busy = 0;//			pStrCopy ( CurrentArea, HeaderBase.AreaName );//			HeaderBase.AreaName[HeaderBase.AreaName[0]+1] = 0;			HeaderBase.CRCIndex = 0;			HeaderBase.CRCText = 0;			HeaderBase.NumberOfMessages = 0;			HeaderBase.lastRead = 0;						counter = sizeof (baseIndexHeaderType);			if ( FSWrite (CBIndexRef, &counter, &HeaderBase) )			{				FSClose ( CBIndexRef );				return -1;			}		}		else			return -1;	GetEOF ( CBIndexRef, &indexSize );	if ( (iErr = FSOpen ( CBHeadName, wdBaseVRef, &CBHeadRef )) != noErr )		if ( iErr == fnfErr )		{			iErr = Create ( CBHeadName, wdBaseVRef, 'Ravl', 'BasT' );			if ( iErr )			{				FSClose ( CBIndexRef );				return -1;			}						iErr = FSOpen ( CBHeadName, wdBaseVRef, &CBHeadRef );			if ( iErr )			{				FSClose ( CBIndexRef );				return -1;			}		}		else		{			FSClose ( CBIndexRef );			return -1;		}		if ( (iErr = FSOpen ( CBTextName, wdBaseVRef, &CBTextRef )) != noErr )		if ( iErr == fnfErr )		{			iErr = Create ( CBTextName, wdBaseVRef, 'Ravl', 'BasT' );			if ( iErr )			{				FSClose ( CBHeadRef );				FSClose ( CBIndexRef );				return -1;			}						iErr = FSOpen ( CBTextName, wdBaseVRef, &CBTextRef );			if ( iErr )			{				FSClose ( CBHeadRef );				FSClose ( CBIndexRef );				return -1;			}		}		else		{			FSClose ( CBHeadRef );			FSClose ( CBIndexRef );			return -1;		}	HBase = (baseHndl) NewHandle (indexSize);		SetFPos ( CBIndexRef, fsFromStart, 0L );		if ( FSRead ( CBIndexRef, &indexSize, (Ptr) *HBase ) )	{		FSClose ( CBIndexRef );		FSClose ( CBHeadRef );		FSClose ( CBTextRef );				DisposeHandle ( (Handle) HBase );				return -1;	}		CurrentBaseNumber = AreaNumber;		return AreaNumber;}Boolean CloseBase (void){	long	counter;	if ( CurrentBaseNumber == -1 )		return FALSE;	SetFPos ( CBIndexRef, fsFromStart, 0L );	SetEOF ( CBIndexRef, 0L );	counter = GetHandleSize ( (Handle) HBase );	FSWrite ( CBIndexRef, &counter, (Ptr) *HBase );		FSClose ( CBIndexRef );	FSClose ( CBHeadRef );	FSClose ( CBTextRef );		DisposeHandle ( (Handle) HBase );	CurrentBaseNumber = -1;	return TRUE;}static long RealNum (long Num){	long	counter = (GetHandleSize ( (Handle) HBase ) - sizeof (baseIndexHeaderType)) /																			sizeof (indexAtomType);	long	i, j;		if (counter)	{		for ( j = 0, i = 0; j < (*HBase)->NumberOfMessages; i++ )			if ( ((*HBase)->indexAtom[i].deleted & 0x0003) == 0 )				if ( j == Num )					return i;				else					j++;	}		return 0x7FFFFFFF;}Boolean ReadMessageAtom ( long MsgNum, indexAtomPtr Atom ){	short		iErr;	long		counter = RealNum (MsgNum);		if ( MsgNum >= (*HBase)->NumberOfMessages )		return FALSE;	if ( counter*sizeof(indexAtomType) + sizeof (baseIndexHeaderType) >= GetHandleSize ((Handle)HBase) )		return FALSE;	*Atom = (*HBase)->indexAtom[counter];	return TRUE;}Boolean WriteMessageAtom ( long MsgNum, indexAtomPtr Atom ){	short		iErr;	long		counter;	if ( MsgNum > (*HBase)->NumberOfMessages )		// Can append here!		return FALSE;	if ( MsgNum == (*HBase)->NumberOfMessages )		// Append	{		counter = (GetHandleSize ( (Handle) HBase ) - sizeof (baseIndexHeaderType)) /																			sizeof (indexAtomType);		SetHandleSize ( (Handle) HBase, (counter+1)*sizeof (indexAtomType) +																	sizeof (baseIndexHeaderType));		(*HBase)->indexAtom[counter] = *Atom;		(*HBase)->NumberOfMessages++;	}	else	{		counter = RealNum (MsgNum);		(*HBase)->indexAtom[counter] = *Atom;	}}long GetNumOfMessages (void){	return (*HBase)->NumberOfMessages;}long GetLastRead (void){	return (*HBase)->lastRead;}short GetDirtyFlag (void){	return (*HBase)->busy;}void SetNumOfMessages ( long Messages ){	(*HBase)->NumberOfMessages = Messages;}void SetLastRead ( long CurrentMsg ){	(*HBase)->lastRead = CurrentMsg;}void SetDirtyFlag ( short dirty ){	(*HBase)->busy = dirty;}Boolean ReadMessage ( long MsgNum, pktmsg **m ){	indexAtomType	Atom;	long			baseTextSize;	long			counter;	char			fromname[MName],					toname[MName];	char			date[MDate],					subj[MSubject];	Handle			h;		if ( !ReadMessageAtom ( MsgNum, &Atom ) )		return FALSE;	storeddeleted = Atom.deleted;	BaseReplyTo = Atom.BaseReplyTo;	BaseNextReply = Atom.BaseNextReply;		if ( SetFPos (CBHeadRef, fsFromStart, Atom.headOffset) )		return FALSE;	if ( !GetASCIIZ ( CBHeadRef, fromname, MName ) ||		 !GetASCIIZ ( CBHeadRef, toname, MName ) ||		 !GetASCIIZ ( CBHeadRef, date, MDate ) ||		 !GetASCIIZ ( CBHeadRef, subj, MSubject ) )		return FALSE;	if ( SetFPos (CBTextRef, fsFromStart, Atom.textOffset) )		return FALSE;	h = NewHandle ( 0 );	if ( !GetMSGText ( CBTextRef, h ) )		return FALSE;	*m = (pktmsg *) NewPtr ( sizeof (pktmsg) );		(*m)->flags = Atom.flags;		(*m)->from = Atom.from;	(*m)->to = Atom.to;	(*m)->reply = Atom.reply;		(*m)->msgid = Atom.msgID;	(*m)->replyid = Atom.repID;	(*m)->storedtime = Atom.storedTime;	strcpy ( (*m)->date, date );	strcpy ( (*m)->toname, toname );	strcpy ( (*m)->fromname, fromname );	strcpy ( (*m)->subj, subj );	(*m)->text = h;//	(*HBase)->AreaName[(*HBase)->AreaName[0]+1] = 0;//	if (CurrentBaseNumber)//		strcpy ( (*m)->area, (char *) &(*HBase)->AreaName[1] );//	else//		(*m)->area[0] = 0;	if (CurrentBaseNumber)		strcpy ( (*m)->area, (char *) &CurrentArea[1] );	else		(*m)->area[0] = 0;	(*m)->seenby.nodes = (*m)->seenby.nets = NULL;	(*m)->path.nodes = (*m)->path.nets = NULL;	(*m)->path.items = (*m)->seenby.items = 0;	return TRUE;}Boolean AppendMessage ( pktmsg *m ){	indexAtomType	Atom;	long			baseTextSize;	long			counter;			memset ( &Atom, 0, sizeof (indexAtomType) );	Atom.flags = m->flags;	Atom.deleted = 0;		Atom.from = m->from;	Atom.to = m->to;	Atom.reply = m->reply;		Atom.msgID = m->msgid;	Atom.repID = m->replyid;	Atom.BaseReplyTo = -1;	Atom.BaseNextReply = -1;	GetEOF ( CBHeadRef, &baseTextSize );	Atom.headOffset = baseTextSize;	SetFPos ( CBHeadRef, fsFromLEOF, 0L );		counter = strlen ( m->fromname ) + 1;	FSWrite ( CBHeadRef, &counter, m->fromname );	counter = strlen ( m->toname ) + 1;	FSWrite ( CBHeadRef, &counter, m->toname );	counter = strlen ( m->date ) + 1;	FSWrite ( CBHeadRef, &counter, m->date );	counter = strlen ( m->subj ) + 1;	FSWrite ( CBHeadRef, &counter, m->subj );	GetEOF ( CBTextRef, &baseTextSize );	Atom.textOffset = baseTextSize;		SetFPos ( CBTextRef, fsFromLEOF, 0 );	counter = GetHandleSize ( m->text );	FSWrite ( CBTextRef, &counter, *(m->text) );	if (!m->storedtime)	{		GetDateTime ( (unsigned long *) &Atom.storedTime );		m->storedtime = Atom.storedTime;	}	else		Atom.storedTime = m->storedtime;	WriteMessageAtom ( (*HBase)->NumberOfMessages, &Atom );		return TRUE;}static short	indRef;static short	headRef;static short	textRef;Boolean CreateAndOpenTMP (void){	short		iErr;	Str255				CBIndexName, CBHeadName, CBTextName;	long				indexSize;	baseIndexHeaderType	HeaderBase;	long				counter;	Str255				TArea;			pStrCopy ( "\p$$$TEMP$$$", TArea );		pStrConc ( TArea, "\p.INDEX", CBIndexName );	pStrConc ( TArea, "\p.HEAD", CBHeadName );	pStrConc ( TArea, "\p.TEXT", CBTextName );	if ( (iErr = FSOpen ( CBIndexName, wdBaseVRef, &indRef )) != noErr )		if ( iErr == fnfErr )		{					iErr = Create ( CBIndexName, wdBaseVRef, 'Ravl', 'BasI' );			if ( iErr )				return -1;							iErr = FSOpen ( CBIndexName, wdBaseVRef, &indRef );			if ( iErr )				return -1;		}		else			return -1;	SetFPos ( indRef, fsFromStart, 0L );	memset ( &HeaderBase, 0, sizeof (baseIndexHeaderType) );	HeaderBase.busy = (*HBase)->busy;//	pStrCopy ( CurrentArea, HeaderBase.AreaName );//	HeaderBase.AreaName[HeaderBase.AreaName[0]+1] = 0;	HeaderBase.CRCIndex = 0;	HeaderBase.CRCText = 0;	HeaderBase.NumberOfMessages = (*HBase)->NumberOfMessages;	HeaderBase.lastRead = (*HBase)->lastRead;		counter = sizeof (baseIndexHeaderType);	if ( FSWrite (indRef, &counter, &HeaderBase) )	{		FSClose ( CBIndexRef );		return -1;	}	SetEOF ( indRef, sizeof (baseIndexHeaderType) );	if ( (iErr = FSOpen ( CBHeadName, wdBaseVRef, &headRef )) != noErr )		if ( iErr == fnfErr )		{			iErr = Create ( CBHeadName, wdBaseVRef, 'Ravl', 'BasT' );			if ( iErr )			{				FSClose ( indRef );				return -1;			}						iErr = FSOpen ( CBHeadName, wdBaseVRef, &headRef );			if ( iErr )			{				FSClose ( indRef );				return -1;			}		}		else		{			FSClose ( indRef );			return -1;		}		if ( (iErr = FSOpen ( CBTextName, wdBaseVRef, &textRef )) != noErr )		if ( iErr == fnfErr )		{			iErr = Create ( CBTextName, wdBaseVRef, 'Ravl', 'BasT' );			if ( iErr )			{				FSClose ( headRef );				FSClose ( indRef );				return -1;			}						iErr = FSOpen ( CBTextName, wdBaseVRef, &textRef );			if ( iErr )			{				FSClose ( headRef );				FSClose ( indRef );				return -1;			}		}		else		{			FSClose ( headRef );			FSClose ( indRef );			return -1;		}	SetFPos ( headRef, fsFromStart, 0L );	SetFPos ( textRef, fsFromStart, 0L );	SetEOF ( headRef, 0L );	SetEOF ( textRef, 0L );		return TRUE;}Boolean RecloseTMP (void){	short		iErr, ii;	Str63				CBIndexName, CBHeadName, CBTextName, CBIndexName1, CBHeadName1, CBTextName1;	long				indexSize, ccc;	baseIndexHeaderType	HeaderBase;	long				counter;	Str255				TArea;	FSSpec				specSrc;			FSClose ( headRef );	FSClose ( indRef );	FSClose ( textRef );	CurrentArea[CurrentArea[0]+1] = 0;		if (CurrentArea[0] > 16)	{		pStrCopy ( CurrentArea, CBIndexName1 );				ccc = 0L;		for (ii=0; ii < CBIndexName1[0]; ii++)		{			ccc += CBIndexName1[ii];			ccc = (ccc << 1) | (ccc >> 31);		}		sprintf ((char *) &CBIndexName1[17], "%.8lX", ccc);		CBIndexName1[0] = strlen ((char *) &CBIndexName1[1]);				pStrConc ( CBIndexName1, "\p.HEAD", CBHeadName1 );		pStrConc ( CBIndexName1, "\p.TEXT", CBTextName1 );		pStrConc ( CBIndexName1, "\p.INDEX", CBIndexName1 );	}	else	{		pStrConc ( CurrentArea, "\p.INDEX", CBIndexName1 );		pStrConc ( CurrentArea, "\p.HEAD", CBHeadName1 );		pStrConc ( CurrentArea, "\p.TEXT", CBTextName1 );	}//	pStrConc ( CurrentArea, "\p.INDEX", CBIndexName1 );//	pStrConc ( CurrentArea, "\p.HEAD", CBHeadName1 );//	pStrConc ( CurrentArea, "\p.TEXT", CBTextName1 );	FSDelete ( CBIndexName1, wdBaseVRef );	FSDelete ( CBHeadName1, wdBaseVRef );	FSDelete ( CBTextName1, wdBaseVRef );	pStrCopy ( "\p$$$TEMP$$$", TArea );		pStrConc ( TArea, "\p.INDEX", CBIndexName );	pStrConc ( TArea, "\p.HEAD", CBHeadName );	pStrConc ( TArea, "\p.TEXT", CBTextName );	FSMakeFSSpec ( wdBaseVRef, 0L, CBIndexName, &specSrc );	FSpRename ( &specSrc, CBIndexName1 );		FSMakeFSSpec ( wdBaseVRef, 0L, CBHeadName, &specSrc );	FSpRename ( &specSrc, CBHeadName1 );		FSMakeFSSpec ( wdBaseVRef, 0L, CBTextName, &specSrc );	FSpRename ( &specSrc, CBTextName1 );		return TRUE;}Boolean AppendTMPMessage ( pktmsg *m ){	indexAtomType	Atom;	long			baseTextSize;	long			counter;			memset ( &Atom, 0, sizeof (indexAtomType) );	Atom.flags = m->flags;	Atom.deleted = storeddeleted & 0xFF00;		Atom.from = m->from;	Atom.to = m->to;	Atom.reply = m->reply;		Atom.msgID = m->msgid;	Atom.repID = m->replyid;	Atom.BaseReplyTo = BaseReplyTo;	Atom.BaseNextReply = BaseNextReply;	GetEOF ( headRef, &baseTextSize );	Atom.headOffset = baseTextSize;	SetFPos ( headRef, fsFromLEOF, 0L );		counter = strlen ( m->fromname ) + 1;	FSWrite ( headRef, &counter, m->fromname );	counter = strlen ( m->toname ) + 1;	FSWrite ( headRef, &counter, m->toname );	counter = strlen ( m->date ) + 1;	FSWrite ( headRef, &counter, m->date );	counter = strlen ( m->subj ) + 1;	FSWrite ( headRef, &counter, m->subj );	GetEOF ( textRef, &baseTextSize );	Atom.textOffset = baseTextSize;		SetFPos ( textRef, fsFromLEOF, 0 );	counter = GetHandleSize ( m->text );	FSWrite ( textRef, &counter, *(m->text) );	if (!m->storedtime)	{		GetDateTime ( (unsigned long *) &Atom.storedTime );		m->storedtime = Atom.storedTime;	}	else		Atom.storedTime = m->storedtime;	SetFPos ( indRef, fsFromLEOF, 0L );		counter = sizeof (indexAtomType);	FSWrite ( indRef, &counter, &Atom );	return TRUE;}void UndeleteAll (void){	short		i;	long		message = RealNum ( GetLastRead () );	long		counter = (GetHandleSize ( (Handle) HBase ) - sizeof (baseIndexHeaderType)) /																		sizeof (indexAtomType);	long		realnum = 0;	if (!counter)		return;	if (!GetNumOfMessages ())		message = 0;	for ( i = 0; i < counter; i++ )	{		(*HBase)->indexAtom[i].BaseReplyTo = -1;		(*HBase)->indexAtom[i].BaseNextReply = -1;		if ( ((*HBase)->indexAtom[i].deleted & 0x00FF) == 1 )		{			realnum++;			(*HBase)->indexAtom[i].deleted = 0;		}		else			if ( ((*HBase)->indexAtom[i].deleted & 0x00FF) == 0 )				realnum++;			else				if (message)					message--;	}		SetLastRead ( message );	SetNumOfMessages ( realnum );}