#include <stdio.h>#include <string.h>#include "ravel_msg_base.h"#include "ravel_tmp_base.h"#include "pktparse.h"#include "Ravel_Prefs.h"#include "AreaUtils.h"#include "Exports.h"#include "log.h"#include "stringutl.h"#include "busy.h"#include "myEnv.h"#include "Pathes.h"#include "statistic.h"extern	short	type2plus;extern	homeHndl		homesystem;			//	¥	Home system structextern	mailPrefHndl	mailHndl;			//	¥	Netmail structextern	short			AreasNumber;		//	¥	Areas structs listextern	areaPrefHndl	*areasHndls;extern	short			GroupsNumber;		//	¥	AreaGroups structs listextern	groupPrefHndl	*groupsHndls;extern	short			NodesNumber;		//	¥	Linked Nodes structs listextern	nodePrefHndl	*nodesHndls;extern	short			wdWorkRefNum;		//	¥	WD for bundles spoolingÉtypedef struct _exp_list {	addr	export_to;	short	number;} exp_list, *exp_list_p, **exp_list_h;extern	long	MaxArcSize;void ExportEchoes ( pktmsg *m, addr *from ){	juncted		newpath;	juncted		newseen;		addr		tempaddr, exportaddr;	short		ar, i, j, r;	pktmsg		*m2nd;	short		tempref, iErr;	exp_list_h	ExportTo;	short		ExportsTo;		char		tmp[256], temp[128];	Handle		h;		FSSpec		spec;	pktheader	*p;		DateTimeRec	dtr;		long		counter, f_time, f_size;	//	Stat.EchoMesages++;	ar = LookForAreaNumber ( m->area );		if (ar == -1)	{		putlog ( lgALRT, "Area %s not found", m->area );		return;	}		ar--;		tempaddr = ((*areasHndls[ar])->useAKA) ?							// seen-by/path		(*homesystem)->AKAAddr[(*areasHndls[ar])->useAKA-1].ad : (*homesystem)->mainAddr.ad;	ExportsTo = 0;	ExportTo = (exp_list_h) NewHandle ((*areasHndls[ar])->numExports * sizeof(exp_list));		for ( i=0; i<(*areasHndls[ar])->numExports; i++ )	{		r = (*areasHndls[ar])->Export[i].Export;		exportaddr = (*nodesHndls[r])->Addr;							// export-to address//		from != NULL means not SCAN		if (from != NULL && cmp2addrs ( from, &exportaddr ))			// no route-back			continue;		if (from != NULL && exportaddr.point == 0 && iskfalist ( &m->seenby, &exportaddr ))	// no seened nodes route			continue;			ExportsTo++;	// make route for another nodes & my points (other points is side effected)		(*ExportTo)[ExportsTo-1].export_to = exportaddr;		(*ExportTo)[ExportsTo-1].number = r;	}		if ( ExportsTo == 0 )	{		DisposeHandle ((Handle) ExportTo);		return;	}			newpath.items = 1;											// add my addr as path	newpath.nets = (short **) NewHandle ( sizeof (short) );	newpath.nodes = (short **) NewHandle ( sizeof (short) );	**newpath.nets = tempaddr.net;	**newpath.nodes = tempaddr.node;	newseen.items = ExportsTo;	newseen.nets = (short **) NewHandle ( (ExportsTo+1) * sizeof (short) );	newseen.nodes = (short **) NewHandle ( (ExportsTo+1) * sizeof (short) );	for ( i = 0; i < ExportsTo; i++ )				// add export addrs as pathes	{		(*newseen.nets)[i] = (*ExportTo)[i].export_to.net;		(*newseen.nodes)[i] = (*ExportTo)[i].export_to.node;	}		if ( from == NULL )					// local must have seen-by	{		newseen.items++;		(*newseen.nets)[ExportsTo] = tempaddr.net;		(*newseen.nodes)[ExportsTo] = tempaddr.node;	}		m2nd = (pktmsg *) NewPtr ( sizeof (pktmsg) );	parse_kludges ( ((from != NULL) ? PMODE_TRANSIT : PMODE_PREPNEW), m, &m2nd, &newseen, &newpath, &tempaddr );	for ( i=0; i<ExportsTo; i++ )	{		r = (*ExportTo)[i].number;		exportaddr = (*ExportTo)[i].export_to;		// export-to address	//		NumToString ( r+1, tempStr );		//		if ( FSOpen ( tempStr, wdWorkRefNum, &tempref ) )		get_flo_pathname (&exportaddr, workPath, (StringPtr) tmp);		strcat (&tmp[1], ".000");		tmp[0] = strlen (&tmp[1]);				do {					iErr = GetInfFile (0, (StringPtr) tmp, (unsigned long *) &f_time, (unsigned long *) &f_size );						if (iErr == noErr)			{				if (f_size < (MaxArcSize*3))					break;				else				{					if (tmp[tmp[0]] >= '9')						tmp[tmp[0]] = 'A';					else						if (tmp[tmp[0]] == 'Z')							break;						else							tmp[tmp[0]]++;				}			}				} while (iErr == noErr);		//		iErr = FSMakeFSSpec ( 0, 0, (StringPtr) tmp, &spec );		if (iErr == fnfErr)		{			p = (pktheader *) NewPtr ( sizeof (pktheader) );			Create ( (StringPtr) tmp, 0, 'Ravl', 'PKT ' );			FSOpen ( (StringPtr) tmp, 0, &tempref );			tempaddr = ((*nodesHndls[r])->yourAka) ?				(*homesystem)->AKAAddr[(*nodesHndls[r])->yourAka-1].ad : (*homesystem)->mainAddr.ad;						p->from.zone = tempaddr.zone;			p->from.net = tempaddr.net;			p->from.node = tempaddr.node;			p->from.point = tempaddr.point;			p->to.zone = exportaddr.zone;			p->to.net = exportaddr.net;			p->to.node = exportaddr.node;			p->to.point = exportaddr.point;			GetTime ( &dtr );			p->year = dtr.year;			p->month = dtr.month;			p->day = dtr.day;			p->hour = dtr.hour;			p->min = dtr.minute;			p->sec = dtr.second;			for ( j = 0; j < 9; j++ )				p->passwd[j] = 0;			for ( j = 0; j < 8; j++ )				if ( !(p->passwd[j] = (*(nodesHndls[r]))->ArcMail_pwd[j]) )					break;			p->pkttype = type2plus;			AddPKTHeadToPKTFile ( tempref, p );			DisposePtr ( (Ptr) p );		}		else			if (iErr == noErr)			{				FSOpen ( (StringPtr) tmp, 0, &tempref );				GetEOF ( tempref, &counter );				SetEOF ( tempref, counter - 2 );				SetFPos ( tempref, fsFromLEOF, 0 );			}			else			{				putlog ( lgALRT, "Can't create bundle for %s.", printaddr (&exportaddr, temp) );								DisposeHandle ( (Handle) newpath.nets );				DisposeHandle ( (Handle) newpath.nodes );								DisposeHandle ( (Handle) newseen.nets );				DisposeHandle ( (Handle) newseen.nodes );								DisposeHandle ((Handle) ExportTo);								FreePktMsg ( m2nd );								return;			}			m2nd->to = exportaddr;		AddMessageToPKTFile ( tempref, m2nd, NULL );			iErr = 0;		counter = 2;		FSWrite ( tempref, &counter, &iErr );				FSClose ( tempref );	}	DisposeHandle ( (Handle) newpath.nets );	DisposeHandle ( (Handle) newpath.nodes );		DisposeHandle ( (Handle) newseen.nets );	DisposeHandle ( (Handle) newseen.nodes );		DisposeHandle ((Handle) ExportTo);	if (from != NULL)	{//	swap texts to preserve seen+by and pathes		h = m2nd->text;		m2nd->text = m->text;		m->text = h;	}		FreePktMsg ( m2nd );}void ExportEchoesOnlyTo ( pktmsg *m, addr *from, addr *to ){	juncted		newpath;	juncted		newseen;		addr		tempaddr;	short		ar, i, j, r;	pktmsg		*m2nd;	short		tempref, iErr;	char		tmp[256], temp[128];	Handle		h;		FSSpec		spec;	pktheader	*p;		DateTimeRec	dtr;		long		counter, f_time, f_size;	//	Stat.EchoMesages++;	ar = LookForAreaNumber ( m->area );		if (ar == -1)	{		putlog ( lgALRT, "Area %s not found", m->area );		return;	}		ar--;		tempaddr = ((*areasHndls[ar])->useAKA) ?							// seen-by/path		(*homesystem)->AKAAddr[(*areasHndls[ar])->useAKA-1].ad : (*homesystem)->mainAddr.ad;	newpath.items = 1;											// add my addr as path	newpath.nets = (short **) NewHandle ( sizeof (short) );	newpath.nodes = (short **) NewHandle ( sizeof (short) );	**newpath.nets = tempaddr.net;	**newpath.nodes = tempaddr.node;	newseen.items = (*areasHndls[ar])->numExports;	newseen.nets = (short **) NewHandle (((*areasHndls[ar])->numExports+1) * sizeof (short));	newseen.nodes = (short **) NewHandle (((*areasHndls[ar])->numExports+1) * sizeof (short));	for (i=0; i<(*areasHndls[ar])->numExports; i++)	{		(*newseen.nets)[i] = (*nodesHndls[(*areasHndls[ar])->Export[i].Export])->Addr.net;		(*newseen.nodes)[i] = (*nodesHndls[(*areasHndls[ar])->Export[i].Export])->Addr.node;	}		if (from == NULL)	{		newseen.items++;		(*newseen.nets)[(*areasHndls[ar])->numExports] = tempaddr.net;		(*newseen.nodes)[(*areasHndls[ar])->numExports] = tempaddr.node;	}		m2nd = (pktmsg *) NewPtr ( sizeof (pktmsg) );	parse_kludges ( (from != NULL) ? PMODE_TRANSIT : PMODE_PREPNEW, m, &m2nd, &newseen, &newpath, &tempaddr );	get_flo_pathname (to, workPath, (StringPtr) tmp);	strcat (&tmp[1], ".000");	tmp[0] = strlen (&tmp[1]);		do {			iErr = GetInfFile (0, (StringPtr) tmp, (unsigned long *) &f_time, (unsigned long *) &f_size );				if (iErr == noErr)		{			if (f_size < (MaxArcSize*3))				break;			else			{				if (tmp[tmp[0]] == '9')					break;				else					tmp[tmp[0]]++;			}		}		} while (iErr == noErr);			if (iErr == fnfErr)	{		p = (pktheader *) NewPtr ( sizeof (pktheader) );		Create ( (StringPtr) tmp, 0, 'Ravl', 'PKT ' );		FSOpen ( (StringPtr) tmp, 0, &tempref );				r = LookForLinkNumber (to);				tempaddr = ((*nodesHndls[r])->yourAka) ?			(*homesystem)->AKAAddr[(*nodesHndls[r])->yourAka-1].ad : (*homesystem)->mainAddr.ad;				p->from.zone = tempaddr.zone;		p->from.net = tempaddr.net;		p->from.node = tempaddr.node;		p->from.point = tempaddr.point;		p->to.zone = to->zone;		p->to.net = to->net;		p->to.node = to->node;		p->to.point = to->point;		GetTime ( &dtr );		p->year = dtr.year;		p->month = dtr.month;		p->day = dtr.day;		p->hour = dtr.hour;		p->min = dtr.minute;		p->sec = dtr.second;		for ( j = 0; j < 9; j++ )			p->passwd[j] = 0;		for ( j = 0; j < 8; j++ )			if ( !(p->passwd[j] = (*(nodesHndls[r]))->ArcMail_pwd[j]) )				break;		p->pkttype = type2plus;		AddPKTHeadToPKTFile ( tempref, p );		DisposePtr ( (Ptr) p );	}	else		if (iErr == noErr)		{			FSOpen ( (StringPtr) tmp, 0, &tempref );			GetEOF ( tempref, &counter );			SetEOF ( tempref, counter - 2 );			SetFPos ( tempref, fsFromLEOF, 0 );		}		else		{			putlog ( lgALRT, "Can't create bundle for %s.", printaddr (to, temp) );						DisposeHandle ( (Handle) newpath.nets );			DisposeHandle ( (Handle) newpath.nodes );						DisposeHandle ( (Handle) newseen.nets );			DisposeHandle ( (Handle) newseen.nodes );						FreePktMsg ( m2nd );						return;		}	m2nd->to = *to;	AddMessageToPKTFile ( tempref, m2nd, NULL );	iErr = 0;	counter = 2;	FSWrite ( tempref, &counter, &iErr );		FSClose ( tempref );	DisposeHandle ( (Handle) newpath.nets );	DisposeHandle ( (Handle) newpath.nodes );		DisposeHandle ( (Handle) newseen.nets );	DisposeHandle ( (Handle) newseen.nodes );		if (from != NULL)	{//	swap texts to preserve seen+by and pathes		h = m2nd->text;		m2nd->text = m->text;		m->text = h;	}		FreePktMsg ( m2nd );}