#include <stdio.h>#include <string.h>#include <Folders.h>#include "ravel_msg_base.h"#include "Ravel_Prefs.h"#include "PascalStr.h"#include "myEnv.h"#include "log.h"#include "Toss.h"#include "Scan.h"#include "Utils.h"#include "pktparse.h"#include "stringutl.h"#include "AreaUtils.h"#include "NetMailRoute.h"#include "Attaches.h"#include "Exports.h"#include "Pathes.h"#include "Flavor.h"#include "Plug-Ins.h"#include "statistic.h"extern	homeHndl		homesystem;			//	е	Home system structextern	mailPrefHndl	mailHndl;			//	е	Netmail structextern	short			AreasNumber;		//	е	Areas structs listextern	areaPrefHndl	*areasHndls;extern	short			GroupsNumber;		//	е	AreaGroups structs listextern	groupPrefHndl	*groupsHndls;extern	short			NodesNumber;		//	е	Linked Nodes structs listextern	nodePrefHndl	*nodesHndls;extern	short			wdWorkRefNum;		//	е	WD for bundles spooling╔extern	statistic		Stat;extern	short	type2plus;void	DoSlice (void);void	InitProgress ( float );void	DrawProgress ( long );void	putProgressName (Str255 name);/****************************************************												   **	Process	Inbound	folder - look for bundles.	   **	Make netmail routing						   **	Make echo area tossing						   **	(in	other level	process	uplinks	& downlinks)   **												   ****************************************************/void Scan (void){	long			i, j, amm, ii, nm;	pktmsg 			*m;	msgbase_atom	Atom;	short			tempref, iErr;	short			zero2, ix, jx;	Str255			tempStrSrc;	pktheader		*p;	addr			tempaddr;	DateTimeRec		dtr;	long			counter;//ееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееее//е Scan netmail	if ( msgbase_open (NETMAIL, false) == NETMAIL )	{		putProgressName ("\pNetMail");			amm = msgbase_getnummsg ();		if (amm && ((ii = msgbase_getdirty ()) != -1))		{			msgbase_close (CLOSE_ONLY);			msgbase_open (NETMAIL, true);			msgbase_setdirty (-1);			InitProgress ( (float) amm );			for ( j=ii; ; j++ )			{				DoSlice ();				DrawProgress (j);					if ( msgbase_read_atom ( j, &Atom ) )				{					if ( (Atom.flags & MSGLOCAL) != 0 && (Atom.flags & MSGSENT) == 0 )					{						msgbase_read_message ( j, &m, READMODE_REPLY | READMODE_TEXT );						Atom.flags |= MSGSENT;						msgbase_write_atom ( j, &Atom );						if ( !CallPlugIns (plugScanMsgMail, m, 0) )						{							m->flags &= ~(MSGLOCAL | MSGSENT | MSGREAD);							ResolveMessage ( m, NULL, FALSE );						}												FreePktMsg (m);						if (Atom.flags & MSGKILL)						{							nm = msgbase_getnummsg ();														if ((Atom.base_flags & ATOM_LOCKED) == 0)							{								msgbase_delete_message (j, ATOM_DELETED);							}						}											nokill:;										}				}				else					break;			}			msgbase_close (CLOSE_UPDATE);		}		else			msgbase_close (CLOSE_ONLY);	}//ееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееее//е Scan echoes	for ( i = 1; i <= AreasNumber; i++ )	{		if ((*areasHndls[i-1])->areaflags & AREA_PASSTROUGH)			continue;			putProgressName ((*areasHndls[i-1])->areaName);			if ( msgbase_open (i, false) == i )		{			amm = msgbase_getnummsg ();			if (amm && ((ii = msgbase_getdirty ()) != -1))			{				msgbase_close (CLOSE_ONLY);				msgbase_open (i, true);								msgbase_setdirty (-1);				InitProgress ( (float) amm );				for ( j=ii; ; j++ )				{					DoSlice ();					DrawProgress (j);							if ( msgbase_read_atom ( j, &Atom ) )					{						if ( (Atom.flags & MSGLOCAL) != 0 && (Atom.flags & MSGSENT) == 0 )						{							msgbase_read_message ( j, &m, READMODE_REPLY | READMODE_TEXT );							Atom.flags |= MSGSENT;							msgbase_write_atom ( j, &Atom );							if ( !CallPlugIns (plugScanMsgEcho, m, 0) )							{								m->flags &= ~(MSGLOCAL | MSGSENT | MSGREAD);								Stat.EchoMesages++;								ExportEchoes ( m, NULL );							}														FreePktMsg (m);						}					}					else						break;				}				msgbase_close (CLOSE_UPDATE);			}			else				msgbase_close (CLOSE_ONLY);		}	}		InitProgress (1.0);//ееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееее	Resolver (MOVE_NETMAIL |			  MOVE_ARCMAIL |			  MOVE_FLOS |			  MOVE_FREQ);				// е Resolve all//ееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееее}