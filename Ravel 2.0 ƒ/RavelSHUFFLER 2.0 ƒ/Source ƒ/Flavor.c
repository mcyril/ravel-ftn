#include <stdio.h>#include <string.h>#include "ravel_msg_base.h"#include "ravel_tmp_base.h"#include "pktparse.h"//#include "Ravel_FTN.h"#include "Ravel_Prefs.h"#include "PascalStr.h"#include "Attaches.h"#include "Pathes.h"#include "stringutl.h"//#include "pktparse.h"#include "log.h"#include "Flavor.h"#include "statistic.h"#include "AreaUtils.h"#include "busy.h"static	char	*pollModes[3] = { ".HLO", ".DLO", ".CLO" };static	char	*pktModes[3] = { ".HKT", ".DKT", ".CKT" };extern	homeHndl		homesystem;			//	¥	Home system structextern	short			NodesNumber;		//	¥	Linked Nodes structs listextern	nodePrefHndl	*nodesHndls;extern	short	type2plus;void CreateFoldersChain (StringPtr base, pktmsg *m, addr *via, char *whatstore, char *resultpath, Boolean kill){	Str255		temp1;	Str15		attFName;	Str255		tempZone, tempPoint, temp;	Str255		temp10;	short		iErr, Poll;	FSSpec		specSrc, specDst;	long		dummy;	FILE		*attFile;		addr		nodeaddr = *via;	if (m->flags & MSGCRASH)		Poll = 2;	else		if (m->flags & MSGDIRECT)			Poll = 1;		else			if (m->flags & MSGHOLD)				Poll = 0;			else			{				iErr = LookForLinkNumber (via);				if (iErr == -1)				{					putlog (lgALRT, "Wrong operation flow! Let it be HOLD (Call Cyril for cure).");					Poll = 0;				}				else					Poll = (*(nodesHndls[iErr]))->Poll;			}	//	¥	Creation or finding zonal subfolderÉ	sprintf ( (char *) &temp1[1], "Zone_%.4X:", nodeaddr.zone );	temp1[0] = strlen ( (char *) &temp1[1] );		pStrConc ( base, temp1, tempZone );		if ( (iErr = FSMakeFSSpec ( 0, 0, tempZone, &specDst )) == fnfErr )	{		if ( DirCreate ( 0, 0, tempZone, &dummy ) )		{			putlog ( lgALRT, "Cannot create zonal folder %s", &temp1[1] );			return;		}		iErr = FSMakeFSSpec ( 0, 0, tempZone, &specDst );	}												// ¥ specDst - FSSpec of appr. zonal Ä.//	¥	Destination node is point?		if ( nodeaddr.point != 0 )	{	//	¥	Creation or finding point subfolderÉ		sprintf ( (char *) &temp1[1], "%.4X%.4X.PTS:", nodeaddr.net, nodeaddr.node );		temp1[0] = strlen ( (char *) &temp1[1] );				pStrConc ( tempZone, temp1, tempPoint );				if ( (iErr = FSMakeFSSpec ( 0, 0, tempPoint, &specDst )) == fnfErr )		{			if ( DirCreate ( 0, 0, tempPoint, &dummy ) )			{				putlog ( lgALRT, "Cannot create point folder %s", &temp1[1] );				return;			}				iErr = FSMakeFSSpec ( 0, 0, tempPoint, &specDst );		}												// ¥ specDst - FSSpec of appr. point Ä.			//	¥	Generate attachment filename for Point Ä				sprintf ( (char *) &attFName[1], "%.8lX%s", (long) nodeaddr.point, pollModes[Poll] );		attFName[0] = strlen ( (char *) &attFName[1] );		}	else	{//	¥	Generate attachment filename for Zonal Ä				sprintf ( (char *) &attFName[1], "%.4X%.4X%s",					nodeaddr.net, nodeaddr.node, pollModes[Poll] );		attFName[0] = strlen ( (char *) &attFName[1] );	}	if (nodeaddr.point == 0)	{		pStrConc ( tempZone, attFName, temp );		tempZone[tempZone[0]+1] = 0;		strcpy (resultpath, (char *) &tempZone[1]);	}	else	{		pStrConc ( tempPoint, attFName, temp );		tempPoint[tempPoint[0]+1] = 0;		strcpy (resultpath, (char *) &tempPoint[1]);	}	temp[temp[0]+1] = 0;	attFile = fopen ( (char *) &temp[1], "a" );	if (attFile)	{		if (whatstore)			fprintf (attFile, "%c%s\n", (kill) ? '-' : '+', whatstore);				fclose (attFile);	}	else		putlog (lgALRT, "Cannot create/open attach file");}void FlavorMessage (pktmsg *m, addr *from, addr *via, Boolean inTransit){	char		tmp[256];	char		tmp1[256];	char		tmp2[128];	FSSpec		spec;	short		iErr, tempref, j;	pktheader	*p;//	addr		tempaddr;	DateTimeRec	dtr;	long		counter;	juncted		newpath;	pktmsg		*m2nd;	short		kk, ix, jx;	FILE		*frqFile;			if (m->flags & MSGFREQ)	{		if (inTransit)		{			putlog (lgATTN, "Freq in transit arrived. Ignore.");			return;		}				Stat.FileRequests++;				if ((m->flags & (MSGHOLD | MSGDIRECT | MSGCRASH)) == 0)			m->flags |= MSGDIRECT;		//		m->flags &= ~(MSGHOLD | MSGDIRECT | MSGCRASH);		CreateFoldersChain ( workPath, m, &m->to, NULL, tmp, false );		get_flo_pathname (&m->to, workPath, (StringPtr) tmp);//		if (m->to.point)//			sprintf ( tmp2, "%.8lX.REQ", (long) m->to.point );//		else//			sprintf ( tmp2, "%.4X%.4X.REQ", m->to.net, m->to.node );////		strcat (tmp, tmp2);		strcat (&tmp[1], ".REQ");		frqFile = fopen ( &tmp[1], "a" );		if (frqFile)		{			fprintf (frqFile, "%s\n\r", m->subj);			fclose (frqFile);		}		else			putlog (lgALRT, "Cannot create/open request file");			return;	}	else		if (m->flags & MSGFILE)		{			if (inTransit)			{				putlog (lgATTN, "File attach in transit arrived. Ignore attached file.");			}			else			{				Stat.FileAttaches++;				CreateFoldersChain (workPath, m, via, m->subj, tmp, (m->flags & MSGKFS) != 0);							for ( ix=0, jx=0; m->subj[ix]; ix++ )					if (m->subj[ix] != ':')					{						m->subj[jx++] = m->subj[ix];					}					else					{						jx=0;						m->subj[0] = 0;					}							m->subj[jx] = 0;			}		}	//	CreateFoldersChain ( workPath, m, via, NULL, tmp, false );//	if (via->point)//		sprintf ( tmp2, "%.8lX.PKT", -((long) via->point) );//	else//		sprintf ( tmp2, "%.8lX.PKT", -(((long) via->net << 16) + (long) via->node) );//	//	strcpy (&tmp1[1], tmp);//	strcat (&tmp1[1], tmp2);	get_flo_pathname (via, workPath, (StringPtr) tmp);	if (m->flags & MSGCRASH)		strcat (&tmp[1], pktModes[2]);	else		if (m->flags & MSGDIRECT)			strcat (&tmp[1], pktModes[1]);		else			if (m->flags & MSGHOLD)				strcat (&tmp[1], pktModes[0]);			else			{				iErr = LookForLinkNumber (via);				if (iErr == -1)				{					putlog (lgALRT, "Wrong operation flow! Let it be HOLD (Call Cyril for cure).");					strcat (&tmp[1], pktModes[0]);				}				else					strcat (&tmp[1], pktModes[(*(nodesHndls[iErr]))->Poll]);			}	tmp[0] = strlen (&tmp[1]);	iErr = FSMakeFSSpec ( 0, 0, (StringPtr) tmp, &spec );	if (iErr == fnfErr)	{		p = (pktheader *) NewPtr ( sizeof (pktheader) );		Create ( (StringPtr) tmp, 0, 'Ravl', 'PKT ' );		FSOpen ( (StringPtr) tmp, 0, &tempref );		p->from.zone = from->zone;		p->from.net = from->net;		p->from.node = from->node;		p->from.point = from->point;		p->to.zone = via->zone;		p->to.net = via->net;		p->to.node = via->node;		p->to.point = via->point;		GetTime ( &dtr );		p->year = dtr.year;		p->month = dtr.month;		p->day = dtr.day;		p->hour = dtr.hour;		p->min = dtr.minute;		p->sec = dtr.second;		kk = LookForLinkNumber (via);		for ( j = 0; j < 9; j++ )			p->passwd[j] = 0;		if (kk != -1)			for ( j = 0; j < 8; j++ )				if ( !(p->passwd[j] = (*(nodesHndls[kk]))->ArcMail_pwd[j]) )					break;		p->pkttype = type2plus;		AddPKTHeadToPKTFile ( tempref, p );		DisposePtr ( (Ptr) p );	}	else		if (iErr == noErr)		{			FSOpen ( (StringPtr) tmp, 0, &tempref );			GetEOF ( tempref, &counter );			SetEOF ( tempref, counter - 2 );			SetFPos ( tempref, fsFromLEOF, 0 );		}		else		{			putlog (lgALRT, "Cannot process this netmail.");			return;		}	m2nd = (pktmsg *) NewPtr ( sizeof (pktmsg) );	parse_kludges ((inTransit) ? PMODE_TRANSIT : PMODE_PREPNEW, m, &m2nd, NULL, NULL, from);	AddMessageToPKTFile ( tempref, m2nd, NULL );		FreePktMsg ( m2nd );	iErr = 0;	counter = 2;	FSWrite ( tempref, &counter, &iErr );		FSClose ( tempref );}