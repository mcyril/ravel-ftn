#include <string.h>#include "ravel_msg_base.h"#include "ravel_asciiz.h"#include "Ravel_Prefs.h"#include "pktparse.h"#include "Pack.h"#include "lzss.h"#include "PascalStr.h"#include "log.h"extern	short			AreasNumber;		//	е	Areas structs listextern	areaPrefHndl	*areasHndls;extern	mailPrefHndl	mailHndl;			//	е	Netmail structextern	short	BaseVRef;extern	long	BaseDirID;extern	short	CBIndexRef;extern	short	CBHeadRef;extern	short	CBTextRef;void	DoSlice (void);void	InitProgress ( float );void	DrawProgress ( long );void	putProgressName (Str255 name);static	char	temp_buff[4096];void Pack (void){	long			i, j, amm, counter;		long			text_pos, head_pos;		msgbase_atom	Atom;	Str255			CBIndexName, CBHeadName, CBTextName, CurrentArea;	Str255			TCBIndexName, TCBHeadName, TCBTextName;	short			TCBIndexRef, TCBHeadRef, TCBTextRef, dup, duo;	msgbase_header	HeaderBase;	char			*tb;		Handle			h_text;	msgbase_text	txt;	Handle			h, dest;	buff_desc		src, dst;	long			growBytes, msgs_removed = 0, vol_wastot = 0, vol_nowtot = 0, vol_was = 0, vol_now = 0;//ееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееее	pStrCopy ("\p$$$TEMP$$$", TCBIndexName);	pStrConc ( TCBIndexName, "\p.HDR", TCBHeadName );	pStrConc ( TCBIndexName, "\p.TXT", TCBTextName );	pStrConc ( TCBIndexName, "\p.INX", TCBIndexName );	dest = NewHandle (0);	for ( i = 0; i <= AreasNumber+1; i++ )	{		if (i > 0 && i <= AreasNumber && ((*areasHndls[i-1])->areaflags & AREA_PASSTROUGH))			continue;		putProgressName ((i == AreasNumber+1) ? "\pBadMail" : ((i) ? (*areasHndls[i-1])->areaName : "\pNetMail"));		DoSlice ();#ifndef LITE		if (i == AreasNumber+1)			duo = 0;		else			if (i)				duo = ((*areasHndls[i-1])->areaflags & AREA_COMPRESSED) << 4;			else				duo = ((*mailHndl)->areaflags & AREA_COMPRESSED) << 4;#else		duo = 0;#endif				if ( msgbase_open_idx (i, true) == i )		{			HCreate (BaseVRef, BaseDirID, TCBIndexName, 'Ravl', 'BasI');			HCreate (BaseVRef, BaseDirID, TCBTextName, 'Ravl', 'BasI');			HCreate (BaseVRef, BaseDirID, TCBHeadName, 'Ravl', 'BasI');						HOpen (BaseVRef, BaseDirID, TCBIndexName, fsRdWrPerm, &TCBIndexRef);			SetEOF (TCBIndexRef, 0L);						HOpen (BaseVRef, BaseDirID, TCBTextName, fsRdWrPerm, &TCBTextRef);			SetEOF (TCBTextRef, 0L);			HOpen (BaseVRef, BaseDirID, TCBHeadName, fsRdWrPerm, &TCBHeadRef);			SetEOF (TCBHeadRef, 0L);			memset ( &HeaderBase, 0, sizeof (msgbase_header) );						HeaderBase.base_sign = 'Rvl1';		//	new base format signature. always 'Rvl1'			HeaderBase.base_flags = 0;			//	messagebase common flags			HeaderBase.base_lastread = 0;			HeaderBase.base_dirtstart = -1;			HeaderBase.base_msg_number = 0;		//	number of messages in base			HeaderBase.base_atom_number = 0;	//	number of atoms in base (msg + deleted msg)			counter = sizeof (msgbase_header);			FSWrite (TCBIndexRef, &counter, &HeaderBase);			if (amm = msgbase_getnummsg ())			{				InitProgress ( (float) amm );				text_pos = 0;				head_pos = 0;				for (j=0; j<amm; j++)				{					if (!msgbase_read_atom ( j, &Atom ))						break;									if (!(j & 7))					{						DoSlice ();					}										DrawProgress (j);					if (SetFPos (CBHeadRef, fsFromStart, Atom.offset_header))						break;										tb = temp_buff;										if (!get_ASCIIZ (CBHeadRef, tb, MName))						break;											tb += strlen (tb) + 1;					if (!get_ASCIIZ (CBHeadRef, tb, MName))						break;					tb += strlen (tb) + 1;					if (!get_ASCIIZ (CBHeadRef, tb, MDate))						break;					tb += strlen (tb) + 1;					if (!get_ASCIIZ (CBHeadRef, tb, MSubject))						break;					tb += strlen (tb) + 1;					if ((Atom.base_flags & ATOM_MSGID) != 0)					{						if (!get_ASCIIZ (CBHeadRef, tb, 127))							break;						tb += strlen (tb) + 1;					}					if ((Atom.base_flags & ATOM_REPLY) != 0)					{						if (!get_ASCIIZ (CBHeadRef, tb, 127))							break;						tb += strlen (tb) + 1;					}					if (SetFPos (CBTextRef, fsFromStart, Atom.offset_text))						break;//					h = NewHandle (0L);//					if (!get_msg_text (CBTextRef, h))//						break;										counter = sizeof (msgbase_text);					if (FSRead (CBTextRef, &counter, &txt))					{						break;					}										switch (txt.text_sign)					{					case 'PL':	dup = 0x0000;	break;					case 'LZ':	dup = 0x0001;	break;					case '6P':	dup = 0x0002;	break;					default:	dup = -1;		break;					}					if (dup < 0)						break;										counter = sizeof (msgbase_atom);										Atom.offset_header = head_pos;					Atom.offset_text = text_pos;										FSWrite (TCBIndexRef, &counter, &Atom);										counter = tb - temp_buff;					FSWrite (TCBHeadRef, &counter, temp_buff);										head_pos += counter;										switch (duo | dup)					{					case 0x0000:		//	plane -> plane											counter = sizeof (msgbase_text);						FSWrite (TCBTextRef, &counter, &txt);						SetHandleSize (dest, txt.text_length);						HLock (dest);												counter = txt.text_length;						vol_was += counter;						vol_now += counter;						FSRead (CBTextRef, &counter, *dest);						FSWrite (TCBTextRef, &counter, *dest);												HUnlock (dest);												text_pos += counter;												break;											case 0x0100:		//	plane -> compressed					case 0x0200:		//	plane -> compressed											SetHandleSize (dest, txt.text_length);						HLock (dest);												counter = txt.text_length;						vol_was += counter;						FSRead (CBTextRef, &counter, *dest);												h = NewHandle (txt.text_length + 4096L);						HLock (h);												src.buff = (unsigned char *) *dest;						src.len = txt.text_length;						src.point = 0L;												dst.buff = (unsigned char *) *h;						dst.len = txt.text_length + 4096L;						dst.point = 0L;						if (duo == 0x0100)							LZSSEncode (&src, &dst);						else							SIXEncode (&src, &dst);												txt.text_sign = (duo == 0x0100) ? 'LZ' : '6P';						txt.text_len_cmp = dst.point;												counter = sizeof (msgbase_text);						FSWrite (TCBTextRef, &counter, &txt);						counter = txt.text_len_cmp;						vol_now += counter;						FSWrite (TCBTextRef, &counter, *h);												DisposeHandle (h);						HUnlock (dest);												text_pos += counter;						break;					case 0x0001:		//	compressed -> plane					case 0x0002:		//	compressed -> plane											SetHandleSize (dest, txt.text_len_cmp);						HLock (dest);												counter = txt.text_len_cmp;						vol_was += counter;						FSRead (CBTextRef, &counter, *dest);												h = NewHandle (txt.text_length);						HLock (h);												src.buff = (unsigned char *) *dest;						src.len = txt.text_len_cmp;						src.point = 0L;												dst.buff = (unsigned char *) *h;						dst.len = txt.text_length;						dst.point = 0L;						if (dup == 0x0001)							LZSSDecode (&src, &dst);						else							SIXDecode (&src, &dst);						txt.text_sign = 'PL';						txt.text_len_cmp = 0;												counter = sizeof (msgbase_text);						FSWrite (TCBTextRef, &counter, &txt);						counter = txt.text_length;						vol_now += counter;						FSWrite (TCBTextRef, &counter, *h);												DisposeHandle (h);						HUnlock (dest);												text_pos += counter;						break;											case 0x0102:		//	compressed2 -> compressed1											SetHandleSize (dest, txt.text_len_cmp);						HLock (dest);												counter = txt.text_len_cmp;						vol_was += counter;						FSRead (CBTextRef, &counter, *dest);												h = NewHandle (txt.text_length);						HLock (h);												src.buff = (unsigned char *) *dest;						src.len = txt.text_len_cmp;						src.point = 0L;												dst.buff = (unsigned char *) *h;						dst.len = txt.text_length;						dst.point = 0L;						SIXDecode (&src, &dst);												HUnlock (dest);						SetHandleSize (dest, txt.text_length + 4096L);						HLock (dest);												src.buff = (unsigned char *) *h;						src.len = txt.text_length;						src.point = 0L;												dst.buff = (unsigned char *) *dest;						dst.len = txt.text_length + 4096L;						dst.point = 0L;						LZSSEncode (&src, &dst);						txt.text_sign = 'LZ';						txt.text_len_cmp = dst.point;												counter = sizeof (msgbase_text);						FSWrite (TCBTextRef, &counter, &txt);						counter = txt.text_len_cmp;						vol_now += counter;						FSWrite (TCBTextRef, &counter, *dest);												DisposeHandle (h);						HUnlock (dest);												text_pos += counter;						break;											case 0x0201:		//	compressed1 -> compressed2											SetHandleSize (dest, txt.text_len_cmp);						HLock (dest);												counter = txt.text_len_cmp;						vol_was += counter;						FSRead (CBTextRef, &counter, *dest);												h = NewHandle (txt.text_length);						HLock (h);												src.buff = (unsigned char *) *dest;						src.len = txt.text_len_cmp;						src.point = 0L;												dst.buff = (unsigned char *) *h;						dst.len = txt.text_length;						dst.point = 0L;						LZSSDecode (&src, &dst);												HUnlock (dest);						SetHandleSize (dest, txt.text_length + 4096L);						HLock (dest);												src.buff = (unsigned char *) *h;						src.len = txt.text_length;						src.point = 0L;												dst.buff = (unsigned char *) *dest;						dst.len = txt.text_length + 4096L;						dst.point = 0L;						SIXEncode (&src, &dst);						txt.text_sign = '6P';						txt.text_len_cmp = dst.point;												counter = sizeof (msgbase_text);						FSWrite (TCBTextRef, &counter, &txt);						counter = txt.text_len_cmp;						vol_now += counter;						FSWrite (TCBTextRef, &counter, *dest);												DisposeHandle (h);						HUnlock (dest);												text_pos += counter;						break;											case 0x0101:		//	compressed -> compressed					case 0x0202:		//	compressed -> compressed											counter = sizeof (msgbase_text);						FSWrite (TCBTextRef, &counter, &txt);						SetHandleSize (dest, txt.text_len_cmp);						HLock (dest);												counter = txt.text_len_cmp;						vol_was += counter;						vol_now += counter;						FSRead (CBTextRef, &counter, *dest);						FSWrite (TCBTextRef, &counter, *dest);												HUnlock (dest);												text_pos += counter;						break;					}					text_pos += sizeof (msgbase_text);				}				HeaderBase.base_msg_number = j;		//	number of messages in base				HeaderBase.base_atom_number = j;	//	number of atoms in base (msg + deleted msg)				HeaderBase.base_dirtstart = msgbase_getdirty ();				HeaderBase.base_flags = (*obtainHBase ())->head.base_flags;				msgs_removed += (*obtainHBase ())->head.base_atom_number - j;				SetFPos (TCBIndexRef, fsFromStart, 0L);								counter = sizeof (msgbase_header);				FSWrite (TCBIndexRef, &counter, &HeaderBase);							vol_nowtot += text_pos;			}			FSClose (TCBIndexRef);			FSClose (TCBTextRef);			FSClose (TCBHeadRef);			msgbase_close (CLOSE_ONLY);						if (i == AreasNumber+1)				pStrCopy ( "\pBADMAIL", CurrentArea );			else				if (i)					pStrCopy ( (*areasHndls[i-1])->areaName, CurrentArea );				else					pStrCopy ( "\pNETMAIL", CurrentArea );						pASCIIZ(CurrentArea);			msgbase_create_unique_name (CurrentArea, CBIndexName);						pStrConc ( CBIndexName, "\p.HDR", CBHeadName );			pStrConc ( CBIndexName, "\p.TXT", CBTextName );			pStrConc ( CBIndexName, "\p.INX", CBIndexName );			{				HParamBlockRec p;				memset (&p, 0, sizeof(p));				p.fileParam.ioNamePtr = CBTextName;				p.fileParam.ioVRefNum = BaseVRef;				p.fileParam.ioDirID = BaseDirID;				if (PBHGetFInfoSync (&p) == noErr)					vol_wastot += p.fileParam.ioFlLgLen;			}			HDelete (BaseVRef, BaseDirID, CBIndexName);			HDelete (BaseVRef, BaseDirID, CBTextName);			HDelete (BaseVRef, BaseDirID, CBHeadName);						HRename (BaseVRef, BaseDirID, TCBIndexName, CBIndexName);			HRename (BaseVRef, BaseDirID, TCBTextName, CBTextName);			HRename (BaseVRef, BaseDirID, TCBHeadName, CBHeadName);			MaxMem (&growBytes);		}	}		DisposeHandle (dest);		InitProgress ( 1.0 );	putlog (lgNOPE, " ");	putlog (lgNOPE, "Removed msgs: %5ld", msgs_removed);	putlog (lgNOPE, "Saved (totl): %5ld%c Saved (comp): %5ld%c",			((vol_wastot - vol_nowtot) > 1023L) ? (long)(vol_wastot - vol_nowtot)/1024L : (long)(vol_wastot - vol_nowtot),			((vol_wastot - vol_nowtot) > 1023L) ? 'K' : 'b',			((vol_was - vol_now) > 1023L) ? (long)(vol_was - vol_now)/1024L : (long)(vol_was - vol_now),			((vol_was - vol_now) > 1023L) ? 'K' : 'b');	putlog (lgNOPE, "Saved (totl): %5ld%% Saved (comp): %5ld%%",			(vol_wastot) ? (long)(((vol_wastot - vol_nowtot) * 100L) / vol_wastot) : 0L,			(vol_was) ? (long)(((vol_was - vol_now) * 100L) / vol_was) : 0L);//ееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееее}