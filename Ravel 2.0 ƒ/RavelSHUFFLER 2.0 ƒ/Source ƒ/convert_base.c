#include <string.h>#include <stdio.h>#include "ravel_msg_base.h"#include "ravel_tmp_base.h"#include "Ravel_Prefs.h"#include "PascalStr.h"#include "myEnv.h"#include "log.h"#include "Toss.h"#include "Utils.h"#include "pktparse.h"#include "stringutl.h"#include "AreaUtils.h"#include "NetMailRoute.h"#include "Attaches.h"#include "Exports.h"#include "ZipIt.h"#include "Plug-Ins.h"#include "statistic.h"typedef struct _old_oneArea {	Str63		areaName;		// Name of area (must be correct for HFS)	short		group;			// Group number	long		areaflags;		// 32-bits	short		useAKA;			// also SEEN-BY is # of address (0 main, >0 AKA)	short		purger;			// # of days for purge	short		numExports;		// Number of exports	short		Export[];		// Exports nodes list} old_areaPrefType, *old_areaPrefPtr, **old_areaPrefHndl;//#define	AREA_PASSTROUGH		0x00000001//	Netmail areasÉ Must be alone #0typedef struct _old_oneMail {	Str31		mailName;		// Netmail Name	long		areaflags;	short		useAKA;			// also SEEN-BY is # of address (0 main, >0 AKA)	short		purger;			// # of days} old_mailPrefType, *old_mailPrefPtr, **old_mailPrefHndl;typedef struct _baseIndexHeader {	short			busy;				// reaserved	unsigned char	AreaName[MName];	// name of area ("NETMAIL" == netmail, not empty!)	long			CRCIndex;			// reserved	long			CRCText;			// reserved	long			lastRead;			// number of last read	long			NumberOfMessages;	// number of messages/*	indexAtomType	indexAtom[NumberOfMessages];*/} baseIndexHeaderType;typedef struct _indexAtom {	short			deleted;			// message is deleted - can purge :)	long			textOffset;			// intext offset from start of file	long			headOffset;			// heders offset		addr			from,				// addresses					to,					//  +++ to field is actually for NetMail only					reply;						long			msgID;				// MSGID unical number copy	long			repID;				// REPLY unical number copy	long			storedTime;	long			flags;	long			BaseReplyTo,		// number of message that was origin for reply					BaseNextReply;		// next reply in base number} indexAtomType, *indexAtomPtr;typedef struct _base {	short			busy;				// reaserved	unsigned char	AreaName[MName];	// name of area ("NETMAIL" == netmail, not empty!)	long			CRCIndex;			// reserved	long			CRCText;			// reserved	long			lastRead;			// number of last read	long			NumberOfMessages;	// number of messages	indexAtomType	indexAtom[];} baseType, *basePtr, **baseHndl;typedef struct								/* Internal storage of message structure */	{	addr				from,				/* from address */						to,					/* to address */						reply;				/* reply address */							char				fromname[MName],						toname[MName];	char				date[MDate],						subj[MSubject];	long				flags;	char				**text;	char				area[64];	long				msgid;	long				replyid;	long				storedtime;	juncted				seenby,						path;	}	_pktmsg;static	char	*M_MSGID = "\1MSGID: %s %lx\xD";static	char	*M_REPLY = "\1REPLY: %s %lx\xD";static	Str255	basepath;static	short	wdBaseVRef;static	short	CBIndexRef;static	short	CBHeadRef;static	short	CBTextRef;static	short	deleted;static	baseHndl			HBase;extern	mailPrefHndl	mailHndl;			//	¥	Netmail structextern	short			AreasNumber;		//	¥	Areas structs listextern	areaPrefHndl	*areasHndls;void	Do_ConvertBase (void);void	putProgressName (Str255 name);void	InitProgress ( float );void	DrawProgress ( long );void	DoSlice (void);static pascal Boolean fileFilter (CInfoPBRec *thePB){	if (thePB->hFileInfo.ioFlFndrInfo.fdType == 'PREF' &&		thePB->hFileInfo.ioFlFndrInfo.fdCreator == 'Ravl')		return( FALSE );		/* new file, keep it in the list */	else		return( TRUE );			/* too old, filter it from the list */}static Boolean _GetASCIIZ ( short fromfile, char *dest, short limit ){	char		buff[256];	long		counter;	short		i;	counter = 256L;	FSRead ( fromfile, &counter, &buff );	SetFPos ( fromfile, 3, -counter );		for ( i=0; i<counter; i++ )	{		if (buff[i])			dest[i] = buff[i];		else			break;					if ( i >= limit )		{			i = 0;			break;		}	}	//	if ( !i )				¥	why ? subject can be empty....//		return FALSE;		dest[i] = 0;	SetFPos ( fromfile, 3, i+1 );		return TRUE;}static Boolean _GetMSGText ( short fromfile, Handle dest ){	char		buff[256];	long		counter, pos;	short		i;		SetHandleSize ( dest, 0L );	pos = 0L;		do {				counter = 256L;		FSRead ( fromfile, &counter, buff );		if ( counter )		{			for ( i=0; i<counter; i++ )				if (!buff[i])					break;						SetHandleSize ( dest, pos+i );			BlockMove ( buff, *dest+pos, i );			pos += i;						if ( i < counter )				break;		}	} while (counter);//	if (!counter)				//	¥	why? empty body is possible!//	{//		SetHandleSize ( dest, 0L );//		return FALSE;//	}	SetHandleSize ( dest, pos+1 );	*((char *)(*dest+pos)) = 0;	SetFPos ( fromfile, fsFromMark, -(counter-i-1) );	return TRUE;}static short OpenBase (StringPtr CurrentArea){	short		iErr, ii;	Str255		CBIndexName, CBHeadName, CBTextName, sss;	long		indexSize, ccc;			putProgressName (CurrentArea);		CurrentArea[CurrentArea[0]+1] = 0;		if (CurrentArea[0] > 16)	{		pStrCopy ( CurrentArea, CBIndexName );				ccc = 0L;		for (ii=0; ii < CBIndexName[0]; ii++)		{			ccc += CBIndexName[ii];			ccc = (ccc << 1) | (ccc >> 31);		}		sprintf ((char *) &CBIndexName[17], "%.8lX", ccc);		CBIndexName[0] = strlen ((char *) &CBIndexName[1]);				pStrConc ( CBIndexName, "\p.HEAD", CBHeadName );		pStrConc ( CBIndexName, "\p.TEXT", CBTextName );		pStrConc ( CBIndexName, "\p.INDEX", CBIndexName );	}	else	{		pStrConc ( CurrentArea, "\p.INDEX", CBIndexName );		pStrConc ( CurrentArea, "\p.HEAD", CBHeadName );		pStrConc ( CurrentArea, "\p.TEXT", CBTextName );	}		if ( (iErr = FSOpen ( CBIndexName, wdBaseVRef, &CBIndexRef )) != noErr )		if ( iErr == fnfErr )		{			baseIndexHeaderType	HeaderBase;			long				counter;								iErr = Create ( CBIndexName, wdBaseVRef, 'Ravl', 'BasI' );			if ( iErr )				return -1;							iErr = FSOpen ( CBIndexName, wdBaseVRef, &CBIndexRef );			if ( iErr )				return -1;							memset ( &HeaderBase, 0, sizeof (baseIndexHeaderType) );						HeaderBase.busy = 0;//			pStrCopy ( CurrentArea, HeaderBase.AreaName );//			HeaderBase.AreaName[HeaderBase.AreaName[0]+1] = 0;			HeaderBase.CRCIndex = 0;			HeaderBase.CRCText = 0;			HeaderBase.NumberOfMessages = 0;			HeaderBase.lastRead = 0;						counter = sizeof (baseIndexHeaderType);			if ( FSWrite (CBIndexRef, &counter, &HeaderBase) )			{				FSClose ( CBIndexRef );				return -1;			}		}		else			return -1;	GetEOF ( CBIndexRef, &indexSize );	if ( (iErr = FSOpen ( CBHeadName, wdBaseVRef, &CBHeadRef )) != noErr )		if ( iErr == fnfErr )		{			iErr = Create ( CBHeadName, wdBaseVRef, 'Ravl', 'BasT' );			if ( iErr )			{				FSClose ( CBIndexRef );				return -1;			}						iErr = FSOpen ( CBHeadName, wdBaseVRef, &CBHeadRef );			if ( iErr )			{				FSClose ( CBIndexRef );				return -1;			}		}		else		{			FSClose ( CBIndexRef );			return -1;		}		if ( (iErr = FSOpen ( CBTextName, wdBaseVRef, &CBTextRef )) != noErr )		if ( iErr == fnfErr )		{			iErr = Create ( CBTextName, wdBaseVRef, 'Ravl', 'BasT' );			if ( iErr )			{				FSClose ( CBHeadRef );				FSClose ( CBIndexRef );				return -1;			}						iErr = FSOpen ( CBTextName, wdBaseVRef, &CBTextRef );			if ( iErr )			{				FSClose ( CBHeadRef );				FSClose ( CBIndexRef );				return -1;			}		}		else		{			FSClose ( CBHeadRef );			FSClose ( CBIndexRef );			return -1;		}	HBase = (baseHndl) NewHandle (indexSize);		SetFPos ( CBIndexRef, fsFromStart, 0L );		if ( FSRead ( CBIndexRef, &indexSize, (Ptr) *HBase ) )	{		FSClose ( CBIndexRef );		FSClose ( CBHeadRef );		FSClose ( CBTextRef );				DisposeHandle ( (Handle) HBase );				return -1;	}		return 0;}static void CloseBase (void){	long	counter;	FSClose ( CBIndexRef );	FSClose ( CBHeadRef );	FSClose ( CBTextRef );		DisposeHandle ( (Handle) HBase );}static long _RealNum (long Num){	long	counter = (GetHandleSize ( (Handle) HBase ) - sizeof (baseIndexHeaderType)) /																			sizeof (indexAtomType);	long	i, j;		if (counter)	{		for ( j = 0, i = 0; j < (*HBase)->NumberOfMessages; i++ )			if ( ((*HBase)->indexAtom[i].deleted & 0x0003) == 0 )				if ( j == Num )					return i;				else					j++;	}		return 0x7FFFFFFF;}static Boolean ReadMessageAtom ( long MsgNum, indexAtomPtr Atom ){	short		iErr;	long		counter = _RealNum (MsgNum);		if ( MsgNum >= (*HBase)->NumberOfMessages )		return FALSE;	if ( counter*sizeof(indexAtomType) + sizeof (baseIndexHeaderType) >= GetHandleSize ((Handle)HBase) )		return FALSE;	*Atom = (*HBase)->indexAtom[counter];	return TRUE;}static Boolean ReadMessage ( long MsgNum, _pktmsg **m ){	indexAtomType	Atom;	long			baseTextSize;	long			counter;	char			fromname[MName],					toname[MName];	char			date[MDate],					subj[MSubject];	Handle			h;		if ( !ReadMessageAtom ( MsgNum, &Atom ) )		return FALSE;	deleted = Atom.deleted;	if ( SetFPos (CBHeadRef, fsFromStart, Atom.headOffset) )		return FALSE;	if ( !_GetASCIIZ ( CBHeadRef, fromname, MName ) ||		 !_GetASCIIZ ( CBHeadRef, toname, MName ) ||		 !_GetASCIIZ ( CBHeadRef, date, MDate ) ||		 !_GetASCIIZ ( CBHeadRef, subj, MSubject ) )		return FALSE;	if ( SetFPos (CBTextRef, fsFromStart, Atom.textOffset) )		return FALSE;	h = NewHandle ( 0 );	if ( !_GetMSGText ( CBTextRef, h ) )		return FALSE;	*m = (_pktmsg *) NewPtr ( sizeof (_pktmsg) );		(*m)->flags = Atom.flags;		(*m)->from = Atom.from;	(*m)->to = Atom.to;	(*m)->reply = Atom.reply;		(*m)->msgid = Atom.msgID;	(*m)->replyid = Atom.repID;	(*m)->storedtime = Atom.storedTime;	strcpy ( (*m)->date, date );	strcpy ( (*m)->toname, toname );	strcpy ( (*m)->fromname, fromname );	strcpy ( (*m)->subj, subj );	(*m)->text = h;	(*m)->area[0] = 0;	(*m)->seenby.nodes = (*m)->seenby.nets = NULL;	(*m)->path.nodes = (*m)->path.nets = NULL;	(*m)->path.items = (*m)->seenby.items = 0;	return TRUE;}static void _FreePktMsg ( _pktmsg *p ){	if ( p )	{		if ( p->seenby.nets )	DisposeHandle ( (Handle) p->seenby.nets );		if ( p->seenby.nodes )	DisposeHandle ( (Handle) p->seenby.nodes );		if ( p->path.nets )		DisposeHandle ( (Handle) p->path.nets );		if ( p->path.nodes )	DisposeHandle ( (Handle) p->path.nodes );		if ( p->text )			DisposeHandle ( p->text );		DisposePtr ( (Ptr) p );	}}void Do_ConvertBase (){	WDPBRec		pbr;							/* local pb */	Point		where = { 0, 0 };	SFReply		reply;		short		oldPref, oldRes;		old_mailPrefHndl	old_mailHndl;		long		i;	short		j;		_pktmsg		*_m;	pktmsg		m, *m2nd;	char		temp[128], tmp[64];	#if defined(powerc) || defined(__powerc)	FileFilterUPP	uupFileFilter = NewFileFilterProc (fileFilter);#endif		oldRes = CurResFile ();	#if defined(powerc) || defined(__powerc)	SFGetFile (where, NULL, uupFileFilter, -1, NULL, NULL, &reply);#else	SFGetFile (where, NULL, fileFilter, -1, NULL, NULL, &reply);#endif#if defined(powerc) || defined(__powerc)	DisposeRoutineDescriptor (uupFileFilter);#endif	if (reply.good)	{		if ((oldPref = OpenRFPerm (reply.fName, reply.vRefNum, fsRdPerm)) != -1)		{			UseResFile (oldPref);			//	Convert NETMAIL for first			GetIndString (basepath, PathID, _basePath);			pbr.ioNamePtr = basepath;			pbr.ioWDProcID = 0L;			pbr.ioWDDirID = 0L;			pbr.ioVRefNum = reply.vRefNum;						PBOpenWDSync (&pbr);						wdBaseVRef = pbr.ioVRefNum;						OpenBase ("\pNETMAIL");						msgbase_open (NETMAIL, true);			InitProgress ((float) (*HBase)->NumberOfMessages);						for (i = 0; i < (*HBase)->NumberOfMessages; i++)			{//				j = _RealNum (i);								if (!(i & 7))					DoSlice ();								DrawProgress (i);								if (ReadMessage (i, &_m))				{					m.seenby.items =	0;					m.seenby.nets =	NULL;					m.seenby.nodes =	NULL;										m.path.items =	0;					m.path.nets =		NULL;					m.path.nodes =		NULL;										m.reply.zone =		0;					m.reply.net =		0;					m.reply.node =		0;					m.reply.point =	0;										m.reply_num =		0;					m.msgid_num =		0;										m.reply_str =		NULL;					m.msgid_str =		NULL;										m.reply_crc =		0;					m.msgid_crc =		0;										m.area[0] =		0;										m.base_flags =		0;										m.flags = _m->flags & 0xFFFF;										strcpy ( m.date, _m->date );					strcpy ( m.subj, _m->subj );					strcpy ( m.fromname, _m->fromname );					strcpy ( m.toname, _m->toname );					m.seenby.nets = NULL;					m.seenby.nodes = NULL;					m.seenby.items = 0;										m.path.nets = NULL;					m.path.nodes = NULL;					m.path.items = 0;									m.text = NewHandle (0);										if (_m->flags & MSGLOCAL)					{						if (_m->msgid)						{							sprintf (temp, M_MSGID, printaddr (&_m->from, tmp), _m->msgid);							PtrAndHand (temp, m.text, strlen (temp));						}						if (_m->replyid)						{							sprintf (temp, M_REPLY, printaddr (&_m->reply, tmp), _m->replyid);							PtrAndHand (temp, m.text, strlen (temp));						}					}										HandAndHand (_m->text, m.text);									parse_kludges (PMODE_TOUCH, &m, NULL, NULL, NULL, NULL);					m2nd = (pktmsg *) NewPtrClear (sizeof (pktmsg));					parse_kludges (PMODE_FORBASE, &m, &m2nd, NULL, NULL, NULL);					m2nd->msg_reply_prev = -1;					m2nd->msg_reply_next = -1;					m2nd->flags = _m->flags;					m2nd->from = _m->from;					m2nd->to = _m->to;					m2nd->reply = _m->reply;					m2nd->msgid_num = _m->msgid;					m2nd->reply_num = _m->replyid;										m2nd->base_flags |= (deleted & 0x8000) ? ATOM_LOCKED : 0;					m2nd->base_flags |= ATOM_WASREAD;					m2nd->storedtime = _m->storedtime;					msgbase_append_message ( m2nd, false );										FreePktMsg ( &m );					FreePktMsg ( m2nd );					_FreePktMsg (_m);				}				else					break;			}						msgbase_close (CLOSE_UPDATE);						CloseBase ();						for (j = 1; j <= AreasNumber; j++)			{				if ((*areasHndls[j-1])->areaflags & AREA_PASSTROUGH)					continue;								OpenBase ((*areasHndls[j-1])->areaName);								msgbase_open (j, true);				InitProgress ((float) (*HBase)->NumberOfMessages);								for (i = 0; i < (*HBase)->NumberOfMessages; i++)				{	//				j = _RealNum (i);										if (!(i & 7))						DoSlice ();										DrawProgress (i);										if (ReadMessage (i, &_m))					{						m.seenby.items =	0;						m.seenby.nets =	NULL;						m.seenby.nodes =	NULL;												m.path.items =	0;						m.path.nets =		NULL;						m.path.nodes =		NULL;												m.storedtime =		0;												m.reply.zone =		0;						m.reply.net =		0;						m.reply.node =		0;						m.reply.point =	0;												m.reply_num =		0;						m.msgid_num =		0;												m.reply_str =		NULL;						m.msgid_str =		NULL;												m.reply_crc =		0;						m.msgid_crc =		0;												m.area[0] =		0;												m.base_flags =		0;												m.flags = _m->flags & 0xFFFF;												strcpy ( m.date, _m->date );						strcpy ( m.subj, _m->subj );						strcpy ( m.fromname, _m->fromname );						strcpy ( m.toname, _m->toname );						m.seenby.nets = NULL;						m.seenby.nodes = NULL;						m.seenby.items = 0;												m.path.nets = NULL;						m.path.nodes = NULL;						m.path.items = 0;												m.text = NewHandle (0);												sprintf (temp, "AREA:%#s\xD", (*areasHndls[j-1])->areaName);						PtrAndHand (temp, m.text, strlen (temp));												if (_m->flags & MSGLOCAL)						{							if (_m->msgid)							{								sprintf (temp, M_MSGID, printaddr (&_m->from, tmp), _m->msgid);								PtrAndHand (temp, m.text, strlen (temp));							}							if (_m->replyid)							{								sprintf (temp, M_REPLY, printaddr (&_m->reply, tmp), _m->replyid);								PtrAndHand (temp, m.text, strlen (temp));							}						}												HandAndHand (_m->text, m.text);												parse_kludges (PMODE_TOUCH, &m, NULL, NULL, NULL, NULL);						m2nd = (pktmsg *) NewPtrClear (sizeof (pktmsg));						parse_kludges (PMODE_FORBASE, &m, &m2nd, NULL, NULL, NULL);						m2nd->msg_reply_prev = -1;						m2nd->msg_reply_next = -1;						m2nd->flags = _m->flags;						m2nd->from = _m->from;						m2nd->to = _m->to;						m2nd->reply = _m->reply;						m2nd->msgid_num = _m->msgid;						m2nd->reply_num = _m->replyid;												m2nd->base_flags |= (deleted & 0x8000) ? ATOM_LOCKED : 0;						m2nd->base_flags |= ATOM_WASREAD;						m2nd->storedtime = _m->storedtime;												msgbase_append_message ( m2nd, false );												FreePktMsg ( &m );						FreePktMsg ( m2nd );						_FreePktMsg (_m);					}					else						break;				}								msgbase_close (CLOSE_UPDATE);								CloseBase ();						}						PBCloseWDSync (&pbr);						CloseResFile (oldPref);		}	}	InitProgress (1.0);		UseResFile (oldRes);}