#include <stdio.h>#include <string.h>#include "ravel_msg_base.h"#include "Ravel_Prefs.h"#include "pktparse.h"#include "PascalStr.h"#include "Attaches.h"#include "Pathes.h"#include "stringutl.h"#include "busy.h"#include "myEnv.h"#include "AreaUtils.h"#include "Plug-Ins.h"#include "Flavor.h"#include "log.h"#include "hashing.h"									extern	homeHndl		homesystem;			//	¥	Home system structextern	mailPrefHndl	mailHndl;			//	¥	Netmail structextern	short			AreasNumber;		//	¥	Areas structs listextern	areaPrefHndl	*areasHndls;extern	short			GroupsNumber;		//	¥	AreaGroups structs listextern	groupPrefHndl	*groupsHndls;extern	short			NodesNumber;		//	¥	Linked Nodes structs listextern	nodePrefHndl	*nodesHndls;extern	short			wdWorkRefNum;		//	¥	WD for bundles spoolingÉextern	Boolean			ZipItExist;static	char	*pollModes[3] = { ".HLO", ".DLO", ".CLO" };static	char	*pktModes[3] = { ".HKT", ".DKT", ".CKT" };static	char	*ValidExt[7] = { "SU", "MO", "TU", "WE", "TH", "FR", "SA" };extern	char 	*arcs[31];extern	long	MaxArcSize;typedef struct _bque {	struct _bque	*next;	short			kill;	long			file;	Str255			pathname;} bque, *pbque;static	pbque		first_bque[3], current_bque[3];typedef struct _que {	struct _que	*next;	addr		address;	} que, *pque;static	pque		first_que, current_que;void ReportToMailer (Boolean);static OSErr myFSpCatMove (FSSpec *srcSpec, FSSpec *dstSpec){	OSErr		rc;	short		src, dst;	char		r_buf[512];	long		ioCounter;	Str255		tmp;			rc = FSpCatMove (srcSpec, dstSpec);	while (rc != noErr)	{		putlog (lgATTN, "FSpCatMove failed (%d), try other wayÉ", rc);				if (dstSpec->name[0] != ':')			pStrCopy ("\p:", tmp);		else			tmp[0] = 0;				pStrConc (tmp, dstSpec->name, tmp);				if (dstSpec->name[dstSpec->name[0]] != ':')			pStrConc (tmp, "\p:", tmp);				pStrConc (tmp, srcSpec->name, dstSpec->name);				rc = FSpCreate (dstSpec, 'Ravl', 'PKT ', 0);		if (rc != noErr)		{			putlog (lgATTN, "FSpCreate failed (%d) part: '%#s'", rc, dstSpec->name);			break;		}				rc = FSpOpenDF (srcSpec, fsRdPerm, &src);		if (rc != noErr)		{			putlog (lgATTN, "FSpOpenDF (src) failed (%d)", rc);			break;		}				rc = FSpOpenDF (dstSpec, fsRdWrPerm, &dst);		if (rc != noErr)		{			putlog (lgATTN, "FSpOpenDF (dst) failed (%d)", rc);			FSClose (src);			break;		}				SetFPos (src, fsFromStart, 0);		SetFPos (dst, fsFromStart, 0);				do {						ioCounter = 512L;			FSRead (src, &ioCounter, r_buf);			FSWrite (dst, &ioCounter, r_buf);				} while (ioCounter);				FSClose (src);		FSClose (dst);				FSpDelete (srcSpec);			break;	}		return rc;}static Boolean ExtExists (char *filename){	short	a;		for (a=0;a<7;a++) 		if ( !strncasecmp (&filename[10], ValidExt[a], 2) )			break;	return (a!=7);}static void AddBundle (short currentzone, short currentnet, short currentnode, short currentpoint){	pque	t_que;	if (first_que)	{		t_que = first_que;				while (t_que)		{			if (t_que->address.zone == currentzone &&				t_que->address.net == currentnet &&				t_que->address.node == currentnode &&				t_que->address.point == currentpoint)				break;						t_que = t_que->next; 		}				if (t_que)			return;		current_que->next = (pque) NewPtr (sizeof (que));		current_que = current_que->next;	}	else	{		first_que = current_que = (pque) NewPtr (sizeof (que));	}		current_que->next = NULL;	current_que->address.zone = currentzone;	current_que->address.net = currentnet;	current_que->address.node = currentnode;	current_que->address.point = currentpoint;}static void de_bundler (addr *address){	Str255			flo, test;	char			temp[256], buff[512];	short			i, a;	FILE			*b_flo;	unsigned long	f_time, f_size;		first_bque[0] = NULL;	first_bque[1] = NULL;	first_bque[2] = NULL;	if (get_flo_pathname (address, outboundPath, flo))	{		for (i=0; i<3; i++)		{			strcpy (&temp[1], (char *) &flo[1]);			strcat (&temp[1], pollModes[i]);						b_flo = fopen (&temp[1], "r");						if (b_flo)			{				while (fgets (buff, 510, b_flo) != NULL)				{					if (!buff[0] || buff[0] == '~')						continue;										strcpy ((char *) &test[1], &buff[1]);					test[0] = strlen (&buff[1]) - 1;										if (GetInfFile (0, test, &f_time, &f_size ) != noErr)						continue;										if (first_bque[i])					{						current_bque[i]->next = (pbque) NewPtr (sizeof (bque));						current_bque[i] = current_bque[i]->next;					}					else					{						first_bque[i] = current_bque[i] = (pbque) NewPtr (sizeof (bque));					}										current_bque[i]->next = NULL;					current_bque[i]->kill = (buff[0] == '-') ? 1 : 0;					pStrCopy (test, current_bque[i]->pathname);										if (!strncasecmp ( (char *) &test[test[0] - 3], ".PKT", 4))						current_bque[i]->file = MOVE_NETMAIL;					else					{						for (a=0;a<7;a++)						//	Validate DOS extensionÉ							if ( !strncasecmp ( (char *) &test[test[0] - 2], ValidExt[a], 2) )								break;								if(a!=7)							current_bque[i]->file = MOVE_ARCMAIL;						else							current_bque[i]->file = MOVE_FLOS;					}				}				fclose (b_flo);				if (!first_bque[i])				{					first_bque[i] = (pbque) NewPtr (sizeof (bque));					current_bque[i]->next = NULL;					current_bque[i]->kill = 0;					current_bque[i]->pathname[0] = 0;					current_bque[i]->file = MOVE_FLOS;				}							temp[0] = strlen (&temp[1]);				FSDelete ((StringPtr) temp, 0);			}		}	}}void Resolver (long process){	short			zdir, ndir, pdir;			// working directory reference numberÉ	CInfoPBRec		cipbr;						/* local pb */	HFileInfo		*fpb = (HFileInfo *)&cipbr;	/* to pointers */	short			rc, idx, idx1, idx2;	Str32			filename, q_name;	long			currentzone, currentnet, currentnode, currentpoint, dummy, cnt, t;	unsigned long	first_t, second_t, sizer, f_time, f_size;	Boolean			reminder = false;		Str255			subfolder, subfolder1;	pque			t_que, q_que;	pbque			t_bque, q_bque;	Str255			flo, flo1, newpktname;	char			temp[256], temp1[256], buff[512], r_buf[512];	FILE			*b_flo, *b_flo1, *term;	FSSpec			srcSpec, dstSpec, arcList[11], accList[11];	unsigned long	arcSize[11];	short			src, dst, nodenum;	long			ioCounter, module, quote;	char			suffix[32], prefix[32];	Boolean			do_append, need_remind = false;	DateTimeRec		dtr;		addr			wrap[2];	first_que = NULL;	current_que = NULL;	workPath[workPath[0]+1] = 0;	if ( ( zdir = myOpenWD ( workPath ) ) == 0 )	{		putlog ( lgALRT, "Unable to open directory %s", &workPath[1] );		return;	}	fpb->ioNamePtr = filename;	for ( idx=1; true; idx++)	{											/* indexing loop */		fpb->ioDirID = 0L;						/* must set on each loop */		fpb->ioFDirIndex = idx;		fpb->ioVRefNum = zdir;		filename[0] = 0;				rc = PBGetCatInfoSync (&cipbr);				if (rc) break;							/* exit when no more entries */		if ( (fpb->ioFlAttrib & 16) && filename[0] == 9 )		{										/* zone folder: Zone_XXXX */			filename[filename[0]+1] = 0;						if ( strncmp ( (char *) &filename[1], "Zone_", 5 ) )				continue;							if ( sscanf ( (char *) &filename[6], "%lX", &currentzone ) == EOF )				continue;						pStrConc ( workPath, filename, subfolder );						ndir = myOpenWD ( subfolder );						for ( idx1=1; true; idx1++)			{											/* indexing loop */				fpb->ioDirID = 0L;						/* must set on each loop */				fpb->ioFDirIndex = idx1;				fpb->ioVRefNum = ndir;				filename[0] = 0;								rc = PBGetCatInfoSync (&cipbr);								if (rc) break;							/* exit when no more entries */						if ( filename[0] == 12 )				{										/* look up for nodes attaches & pts */					filename[filename[0]+1] = 0;		/* NNNNnnnn.?LO or NNNNnnnn.PTS */										if ( !(fpb->ioFlAttrib & 16) &&			//	¥	NODE attach						 filename[9] == '.' &&						((!strncmp ( (char *) &filename[10], "00", 2 ) && (process & MOVE_ARCMAIL) != 0) ||						 (!strncmp ( (char *) &filename[11], "LO", 2 ) && (process & MOVE_FLOS) != 0) ||						 (!strncmp ( (char *) &filename[11], "KT", 2 ) && (process & MOVE_NETMAIL) != 0) ||						 (!strncmp ( (char *) &filename[10], "REQ", 3 ) && (process & MOVE_FREQ) != 0) ))					{						if ( sscanf ( (char *) &filename[1], "%lX", &currentnode ) == EOF )							continue;										currentnet = currentnode >> 16;						currentnode &= 0x0000FFFF;						AddBundle (currentzone, currentnet, currentnode, 0);					}					else						if ( (fpb->ioFlAttrib & 16) &&		//	¥	Point folder							 !strncmp ( (char *) &filename[9], ".PTS", 4 ) )						{							if ( sscanf ( (char *) &filename[1], "%lX", &currentnode ) == EOF )								continue;														currentnet = currentnode >> 16;							currentnode &= 0x0000FFFF;														pStrConc ( subfolder, "\p:", subfolder1 );							pStrConc ( subfolder1, filename, subfolder1 );														pdir = myOpenWD ( subfolder1 );														for ( idx2=1; true; idx2++)							{											/* indexing loop */								fpb->ioDirID = 0L;						/* must set on each loop */								fpb->ioFDirIndex = idx2;								fpb->ioVRefNum = pdir;								filename[0] = 0;																rc = PBGetCatInfoSync (&cipbr);																if (rc) break;							/* exit when no more entries */														if ( filename[0] == 12 )								{										/* look up for pts attaches */									filename[filename[0]+1] = 0;		/* NNNNNNNN.?LO */												if ( !(fpb->ioFlAttrib & 16) &&			//	¥	point attach										 filename[9] == '.' &&										((!strncmp ( (char *) &filename[10], "00", 2 ) && (process & MOVE_ARCMAIL) != 0) ||										 (!strncmp ( (char *) &filename[11], "LO", 2 ) && (process & MOVE_FLOS) != 0) ||										 (!strncmp ( (char *) &filename[11], "KT", 2 ) && (process & MOVE_NETMAIL) != 0) ||										 (!strncmp ( (char *) &filename[10], "REQ", 3 ) && (process & MOVE_FREQ) != 0) ))									{										if ( sscanf ( (char *) &filename[1], "%lX", &currentpoint ) == EOF )											continue;																				AddBundle (currentzone, currentnet, currentnode, currentpoint);									}								}														}	/* points cycle */														myCloseWD ( pdir );						}				}							}	/* node cycle */					myCloseWD ( ndir );					}	}			/* zone cycle */		myCloseWD ( zdir );	while (first_que)	{//	¥	Processing bundles here				nodenum = LookForLinkNumber (&first_que->address);				if (!bsy_raise (&first_que->address, workPath))		{			putlog (lgNOPE, "Bundling for %s.", printaddr (&first_que->address, temp1));			de_bundler (&first_que->address);					if (!get_flo_pathname (&first_que->address, outboundPath, flo))				continue;			if (!get_flo_pathname (&first_que->address, workPath, flo1))				continue;						wrap[0] = (*homesystem)->mainAddr.ad;			wrap[1] = first_que->address;			sprintf (prefix, "%.8lX", hash ((char *) &wrap[0], 2 * sizeof (addr)));			for (idx=0; idx<3; idx++)			{				strcpy (&temp[1], (char *) &flo[1]);				strcat (&temp[1], pollModes[idx]);		//	¥	FILE ATTACHES	//	//	¥	Preserve old flos				if (first_bque[idx])				{					t_bque = first_bque[idx];										while (t_bque)					{						if (t_bque->file == MOVE_FLOS)						{							b_flo = fopen (&temp[1], "a");														if (t_bque->pathname[0])								fprintf (b_flo, "%c%#s\xA", (t_bque->kill) ? '-' : '+', t_bque->pathname);														fclose (b_flo);						}												t_bque = t_bque->next; 					}				}								if ((process & MOVE_FLOS) != 0)				{	//	¥	File attaches resolver									strcpy (&temp1[1], (char *) &flo1[1]);					strcat (&temp1[1], pollModes[idx]);										b_flo1 = fopen (&temp1[1], "r");										if (b_flo1)					{						b_flo = fopen (&temp[1], "a");												while (fgets (buff, 510, b_flo1) != NULL)							fprintf (b_flo, "%s", buff);												fclose (b_flo);						fclose (b_flo1);												temp1[0] = strlen (&temp1[1]);						FSDelete ((StringPtr) temp1, 0);					}				}					//	¥	NETMAIL ATTACHES	//	//	¥	Preserve old netmail								q_bque = NULL;		//	Last netmail's used pkt								if (first_bque[idx])				{					t_bque = first_bque[idx];										while (t_bque)					{						if (t_bque->file == MOVE_NETMAIL)						{							b_flo = fopen (&temp[1], "a");														fprintf (b_flo, "%c%#s\xA", (t_bque->kill) ? '-' : '+', t_bque->pathname);														if (GetInfFile (0, t_bque->pathname, &f_time, &f_size ) == noErr)							{								if (f_size < MaxArcSize)									q_bque = t_bque;							}														fclose (b_flo);						}												t_bque = t_bque->next; 					}				}								if ((process & MOVE_NETMAIL) != 0)				{	//	¥	NetMail resolver									strcpy (&temp1[1], (char *) &flo1[1]);					strcat (&temp1[1], pktModes[idx]);										temp1[0] = strlen (&temp1[1]);										if (GetInfFile (0, (StringPtr) temp1, &f_time, &f_size ) == noErr)					{	//	¥ pkt to send present											if (q_bque)						{	//	¥	append to exists							rc = FSMakeFSSpec (0, 0, (StringPtr) temp1, &srcSpec);							rc = FSMakeFSSpec (0, 0, q_bque->pathname, &dstSpec);														rc = FSpOpenDF ( &srcSpec, fsRdPerm, &src);							rc = FSpOpenDF ( &dstSpec, fsRdWrPerm, &dst);							SetFPos (src, fsFromStart, sizeof (struct _pkthdr));							SetFPos (dst, fsFromLEOF, -2);														putlog (lgNOPE, "  Append Netmail %#s -> %#s", srcSpec.name, dstSpec.name);														do {																ioCounter = 512L;								FSRead (src, &ioCounter, r_buf);								FSWrite (dst, &ioCounter, r_buf);														} while (ioCounter);														FSClose (src);							FSClose (dst);														FSpDelete ( &srcSpec );						}						else						{	//	¥	create new													pStrCopy (flo, subfolder);							subfolder[0] -= 8;			//	kill fielname (use folder)														rc = FSMakeFSSpec (0, 0, (StringPtr) temp1, &srcSpec);							rc = FSMakeFSSpec (0, 0, subfolder, &dstSpec);														sprintf ((char *) &newpktname[1], "%.8lX.PKT", msgbase_new_msgid ());							newpktname[0] = strlen ((char *) &newpktname[1]);														putlog (lgNOPE, "  Create Netmail %#s -> %#s", srcSpec.name, newpktname);							rc = FSpRename (&srcSpec, newpktname);							pStrCopy (newpktname, srcSpec.name);							rc = myFSpCatMove (&srcSpec, &dstSpec);													b_flo = fopen (&temp[1], "a");							fprintf (b_flo, "-%#s%#s\xA", subfolder, newpktname);							fclose (b_flo);						}					}				}	//	¥	ARCMAIL ATTACHES	//	//	¥	Preserve old arcmail				if (first_bque[idx])				{					t_bque = first_bque[idx];										while (t_bque)					{						if (t_bque->file == MOVE_ARCMAIL)						{							b_flo = fopen (&temp[1], "a");							fprintf (b_flo, "%c%#s\xA", (t_bque->kill) ? '-' : '+', t_bque->pathname);							fclose (b_flo);						}												t_bque = t_bque->next; 					}				}								if (nodenum != -1 && (process & MOVE_ARCMAIL) != 0 && (*nodesHndls[nodenum])->Poll == idx)				{	//	¥	ArcMail resolver									strcpy ((char *) &subfolder[1], (char *) &flo1[1]);					strcat ((char *) &subfolder[1], ".$$$");						//	¥	Determine starting arcmail suffix								GetTime ( &dtr );					term = fopen ((char *) &subfolder[1], "r");										if (!term)					{					recreate:											sprintf ( suffix, "%s0", ValidExt[dtr.dayOfWeek-1] );					}					else					{						if (fgets (suffix, 16, term) == NULL)						{							fclose (term);							goto recreate;						}												fclose (term);												if (strncasecmp (suffix, ValidExt[dtr.dayOfWeek-1], 2))							goto recreate;													suffix[3] = 0;					}								//	¥	Prepare pkts' list								for (idx1 = 0; idx1 < 10; idx1++)					{						strcpy (&temp1[1], (char *) &flo1[1]);						strcat (&temp1[1], ".000");						temp1[0] = strlen (&temp1[1]);												temp1[temp1[0]] += idx1;												if (GetInfFile (0, (StringPtr) temp1, &f_time, &arcSize[idx1]) != noErr)							break;												rc = FSMakeFSSpec (0, 0, (StringPtr) temp1, &arcList[idx1]);						sprintf ((char *) &newpktname[1], "%.8lX.PKT", msgbase_new_msgid ());						newpktname[0] = strlen ((char *) &newpktname[1]);						rc = FSpRename (&arcList[idx1], newpktname);						pStrCopy (newpktname, arcList[idx1].name);					}									//	¥	Set list's terminator					arcList[idx1].name[0] = 0;									//	¥	Compress all										idx1 = 0;										while (arcList[idx1].name[0])					{						pStrCopy (flo, subfolder);						subfolder[0] -= 8;			//	kill fielname (use folder)						subfolder[subfolder[0]+1] = 0;												strcat ((char *) &subfolder[1], prefix);						strcat ((char *) &subfolder[1], ".");						strcat ((char *) &subfolder[1], suffix);						subfolder[0] = strlen ((char *) &subfolder[1]);												if (GetInfFile (0, subfolder, &f_time, &f_size) != noErr)						{					//	¥	Create new												do_append = false;							quote = MaxArcSize;							rc = Create (subfolder, 0, 'RvlS', 'TEMP');							rc = FSMakeFSSpec (0, 0, subfolder, &dstSpec);							FSDelete (subfolder, 0);						}						else						{				//	¥	try append													do_append = true;							quote = MaxArcSize - (long)f_size;														rc = FSMakeFSSpec (0, 0, subfolder, &dstSpec);						}												if (quote < 0)						{							if (suffix[2] >= '9')								suffix[2] = 'A';							else								if (suffix[2] == 'Z')									quote = 0x7FFFFFFFL;								else								{									suffix[2]++;									continue;								}						}												accList[0].name[0] = 0;						idx2 = 0;												while (1)						{							if (!arcList[idx1].name[0])								break;														putlog (lgNOPE, "  Compressing %#s -> %#s", arcList[idx1].name, dstSpec.name);							accList[idx2++] = arcList[idx1];							quote -= arcSize[idx1++] / 3;														if (quote < 0)								break;						}												if (!accList[0].name[0])							break;						accList[idx2].name[0] = 0;												if (!(*(nodesHndls[nodenum]))->Compressor)							goto non_compress;												module = 1 << ((*(nodesHndls[nodenum]))->Compressor - 1);						if (CallArchiverPlugIns (	true,					//	compress													do_append,				//	not append													module,					//	compressor													accList,				//	what compress													&dstSpec				//	archive												) != plugRetContinue)						{							putlog (lgALRT, "No such compressor (%s). Compression fault. Move PKTs.",								arcs[(*(nodesHndls[nodenum]))->Compressor - 1]);													non_compress:													pStrCopy (flo, subfolder);							subfolder[0] -= 8;			//	kill fielname (use folder)														rc = FSMakeFSSpec (0, 0, subfolder, &dstSpec);														idx2 = 0;							while (accList[idx2].name[0])							{								putlog (lgNOPE, "    Moveing -> %#s", accList[idx2].name);								rc = myFSpCatMove (&accList[idx2], &dstSpec);															b_flo = fopen (&temp[1], "a");								fprintf (b_flo, "-%#s%#s\xA", subfolder, accList[idx2].name);								fclose (b_flo);								idx2++;							}						}						else						{							if (!do_append)							{								pStrCopy (flo, subfolder);								subfolder[0] -= 8;			//	kill fielname (use folder)								b_flo = fopen (&temp[1], "a");								fprintf (b_flo, "-%#s%#s\xA", subfolder, dstSpec.name);								fclose (b_flo);							}														idx2 = 0;							while (accList[idx2].name[0])							{								FSpDelete (&accList[idx2]);								idx2++;							}						}					}										strcpy ((char *) &subfolder[1], (char *) &flo1[1]);					strcat ((char *) &subfolder[1], ".$$$");						//	¥	Determine starting arcmail suffix								GetTime ( &dtr );					term = fopen ((char *) &subfolder[1], "w");										fprintf ( term, "%s", suffix );										fclose (term);				}			}						if ((process & MOVE_FREQ) != 0)			{	//	¥	File requests resolver							strcpy (&temp1[1], (char *) &flo1[1]);				strcat (&temp1[1], ".REQ");				temp1[0] = strlen (&temp1[1]);								rc = FSMakeFSSpec (0, 0, (StringPtr) temp1, &srcSpec);								if (rc == noErr)				{					strcpy ((char *) &subfolder[1], (char *) &flo[1]);					strcat ((char *) &subfolder[1], ".REQ");					subfolder[0] = strlen ((char *) &subfolder[1]);					rc = FSMakeFSSpec (0, 0, subfolder, &dstSpec);										if (rc != noErr)					{						rc = Create (subfolder, 0, 'CWIE', 'TEXT');						rc = FSMakeFSSpec (0, 0, subfolder, &dstSpec);					}										rc = FSpOpenDF ( &srcSpec, fsRdPerm, &src);					rc = FSpOpenDF ( &dstSpec, fsRdWrPerm, &dst);					SetFPos (src, fsFromStart, 0);					SetFPos (dst, fsFromLEOF, 0);									do {												ioCounter = 512L;						FSRead (src, &ioCounter, r_buf);						FSWrite (dst, &ioCounter, r_buf);										} while (ioCounter);										FSClose (src);					FSClose (dst);										FSpDelete ( &srcSpec );				}			}			bsy_clear (&first_que->address, workPath);		}		else		{			need_remind = true;			putlog (lgATTN, "Bundling for %s is busy.", printaddr (&first_que->address, temp1));		}		current_que = first_que->next;		DisposePtr ((Ptr) first_que);		first_que = current_que;	}	ReportToMailer (!need_remind);}