#include <Sound.h>#include <stdio.h>#include <string.h>#include "ravel_msg_base.h"#include "ravel_tmp_base.h"#include "busy.h"#include "Toss.h"#include "Scan.h"#include "PascalStr.h"#include "Ravel_Prefs.h"#include "key.h"#include "What.h"#include "Linker.h"#include "Purge.h"#include "Pack.h"#include "log.h"#include "statistic.h"#include "Plug-Ins.h"#include "ZipIt.h"#include "hashing.h"#include "Attaches.h"#include "do_about.h"#include "nodelist.h"#include "myEnv.h"#include "Pathes.h"#define	kRavelEventClass	'R&vl'#define	kAEEnqueueCmd		'enQu'#define	kAENotifyQuill		'ntQu'#define	kAEScanComplete		'scQu'#define	kAEAskRemind		'rmQu'#define	kAERescan			'rsQu'#define HiWrd(a)	(((a) >> 16) & 0xFFFF)#define LoWrd(a)	((a) & 0xFFFF)enum {	uppAEHandlerProcInfo = kPascalStackBased		 | RESULT_SIZE(SIZE_CODE(sizeof(OSErr)))		 | STACK_ROUTINE_PARAMETER(1, SIZE_CODE(sizeof(Ptr)))		 | STACK_ROUTINE_PARAMETER(2, SIZE_CODE(sizeof(Ptr)))		 | STACK_ROUTINE_PARAMETER(3, SIZE_CODE(sizeof(long))),//	pascal Boolean myAlertProc (DialogPtr theDialog, EventRecord *theEvent, short *itemHit)	uppModalProcInfo = kPascalStackBased		 | RESULT_SIZE(SIZE_CODE(sizeof(Boolean)))		 | STACK_ROUTINE_PARAMETER(1, SIZE_CODE(sizeof(Ptr)))		 | STACK_ROUTINE_PARAMETER(2, SIZE_CODE(sizeof(Ptr)))		 | STACK_ROUTINE_PARAMETER(3, SIZE_CODE(sizeof(Ptr))),};Boolean			gAppearance = false;char			*tempBuffer;short			type2plus;			// • Type 2+ packets enabler.short			timezone;			// • Time Zone number.long			MaxArcSize;			// • Max. size of arcmailshort			gQuit;				// • Perform quittingshort			gWait;				// • WAIT command encountered (quit after QUIT)Str255			Pathes[6];Str255			RealName, NodeLists;Str63			MacModel;extern	Boolean	gBaseBusy;homeHndl		homesystem;			//	•	Home system structmailPrefHndl	mailHndl;			//	•	Netmail structshort			AreasNumber;		//	•	Areas structs listareaPrefHndl	*areasHndls;short			GroupsNumber;		//	•	AreaGroups structs listgroupPrefHndl	*groupsHndls;short			NodesNumber;		//	•	Linked Nodes structs listnodePrefHndl	*nodesHndls;routeHndl		Routing;short			wdWorkRefNum;		//	•	WD for bundles spooling…//	Boolean			ZipItExist;//	Boolean			StuffItExist;DialogPtr		RavelWindow;		Boolean		multiline_flag = false;		short		multiline_line = '!' - '0';static	RGBColor	colorBlack = {17030, 17030, 17030};static	RGBColor	colorWhite = {53055, 53055, 65535};static	long	progressValue = 0;static	float	limit = 0.0;static	float	ratio = 1.0;static	Rect	box;Boolean	ReadPreference (void);void	DoSlice (void);void	Do_ConvertBase (void);void	InitProgress (float howmuch);void	DrawProgress (long i);void	putProgressName (Str255 name);static	void EnqueueCommand (short doit);void	ReportToMailer (Boolean);OSErr	FindAProcess (OSType typeToFind, OSType creatorToFind, ProcessSerialNumberPtr processSN);void	UpdatePreference_Links (void);void	UpdatePreference_Areas (void);enum {	uppPlugEntryProcInfo = kThinkCStackBased		 | STACK_ROUTINE_PARAMETER(1, SIZE_CODE(sizeof(Ptr)))	};static	UniversalProcPtr	uupMyHandleQuit, uupMyHandleOAPP, uupMyHandleEnqueue;OSErr FindAProcess (OSType typeToFind, OSType creatorToFind,			ProcessSerialNumberPtr processSN){	ProcessInfoRec	tempInfo;	FSSpec	procSpec;	Str31		processName;	OSErr		myErr = noErr;	// start at the beginning of the process list	processSN->lowLongOfPSN = kNoProcess;	processSN->highLongOfPSN = 0;	// initialize the process information record	tempInfo.processInfoLength = sizeof(ProcessInfoRec);	tempInfo.processName = (StringPtr)&processName;	tempInfo.processAppSpec = &procSpec;//	while((tempInfo.processSignature != creatorToFind ||//			tempInfo.processType != typeToFind) ||//			myErr != noErr)		do {		myErr = GetNextProcess (processSN);		if (myErr == noErr)		{			GetProcessInformation(processSN, &tempInfo);			if (tempInfo.processSignature == creatorToFind &&				tempInfo.processType == typeToFind)				break;		}			} while (myErr == noErr);	return(myErr);}void InitProgress (float howmuch){	Handle		iHandle;	short		iType;	RGBColor	oldFColor;	Rect		bbox;	GrafPtr		oldPort;	if (howmuch == 0)		howmuch = 1.0;		GetPort (&oldPort);	SetPort (RavelWindow);	GetDialogItem ( RavelWindow, 3, &iType, &iHandle, &box );	if (!gAppearance)	{		if (howmuch < 0)			howmuch = 1.0;			GetForeColor (&oldFColor);		RGBForeColor (&colorWhite);		FillRect ( &box, &qd.black );		RGBForeColor (&oldFColor);				bbox = box;		InsetRect ( &bbox, -1, -1 );		FrameRect ( &bbox );	}	progressValue = 0;	if (gAppearance)	{		Boolean indeterminate;		if (howmuch < 0)		{			indeterminate = true;					SetControlData((ControlHandle)iHandle,							kControlLabelPart,							kControlProgressBarIndeterminateTag,							sizeof(Boolean),							&indeterminate);		}		else		{			indeterminate = false;					SetControlData((ControlHandle)iHandle,							kControlLabelPart,							kControlProgressBarIndeterminateTag,							sizeof(Boolean),							&indeterminate);			if (howmuch > 32000)				ratio = 32000.0 / howmuch;			else				ratio = 1.0;					limit = ratio * howmuch;			SetControlMinimum ((ControlHandle)iHandle, 0);			SetControlMaximum ((ControlHandle)iHandle, limit);			SetControlValue ((ControlHandle)iHandle, progressValue);		}	}	else		limit = ((float)(box.right - box.left))/howmuch;	/* use a float to get good*/	InvalRect(&box);		SetPort (oldPort);}void DrawProgress (long i){	RGBColor	oldFColor;	Rect		bbox;	GrafPtr		oldPort;	Handle		iHandle;	short		iType;			if (i == -1)		i = progressValue;	else		if (progressValue == i)			return;		GetPort (&oldPort);	SetPort (RavelWindow);	if (gAppearance)	{		progressValue = ratio * i;		GetDialogItem ( RavelWindow, 3, &iType, &iHandle, &box );		SetControlValue ((ControlHandle)iHandle, progressValue);	}	else	{		bbox = box;		bbox.right = box.left + (progressValue = i)*limit;		GetForeColor (&oldFColor);		RGBForeColor (&colorBlack);		FillRect ( &bbox, &qd.black );		bbox = box;		bbox.left = box.left + progressValue*limit;		RGBForeColor (&colorWhite);		FillRect ( &bbox, &qd.black );		RGBForeColor (&oldFColor);	}	SetPort (oldPort);}void putProgressName (Str255 name){	Rect		iRect;	Handle		iHandle;	short		iType;	GetDialogItem ( RavelWindow, 2, &iType, &iHandle, &iRect );	SetDialogItemText ( iHandle, name );}#define	MENU_APPLE		1#define	MENU_FILE		2#define	MENU_EDIT		3#define	MENU_SHUFFLER	4/*	Apple	*/#define	ITEM_ABOUT		1/*	File	*/#define	ITEM_CONVERT	1//		-----------		2#define	ITEM_QUIT		3/*	Edit	*/#define	ITEM_UNDO		1//		-----------		2#define	ITEM_CUT		3#define	ITEM_COPY		4#define	ITEM_PASTE		5#define	ITEM_CLEAR		6static void AdjustMenus (void){	MenuHandle		menu;			menu = GetMenuHandle (MENU_APPLE);			//	•••	About	if (DoIt)	{		DisableItem (menu, ITEM_ABOUT);	}	else	{		EnableItem (menu, ITEM_ABOUT);	}	menu = GetMenuHandle (MENU_FILE);			//	•••	File	if (DoIt)	{		DisableItem (menu, ITEM_CONVERT);		DisableItem (menu, ITEM_QUIT);	}	else	{		EnableItem (menu, ITEM_CONVERT);		EnableItem (menu, ITEM_QUIT);	}	menu = GetMenuHandle (MENU_SHUFFLER);		//	•••	Session	if (DoIt)	{		DisableItem (menu, 0);	}	else	{		EnableItem (menu, 0);	}}static void DoMenuCommand (register long menuResult, short options){	register short	menuItem;	Str255			daName;	short			i;	DialogPtr		doom;	PicHandle		hPic;	GrafPtr			oldGraf;	MenuHandle		theMenu;		menuItem = LoWrd(menuResult);	switch(HiWrd(menuResult))	{		case MENU_APPLE:					//	•••	Apple Menu					switch(menuItem)			{			case ITEM_ABOUT:			//	•••	"About RavelMAIL…"					HiliteMenu (0);				do_about (options);				break;			default:		//	•••	Others…								GetMenuItemText (GetMenuHandle(1), menuItem, (Byte *)&daName);				OpenDeskAcc((Byte *)&daName);								break;			}			break;		case MENU_FILE:						//	•••	File menu			switch(menuItem)			{			case ITEM_CONVERT:							if (!base_bsy_check ())				{					putlog (lgNOPE, "Converting old base.");										base_bsy_raise ();										DoIt = -1;					Do_ConvertBase ();					DoIt = 0;					base_bsy_clear ();				}				else					putlog (lgNOPE, "Base busy.");				break;						case ITEM_QUIT:				//	•••	Qiut now							gQuit = true;				break;			}			break;		case MENU_EDIT:						//	•••	Edit menu			break;					case MENU_SHUFFLER:					//	•••	Shuffler			if (menuItem <= _IMPORT)				EnqueueCommand (menuItem);			else			{//	•	Custom here								theMenu = GetMenu ( 4 );				GetMenuItemText (theMenu, menuItem, DoItName);				DoItName[DoItName[0]+1] = 0;				EnqueueCommand (-1);			}						break;	}	HiliteMenu(0);}/* ----- Handle new event ---------------------------------------------- */#define SuspendResume	1#define ResumeMask		1static void DoEvent(register EventRecord *event){	register short	part;	WindowPtr		window;	unsigned char	key;			/* ASCII key code */	short			iType;	Handle			iHandle;	Rect			iRect;	short			i, j;	Cell			theCell;	DialogPtr		dialog;	Boolean			wasdouble;		if (gAppearance)		IdleControls(RavelWindow);	switch( event->what )	{		case mouseDown:					switch ( part = FindWindow(event->where, &window) )			{								case inMenuBar:									AdjustMenus ();					DoMenuCommand (MenuSelect(event->where), event->modifiers);					break;								case inSysWindow:									SystemClick(event, window);					break;								case inContent:									if (window != FrontWindow())						SelectWindow(window);					else					{						if (window == RavelWindow)						{							SetPort(window);							GlobalToLocal(&event->where);	//						DocumentClick((DocumentPeek)window, event->where, event->modifiers);						}					}										break;				case inDrag:					DragWindow ( window, event->where, &qd.screenBits.bounds );					break;				case inGoAway:					if ( ((WindowPeek) window)->windowKind < 0 )						CloseDeskAcc(((WindowPeek)window)->windowKind);					else					{						if (!DoIt)							if (TrackGoAway(window, event->where))								gQuit = true;					}										break;				}								break;							case autoKey:			case keyDown:								if ( ((WindowPeek) FrontWindow())->windowKind < 0 )					break;				else					if ( (event->modifiers & cmdKey) && !DoIt )					{						key = event->message & charCodeMask;								AdjustMenus();						DoMenuCommand ( MenuKey(key), event->modifiers );					}				break;			case activateEvt:				//			if ( (WindowPtr) event->message == RavelWindow )	//				ActivateDocument((DocumentPeek)event->message,	//					event->modifiers & activeFlag);					break;				case updateEvt:					if ( (WindowPtr) event->message == RavelWindow )				{					Rect	bbox;					GrafPtr		oldPort;															GetPort (&oldPort);					SetPort (RavelWindow);					BeginUpdate((WindowPtr)event->message);					SetPort ( RavelWindow );					UpdateDialog ( RavelWindow, RavelWindow->visRgn );					EndUpdate((WindowPtr)event->message);					DrawProgress (-1);										if (!gAppearance)					{						bbox = box;						InsetRect ( &bbox, -1, -1 );						FrameRect ( &bbox );					}										updtlog ();					SetPort (oldPort);				}				break;							case diskEvt:								if (HiWord(event->message) != noErr) {	//				static Point where = { 80, 80 };	//				DIBadMount(where, event->message);				}								break;			case kHighLevelEvent:				AEProcessAppleEvent (event);				break;			case osEvt:					if ( ((unsigned long) event->message >> 24) == SuspendResume )				{					window = FrontWindow();									if ( event->message & ResumeMask )					{	//					Background = FALSE;											if ( (WindowPtr) event->message == RavelWindow )						{							HiliteWindow(window, true);						}					}					else					{	//					Background = TRUE;												if ( (WindowPtr) event->message == RavelWindow )						{							HiliteWindow(window, false);						}					}				}				break;			case nullEvent:#ifndef LITE#ifdef PROTECTED				if (keys.crc != keys.oldcrc)					ExitToShell ();						if ((keys.oldcs+1+keys.cs)&0xFFFF)					ExitToShell ();									(*homesystem)->mainAddr.ad = keys.regAddr;#endif#endif				break;		}}void DoSlice (){	EventRecord		event;	WaitNextEvent (everyEvent, &event, 0, NULL);	DoEvent (&event);}static pascal OSErr MyHandleQuit (const AppleEvent *theAppleEvent, AppleEvent *reply, long handlerRefcon){	if (!DoIt && gWait)		gQuit = true;	return (gQuit) ? noErr : userCanceledErr;}static pascal OSErr MyHandleOAPP (const AppleEvent *theAppleEvent, AppleEvent *reply, long handlerRefcon){	return	noErr;}static pascal OSErr MyHandleEnqueue (const AppleEvent *theAppleEvent, AppleEvent *reply, long handlerRefcon){	Str255		name;	Rect		iRect;	Handle		iHandle;	short		iType;	if (!ParseCommand())	{		DoIt = _WAIT;		EnqueueCommand (DoIt);	}	else		DoIt = DequeueCommand(false);	return	noErr;}static void InitToolbox (void){	InitGraf((Ptr) &qd.thePort);	InitFonts();	InitWindows();	InitMenus();	FlushEvents(everyEvent,0);	TEInit();	InitDialogs(0L);	InitCursor();}void UpdatePreference_Links (void){	Handle	h;	short	oldResNum = CurResFile ();	short	prefResNum = OpenResFile ( prefFile );	short	i;		if ( prefResNum == -1 )	{		putlog (lgALRT, "Can't open preferences for updating.");		return;	}		UseResFile ( prefResNum );	for (i = 0; i < NodesNumber; i++)	{		if ( (h = Get1Resource ( nodesRes, i )) != NULL )		{			RemoveResource (h);			DisposeHandle (h);			UpdateResFile ( prefResNum );		}		AddResource ( (Handle) nodesHndls[i], nodesRes, i, "\pLink description" );		WriteResource ( (Handle) nodesHndls[i] );		DetachResource ( (Handle) nodesHndls[i] );	}	UseResFile ( oldResNum );	CloseResFile ( prefResNum );}void UpdatePreference_Areas (void){	Handle	h;	short	oldResNum = CurResFile ();	short	prefResNum = OpenResFile ( prefFile );	short	i;		if ( prefResNum == -1 )	{		putlog (lgALRT, "Can't open preferences for updating.");		return;	}		UseResFile ( prefResNum );	for (i = 0; i < AreasNumber; i++)	{		if ( (h = Get1Resource ( areasRes, i+1 )) != NULL )		{			RemoveResource (h);			DisposeHandle (h);			UpdateResFile ( prefResNum );		}		AddResource ( (Handle) areasHndls[i], areasRes, i+1, "\pArea description" );		WriteResource ( (Handle) areasHndls[i] );		DetachResource ( (Handle) areasHndls[i] );	}	UseResFile ( oldResNum );	CloseResFile ( prefResNum );}Boolean ReadPreference (void){	Handle	h;	short	oldResNum = CurResFile ();	short	prefResNum = OpenResFile ( prefFile );	Boolean	res = FALSE;	short	i;	Str255	temp;	FSSpec	spec;	long	dummy;	//	iFileRef = OpenRFPerm(fileName,vRefNum,permission);		if ( prefResNum == -1 )		return res;	UseResFile ( prefResNum );	h = Get1Resource ('VERS', 0);	if (!h || **h != 2)		return res;		ReleaseResource (h);		do {		h = Get1Resource ( 'Shfl', 0 );		if (h)		{			type2plus = *((short *) *h);						if (type2plus != 0x0000 &&				type2plus != 0x0200 &&				type2plus != 0x02FF &&				type2plus != 0x0201 &&				type2plus != 0x0220)			{				type2plus = 0x0200;			}						timezone = *((short *) (*h+2));			MaxArcSize = (long) (*((short *) (*h+4)));						if (MaxArcSize <= 0)				MaxArcSize = 0x7FFFFFFFL;			else				MaxArcSize *= 1024L;						if (timezone == 'TZ')			{				MachineLocation	loc;				long			lll;											ReadLocation (&loc);							lll = loc.u.gmtDelta & 0x00FFFFFFL;								if (loc.u.gmtDelta & 0x00010000L)					lll |= 0xFF000000L;				lll = lll / 3600L;				timezone = lll;			}			ReleaseResource (h);		}		else		{			type2plus = 0x0200;			timezone = 0;		}			//•	Get pathes…			if ( Get1Resource ( 'STR#', PathID ) && !LMGetResErr () )		{					for ( i = 0; i < _logPath; i++ )			{				GetIndString ( Pathes[i], PathID, i+1 );				Pathes[i][Pathes[i][0]+1] = 0;			}				//•	Check/Create all folders…				for ( i = 0; i < _basePath; i++ )			{				pStrCopy ( Pathes[i], temp );	//			temp[0]--;								if ( FSMakeFSSpec ( 0, 0, temp, &spec ) == fnfErr )				{					if ( DirCreate ( 0, 0, temp, &dummy ) )						return FALSE;				}			}		}		else			break;		//•	NodeList path			GetIndString ( NodeLists, PathID, 7 );		//•	Get home system info…			if ( (h = Get1Resource ( homeRes, 0 )) != NULL )		{			DetachResource ( h );			MoveHHi ( h );			HLock ( h );		}		else			break;				homesystem = (homeHndl) h;	//•	Get netmail desc…			if ( (h = Get1Resource ( mailRes, 0 )) != NULL )		{			DetachResource ( h );			MoveHHi ( h );			HLock ( h );		}		else			break;				mailHndl = (mailPrefHndl) h;	//•	Get areas desc…			AreasNumber = Count1Resources ( areasRes );		areasHndls = (areaPrefHndl *) NewPtr ( AreasNumber * sizeof (Handle) );				for ( i = 1; ; i++ )			if ( (h = Get1Resource ( areasRes, i )) != NULL )			{				DetachResource ( h );				MoveHHi ( h );				HLock ( h );								areasHndls[i-1] = (areaPrefHndl) h;			}			else				break;		if ( i-1 != AreasNumber )			break;	//•	Get groups desc…		GroupsNumber = Count1Resources ( groupsRes );		groupsHndls = (groupPrefHndl *) NewPtr ( GroupsNumber * sizeof (Handle) );		for ( i = 0; ; i++ )			if ( (h = Get1Resource ( groupsRes, i )) != NULL )			{				DetachResource ( h );				MoveHHi ( h );				HLock ( h );				groupsHndls[i] = (groupPrefHndl) h;			}					else				break;						if ( i != GroupsNumber )			break;	//•	Get nodes desc…		NodesNumber = Count1Resources ( nodesRes );		nodesHndls = (nodePrefHndl *) NewPtr ( NodesNumber * sizeof (Handle) );		for ( i = 0; ; i++ )			if ( (h = Get1Resource ( nodesRes, i )) != NULL )			{				DetachResource ( h );				MoveHHi ( h );				HLock ( h );				nodesHndls[i] = (nodePrefHndl) h;			}					else				break;		if ( i != NodesNumber )			break;				//•	Get NetMail routing…				if ( (h = Get1Resource ( routeRes, 0 )) != NULL )		{			DetachResource ( h );			MoveHHi ( h );			HLock ( h );		}		else			break;				Routing = (routeHndl) h;		h = Get1Resource ( 'Real', 0 );				if (!h)			RealName[0] = 0;		else		{			pStrCopy ( (StringPtr) *h, RealName );			RealName[RealName[0]+1] = 0;			ReleaseResource (h);		}#ifndef LITE#ifdef PROTECTED		h = Get1Resource ( 'TEXT', 0 );		if (h)			DetachResource (h);				keyHandle = h;#endif#endif		res = TRUE;	} while (0);	UseResFile ( oldResNum );	CloseResFile ( prefResNum );	return res;}static void get_model (void){	Handle		hhh;	Ptr			ppp;	long		mmm, nnn, i;	Gestalt ( 'mach', &mmm );		if (mmm == gestaltMacOSCompatibility)	{		pStrCopy ( "\pTruBlueEnvironment", MacModel );	}	else	{		hhh = Get1Resource ( 'mode', 0 );		HLock(hhh);		nnn = GetHandleSize ( hhh );		ppp = *hhh;				i = 2;				do {					if ( mmm == *((long *)(ppp + i)))				break;						i += 4;			i += *(ppp + i) + 1;			i = (i + 1) & 0xFFFFFFFE;				} while ( i < nnn );				if ( i < nnn )			pStrCopy ( (StringPtr) (ppp + i + 4), MacModel );		else			NumToString ( mmm, MacModel );				ReleaseResource (hhh);	}}static void killBusyFlags (void){	Handle		busytogo;	Str255		subfolder, subfolder1, subfolder2;	Str31		filename;	short		zdir, ndir, pdir;			// working directory reference number…	CInfoPBRec	cipbr;						/* local pb */	HFileInfo	*fpb = (HFileInfo *)&cipbr;	/* to pointers */	short		rc, idx;	short		idx1, idx2;	long		dummy, yup;	putlog ('~', "Cleaning up expired BUSY flags.");	busytogo = NewHandle (0);	workPath[workPath[0]+1] = 0;	if ( ( zdir = myOpenWD ( workPath ) ) == 0 )	{		putlog ( lgALRT, "Unable to open directory %s", &workPath[1] );		return;	}	fpb->ioNamePtr = filename;	for ( idx=1; true; idx++)	{											/* indexing loop */		fpb->ioDirID = 0L;						/* must set on each loop */		fpb->ioFDirIndex = idx;		fpb->ioVRefNum = zdir;		filename[0] = 0;				rc = PBGetCatInfoSync (&cipbr);				if (rc) break;							/* exit when no more entries */		if ( (fpb->ioFlAttrib & 16) && filename[0] == 9 )		{										/* zone folder: Zone_XXXX */			filename[filename[0]+1] = 0;						if ( strncmp ( (char *) &filename[1], "Zone_", 5 ) )				continue;							pStrConc ( workPath, filename, subfolder );						ndir = myOpenWD ( subfolder );						for ( idx1=1; TRUE; idx1++)			{											/* indexing loop */				fpb->ioDirID = 0L;						/* must set on each loop */				fpb->ioFDirIndex = idx1;				fpb->ioVRefNum = ndir;				filename[0] = 0;								rc = PBGetCatInfoSync (&cipbr);								if (rc) break;							/* exit when no more entries */						if ( filename[0] == 12 )				{										/* look up for nodes attaches & pts */					filename[filename[0]+1] = 0;		/* NNNNnnnn.?LO or NNNNnnnn.PTS */										if ( !(fpb->ioFlAttrib & 16) &&			//	•	NODE busied						 !strncmp ( (char *) &filename[9], ".BSY", 4 ) )					{		//	•	Check up it here for nodes								if (fpb->ioFlFndrInfo.fdType == 'BSY!')						{							pStrConc ( subfolder, "\p:", subfolder1 );							pStrConc ( subfolder1, filename, subfolder1 );							putlog (lgATTN, "BSY to remove: %#s", subfolder1);							PtrAndHand ( subfolder1, busytogo, subfolder1[0]+1 );						}					}					else						if ( (fpb->ioFlAttrib & 16) &&		//	•	Point folder							 !strncmp ( (char *) &filename[9], ".PTS", 4 ) )						{							pStrConc ( subfolder, "\p:", subfolder1 );							pStrConc ( subfolder1, filename, subfolder1 );														pdir = myOpenWD ( subfolder1 );														for ( idx2=1; TRUE; idx2++)							{											/* indexing loop */								fpb->ioDirID = 0L;						/* must set on each loop */								fpb->ioFDirIndex = idx2;								fpb->ioVRefNum = pdir;								filename[0] = 0;																rc = PBGetCatInfoSync (&cipbr);																if (rc) break;							/* exit when no more entries */														if ( filename[0] == 12 )								{										/* look up for pts attaches */									filename[filename[0]+1] = 0;		/* NNNNNNNN.?LO */												if ( !(fpb->ioFlAttrib & 16) &&			//	•	point attach										 !strncmp ( (char *) &filename[9], ".BSY", 4 ) )									{		//	•	Check up it here for points																				if (fpb->ioFlFndrInfo.fdType == 'BSY!')										{											pStrConc ( subfolder1, "\p:", subfolder2 );											pStrConc ( subfolder2, filename, subfolder2 );											putlog (lgATTN, "BSY to remove: %#s", subfolder2);											PtrAndHand ( subfolder2, busytogo, subfolder2[0]+1 );										}									}								}														}	/* points cycle */														myCloseWD ( pdir );						}				}							}	/* node cycle */					myCloseWD ( ndir );		}	}			/* zone cycle */	myCloseWD ( zdir );	HLock (busytogo);	dummy = GetHandleSize (busytogo);		if (dummy)	{		for (yup = 0; yup < dummy; )		{			pStrCopy ( (StringPtr) &((*busytogo)[yup]), subfolder );			subfolder[subfolder[0]+1] = 0;			FSDelete ( subfolder, 0 );			yup += subfolder[0] + 1;		}	}		DisposeHandle (busytogo);}static MenuHandle myMenus[4];void main (void){	Str255		name;	Rect		iRect;	Handle		iHandle;	short		iType, oDoIt, iErr, i, j;	unsigned long	checksum = 0;	ProcessSerialNumber	launchedProcessSN;	AppleEvent		event, reply;	AEAddressDesc	address;		short			curResFile = CurResFile();	plugsChainPtr		plug;		InitToolbox();	MaxApplZone ();	InitCommand ();	myMenus[0] = GetMenu ( 1 );	myMenus[1] = GetMenu ( 2 );	myMenus[2] = GetMenu ( 3 );	myMenus[3] = GetMenu ( 4 );	AppendResMenu ( myMenus[0], 'DRVR' );	InsertMenu ( myMenus[0], 0 );	InsertMenu ( myMenus[1], 0 );	InsertMenu ( myMenus[2], 0 );	InsertMenu ( myMenus[3], 0 );	DrawMenuBar();		gQuit = false;	gWait = true;	tempBuffer = NewPtr (0x8000);	if ( ReadPreference () )	{		OSErr	err;		long	result;				RavelWindow = GetNewDialog ( 128, NULL, (WindowPtr) -1L );		iHandle = Get1Resource ( 'WLOC', 128 );		if (iHandle)		{			if (PtInRect (*(Point*)(*iHandle), &(*LMGetGrayRgn ())->rgnBBox))				MoveWindow ( RavelWindow, ((Point*)(*iHandle))->h, ((Point*)(*iHandle))->v, true );			ReleaseResource (iHandle);		}				err = Gestalt( gestaltAppearanceAttr, &result );		if ( err == noErr )		{			gAppearance = true;						GetDialogItem (RavelWindow, 3, &iType, &iHandle, &iRect);						iHandle = (Handle)NewControl (RavelWindow,									&iRect,									"\p",									true,									0,									0,									100,									(5 << 4) + 0,									0);			SetDialogItem(RavelWindow, 3, kResourceControlDialogItem, iHandle, &iRect);		}				ShowWindow (RavelWindow);		DrawDialog (RavelWindow);		InitProgress ( -1.0 );		if (gAppearance)			IdleControls(RavelWindow);		openlog ();#ifndef LITE#ifdef PROTECTED		if (!CheckKey ())		{			closelog ();			goto outahere1;		}		j = GetHandleSize (keys.Invalidater)/4;		for (i=0;i<j-1;i++)		{			if (((unsigned long *)*keys.Invalidater)[i] == keys.crc)				checksum++;			checksum += ((unsigned long *)*keys.Invalidater)[i];		}				if (checksum != ((unsigned long *)*keys.Invalidater)[i] || j<0x200/4)		{			Alert (127, NULL);			ExitToShell ();		}		if (keys.crc != keys.oldcrc)			ExitToShell ();		if ((keys.oldcs+1+keys.cs)&0xFFFF)			ExitToShell ();#endif#endif#ifndef LITE		putlog ( lgNOPE, "Begin, " SHUFFLERNAME " " RAVELVERS " " RAVELISA " " RAVELBUILD );#else		putlog ( lgNOPE, "Begin, " SHUFFLERNAME " " RAVELVERS " " RAVELBUILD );#endif		putlog ( lgNOPE, "%s packets enabled.",				(type2plus == 0x0000) ? "FTS-0001" : (					(type2plus == 0x0200) ? "Type 2" : (						(type2plus == 0x0220) ? "Type 2.2" : (							(type2plus == 0x0201) ? "QMail" : (								(type2plus == 0x02FF) ? "Type 2+" : "BAD")))));		killBusyFlags ();		tmpbase_init ();		if (msgbase_init ())		{			putlog ( lgALRT, "Base initialization fault." );			closelog ();			goto outahere1;		}		ReadNodeList ();//		pluginscontrol = NULL;//		pluginscontrolppc = NULL;		PreparePlugsStructure ();		LookForPlugIns ();				if (!ParseCommand())		{			pStrCopy ("\pWaiting…", name);			DoIt = _WAIT;			EnqueueCommand (DoIt);		}		else			DoIt = DequeueCommand(false);		get_model ();				crcinit ();				gQuit = false;		gWait = (DoIt == _WAIT);		#if defined(powerc) || defined(__powerc)		uupMyHandleQuit = NewRoutineDescriptor ((ProcPtr) MyHandleQuit, uppAEHandlerProcInfo, GetCurrentISA ());		uupMyHandleOAPP = NewRoutineDescriptor ((ProcPtr) MyHandleOAPP, uppAEHandlerProcInfo, GetCurrentISA ());		uupMyHandleEnqueue = NewRoutineDescriptor ((ProcPtr) MyHandleEnqueue, uppAEHandlerProcInfo, GetCurrentISA ());		if (AEInstallEventHandler (kCoreEventClass, kAEQuitApplication, uupMyHandleQuit, 0, false))			DebugStr ("\pAE Installation failed!");		if (AEInstallEventHandler(kCoreEventClass, kAEOpenApplication, uupMyHandleOAPP, 0, false))			DebugStr ("\pAE Installation failed!");		if (AEInstallEventHandler(kCoreEventClass, kAEOpenDocuments, uupMyHandleOAPP, 0, false))			DebugStr ("\pAE Installation failed!");		if (AEInstallEventHandler(kRavelEventClass, kAEEnqueueCmd, uupMyHandleEnqueue, 0, false))			DebugStr ("\pAE Installation failed!");#else		if (AEInstallEventHandler (kCoreEventClass, kAEQuitApplication, &MyHandleQuit, 0, false))			DebugStr ("\pAE Installation failed!");		if (AEInstallEventHandler(kCoreEventClass, kAEOpenApplication, &MyHandleOAPP, 0, false))			DebugStr ("\pAE Installation failed!");		if (AEInstallEventHandler(kCoreEventClass, kAEOpenDocuments, &MyHandleOAPP, 0, false))			DebugStr ("\pAE Installation failed!");		if (AEInstallEventHandler(kRavelEventClass, kAEEnqueueCmd, &MyHandleEnqueue, 0, false))			DebugStr ("\pAE Installation failed!");#endif		InitProgress ( 1.0 );		do {						oDoIt = DoIt;			DoIt = DequeueCommand (true);						if (DoIt)			{				if (DoIt > 0)				{					strcpy ( (char *) &name[1], command[DoIt-1] );					name[0] = strlen ( command[DoIt-1] );				}				else					pStrCopy ( "\pCustom call…", name );				GetDialogItem ( RavelWindow, 1, &iType, &iHandle, &iRect );				SetDialogItemText ( iHandle, name );				ZeroStat ();				switch ( DoIt )				{				case _TOSS:		//	•	Toss inbound/make outbound, resolve netmail												putlog ( lgNOPE, "Processing %s.", command[DoIt-1] );								tmpbase_open ();																if (CallPlugIns (plugPreTossLaunch, NULL, 0) == plugRetContinue)								{									Toss ();								}																tmpbase_close ();								OutStatTossed ();																break;								case _NETPACK:	//	•	Toss inbound/make outbound, resolve netmail												putlog ( lgNOPE, "Processing %s.", command[DoIt-1] );																tmpbase_open ();								if (CallPlugIns (plugPreNetPackLaunch, NULL, 0) == plugRetContinue)								{									NetPack ();								}																tmpbase_close ();								OutStatTossed ();																break;				case _SCAN:		//	•	Scan mbase for new msgs,m ake outbound, resolve netmail								if (!base_bsy_check ())								{									base_bsy_raise ();									tmpbase_open ();									putlog ( lgNOPE, "Processing %s.", command[DoIt-1] );									if (CallPlugIns (plugPreScanLaunch, NULL, 0) == plugRetContinue)									{										Scan ();									}									base_bsy_clear ();									tmpbase_close ();									OutStatScanned ();								}								else									putlog (lgNOPE, "Base busy.");																break;				case _PACK:		//	•	Repack message bases								if (!base_bsy_check ())								{									base_bsy_raise ();									putlog ( lgNOPE, "Processing %s.", command[DoIt-1] );									Pack ();									base_bsy_clear ();								}								else									putlog (lgNOPE, "Base busy.");								break;				case _PURGE:	//	•	Set deleted flags in all old messages								if (!base_bsy_check ())								{									base_bsy_raise ();									putlog ( lgNOPE, "Processing %s.", command[DoIt-1] );									PurgeDestructive ();									base_bsy_clear ();								}								else									putlog (lgNOPE, "Base busy.");								break;				case _LINK:		//	•	Make chained reply messages links								if (!base_bsy_check ())								{									base_bsy_raise ();									putlog ( lgNOPE, "Processing %s.", command[DoIt-1] );									MsgLink ();									base_bsy_clear ();								}								else									putlog (lgNOPE, "Base busy.");								break;				case _UNDEL:	//	•	Drop deleted flags in all messages								if (!base_bsy_check ())								{									base_bsy_raise ();									putlog ( lgNOPE, "Processing %s.", command[DoIt-1] );									Undel ();									base_bsy_clear ();								}								else									putlog (lgNOPE, "Base busy.");								break;								case _WAIT:		//	•	Set wait mode				//								putlog ( lgNOPE, "Waiting…" );								gWait = true;								break;								case _IMPORT:	//	•	External remind to import temp to main base												putlog ( lgNOPE, "Processing %s.", command[DoIt-1] );								tmpbase_open ();								tmpbase_close ();								break;				case _REMIND:	//	•	External remind to bundle								putlog ( lgNOPE, "Processing %s.", command[DoIt-1] );								Resolver (MOVE_NETMAIL |										  MOVE_ARCMAIL |										  MOVE_FLOS |										  MOVE_FREQ);				// • Resolve all								break;								default:									if (DoIt < 0)					{						putlog ( lgNOPE, "Processing custom %#s.", DoItName );						tmpbase_open ();						CallNamedPlugIns (DoItName);						tmpbase_close ();					}					else						putlog ( lgALRT, "Command %s is not implemented yet.", command[DoIt-1] );								break;				}				CallPlugIns (plugMisc, NULL, secondOperationComplete);								if (!cmdList.qHead)					while ( !FindAProcess ( 'APPL', 'RvlQ', &launchedProcessSN ) )					{						iErr = AECreateDesc (typeProcessSerialNumber, &launchedProcessSN, sizeof(launchedProcessSN), &address);						if (iErr)						{							putlog ( lgALRT, "AECreateDesc (err = %d).", iErr );								break;						}												iErr = AECreateAppleEvent (kRavelEventClass, (gBaseBusy) ? kAENotifyQuill : kAEScanComplete, &address, kAutoGenerateReturnID, kAnyTransactionID, &event);						if (iErr)						{							putlog ( lgALRT, "AECreateAppleEvent (err = %d).", iErr );								AEDisposeDesc(&address);							break;						}						iErr = AESend (&event, &reply, kAENeverInteract + kAENoReply, kAENormalPriority, kAEDefaultTimeout, NULL, NULL);						if (iErr)						{							putlog ( lgALRT, "AESend (err = %d).", iErr );								AEDisposeDesc(&event);							AEDisposeDesc(&address);							break;						}												AEDisposeDesc(&event);						AEDisposeDesc(&address);												break;					}						InitProgress (1.0);				putProgressName ("\p");				gBaseBusy = false;			}			else			{				if (oDoIt)				{					putlog ( lgNOPE, "Waiting…" );					pStrCopy ( "\pWaiting…", name );					GetDialogItem ( RavelWindow, 1, &iType, &iHandle, &iRect );					SetDialogItemText ( iHandle, name );				}							if (!gWait)					gQuit = true;			}						DoSlice ();				} while (!gQuit);		DisposPlugIns ();#if defined(powerc) || defined(__powerc)		AERemoveEventHandler (kCoreEventClass, kAEQuitApplication, uupMyHandleQuit, false);		AERemoveEventHandler (kCoreEventClass, kAEOpenApplication, uupMyHandleOAPP, false);		AERemoveEventHandler (kCoreEventClass, kAEOpenDocuments, uupMyHandleOAPP, false);		AERemoveEventHandler (kRavelEventClass, kAEEnqueueCmd, uupMyHandleEnqueue, false);		DisposeRoutineDescriptor (uupMyHandleQuit);		DisposeRoutineDescriptor (uupMyHandleOAPP);		DisposeRoutineDescriptor (uupMyHandleEnqueue);#else		AERemoveEventHandler (kCoreEventClass, kAEQuitApplication, &MyHandleQuit, false);		AERemoveEventHandler (kCoreEventClass, kAEOpenApplication, &MyHandleOAPP, false);		AERemoveEventHandler (kCoreEventClass, kAEOpenDocuments, &MyHandleOAPP, false);		AERemoveEventHandler (kRavelEventClass, kAEEnqueueCmd, &MyHandleEnqueue, false);#endif		putlog ( lgNOPE, "End." );		closelog ();				UseResFile(curResFile);		iHandle = Get1Resource ( 'WLOC', 128 );		if (iHandle)			RemoveResource (iHandle);		iHandle = NewHandle (sizeof (Point));		HLock (iHandle);				memcpy ( *iHandle, &((DialogPeek)RavelWindow)->window.port.portRect, sizeof (Point) );		LocalToGlobal ( (Point*)*iHandle );		AddResource ( iHandle, 'WLOC', 128, "\p" );			msgbase_dispose ();		DisposeDialog (RavelWindow);	}	else	{		goto outahere;			outahere1:		DisposeDialog (RavelWindow);	outahere:		SysBeep ( 10 );	}}/*void ReportToMailer (Boolean rescan){	ProcessSerialNumber	launchedProcessSN;	AppleEvent		event, reply;	AEAddressDesc	address;	short			iErr;	if ( !FindAProcess ( 'APPL', 'RvlM', &launchedProcessSN ) )	{		iErr = AECreateDesc (typeProcessSerialNumber, &launchedProcessSN, sizeof(launchedProcessSN), &address);		if (iErr)		{			putlog ( lgALRT, "AECreateDesc (err = %d).", iErr );				return;		}				iErr = AECreateAppleEvent (kRavelEventClass, (rescan) ? kAERescan : kAEAskRemind, &address, kAutoGenerateReturnID, kAnyTransactionID, &event);		if (iErr)		{			putlog ( lgALRT, "AECreateAppleEvent (err = %d).", iErr );				AEDisposeDesc(&address);			return;		}		iErr = AESend (&event, &reply, kAENeverInteract + kAENoReply, kAENormalPriority, kAEDefaultTimeout, NULL, NULL);		if (iErr)		{			putlog ( lgALRT, "AESend (err = %d).", iErr );				AEDisposeDesc(&event);			AEDisposeDesc(&address);			return;		}				AEDisposeDesc(&event);		AEDisposeDesc(&address);	}}*/void ReportToMailer (Boolean rescan){	ProcessInfoRec		tempInfo;	FSSpec				procSpec;	Str31				processName;	OSErr				iErr = noErr;	ProcessSerialNumber	processSN;	AppleEvent			event, reply;	AEAddressDesc		address;	// start at the beginning of the process list	processSN.lowLongOfPSN = kNoProcess;	processSN.highLongOfPSN = 0;	// initialize the process information record	tempInfo.processInfoLength = sizeof(ProcessInfoRec);	tempInfo.processName = (StringPtr)&processName;	tempInfo.processAppSpec = &procSpec;	do {		iErr = GetNextProcess (&processSN);		if (iErr == noErr)		{			GetProcessInformation (&processSN, &tempInfo);			if (tempInfo.processSignature == 'RvlM' && tempInfo.processType == 'APPL')			{				iErr = AECreateDesc (typeProcessSerialNumber, &processSN, sizeof(processSN), &address);				if (iErr)				{					putlog ( lgALRT, "AECreateDesc (err = %d).", iErr );						continue;				}								iErr = AECreateAppleEvent (kRavelEventClass, (rescan) ? kAERescan : kAEAskRemind, &address, kAutoGenerateReturnID, kAnyTransactionID, &event);				if (iErr)				{					putlog ( lgALRT, "AECreateAppleEvent (err = %d).", iErr );						AEDisposeDesc(&address);					continue;				}				iErr = AESend (&event, &reply, kAENeverInteract + kAENoReply, kAENormalPriority, kAEDefaultTimeout, NULL, NULL);				if (iErr)				{					putlog ( lgALRT, "AESend (err = %d).", iErr );						AEDisposeDesc(&event);					AEDisposeDesc(&address);					continue;				}								AEDisposeDesc(&event);				AEDisposeDesc(&address);			}		}			} while (iErr == noErr);}