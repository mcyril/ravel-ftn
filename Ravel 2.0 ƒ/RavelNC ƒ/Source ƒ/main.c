#include <Sound.h>#include <stdio.h>#include <string.h>#include "mynodes.h"#include "PKT.h"#include "Prefs.h"#include "stringutl.h"#include "PascalStr.h"Ptr		buffer;short	inbuff;long	lenbuff, tbuff;//	#define	BUFFLEN		2048DialogPtr	RavelWindow;ListHandle	NodeList, PointList;char		*ravelnodes = "Ravel.NODELIST";StringPtr	ravelnodesindex = "\pRavel.NODELIST.INDEX";short		pointformat;nodelistheader	header;short	inRefNum, refNumFILES, refNumZONES, refNumNETS, refNumNODES, refNumPOINTS, refNumBOSS;Boolean	newnetwonodes = false;enum {	uppAEHandlerProcInfo = kPascalStackBased		 | RESULT_SIZE(SIZE_CODE(sizeof(OSErr)))		 | STACK_ROUTINE_PARAMETER(1, SIZE_CODE(sizeof(Ptr)))		 | STACK_ROUTINE_PARAMETER(2, SIZE_CODE(sizeof(Ptr)))		 | STACK_ROUTINE_PARAMETER(3, SIZE_CODE(sizeof(long))),//	pascal Boolean myAlertProc (DialogPtr theDialog, EventRecord *theEvent, short *itemHit)	uppModalProcInfo = kPascalStackBased		 | RESULT_SIZE(SIZE_CODE(sizeof(Boolean)))		 | STACK_ROUTINE_PARAMETER(1, SIZE_CODE(sizeof(Ptr)))		 | STACK_ROUTINE_PARAMETER(2, SIZE_CODE(sizeof(Ptr)))		 | STACK_ROUTINE_PARAMETER(3, SIZE_CODE(sizeof(Ptr))),};/*      Zone --          Begins the definition of a geographic zone and define           its coordinator.  All the data lines following a line           with the "Zone" keyword down to,  but not including the           next occurrence of a "Zone" keyword,  are regions,            nets and nodes within the defined zone.     Region --          Begins the definition of a geographic region and           defines its coordinator.  All the data lines following           a line with the "Region" keyword down to,  but not           including the next occurrence of a "Region" or "Host"           keyword, are independent nodes within the defined           region.     Host --          Begins the definition of a local network and defines           its host.  All the data lines following a line with the           "Host" keyword down to,  but not including the next           occurrence of a "Region" or "Host" keyword,  are local           nodes,  members of the defined local network.  The           difference between a region and a local network is in           the routing of messages.  A message addressed to a           member of a region is sent  direct to the addressee,           while a message to a member of a local network is sent           to the network host.     Hub --          Begins the definition of a routing subunit within a           multilevel local  network.  The hub is the routing           focal point for nodes listed below it until the next           occurrence of a "Hub",  "Region",  "Host",  or "Zone"           keyword.  The hub entry MUST be a redundant entry,            with a unique number,  for one of the nodes listed           below it.  This is necessary because some nodelist           processors eliminate these entries in all but the local           network.     Pvt --          Defines a private node with unlisted number.  Private           nodes are only allowed as members of local networks.     Hold --          Defines a  node which  is temporarily down.  Mail may           be sent to it and is held by its host or coordinator.     Down --          Defines a node which is not operational.  Mail may NOT           be sent  to it.  This keyword  may not be used for           longer than two weeks on any single node,  at which            point the "down" node is to be removed from the           nodelist.     <empty> --          Defines a normal node entry.*/#define	_ZONE		0#define	_REGION		1#define	_HOST		2#define	_HUB		3#define	_DOWN		4#define	_HOLD		5#define	_PVT		6#define	_BOSS		7#define	_POINT		8static char		*token[] = {								"zone",								"region",								"host",								"hub",								"pvt",								"hold",								"down",								"boss",								"point",								""							};#define	f_zone		0x0001	//	zone coordinator#define	f_region	0x0002	//	region coordinator#define	f_host		0x0004	//	net host#define	f_hub		0x0008	//	net hub#define	f_down		0x0010	//	down node#define	f_hold		0x0020	//	hold node#define	f_pvt		0x0040	//	private node#define	f_point		0x8000	//	it's pointstatic short	flags_array[] = {																		f_zone,			//	_ZONE									f_region,		//	_REGION									f_host,			//	_HOST									f_hub,			//	_HUB									f_pvt,			//	_PVT									f_hold,			//	_HOLD									f_down,			//	_DOWN									0,				//	_BOSS									f_point,		//	_POINT									0				//	noper								};static	addr		current;static	long		curoffset;static	short		curfile;static	long		inNetOffset;static	long		inNodeOffset;static	long		inPointOffset;static	Handle		h_files;static	noderec		*List_NODES;static	pointrec	*List_POINTS;typedef struct _nets {	short			net;	short			fnum;	long			foffset;	long			innodearray;	struct _nets	*nextnet;} nets, *p_nets;typedef struct _zones {	short			zone;	short			fnum;	long			foffset;	long			innetarray;	struct _zones	*nextzone;	p_nets			nets;} zones, *p_zones;typedef struct _boss {	short			zone;	short			net;	short			node;	long			inpointoffset;	} boss;typedef struct _sequence {	short	zone;	short	net;	long	innode;} sequence;static	Handle		sequentor;static	p_zones		List_ZONES;static	RGBColor	colorBlack = {17030, 17030, 17030};static	RGBColor	colorWhite = {53055, 53055, 65535};static	long	progressValue;static	float	limit;static	Rect	box;static void errWrongPoint (void){	ParamText ("\pWrong pointlist format. Change preference first.", "\p", "\p", "\p");	Alert (132, NULL);	ExitToShell ();}static void errWrongZone (void){	ParamText ("\pUnpointed zone. Use complete nodelist or make prefix file.", "\p", "\p", "\p");	Alert (132, NULL);	ExitToShell ();}static void InitProgress (float howmuch){	Handle		iHandle;	short		iType;	RGBColor	oldFColor;	Rect		bbox;	GrafPtr		oldPort;			GetPort (&oldPort);	SetPort (RavelWindow);	GetDialogItem ( RavelWindow, 2, &iType, &iHandle, &box );	GetForeColor (&oldFColor);	RGBForeColor (&colorWhite);	FillRect ( &box, &qd.black );	RGBForeColor (&oldFColor);		bbox = box;	InsetRect ( &bbox, -1, -1 );	FrameRect ( &bbox );	progressValue = 0;	limit = ((float)(box.right - box.left))/howmuch;	/* use a float to get good*/	SetPort (oldPort);}static void DrawProgress (long i){	RGBColor	oldFColor;	Rect		bbox;	GrafPtr		oldPort;			if (progressValue == i)		return;		GetPort (&oldPort);	SetPort (RavelWindow);	bbox = box;	bbox.right = box.left + (progressValue = i)*limit;	GetForeColor (&oldFColor);	RGBForeColor (&colorBlack);	FillRect ( &bbox, &qd.black );	bbox = box;	bbox.left = box.left + (progressValue = i)*limit;	RGBForeColor (&colorWhite);	FillRect ( &bbox, &qd.black );	RGBForeColor (&oldFColor);	SetPort (oldPort);}static void putProgressName (Str255 name){	Rect		iRect;	Handle		iHandle;	short		iType;	GetDialogItem ( RavelWindow, 1, &iType, &iHandle, &iRect );	SetDialogItemText ( iHandle, name );}static void InitToolbox(){	MaxApplZone ();	MoreMasters ();	MoreMasters ();	MoreMasters ();	MoreMasters ();	InitGraf ((Ptr) &qd.thePort);	InitFonts ();	InitWindows ();	InitMenus ();	FlushEvents (everyEvent,0);	InitDialogs (0L);	InitCursor ();}/*еееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееее*///	points list operationspointrec	**hpRec;static void addpntrec (unsigned short point, short fnum, long foffset){	pointrec	pRec;	long		iolen;		if (!hpRec)		hpRec = (pointrec **) NewHandle (0);		iolen = GetHandleSize ((Handle) hpRec);	iolen += sizeof (pointrec);	SetHandleSize ((Handle) hpRec, iolen);	iolen = (iolen / sizeof (pointrec)) - 1;	(*hpRec)[iolen].point = point;	(*hpRec)[iolen].fnum = fnum;	(*hpRec)[iolen].foffset = foffset;}static void initList_POINTS (void){	Create ( "\p$Nodelist.points", 0, 'Ravl', 'TEMP' );	FSOpen ( "\p$Nodelist.points", 0, &refNumPOINTS );	SetEOF ( refNumPOINTS, 0 );	inPointOffset = 0;//еее	hpRec = (pointrec **) NewHandle (0);}static void destructList_POINTS (void){	long		inOutCount = sizeof (pointrec);	pointrec	pRec;/*		pRec.point = -1;	pRec.fnum = -1;	pRec.foffset = -1;*/	addpntrec (-1, -1, -1);	HLock ((Handle) hpRec);	inOutCount = GetHandleSize ((Handle) hpRec);	FSWrite ( refNumPOINTS, &inOutCount, *((Handle)hpRec) );	FSClose ( refNumPOINTS );		DisposeHandle ((Handle)hpRec);	hpRec = NULL;}static void closeList_POINTS (void){	long		inOutCount = sizeof (pointrec);	pointrec	pRec;	long		ii, jj, kk;/*	pRec.point = -1;	pRec.fnum = -1;	pRec.foffset = -1;*/	addpntrec (-1, -1, -1);	HLock ((Handle) hpRec);	inOutCount = GetHandleSize ((Handle) hpRec);		kk = inOutCount / sizeof (pointrec);		for (ii = 0; ii < kk - 1; ii++)		for (jj = 0; jj < kk - ii - 1; jj++)			if ((*hpRec)[jj].point > (*hpRec)[jj+1].point)			{				pRec = (*hpRec)[jj];				(*hpRec)[jj] = (*hpRec)[jj+1];				(*hpRec)[jj+1] = pRec;			}	FSWrite ( refNumPOINTS, &inOutCount, *((Handle)hpRec) );		DisposeHandle ((Handle)hpRec);	hpRec = NULL;	inPointOffset += sizeof (pointrec);}static void addList_POINTS (void)			//	add & write new node definition{	long		inOutCount = sizeof (pointrec);	pointrec	pRec;/*		pRec.point = current.point;	pRec.fnum = curfile;	pRec.foffset = curoffset;		FSWrite ( refNumPOINTS, &inOutCount, &pRec );*/	addpntrec (current.point, curfile, curoffset);	inPointOffset += sizeof (pointrec);}/*еееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееее*///	boosses list operationsstatic void initList_BOSS (void){	Create ( "\p$Nodelist.boss", 0, 'Ravl', 'TEMP' );	FSOpen ( "\p$Nodelist.boss", 0, &refNumBOSS );	SetEOF ( refNumBOSS, 0 );}static void destructList_BOSS (void){	boss		dummy;	long		inOutCount = sizeof (boss);		dummy.zone = -1;	dummy.net = -1;	dummy.node = -1;	dummy.inpointoffset = -1;	FSWrite ( refNumBOSS, &inOutCount, &dummy );	FSClose ( refNumBOSS );}static void addList_BOSS (void)			//	add & write new node definition{	boss		dummy;	long		inOutCount = sizeof (boss);		if (inPointOffset)		closeList_POINTS ();		dummy.zone = current.zone;	dummy.net = current.net;	dummy.node = current.node;	dummy.inpointoffset = inPointOffset;	FSWrite ( refNumBOSS, &inOutCount, &dummy );}/*еееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееее*///	nodes list operationsstatic void initList_NODES (void){	Create ( "\p$Nodelist.nodes", 0, 'Ravl', 'TEMP' );	FSOpen ( "\p$Nodelist.nodes", 0, &refNumNODES );	SetEOF ( refNumNODES, 0 );	List_NODES = (noderec *) NewPtr (sizeof (noderec));	inNodeOffset = 0;}static void closeList_NODES (void)			//	write term of node definition{	long	inOutCount = sizeof (noderec);	List_NODES->node = -1;	List_NODES->flags = -1;	List_NODES->foffset = -1;	List_NODES->pointoffset = -1;	FSWrite ( refNumNODES, &inOutCount, List_NODES );	inNodeOffset += sizeof (noderec);}static void destructList_NODES (void){	closeList_NODES ();		DisposePtr ( (Ptr) List_NODES );	List_NODES = NULL;	GetEOF ( refNumNODES, &header.ofs_points );	FSClose ( refNumNODES );}static void addList_NODES (short tkn)			//	add & write new node definition{	long	inOutCount = sizeof (noderec);	newnetwonodes = false;	memset ( List_NODES, 0, sizeof (noderec) );		List_NODES->node = current.node;	List_NODES->flags = flags_array[tkn];	List_NODES->foffset = curoffset;	List_NODES->pointoffset = 0;	FSWrite ( refNumNODES, &inOutCount, List_NODES );	inNodeOffset += sizeof (noderec);} /*еееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееее*///	net list operationsstatic void destructList_NETS (void){	p_zones		over_zone;	p_nets		over_net, p;	long		innetoffset = 0, ioCount;	netrec		Net;		Create ( "\p$Nodelist.nets", 0, 'Ravl', 'TEMP' );	FSOpen ( "\p$Nodelist.nets", 0, &refNumNETS );	SetEOF ( refNumNETS, 0 );	over_zone = List_ZONES;		do {			over_net = over_zone->nets;				if (over_net)		{			over_zone->innetarray = innetoffset;			do {				Net.net = over_net->net;				Net.fnum = over_net->fnum;				Net.foffset = over_net->foffset;				Net.nodeoffset = over_net->innodearray;								ioCount = sizeof (netrec);				FSWrite ( refNumNETS, &ioCount, &Net );								innetoffset += sizeof (netrec);				p = over_net->nextnet;				DisposePtr ((Ptr)over_net);				over_net = p;						} while (over_net);		}		else			over_zone->innetarray = -1;				Net.net = -1;		Net.fnum = -1;		Net.foffset = -1;		Net.nodeoffset = -1;				ioCount = sizeof (netrec);		FSWrite ( refNumNETS, &ioCount, &Net );				innetoffset += sizeof (netrec);				over_zone = over_zone->nextzone;			} while (over_zone);	GetEOF ( refNumNETS, &header.ofs_nodes );	FSClose ( refNumNETS );}/*static void closeList_NETS (void)			//	write term of net definition{	long	inOutCount = sizeof (netrec);	if (inNodeOffset)		closeList_NODES ();	List_NETS->net = -1;	List_NETS->foffset = -1;	List_NETS->nodeoffset = -1;	FSWrite ( refNumNETS, &inOutCount, List_NETS );	inNetOffset += sizeof (netrec);}*/static void addList_NETS (void)				//	add & write new net definition{	p_zones		over_zone;	p_nets		over_net;	sequence	seq;	sequence	*sseq;	long		jjj;		over_zone = List_ZONES;		while (over_zone->nextzone)		if (over_zone->zone == current.zone)			break;		else			over_zone = over_zone->nextzone;	if (over_zone->zone != current.zone)		return;	over_net = over_zone->nets;	if (!over_net)	{		over_net = (p_nets) NewPtrClear (sizeof(nets));		over_zone->nets = over_net;//		newnetwonodes = false;	}	else	{		while (over_net->nextnet)			if (over_net->net == current.net)				break;			else				over_net = over_net->nextnet;		if (over_net->net != current.net)		{			over_net->nextnet = (p_nets) NewPtrClear (sizeof(nets));			over_net = over_net->nextnet;		}	}		if (inNodeOffset)		closeList_NODES ();	over_net->net = current.net;	over_net->fnum = curfile;	over_net->foffset = curoffset;	over_net->innodearray = inNodeOffset;	seq.zone = current.zone;	seq.net = current.net;	seq.innode = inNodeOffset;	if (PtrAndHand ( &seq, sequentor, sizeof (sequence) ))		DebugStr ("\pNot enough memory╔");	sseq = (sequence *) *sequentor;	jjj = GetHandleSize (sequentor) / sizeof(sequence);//	if ( jjj > 1 && sseq[jjj-1].innode == sseq[jjj-2].innode )//	{//		over_net = over_zone->nets;//	//		while (over_net->net != sseq[jjj-2].net)//				over_net = over_net->nextnet;////		over_net->innodearray = -1;//		sseq[jjj-2].innode = -1;//	}	if ( jjj > 1 && newnetwonodes )	{		over_net = over_zone->nets;			while (over_net->net != sseq[jjj-2].net)				over_net = over_net->nextnet;		over_net->innodearray = -1;		sseq[jjj-2].innode = -1;	}	newnetwonodes = true;}/*еееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееее*///	zone list operationsstatic void initList_ZONES (void){	List_ZONES = NULL;}static void destructList_ZONES (void){	p_zones		over_zone, p;	long		innetoffset = 0, ioCount;	zonerec		ZoneR;		Create ( "\p$Nodelist.zones", 0, 'Ravl', 'TEMP' );	FSOpen ( "\p$Nodelist.zones", 0, &refNumZONES );	SetEOF ( refNumZONES, 0 );	over_zone = List_ZONES;		do {			ZoneR.zone = over_zone->zone;		ZoneR.fnum = over_zone->fnum;		ZoneR.foffset = over_zone->foffset;		ZoneR.netoffset = over_zone->innetarray;				ioCount = sizeof (zonerec);		FSWrite ( refNumZONES, &ioCount, &ZoneR );				p = over_zone->nextzone;		DisposePtr ((Ptr)over_zone);		over_zone = p;			} while (over_zone);	ZoneR.zone = -1;	ZoneR.fnum = -1;	ZoneR.foffset = -1;	ZoneR.netoffset = -1;		ioCount = sizeof (zonerec);	FSWrite ( refNumZONES, &ioCount, &ZoneR );	GetEOF ( refNumZONES, &header.ofs_nets );		FSClose ( refNumZONES );}static void addList_ZONES (void){	p_zones		over;		if (!List_ZONES)	{		List_ZONES = (p_zones) NewPtr (sizeof(zones));		over = List_ZONES;	}	else	{		over = List_ZONES;				while (over->nextzone)			if (over->zone == current.zone)				return;			else				over = over->nextzone;		if (over->zone == current.zone)			return;		over->nextzone = (p_zones) NewPtr (sizeof(zones));		over = over->nextzone;	}		memset ( over, 0, sizeof (zones) );		over->zone = current.zone;	over->fnum = curfile;	over->foffset = curoffset;	over->nextzone = NULL;	over->nets = NULL;}/*еееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееее*///	nodelist files operationsstatic void initList_FILES (void){	h_files = NewHandle (0);	curfile = -1;}static void addList_FILES (StringPtr filename, unsigned long modificated, short pointlist){	filerec		List_FILES;		curfile++;	memset ( &List_FILES, 0, sizeof (filerec) );	pStrCopy ( filename, List_FILES.fname );	List_FILES.modifdate = modificated;	List_FILES.points = pointlist;						//	nodelist type	if (PtrAndHand ( &List_FILES, h_files, sizeof (filerec)))		DebugStr ("\pNot enough memory╔");}/*еееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееее*/static	long	numOfBosses;static void OpenLookUpPointForBoss (void){	FSOpen ( "\p$Nodelist.boss", 0, &refNumBOSS );	GetEOF ( refNumBOSS, &numOfBosses );	numOfBosses = numOfBosses / sizeof (boss);}static long LookUpPointForBoss (void){	register long	inBoss, i;	long			ioCount;	boss			buff[256];			if (!numOfBosses)		return -1;		SetFPos ( refNumBOSS, fsFromStart, 0 );/*		for (inBoss = 0; inBoss < numOfBosses; inBoss += sizeof (boss))	{		ioCount = sizeof (boss);		FSRead ( refNumBOSS, &ioCount, &buff );		if ( buff.zone == current.zone &&			 buff.net == current.net &&			 buff.node == current.node )			return buff.inpointoffset;	}*/	for (inBoss = 0; inBoss < numOfBosses; inBoss += 256)	{		ioCount = sizeof (boss) * 256;		FSRead ( refNumBOSS, &ioCount, buff );				for (i = 0; i < 256; i++)			if ( buff[i].zone == current.zone &&				 buff[i].net == current.net &&				 buff[i].node == current.node )			{//				Debugger ();				return buff[i].inpointoffset;			}	}	if (inBoss < numOfBosses)	{		ioCount = sizeof (boss) * 256;		FSRead ( refNumBOSS, &ioCount, buff );				for (i = 0; i < numOfBosses - inBoss; i++)			if ( buff[i].zone == current.zone &&				 buff[i].net == current.net &&				 buff[i].node == current.node )			{//				Debugger ();				return buff[i].inpointoffset;			}	}	return -1;}static void CloseLookUpPointForBoss (void){	FSClose ( refNumBOSS );}static void initDataBuffer (void){	buffer = NewPtr (1024);}static void closeDataBuffer (void){	DisposePtr (buffer);}static void initDataFlow (void){	long	inOutCount = 1024;	inbuff = 0;	tbuff = 0;	GetEOF ( inRefNum, &lenbuff );	FSRead ( inRefNum, &inOutCount, buffer );}static short GetDataByte (void){	long	inOutCount = 1024;	if (tbuff >= lenbuff)		return EOF;			if (inbuff >= 1024)	{		DrawProgress (tbuff);		FSRead ( inRefNum, &inOutCount, buffer );		inbuff = 0;	}		tbuff++;	return (buffer[inbuff++])&0xFF;}static void passToCR (void){	register short	c;		while ((c = GetDataByte ()) != EOF)		if (c == 0x0D)			break;}static void getTokenToComma (StringPtr str){	short	ins = str[0];	register short	c;		while ((c = GetDataByte ()) != EOF)		if (c == ',' || c == 0x0D)			break;		else		{			str[ins+1] = c;			ins++;		}		str[0] = ins;	str[ins+1] = 0;}static short fndtoken (char **tt, char *from){	short	res = 0;		while (tt[res][0])		if (!strncasecmp ( from, tt[res], strlen (tt[res]) ))			return res;		else			res++;		return -1;}static long getModificationDate (StringPtr fname){	FileParam	pb;		pb.ioCompletion = NULL;	pb.ioVRefNum = 0;	pb.ioFVersNum = 0;	pb.ioFDirIndex = 0;	pb.ioNamePtr = fname;		PBGetFInfoSync ((ParmBlkPtr) &pb);		return pb.ioFlMdDat;}static void recompile (){	Str255		str, logger;	char		tmp[128];		short		c, y, lastzone = 0;	short		tkn;	long		ltemp, inOutCount;	FILE		*rnl;		Handle		h;	zonerec		*pzone, tzone;	netrec		*pnet, tnet;	noderec		*pnode, tnode;	long		i, j, ii, jj, iseq, lseq, l_1, l_2, zooz;	sequence	*seq;	Boolean		pointinprogress;		memset ( &header, 0, sizeof (nodelistheader) );	strncpy ( header.sign, "RavelNODELIST009", 16 );		initDataBuffer ();		current.zone = 0;	current.net = 0;	current.node = 0;	current.point = 0;		initList_FILES ();			//	create empty list of node(point)list	initList_ZONES ();	initList_NODES ();	initList_BOSS ();	initList_POINTS ();	sequentor = NewHandle (0);	rnl = fopen ( ravelnodes, "r" );		if (!rnl)	{		SysBeep (10);		return;	}	RavelWindow = GetNewDialog ( 130, NULL, (WindowPtr) -1 );	DrawDialog (RavelWindow);		while ( fscanf ( rnl, "%s %ld %ld\n", tmp, &l_1, &l_2 ) != EOF )	{		if (tmp[0] == '#')		{			strcpy ( (char *) &str[1], &tmp[1] );			lastzone = l_1;			pointformat = l_2;		}		else			strcpy ( (char *) &str[1], tmp );				str[0] = strlen ((char *) &str[1]);				pStrCopy ( "\pParse ", logger );		pStrConc ( logger, str, logger );		putProgressName ( logger );				addList_FILES ( str, getModificationDate (str), (tmp[0] == '#') ? 1 : 0 );		if (FSOpen ( str, 0, &inRefNum ))		{			SysBeep (10);			continue;		}				initDataFlow ();		InitProgress (lenbuff);				pointinprogress = (tmp[0] == '#');//		current.zone = 0;		while ((c = GetDataByte ()) != EOF)		{			curoffset = tbuff-1;						switch (c)			{			case 0x0A:				//	LF pass through╔							break;						case ';':				//	comments╔							passToCR ();				break;							case ',':				//	unflagged string started╔							tkn = 9;								if (pointinprogress)				{					if (pointformat == 1 || pointformat == 3)						goto empty_pt;					else					{						if (current.zone == 0)							errWrongPoint ();												str[0] = 0;						getTokenToComma ( str );						StringToNum ( str, &ltemp );						current.node = ltemp;												addList_BOSS ();						passToCR ();					}				}				else					goto empty;								break;							default:							str[0] = 1;				str[1] = c;				getTokenToComma ( str );							switch (tkn = fndtoken (token, (char *) &str[1]))				{				case _ZONE:									if (!pointinprogress)					{						str[0] = 0;						getTokenToComma ( str );						StringToNum ( str, &ltemp );												current.zone = lastzone = ltemp;//						current.net = 0;						current.net = lastzone;						current.node = 0;						current.point = 0;												addList_ZONES ();						addList_NETS ();					}										passToCR ();					break;								case _REGION:									if (!pointinprogress)					{						if (!lastzone)							errWrongZone ();											str[0] = 0;						getTokenToComma ( str );						StringToNum ( str, &ltemp );												current.net = ltemp;						current.node = 0;						current.point = 0;												addList_NETS ();					}					else						if (pointformat == 2)						{							str[0] = 0;							getTokenToComma ( str );							StringToNum ( str, &ltemp );							current.zone = lastzone;							current.net = ltemp;							current.node = 0;							current.point = 0;						}										passToCR ();					break;									case _HOST:					if (!pointinprogress)					{						if (!lastzone)							errWrongZone ();											str[0] = 0;						getTokenToComma ( str );						StringToNum ( str, &ltemp );						current.net = ltemp;						current.node = 0;						current.point = 0;												addList_NETS ();					}					else					{						current.zone = lastzone;											switch (pointformat)						{						case 1:													errWrongPoint ();							break;													case 2:		//	Host,NET													str[0] = 0;							getTokenToComma ( str );							StringToNum ( str, &ltemp );							current.net = ltemp;							current.node = 0;							current.point = 0;							break;												case 3:		//	Host,FakeRegion,NET/NODE,╔													str[0] = 0;							getTokenToComma ( str );							str[0] = 0;							getTokenToComma ( str );														str[str[0]+1] = 0;														for (y = 1; y <= str[0]; y++)								if (str[y] == '/')									break;														if (str[y] != '/')								errWrongPoint ();							str[0] = y - 1;														StringToNum ( str, &ltemp );							current.net = ltemp;														for (; ; y++)								if (!str[y])									break;														str[str[0]+1] = y - str[0] - 2;														StringToNum ( &str[str[0]+1], &ltemp );							current.node = ltemp;							current.point = 0;							addList_BOSS ();							passToCR ();							break;												}											break;					}										passToCR ();					break;				case _HUB:				case _DOWN:				case _HOLD:				case _PVT:								empty:									str[0] = 0;					getTokenToComma ( str );										if (current.net)					{						StringToNum ( str, &ltemp );						current.node = ltemp;						current.point = 0;												addList_NODES (tkn);					}										passToCR ();					break;								case _BOSS:									if (pointformat != 1)						errWrongPoint ();					str[0] = 0;					getTokenToComma ( str );										current.zone = 0;					current.net = 0;					current.node = 0;					current.point = 0;										parseaddr ( &current, (char *) &str[1] );										addList_BOSS ();										break;								case _POINT:								empty_pt:									if (current.zone == 0)						errWrongPoint ();										str[0] = 0;					getTokenToComma ( str );					StringToNum ( str, &ltemp );					current.point = ltemp;										addList_POINTS ();								passToCR ();					break;									default:									passToCR ();					break;				}				break;			}		}		FSClose ( inRefNum );	}		fclose (rnl);		destructList_NETS ();	destructList_ZONES ();	destructList_NODES ();	destructList_BOSS ();	destructList_POINTS ();/*еееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееее*///	join all files to one!	putProgressName ( "\pJoining╔" );	header.ofs_zones = GetHandleSize (h_files) + sizeof (header);	header.ofs_nets += header.ofs_zones;	header.ofs_nodes += header.ofs_nets;	header.ofs_points += header.ofs_nodes;		Create ( ravelnodesindex, 0, 'Ravl', 'TEMP' );	FSOpen ( ravelnodesindex, 0, &refNumFILES );	SetEOF ( refNumFILES, 0 );	inOutCount = sizeof (nodelistheader);	FSWrite ( refNumFILES, &inOutCount, &header );		inOutCount = GetHandleSize (h_files);	HLock ( h_files );	FSWrite ( refNumFILES, &inOutCount, *h_files );	DisposeHandle ( h_files );		h = NewHandle ( 1024L * 512 );	MoveHHi (h);	HLock (h);	//	append & sort ZONES		putProgressName ( "\pJoining & sorting zones╔" );	pzone = (zonerec *) *h;	FSOpen ( "\p$Nodelist.zones", 0, &refNumZONES );	GetEOF ( refNumZONES, &inOutCount );	ltemp = inOutCount / sizeof(zonerec);	FSRead ( refNumZONES, &inOutCount, pzone );	FSClose ( refNumZONES );		InitProgress (ltemp);		for ( i = 0; i < ltemp - 2; i++ )	{		DrawProgress (i);				for ( j = 0; j < ltemp - 2 - i; j++ )			if (pzone[j].zone > pzone[j+1].zone)			{				tzone = pzone[j];				pzone[j] = pzone[j+1];				pzone[j+1] = tzone;			}	}		FSWrite ( refNumFILES, &inOutCount, *h );//	append & sort NETS	putProgressName ( "\pJoining & sorting nets╔" );	pnet = (netrec *) *h;	FSOpen ( "\p$Nodelist.nets", 0, &refNumZONES );	GetEOF ( refNumZONES, &inOutCount );	ltemp = inOutCount / sizeof(netrec);	FSRead ( refNumZONES, &inOutCount, pnet );	FSClose ( refNumZONES );		InitProgress (ltemp);	for ( ii = 0; ii < ltemp - 1;  )	{		DrawProgress (ii);//		for ( i = ii; pnet[i+1].net != -1; i++ )		for ( i = ii; pnet[i+1].net != 0xFFFF; i++ )		{//			for ( j = ii; pnet[j+1].net != -1; j++ )			for ( j = ii; pnet[j+1].net != 0xFFFF; j++ )				if (pnet[j].net > pnet[j+1].net)				{					tnet = pnet[j];					pnet[j] = pnet[j+1];					pnet[j+1] = tnet;				}		}//		ii += i + 2;		ii = i + 2;	}		FSWrite ( refNumFILES, &inOutCount, *h );//	append & sort & substitute points in NODES	pnode = (noderec *) *h;	FSOpen ( "\p$Nodelist.nodes", 0, &refNumZONES );	GetEOF ( refNumZONES, &inOutCount );	ltemp = inOutCount;		lseq = GetHandleSize (sequentor) / sizeof (sequence);	seq = (sequence *) *sequentor;	//	for (iseq=1; iseq < lseq; iseq++)//		if (seq[iseq].innode == seq[iseq-1].innode)//		{//			seq[iseq-1].innode = -1;//		}	iseq = 0;	ii = 0;		OpenLookUpPointForBoss ();		while (ii < ltemp)	{		putProgressName ( "\pJoining & sorting nodes╔" );		if (seq[iseq].innode >= 0)		{			jj = 0;				do {							inOutCount = sizeof (noderec);				if ( FSRead ( refNumZONES, &inOutCount, &pnode[jj] ) != noErr ||					 inOutCount != sizeof (noderec) )				{					DebugStr ("\pbad sequence or loop condition╔");				}								ii += sizeof (noderec);				jj++;							} while (pnode[jj-1].pointoffset != -1);				InitProgress ( jj );						for ( i = 0; i < jj - 2; i++ )			{								DrawProgress (i);								for ( j = 0; j < jj - 2 - i; j++ )					if (pnode[j].node > pnode[j+1].node)					{						tnode = pnode[j];						pnode[j] = pnode[j+1];						pnode[j+1] = tnode;					}			}						current.zone = seq[iseq].zone;			current.net = seq[iseq].net;				zooz = iseq + 1;						while (seq[zooz].innode >= 0)				if (seq[zooz].zone == current.zone && seq[zooz].net == current.net)					break;				else					zooz++;						if (seq[zooz].innode < 0)			{				putProgressName ( "\pAppend points references╔" );						InitProgress ( jj );								for ( i = 0; i < jj - 1; i++ )				{				//	lookup points definitions										DrawProgress (i);										current.node = pnode[i].node;					current.point = 0;										pnode[i].pointoffset = LookUpPointForBoss ();				}								inOutCount = sizeof (noderec) * jj;				FSWrite ( refNumFILES, &inOutCount, *h );			}		}		else			if (iseq)			{				inOutCount = sizeof (noderec);				if ( FSRead ( refNumZONES, &inOutCount, &pnode[0] ) != noErr ||					 inOutCount != sizeof (noderec) )				{					DebugStr ("\pbad sequence or loop condition╔");				}								ii += sizeof (noderec);								inOutCount = sizeof (noderec);				FSWrite ( refNumFILES, &inOutCount, *h );			}				iseq++;	}	FSClose ( refNumZONES );	CloseLookUpPointForBoss ();		DisposeHandle (sequentor);	//	append points (unsorted╔)		FSOpen ( "\p$Nodelist.points", 0, &refNumPOINTS );	putProgressName ( "\pJoining points╔" );	do {			inOutCount = 0x2000;		FSRead ( refNumPOINTS, &inOutCount, *h );		FSWrite ( refNumFILES, &inOutCount, *h );		} while (inOutCount);	FSClose ( refNumPOINTS );	FSClose ( refNumFILES );	closeDataBuffer ();		putProgressName ( "\pTerminating╔" );	FSDelete ( "\p$Nodelist.boss", 0 );	FSDelete ( "\p$Nodelist.nets", 0 );	FSDelete ( "\p$Nodelist.nodes", 0 );	FSDelete ( "\p$Nodelist.points", 0 );	FSDelete ( "\p$Nodelist.zones", 0 );	DisposeDialog (RavelWindow);}static void myOutDialog (void){	short	iType;	Handle	iHandle;	Rect	iRect, rView, rDataBnds;	Point	cellSize;	RavelWindow = GetNewDialog ( 128, NULL, (WindowPtr) -1 );	SetPort ( RavelWindow );	TextFont ( 4 );	TextSize ( 9 );	GetDialogItem ( RavelWindow, 5, &iType, &iHandle, &rView );	SetRect ( &rDataBnds, 0, 0, 1, 0 );	rView.right -= 15;	SetPt ( &cellSize, 0, 0 );	NodeList = LNew ( &rView, &rDataBnds, cellSize, 0, RavelWindow, true, false, false, true );	(*NodeList)->selFlags = 0x82;	(*NodeList)->port->txFont = 4;	(*NodeList)->port->txSize = 9;	(*NodeList)->indent.h = 5;	(*NodeList)->indent.v = 9;	GetDialogItem ( RavelWindow, 8, &iType, &iHandle, &rView );	SetRect ( &rDataBnds, 0, 0, 1, 0 );	rView.right -= 15;	SetPt ( &cellSize, 0, 0 );	PointList = LNew ( &rView, &rDataBnds, cellSize, 0, RavelWindow, true, false, false, true );	(*PointList)->selFlags = 0x82;	(*PointList)->port->txFont = 4;	(*PointList)->port->txSize = 9;	(*PointList)->indent.h = 5;	(*PointList)->indent.v = 9;	DrawDialog ( RavelWindow );		LActivate ( true, NodeList );	LSetDrawingMode ( true, NodeList );	LUpdate ( RavelWindow->visRgn, NodeList );	LActivate ( true, PointList );	LSetDrawingMode ( true, PointList );	LUpdate ( RavelWindow->visRgn, PointList );}static pascal Boolean ModalFilterProc ( DialogPtr theDialog, EventRecord *theEvent, short *itemHit ){	Boolean result = false;	char	tmp[128];		if (theEvent->what == mouseDown)	{		Point		localWhere = theEvent->where;		GrafPtr		savePort;		short		initem, part;		WindowPtr	window;						switch ( part = FindWindow(theEvent->where, &window) )		{						case inSysWindow:							SystemClick(theEvent, window);				result = true;				break;						case inContent:							if (window != FrontWindow())				{					SelectWindow(window);					result = true;				}				else				{					if (window == RavelWindow)					{						GetPort (&savePort);						SetPort (theDialog);						GlobalToLocal (&localWhere);												initem = FindDialogItem (theDialog, localWhere);												if (initem == 4)		// 5 is nodelist pump!						{							LClick ( localWhere, theEvent->modifiers, NodeList );							result = true;						}						else							if (initem == 7)	// 8 is pointlist pump!							{								LClick ( localWhere, theEvent->modifiers, PointList );								result = true;							}												SetPort (savePort);					}				}								break;				case inDrag:					DragWindow ( window, theEvent->where, &qd.screenBits.bounds );				result = true;				break;				case inGoAway:							if (TrackGoAway(window, theEvent->where))				{					if (window == RavelWindow)					{						*itemHit = 1;						result = true;					}					else						if ( ((WindowPeek) window)->windowKind < 0 )							CloseDeskAcc(((WindowPeek)window)->windowKind);				}				break;			}	}	else		if (theEvent->what == keyDown)		{			char	key = theEvent->message & 0xFFL;			*itemHit = 0;						if (key == 0x03 || key == 0x0D)			{				*itemHit = 1;				result = true;			}		}	return result;}static Boolean AlreadyInList (ListHandle list, StringPtr str){	short	dummy;	Str255	temp;	short	len;	Cell	theCell;	for ( dummy = 0; dummy < (*list)->dataBounds.bottom; dummy++ )	{		SetPt ( &theCell, 0, dummy );		len = 255;		LGetCell ( &temp[1], &len, theCell, list );		temp[0] = len;			if (!pStrComp (temp, str))			break;	}		if (dummy == (*list)->dataBounds.bottom)		return false;	else		return true;}static Boolean AlreadyInPList (ListHandle list, StringPtr str){	short	dummy;	Str255	temp;	short	len;	Cell	theCell;	for ( dummy = 0; dummy < (*list)->dataBounds.bottom; dummy++ )	{		SetPt ( &theCell, 0, dummy );		len = 255;		LGetCell ( &temp[1], &len, theCell, list );		temp[0] = len - 8;			if (!pStrComp (temp, str))			break;	}		if (dummy == (*list)->dataBounds.bottom)		return false;	else		return true;}static Boolean doList (void){	short		itemHit, iHit, dummy;	Point		where = {100, 100};	SFReply		reply;	SFTypeList	typeList;	Cell		theCell;	short		len;	Str255		temp;		Handle		h;	short		iType, lastzone;	Rect		iRect;		long		ltemp, l_1, l_2;		FILE		*rnl;	char		nodeFile[64], yup[128];	DialogPtr	RWindow;	#if defined(powerc) || defined(__powerc)	UniversalProcPtr	uupFilterProc;	uupFilterProc = NewRoutineDescriptor ((ProcPtr) ModalFilterProc, uppModalProcInfo, GetCurrentISA ());#endif		myOutDialog ();	rnl = fopen ( ravelnodes, "r" );		if (rnl)	{		while ( fscanf ( rnl, "%s %ld %ld\n", nodeFile, &l_1, &l_2 ) != EOF )		{			lastzone = l_1;			pointformat = l_2;			if (nodeFile[0] != '#')			{				dummy = LAddRow ( 1, 0x7FFF, NodeList );				SetPt ( &theCell, 0, dummy );				LSetCell ( nodeFile, strlen (nodeFile), theCell, NodeList );				}			else			{				sprintf (yup, "%s %.5d %.1d", &nodeFile[1], lastzone, pointformat);				dummy = LAddRow ( 1, 0x7FFF, PointList );				SetPt ( &theCell, 0, dummy );				LSetCell ( yup, strlen (yup), theCell, PointList );				}		}				fclose (rnl);	}		do {	#if defined(powerc) || defined(__powerc)		ModalDialog ( uupFilterProc, &itemHit );#else		ModalDialog ( ModalFilterProc, &itemHit );#endif		switch (itemHit)		{		case 1:			//	close		case 2:			//	compile					break;					case 3:			//	add nodelist in nodelist :-D					typeList[0] = 'TEXT';						SFGetFile ( where, "\p", NULL, 1, typeList, NULL, &reply );			if (reply.good)			{				if (FSOpen (reply.fName, 0, &dummy) == noErr)				{					FSClose (dummy);										if ( !AlreadyInList (NodeList, reply.fName) &&						 !AlreadyInPList (PointList, reply.fName) )					{						dummy = LAddRow ( 1, 0x7FFF, NodeList );						SetPt ( &theCell, 0, dummy );						LSetCell ( &reply.fName[1], reply.fName[0], theCell, NodeList );						}					else						SysBeep (10);				}				else					SysBeep (10);			}			LUpdate ( RavelWindow->visRgn, NodeList );			LUpdate ( RavelWindow->visRgn, PointList );			break;				case 7:			//	remove nodelist from nodelist :-D			SetPt ( &theCell, 0, 0 );				if ( LGetSelect ( 1, &theCell, NodeList) )			{				LDelRow ( 1, theCell.v, NodeList );			}				break;					case 5:			//	nodelist click processing					break;					case 6:			//	add pointlist in pointlist :-D					typeList[0] = 'TEXT';						SFGetFile ( where, "\p", NULL, 1, typeList, NULL, &reply );			if (reply.good)			{				if (FSOpen (reply.fName, 0, &dummy) == noErr)				{					FSClose (dummy);										if ( !AlreadyInList (NodeList, reply.fName) &&						 !AlreadyInPList (PointList, reply.fName) )					{						RWindow = GetNewDialog ( 131, NULL, (WindowPtr) -1 );												pointformat = 1;												GetDialogItem (RWindow, pointformat+1, &iType, &h, &iRect);						SetControlValue ((ControlHandle) h,1);												do {													ModalDialog (NULL, &iHit);													if (iHit > 1 && iHit < 5 && pointformat != (iHit - 1))							{								GetDialogItem (RWindow, pointformat+1, &iType, &h, &iRect);								SetControlValue ((ControlHandle) h,0);																pointformat = iHit - 1;																GetDialogItem (RWindow, pointformat+1, &iType, &h, &iRect);								SetControlValue ((ControlHandle) h,1);							}												} while (iHit != 1);						GetDialogItem (RWindow, 15, &iType, &h, &iRect);						GetDialogItemText (h, temp);												DisposeDialog (RWindow);												StringToNum (temp, &ltemp);						sprintf (yup, "%#s %.5d %.1d", reply.fName, (short) ltemp, pointformat);						dummy = LAddRow ( 1, 0x7FFF, PointList );						SetPt ( &theCell, 0, dummy );						LSetCell ( yup, strlen (yup), theCell, PointList );						}					else						SysBeep (10);				}				else					SysBeep (10);			}			LUpdate ( RavelWindow->visRgn, NodeList );			LUpdate ( RavelWindow->visRgn, PointList );			break;				case 4:			//	remove pointlist from pointlist :-D			SetPt ( &theCell, 0, 0 );				if ( LGetSelect ( 1, &theCell, PointList) )			{				LDelRow ( 1, theCell.v, PointList );			}				break;					case 8:			//	pointlist click processing					break;					}	} while (itemHit != 1 && itemHit != 2);		rnl = fopen ( ravelnodes, "w" );		for ( dummy = 0; dummy < (*NodeList)->dataBounds.bottom; dummy++ )	{		SetPt ( &theCell, 0, dummy );		len = 255;		LGetCell ( nodeFile, &len, theCell, NodeList );		nodeFile[len] = 0;				fprintf ( rnl, "%s\r", nodeFile );	}		for ( dummy = 0; dummy < (*PointList)->dataBounds.bottom; dummy++ )	{		SetPt ( &theCell, 0, dummy );		len = 255;		LGetCell ( nodeFile, &len, theCell, PointList );		nodeFile[len] = 0;				fprintf ( rnl, "#%s\r", nodeFile );	}		fclose (rnl);		LDispose (NodeList);	LDispose (PointList);	DisposeDialog (RavelWindow);#if defined(powerc) || defined(__powerc)	DisposeRoutineDescriptor (uupFilterProc);#endif	return itemHit == 2;}static MenuHandle myMenus[3];static void Loop (void){	EventRecord		event;	WindowPtr		window;	DialogPtr		dialog;	short			part, menuItem;	long			menuResult;	Str255			daName;	char			key;	Handle			h;	short			iType, iHit;	Rect			iRect;			WaitNextEvent (everyEvent, &event, 0, NULL);	switch ( event.what )	{	case mouseDown:			switch ( part = FindWindow (event.where, &window) )		{		case inMenuBar:					menuResult = MenuSelect(event.where);				doMenu:					menuItem = LoWord(menuResult);					switch(HiWord(menuResult))			{			case 1:					//	еее	Apple Menu							switch(menuItem)				{				case 1:			//	еее	"About RavelMAIL╔"					dialog = GetNewDialog(129, NULL, (WindowPtr) -1L);										do {											ModalDialog (NULL, &iHit);										} while (iHit != 1);										DisposeDialog (dialog);					break;				default:		//	еее	Others╔										GetMenuItemText (GetMenuHandle (1), menuItem, daName);					OpenDeskAcc(daName);										break;				}					break;				case 2:						//	еее	File menu					switch(menuItem)				{				case 1:			//	еее	list									if (!doList ())						break;									case 2:			//	еее	recompile									HiliteMenu(0);					recompile ();					break;/*									case 4:			//	еее Preferences									RavelWindow = GetNewDialog ( 131, NULL, (WindowPtr) -1 );										GetDialogItem (RavelWindow, pointformat+1, &iType, &h, &iRect);					SetCtlValue ((ControlHandle) h,1);										do {											ModalDialog (NULL, &iHit);											if (iHit > 1 && iHit < 5 && pointformat != (iHit - 1))						{							GetDialogItem (RavelWindow, pointformat+1, &iType, &h, &iRect);							SetCtlValue ((ControlHandle) h,0);														pointformat = iHit - 1;														GetDialogItem (RavelWindow, pointformat+1, &iType, &h, &iRect);							SetCtlValue ((ControlHandle) h,1);						}										} while (iHit != 1);										DisposDialog (RavelWindow);										break;*/									case 4:			//	еее	Qiut now/*									h = Get1Resource ('Pref', 0);					if (!h)					{						h = NewHandle (sizeof (short));						AddResource (h, 'Pref', 0, "\p");					}						*((short *) *h) = pointformat;										ChangedResource (h);					WriteResource (h);*/					ExitToShell ();										break;				}					break;			}					HiliteMenu(0);					break;				case inSysWindow:					SystemClick (&event, window);			break;		}				break;		case keyDown:				if ( ((WindowPeek) FrontWindow())->windowKind < 0 )			break;				key = event.message & charCodeMask;		if ( event.modifiers & cmdKey )		{			menuResult = MenuKey(key);			goto doMenu;		}				break;	case activateEvt:		break;	case updateEvt:		break;			case diskEvt:		break;	case osEvt:		break;	case nullEvent:		break;	}}static short myOpenWD ( StringPtr workPath ){	WDPBRec		pbr;							/* local pb */	pbr.ioNamePtr = workPath;	pbr.ioWDProcID = 0L;	pbr.ioWDDirID = 0L;	pbr.ioVRefNum = 0;		if ( PBOpenWDSync (&pbr) )	{		return 0;	}		return pbr.ioVRefNum;}void main (){	Handle		h;	Str255		lll;	short		prefResNum;	short		oldResNum, wdRefNum;	InitToolbox ();	myMenus[0] = GetMenu ( 1 );	myMenus[1] = GetMenu ( 2 );	myMenus[2] = GetMenu ( 3 );	AppendResMenu ( myMenus[0], 'DRVR' );	InsertMenu ( myMenus[0], 0 );	InsertMenu ( myMenus[1], 0 );	InsertMenu ( myMenus[2], 0 );	DrawMenuBar();/*		h = Get1Resource ('Pref', 0);	if (h)	{		pointformat = *((short *) *h);		ReleaseResource (h);	}*/		prefResNum = OpenRFPerm ( "\pRavel.PREF", 0, fsRdWrPerm );	oldResNum = CurResFile ();	if (prefResNum == -1)		ExitToShell ();	UseResFile (prefResNum);	h = Get1Resource ( 'STR#', 1 );		if (!h)		ExitToShell ();	GetIndString ( lll, 1, 7 );		UseResFile (oldResNum);	CloseResFile (prefResNum);		wdRefNum = myOpenWD ( lll );		if (wdRefNum)	{		FSSpec	spec;				if (FSMakeFSSpec (wdRefNum, 0, "\pRavel.NODELIST", &spec) == noErr)		{			LMSetCurDirStore (spec.parID);		}				SetVol ( NULL, wdRefNum );	}	else		ExitToShell ();			for (;;) Loop ();}