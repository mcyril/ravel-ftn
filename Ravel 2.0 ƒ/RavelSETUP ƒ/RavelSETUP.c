/*	(c) 1997 Wicked Cyril	Based on ThinkReference "Adding Items to the Print Dialog"	Sample only. No filters, no globals.	Шаблон-диалог - rID == 128		Его последний user-item обозначает позицию, для вывода панелей		(используется только левый верхний угол). Сам не выводится (убивается		после прорисовки диалога).	Панели-диалоги - rID: 256..259	lastID			-	последний элемент шаблона.	lastappendedID	-	последний элемент каждой панели (с учетом общих).	Никаких накруток - используется ShortenDITL.*/#include <Sound.h>#include <stdio.h>#include <string.h>#include <serial.h>#include "PopUpLib.h"#include "defines.h"#include "PKT.h"#include "PascalStr.h"#include "Prefs.h"#include "Scheduler.h"#include "compatible.h"#include "stringutl.h"#include "addresses.h"#include "Pathes.h"#define	tmplBase	255typedef struct {	MenuHandle		mHandle;	short			mID;	char			mPrivate;} popupPrivateData;Str255			Pathes[8];extern	homeHndl		homesystem;			//	•	Home system structextern	mailPrefHndl	mailHndl;			//	•	Netmail structextern	short			AreasNumber;		//	•	Areas structs listextern	areaPrefHndl	*areasHndls;extern	short			GroupsNumber;		//	•	AreaGroups structs listextern	groupPrefHndl	*groupsHndls;extern	short			NodesNumber;		//	•	Linked Nodes structs listextern	nodePrefHndl	*nodesHndls;extern	routeHndl		Routing;extern	short			eventsNumber;		//	•	Events listextern	eventsHndl		*eventsHndls;extern	behaviorHndl	behavior;			//	•	Unattended behaviors listextern	prefHndl		comm_pref;			//	•	Communications preferencesextern	h_wzoo			wazoo;extern	h_shfl			shufle;extern	h_tpt_opt		hydra;extern	h_ftsc			ftsc;extern	Str255			mdmInitStr;			//	•	Modem initialization stringextern	Str255			RealName;extern	Str255			ShufflerPathName;extern	StringPtr		*commoninits;static	ListHandle		akaList;static	ListHandle		linkList;static	short			semaphore;static	short			wasmove;static	short			bauds[12] = {	baud300, baud600, baud1200, baud1800,	baud2400, baud3600, baud4800, baud7200,	baud9600, baud19200, baud38400, baud57600};static	short			stops[3] = {	stop10, stop15, stop20};static	short			parities[3] = {	noParity, oddParity, evenParity	};static	short			datas[4] = {	data5, data6, data7, data8	};static	PopUpMenuHandle	linksGroupSet, linksEventSet;static	PopUpMenuHandle	canCall, canAccept, canFreq;static void InitToolbox (void){	MaxApplZone ();	MoreMasters ();	MoreMasters ();	MoreMasters ();	MoreMasters ();	InitGraf ((Ptr) &qd.thePort);	InitFonts ();	InitWindows ();	InitMenus ();	FlushEvents (everyEvent,0);	InitDialogs (0L);	InitCursor ();}//	Create dialog and kill last user-item. Its coordinates (paneRect) are pane positions.static void _InstallDITL (DialogPtr *theDialog, short resID, short *lastID, Rect *paneRect){	short	iType;	Handle	iHandle;		*theDialog = GetNewDialog ( resID, NULL, (WindowPtr) -1L );	*lastID = CountDITL ( *theDialog );	GetDialogItem ( *theDialog, *lastID, &iType, &iHandle, paneRect );	ShortenDITL ( *theDialog, 1 );	*lastID = CountDITL ( *theDialog );}//	Append pane's DITL to dialog with sys routine. teActive is the first TextEdit box id.static void _AppendDITL (DialogPtr theDialog, short resID, short *lastappendedID, Rect *paneRect){	typedef struct {			Handle			itmHndl;		Rect			itmRect;		char			itmType;		unsigned char	itmData[];	} DITLItem, *pDITLItem, **hDITLItem;	typedef struct {			short		dlgMaxIndex;		DITLItem	DITLItems[];		} ItemList, *pItemList, **hItemList;	short		*IntPtr;	Handle		inDITL;	hItemList	hDITL;	pDITLItem	pItem;	hItemList	hItems;	short		firstItem;	short		newItems, i;	long		sizeHandle, dataSize;	short		err;		//	• Get items list to append to exist list…	inDITL = GetResource ( 'DITL', resID + (((DialogPeek) theDialog)->window.refCon & 0xFFFF) );	hDITL = (hItemList) inDITL;	HLock ((Handle) hDITL);//	• Process recalc of item's rects…	pItem = (DITLItem *)&((**hDITL).DITLItems);	newItems = (**hDITL).dlgMaxIndex;	for (i = 0; i <= newItems; i++)	{		OffsetRect ( &pItem->itmRect, paneRect->left, paneRect->top );		dataSize = (pItem->itmData[0] + 1) & 0xFFFE;		pItem  = (DITLItem *)(((char *)pItem) +  dataSize + sizeof(DITLItem));	}	HUnlock ((Handle) hDITL);//	• Make appending…	AppendDITL ( theDialog, (Handle) hDITL, overlayDITL );	*lastappendedID = CountDITL (theDialog);	ReleaseResource ((Handle) hDITL);}static void set_h_opt (DialogPtr theDialog, short base_cb, long options){	long		i;	short		j;	short		iType;	Handle		iHandle;	Rect		iRect;		i = 1L;	for (j = 0; j < 11; j++)	{		GetDialogItem (theDialog, base_cb+j, &iType, &iHandle, &iRect );		SetControlValue ((ControlHandle) iHandle, ((options & i) != 0) ? 1 : 0);		i <<= 1;	}}static long get_h_opt (DialogPtr theDialog, short base_cb){	long		i, res;	short		j;	short		iType;	Handle		iHandle;	Rect		iRect;	res = 0L;	i = 1L;	for (j = 0; j < 11; j++)	{		GetDialogItem (theDialog, base_cb+j, &iType, &iHandle, &iRect );		res |= (GetControlValue ((ControlHandle) iHandle)) ? i : 0L;		i <<= 1;	}		return res;}static void ResyncDefGroupMenu (DialogPtr theDialog){	short		i, groups;	short		iType, markChar;	Handle		iHandle;	Rect		iRect;	MenuHandle	mHandle;	Str255		temp;			GetDialogItem ( theDialog, linkDefaultGroup, &iType, &iHandle, &iRect );	mHandle = ((popupPrivateData *)(*(*((ControlHandle) iHandle))->contrlData))->mHandle;		groups = CountMItems (mHandle);		for (i=groups; i>0; i--)		DeleteMenuItem (mHandle, i);		iType = CountMItems ((**linksGroupSet).menuHdl);	groups = 0;		for (i=1; i<=iType; i++)	{		GetItemMark ((**linksGroupSet).menuHdl, i, &markChar);		if (markChar)		{			GetMenuItemText ((**linksGroupSet).menuHdl, i, temp);			AppendMenu ( mHandle, temp );			groups++;		}	}		SetControlMinimum ( (ControlHandle) iHandle, (groups) ? 1 : 0 );	SetControlMaximum ( (ControlHandle) iHandle, groups );	SetControlValue ( (ControlHandle) iHandle, (groups) ? 1 : 0 );}static pascal Boolean ModalFilterProc ( DialogPtr theDialog, EventRecord *theEvent, short *itemHit ){	Boolean 	result = false;	Point		localWhere = theEvent->where;	GrafPtr		savePort;	short		initem, part;	WindowPtr	window;	short		pane = (((DialogPeek)theDialog)->window.refCon) & 0xFFFF;	short		item = (((DialogPeek)theDialog)->window.refCon) >> 16;		Boolean		dblClick;	switch (theEvent->what)	{	case keyDown:	case autoKey:			part = theEvent->message & 0x00FF;			if (part < 0x20 && part != 8 && part != 9 && part != 0x1c && part != 0x1d)			result = true;					break;		case mouseDown:			switch ( part = FindWindow (theEvent->where, &window) )		{		case inContent:					if (window != FrontWindow())			{				SelectWindow(window);				result = true;			}			else			{				GetPort (&savePort);				SetPort (theDialog);				GlobalToLocal (&localWhere);								initem = FindDialogItem (theDialog, localWhere) + 1;								if (initem > item)				{					initem -= item;					switch (pane)					{					case paneSystem:				//	System setup: AKA list present												if (initem == sysAkaList)						{							LClick ( localWhere, theEvent->modifiers, akaList );							result = true;						}												break;										case paneSession:											switch (initem)						{						case sessCanIssue:							HandlePopUp (canCall);							result = true;							break;													case sessCanAccept:							HandlePopUp (canAccept);							result = true;							break;													case sessCanFreq:														HandlePopUp (canFreq);							result = true;							break;													default:														break;						}											break;										case paneAreas:					case paneLinx:					case paneGroups:					case paneEvents:					case paneEvtBehave:					case paneRouting:						semaphore = false;						wasmove = -1;						if (initem == linxList)						{							dblClick = LClick ( localWhere, theEvent->modifiers, linkList );							result = true;						}												if ((pane == paneAreas || pane == paneRouting) && wasmove != -1)							*itemHit = 666;						else							if (dblClick)							{								*itemHit = areasEdit + item;							}				/*								switch (initem)						{						case linkGroupsSet:														HandlePopUp (linksGroupSet);							result = false;							break;													case linkEvent:													HandlePopUp (linksEventSet);							result = true;							break;						}				*/						break;					}				}								SetPort (savePort);			}						break;		}				break;	}	return result;}static void FullLinksMenu ( PopUpMenuHandle mh ){	short	i;	Str255	t;		for ( i = 0; i < NodesNumber; i++ )	{		printaddr ( &(*nodesHndls[i])->Addr, (char *) &t[1] );		t[0] = strlen ((char *) &t[1]);		AppendMenu ( (*mh)->menuHdl, "\pdum" );		SetMenuItemText ( (*mh)->menuHdl, i+1, t );	}}static void FullGroupsMenu ( PopUpMenuHandle mh ){	short	i;		for ( i = 0; i < GroupsNumber; i++ )		AppendMenu ( (*mh)->menuHdl, (*groupsHndls[i])->groupName );}static void print_time (_times what, StringPtr res){	sprintf ( (char *) &res[1], "%.2d:%.2d", 							(short) what.hour,							(short) what.minute );	res[0] = strlen ((char *) &res[1]);}static void scan_time (_times *what, StringPtr res){	unsigned short		a, b;	res[res[0]+1] = 0;	a = b = 0;		sscanf ( (char *) &res[1], "%d:%d", &a, &b );	what->hour = (a > 23) ? 0 : a;	what->minute = (b > 59) ? 0 : b;}static void FullEventsMenu ( PopUpMenuHandle mh ){	short	i;	Str255	t, temp;		for ( i = 0; i < eventsNumber; i++ )	{		NumToString ( i+1, t );				pStrConc (t, "\p, ", t);				print_time ( (*(*eventsHndls[i]))[1].Start, temp );				pStrConc (t, temp, t);		pStrConc (t, "\p - ", t);		print_time ( (*(*eventsHndls[i]))[1].End, temp );		pStrConc (t, temp, t);		AppendMenu ( (*mh)->menuHdl, t );	}}static void ProcessLinkInitialization (DialogPtr theDialog, short currentItem){	short		iType, i, dummy, j, markChar;	Handle		iHandle;	Rect		iRect, rDataBnds;	Point		cellSize, theCell;	Str255		temp;	Str255		tmp;	MenuHandle	mHandle;	long		lll;	//	•	setup text strings	//	node name		GetDialogItem ( theDialog, linkName, &iType, &iHandle, &iRect );	SetDialogItemText ( iHandle, (*nodesHndls[currentItem])->nodeName );		//	node phone		GetDialogItem ( theDialog, linkPhone, &iType, &iHandle, &iRect );	SetDialogItemText ( iHandle, (*nodesHndls[currentItem])->nodePhone );		//	node address		printaddr ( &(*nodesHndls[currentItem])->Addr, (char *) &temp[1] );	temp[0] = strlen ( (char *) &temp[1] );	GetDialogItem ( theDialog, linkAddress, &iType, &iHandle, &iRect );	SetDialogItemText ( iHandle, temp );		//	arcmail pwd		temp[9] = 0;	strncpy ( (char *) &temp[1], (*nodesHndls[currentItem])->ArcMail_pwd, 8 );	temp[0] = strlen ( (char *) &temp[1] );	GetDialogItem ( theDialog, linkArcPwd, &iType, &iHandle, &iRect );	SetDialogItemText ( iHandle, temp );		//	areafix pwd	temp[9] = 0;	strncpy ( (char *) &temp[1], (*nodesHndls[currentItem])->AreaFix_pwd, 8 );	temp[0] = strlen ( (char *) &temp[1] );	GetDialogItem ( theDialog, linkAFixPwd, &iType, &iHandle, &iRect );	SetDialogItemText ( iHandle, temp );		//	session pwd	temp[9] = 0;	strncpy ( (char *) &temp[1], (*nodesHndls[currentItem])->Session_pwd, 8 );	temp[0] = strlen ( (char *) &temp[1] );	GetDialogItem ( theDialog, linkSessPwd, &iType, &iHandle, &iRect );	SetDialogItemText ( iHandle, temp );		//	init string (if any)		if (commoninits[currentItem])	{		GetDialogItem ( theDialog, linkInit, &iType, &iHandle, &iRect );		SetDialogItemText ( iHandle, commoninits[currentItem] );	}		//	use aka		GetDialogItem ( theDialog, linkUseAka, &iType, &iHandle, &iRect );	SetControlValue ( (ControlHandle) iHandle, (*nodesHndls[currentItem])->yourAka + 1 );		//	use compressor		GetDialogItem ( theDialog, linkCompressor, &iType, &iHandle, &iRect );	SetControlValue ( (ControlHandle) iHandle, (*nodesHndls[currentItem])->Compressor + 1 );	//	poll type		GetDialogItem ( theDialog, linkPollType, &iType, &iHandle, &iRect );	SetControlValue ( (ControlHandle) iHandle, (*nodesHndls[currentItem])->Poll + 1 );	//	groups		iType = CountMItems ((*linksGroupSet)->menuHdl);		for (i=1; i<=iType;i++)		CheckItem ( (*linksGroupSet)->menuHdl, i, false );		for (i=0; i<(*nodesHndls[currentItem])->GroupsNumber; i++)		CheckItem ( (*linksGroupSet)->menuHdl, (*nodesHndls[currentItem])->group[i] + 1, true );		ResyncDefGroupMenu (theDialog);		j = 0;	for (i=0; i<(*nodesHndls[currentItem])->group[0]; i++)	{		GetItemMark ((**linksGroupSet).menuHdl, i+1, &markChar);		if (markChar)		{			j++;		}	}			GetDialogItem ( theDialog, linkDefaultGroup, &iType, &iHandle, &iRect );	SetControlValue ( (ControlHandle) iHandle, j + 1 );	//	events		lll = 1L;	for (i=0; i<eventsNumber; i++)	{		CheckItem ( (*linksEventSet)->menuHdl, i + 1, ((*nodesHndls[currentItem])->evt_mask & lll) != 0 );		lll <<= 1;	}	//	flags		GetDialogItem ( theDialog, linkEMSI, &iType, &iHandle, &iRect );	SetControlValue ( (ControlHandle) iHandle, ((*nodesHndls[currentItem])->nodeflags & NODE_NOEMSI) ? 1 : 0 );	GetDialogItem ( theDialog, linkYooHoo, &iType, &iHandle, &iRect );	SetControlValue ( (ControlHandle) iHandle, ((*nodesHndls[currentItem])->nodeflags & NODE_NOYOOHOO) ? 1 : 0 );	GetDialogItem ( theDialog, linkPackNetMail, &iType, &iHandle, &iRect );	SetControlValue ( (ControlHandle) iHandle, ((*nodesHndls[currentItem])->nodeflags & NODE_COMPRESSNETMAIL) ? 1 : 0 );	GetDialogItem ( theDialog, linkAutoCreate, &iType, &iHandle, &iRect );	SetControlValue ( (ControlHandle) iHandle, ((*nodesHndls[currentItem])->nodeflags & NODE_ALLOWAUTOCREATE) ? 1 : 0 );	GetDialogItem ( theDialog, linkSEAlink, &iType, &iHandle, &iRect );	SetControlValue ( (ControlHandle) iHandle, ((*nodesHndls[currentItem])->nodeflags & NODE_NOSEALINK) ? 1 : 0 );	GetDialogItem ( theDialog, linkZedZip, &iType, &iHandle, &iRect );	SetControlValue ( (ControlHandle) iHandle, ((*nodesHndls[currentItem])->nodeflags & NODE_NOZEDZIP) ? 1 : 0 );	GetDialogItem ( theDialog, linkZedZap, &iType, &iHandle, &iRect );	SetControlValue ( (ControlHandle) iHandle, ((*nodesHndls[currentItem])->nodeflags & NODE_NOZEDZAP) ? 1 : 0 );	GetDialogItem ( theDialog, linkDirZap, &iType, &iHandle, &iRect );	SetControlValue ( (ControlHandle) iHandle, ((*nodesHndls[currentItem])->nodeflags & NODE_NODIRZAP) ? 1 : 0 );	GetDialogItem ( theDialog, linkJanus, &iType, &iHandle, &iRect );	SetControlValue ( (ControlHandle) iHandle, ((*nodesHndls[currentItem])->nodeflags & NODE_NOJANUS) ? 1 : 0 );	GetDialogItem ( theDialog, linkHydra, &iType, &iHandle, &iRect );	SetControlValue ( (ControlHandle) iHandle, ((*nodesHndls[currentItem])->nodeflags & NODE_NOHYDRA) ? 1 : 0 );	GetDialogItem ( theDialog, linkxHydra, &iType, &iHandle, &iRect );	SetControlValue ( (ControlHandle) iHandle, ((*nodesHndls[currentItem])->nodeflags & NODE_NOXHYDRA) ? 1 : 0 );}static pascal Boolean areaFilter ( DialogPtr theDialog, EventRecord *theEvent, short *itemHit ){	Boolean 	result = false;	Point		localWhere = theEvent->where;	GrafPtr		savePort;	short		initem, part;	WindowPtr	window;	switch (theEvent->what)	{	case mouseDown:			switch ( part = FindWindow (theEvent->where, &window) )		{		case inContent:					if (window != FrontWindow())			{//				SelectWindow(window);				result = false;			}			else			{				GetPort (&savePort);				SetPort (theDialog);				GlobalToLocal (&localWhere);								initem = FindDialogItem (theDialog, localWhere) + 1;				switch (initem)				{				case areaExports:										HandlePopUp (linksGroupSet);					result = false;					break;				}								SetPort (savePort);			}						break;		}				break;	}	return result;}static pascal Boolean groupFilter ( DialogPtr theDialog, EventRecord *theEvent, short *itemHit ){	Boolean 	result = false;	Point		localWhere = theEvent->where;	GrafPtr		savePort;	short		initem, part;	WindowPtr	window;	switch (theEvent->what)	{	case mouseDown:			switch ( part = FindWindow (theEvent->where, &window) )		{		case inContent:					if (window != FrontWindow())			{//				SelectWindow(window);				result = false;			}			else			{				GetPort (&savePort);				SetPort (theDialog);				GlobalToLocal (&localWhere);								initem = FindDialogItem (theDialog, localWhere) + 1;				switch (initem)				{				case groupExports:										HandlePopUp (linksGroupSet);					result = false;					break;				}								SetPort (savePort);			}						break;		}				break;	}	return result;}static pascal Boolean linkFilter ( DialogPtr theDialog, EventRecord *theEvent, short *itemHit ){	Boolean 	result = false;	Point		localWhere = theEvent->where;	GrafPtr		savePort;	short		initem, part, zzz;	WindowPtr	window;	switch (theEvent->what)	{	case mouseDown:			switch ( part = FindWindow (theEvent->where, &window) )		{		case inContent:					if (window != FrontWindow())			{//				SelectWindow(window);				result = false;			}			else			{				GetPort (&savePort);				SetPort (theDialog);				GlobalToLocal (&localWhere);								initem = FindDialogItem (theDialog, localWhere) + 1;				switch (initem)				{				case linkGroupsSet:										if (!HandlePopUp (linksGroupSet))					{						*itemHit = 0;						result = true;					}					break;									case linkEvent:									HandlePopUp (linksEventSet);					result = true;					break;				}								SetPort (savePort);			}						break;		}				break;	}	return result;}static Boolean ProcessOneLink (short currentItem){	DialogPtr	linxDlg;	short		iHit, defgrp, groups, markChar;	short		iType, i, j, dummy;	Handle		iHandle;	Rect		iRect, rDataBnds;	MenuHandle	mHandle;	Str255		temp, d;	ADDR		address;	long		lll;	addr		tempaddr;			linxDlg = GetNewDialog ( 500, NULL, (WindowPtr) -1L );	SetPort (linxDlg);	linksGroupSet = InitPopUp (linxDlg, 110, linkGroupsSet, 1, "\pGroups Set", FullGroupsMenu);	DrawPopUp (linksGroupSet);		linksEventSet = InitPopUp (linxDlg, 112, linkEvent, 1, "\pEvents", FullEventsMenu);	DrawPopUp (linksEventSet);		GetDialogItem ( linxDlg, linkUseAka, &iType, &iHandle, &iRect );	mHandle = ((popupPrivateData *)(*(*((ControlHandle) iHandle))->contrlData))->mHandle;		printaddr ( &(*homesystem)->mainAddr.ad, (char *) &temp[1] );	temp[0] = strlen ( (char *) &temp[1] );	AppendMenu ( mHandle, "\pdum" );	SetMenuItemText ( mHandle, 1, temp );	for ( i = 0; i < (*homesystem)->AKAcount; i++ )	{		printaddr ( &(*homesystem)->AKAAddr[i].ad, (char *) &temp[1] );		temp[0] = strlen ( (char *) &temp[1] );		AppendMenu ( mHandle, "\pdum" );		SetMenuItemText ( mHandle, i+2, temp );	}		SetControlMinimum ( (ControlHandle) iHandle, 1 );	SetControlMaximum ( (ControlHandle) iHandle, (*homesystem)->AKAcount + 1 );	ProcessLinkInitialization (linxDlg, currentItem);	do {			ModalDialog ( linkFilter, &iHit );		switch (iHit)		{		case linkEMSI:		case linkPackNetMail:		case linkAutoCreate:		case linkZedZip:		case linkZedZap:		case linkSEAlink:		case linkDirZap:		case linkJanus:		case linkHydra:		case linkxHydra:		case linkYooHoo:					GetDialogItem ( linxDlg, iHit, &iType, &iHandle, &iRect );			dummy = GetControlValue ( (ControlHandle) iHandle );			SetControlValue ( (ControlHandle) iHandle, !dummy );			break;				case linkGroupsSet:						ResyncDefGroupMenu (linxDlg);			break;		case linkOK:					//	node name						GetDialogItem ( linxDlg, linkName, &iType, &iHandle, &iRect );			GetDialogItemText ( iHandle, temp );						if (!temp[0])			{				SysBeep (10);				iHit = 0;				break;			}						//	node address			GetDialogItem ( linxDlg, linkAddress, &iType, &iHandle, &iRect );			GetDialogItemText ( iHandle, temp );			temp[temp[0]+1] = 0;						address.Zone = 0;			address.Net = 0;			address.Node = 0;			address.Point = 0;						find_addr ( (char *) &temp[1], &address, (char *) &d[1] );			if (address.Zone == 0 || address.Net == 0)			{				SysBeep (10);				iHit = 0;				break;			}			tempaddr.zone = address.Zone;			tempaddr.net = address.Net;			tempaddr.node = address.Node;			tempaddr.point = address.Point;						for (i=0; i<NodesNumber; i++)				if (i==currentItem)					continue;				else					if (cmp2addrs (&tempaddr, &(*nodesHndls[i])->Addr))						break;			if (i<NodesNumber)			{				SysBeep (10);				iHit = 0;				break;			}			//	arcmail pwd						GetDialogItem ( linxDlg, linkArcPwd, &iType, &iHandle, &iRect );			GetDialogItemText ( iHandle, temp );						if (temp[0]>8)			{				SysBeep (10);				iHit = 0;				break;			}						//	areafix pwd			GetDialogItem ( linxDlg, linkAFixPwd, &iType, &iHandle, &iRect );			GetDialogItemText ( iHandle, temp );			if (temp[0]>8)			{				SysBeep (10);				iHit = 0;				break;			}						//	session pwd			GetDialogItem ( linxDlg, linkSessPwd, &iType, &iHandle, &iRect );			GetDialogItemText ( iHandle, temp );			if (temp[0]>8)			{				SysBeep (10);				iHit = 0;				break;			}			break;		}	} while (iHit != linkOK && iHit != linkCancel);		if (iHit == linkOK)	{//	•	Greate OK? Hail eggs? Viva balls?					//	node name				GetDialogItem ( linxDlg, linkName, &iType, &iHandle, &iRect );		GetDialogItemText ( iHandle, (*nodesHndls[currentItem])->nodeName );				//	node phone				GetDialogItem ( linxDlg, linkPhone, &iType, &iHandle, &iRect );		GetDialogItemText ( iHandle, (*nodesHndls[currentItem])->nodePhone );				//	node address		(*nodesHndls[currentItem])->Addr.zone = address.Zone;		(*nodesHndls[currentItem])->Addr.net = address.Net;		(*nodesHndls[currentItem])->Addr.node = address.Node;		(*nodesHndls[currentItem])->Addr.point = address.Point;				//	arcmail pwd				GetDialogItem ( linxDlg, linkArcPwd, &iType, &iHandle, &iRect );		GetDialogItemText ( iHandle, temp );		temp[temp[0]+1] = 0;		strncpy ( (*nodesHndls[currentItem])->ArcMail_pwd, (char *) &temp[1], 8 );				//	areafix pwd		GetDialogItem ( linxDlg, linkAFixPwd, &iType, &iHandle, &iRect );		GetDialogItemText ( iHandle, temp );		temp[temp[0]+1] = 0;		strncpy ( (*nodesHndls[currentItem])->AreaFix_pwd, (char *) &temp[1], 8 );		//	session pwd		GetDialogItem ( linxDlg, linkSessPwd, &iType, &iHandle, &iRect );		GetDialogItemText ( iHandle, temp );		temp[temp[0]+1] = 0;		strncpy ( (*nodesHndls[currentItem])->Session_pwd, (char *) &temp[1], 8 );		if (commoninits[currentItem])		{			DisposePtr ((Ptr) commoninits[currentItem]);		}		GetDialogItem ( linxDlg, linkInit, &iType, &iHandle, &iRect );		GetDialogItemText ( iHandle, temp );				if (temp[0])		{			commoninits[currentItem] = (StringPtr) NewPtrClear (temp[0] + 2);			pStrCopy (temp, commoninits[currentItem]);		}		else			commoninits[currentItem] = NULL;		//	use aka				GetDialogItem ( linxDlg, linkUseAka, &iType, &iHandle, &iRect );		(*nodesHndls[currentItem])->yourAka = GetControlValue ( (ControlHandle) iHandle ) - 1;				//	use compressor				GetDialogItem ( linxDlg, linkCompressor, &iType, &iHandle, &iRect );		(*nodesHndls[currentItem])->Compressor = GetControlValue ( (ControlHandle) iHandle ) - 1;		//	poll type				GetDialogItem ( linxDlg, linkPollType, &iType, &iHandle, &iRect );		(*nodesHndls[currentItem])->Poll = GetControlValue ( (ControlHandle) iHandle ) - 1;			//	groups				GetDialogItem ( linxDlg, linkDefaultGroup, &iType, &iHandle, &iRect );		mHandle = ((popupPrivateData *)(*(*((ControlHandle) iHandle))->contrlData))->mHandle;				defgrp = GetControlValue ((ControlHandle) iHandle);		groups = CountMItems (mHandle);		SetHandleSize ( (Handle) nodesHndls[currentItem], sizeof (nodePrefType) + groups * sizeof (short) );		(*nodesHndls[currentItem])->GroupsNumber = groups;				iType = CountMItems ((**linksGroupSet).menuHdl);		j = 1;				if (groups > 1)			for (i=1; i<=iType;i++)			{				GetItemMark ((**linksGroupSet).menuHdl, i, &markChar);				if (markChar)				{					if (i != defgrp)						(*nodesHndls[currentItem])->group[j++] = i - 1;					else						(*nodesHndls[currentItem])->group[0] = i - 1;				}			}			else				if (groups == 1)					for (i=1; i<=iType;i++)					{						GetItemMark ((**linksGroupSet).menuHdl, i, &markChar);						if (markChar)						{							(*nodesHndls[currentItem])->group[0] = i - 1;							break;						}					}										//	events				(*nodesHndls[currentItem])->evt_mask = 0;		lll = 1L;		for (i=0; i<eventsNumber; i++)		{			GetItemMark ((**linksEventSet).menuHdl, i+1, &markChar);			if (markChar)				(*nodesHndls[currentItem])->evt_mask |= lll;			lll <<= 1;		}			//	flags				(*nodesHndls[currentItem])->nodeflags = 0L;				GetDialogItem ( linxDlg, linkEMSI, &iType, &iHandle, &iRect );		(*nodesHndls[currentItem])->nodeflags |= (GetControlValue ( (ControlHandle) iHandle)) ? NODE_NOEMSI : 0;			GetDialogItem ( linxDlg, linkYooHoo, &iType, &iHandle, &iRect );		(*nodesHndls[currentItem])->nodeflags |= (GetControlValue ( (ControlHandle) iHandle)) ? NODE_NOYOOHOO : 0;			GetDialogItem ( linxDlg, linkPackNetMail, &iType, &iHandle, &iRect );		(*nodesHndls[currentItem])->nodeflags |= (GetControlValue ( (ControlHandle) iHandle)) ? NODE_COMPRESSNETMAIL : 0;			GetDialogItem ( linxDlg, linkAutoCreate, &iType, &iHandle, &iRect );		(*nodesHndls[currentItem])->nodeflags |= (GetControlValue ( (ControlHandle) iHandle)) ? NODE_ALLOWAUTOCREATE : 0;		GetDialogItem ( linxDlg, linkSEAlink, &iType, &iHandle, &iRect );		(*nodesHndls[currentItem])->nodeflags |= (GetControlValue ( (ControlHandle) iHandle)) ? NODE_NOSEALINK : 0;		GetDialogItem ( linxDlg, linkZedZip, &iType, &iHandle, &iRect );		(*nodesHndls[currentItem])->nodeflags |= (GetControlValue ( (ControlHandle) iHandle)) ? NODE_NOZEDZIP : 0;		GetDialogItem ( linxDlg, linkZedZap, &iType, &iHandle, &iRect );		(*nodesHndls[currentItem])->nodeflags |= (GetControlValue ( (ControlHandle) iHandle)) ? NODE_NOZEDZAP : 0;		GetDialogItem ( linxDlg, linkDirZap, &iType, &iHandle, &iRect );		(*nodesHndls[currentItem])->nodeflags |= (GetControlValue ( (ControlHandle) iHandle)) ? NODE_NODIRZAP : 0;		GetDialogItem ( linxDlg, linkJanus, &iType, &iHandle, &iRect );		(*nodesHndls[currentItem])->nodeflags |= (GetControlValue ( (ControlHandle) iHandle)) ? NODE_NOJANUS : 0;		GetDialogItem ( linxDlg, linkHydra, &iType, &iHandle, &iRect );		(*nodesHndls[currentItem])->nodeflags |= (GetControlValue ( (ControlHandle) iHandle)) ? NODE_NOHYDRA : 0;		GetDialogItem ( linxDlg, linkxHydra, &iType, &iHandle, &iRect );		(*nodesHndls[currentItem])->nodeflags |= (GetControlValue ( (ControlHandle) iHandle)) ? NODE_NOXHYDRA : 0;	}		DisposePopUp (linksGroupSet);	DisposePopUp (linksEventSet);		DisposeDialog (linxDlg);		return (iHit == linkOK);}static Boolean ProcessOneArea (short currentItem){	DialogPtr	linxDlg;	short		iHit, links, markChar;	short		iType, i, j, dummy;	Handle		iHandle;	Rect		iRect, rDataBnds;	MenuHandle	mHandle;	Str255		temp, d;	ADDR		address;	long		lll;	addr		tempaddr;			linxDlg = GetNewDialog ( 501, NULL, (WindowPtr) -1L );	SetPort (linxDlg);	linksGroupSet = InitPopUp (linxDlg, 115, areaExports, 1, "\pExport-to", FullLinksMenu);	DrawPopUp (linksGroupSet);		iType = CountMItems ((*linksGroupSet)->menuHdl);		for (i=1; i<=iType;i++)		CheckItem ( (*linksGroupSet)->menuHdl, i, false );		for (i=0; i<(*areasHndls[currentItem])->numExports; i++)		CheckItem ( (*linksGroupSet)->menuHdl, (*areasHndls[currentItem])->Export[i].Export + 1, true );		GetDialogItem ( linxDlg, areaNam, &iType, &iHandle, &iRect );	SetDialogItemText ( iHandle, (*areasHndls[currentItem])->areaName );	GetDialogItem ( linxDlg, areaUseAKA, &iType, &iHandle, &iRect );	mHandle = ((popupPrivateData *)(*(*((ControlHandle) iHandle))->contrlData))->mHandle;		printaddr ( &(*homesystem)->mainAddr.ad, (char *) &temp[1] );	temp[0] = strlen ( (char *) &temp[1] );	AppendMenu ( mHandle, "\pdum" );	SetMenuItemText ( mHandle, 1, temp );	for ( i = 0; i < (*homesystem)->AKAcount; i++ )	{		printaddr ( &(*homesystem)->AKAAddr[i].ad, (char *) &temp[1] );		temp[0] = strlen ( (char *) &temp[1] );		AppendMenu ( mHandle, "\pdum" );		SetMenuItemText ( mHandle, i+2, temp );	}		SetControlMinimum ( (ControlHandle) iHandle, 1 );	SetControlMaximum ( (ControlHandle) iHandle, (*homesystem)->AKAcount + 1 );	SetControlValue ( (ControlHandle) iHandle, (*areasHndls[currentItem])->useAKA + 1 );	GetDialogItem ( linxDlg, areaGroup, &iType, &iHandle, &iRect );	mHandle = ((popupPrivateData *)(*(*((ControlHandle) iHandle))->contrlData))->mHandle;		for ( i = 0; i < GroupsNumber; i++ )	{		AppendMenu ( mHandle, "\pdum" );		SetMenuItemText ( mHandle, i+1, (*groupsHndls[i])->groupName );	}	SetControlMinimum ( (ControlHandle) iHandle, 1 );	SetControlMaximum ( (ControlHandle) iHandle, GroupsNumber );	SetControlValue ( (ControlHandle) iHandle, (*areasHndls[currentItem])->group + 1 );	GetDialogItem ( linxDlg, areaPurger, &iType, &iHandle, &iRect );	NumToString ((*areasHndls[currentItem])->purger, temp);	SetDialogItemText ( iHandle, temp );	GetDialogItem ( linxDlg, areaPass, &iType, &iHandle, &iRect );	SetControlValue ( (ControlHandle) iHandle, ((*areasHndls[currentItem])->areaflags & AREA_PASSTROUGH) != 0 );	do {			ModalDialog ( areaFilter, &iHit );		switch (iHit)		{		case areaPass:			GetDialogItem ( linxDlg, iHit, &iType, &iHandle, &iRect );			dummy = GetControlValue ( (ControlHandle) iHandle );			SetControlValue ( (ControlHandle) iHandle, !dummy );			break;				case areaOK:					//	area name						GetDialogItem ( linxDlg, areaNam, &iType, &iHandle, &iRect );			GetDialogItemText ( iHandle, temp );						if (!temp[0])			{				SysBeep (10);				iHit = 0;				break;			}						UprText ((char *) &temp[1], temp[0]);						for (i = 0; i < AreasNumber; i++ )				if (i == currentItem)					continue;				else					if (!pStrComp (temp, (*areasHndls[i])->areaName))						break;						if (i < AreasNumber)			{				SysBeep (10);				iHit = 0;				break;			}						GetDialogItem ( linxDlg, areaPurger, &iType, &iHandle, &iRect );			GetDialogItemText ( iHandle, temp );			StringToNum (temp, &lll);						if (!lll)			{				SysBeep (10);				iHit = 0;				break;			}						break;		}	} while (iHit != linkOK && iHit != linkCancel);		if (iHit == areaOK)	{//	•	Greate OK? Hail eggs? Viva balls?		GetDialogItem ( linxDlg, areaNam, &iType, &iHandle, &iRect );		GetDialogItemText ( iHandle, (*areasHndls[currentItem])->areaName );		UprText ((char *) &(*areasHndls[currentItem])->areaName[1], (*areasHndls[currentItem])->areaName[0]);				(*areasHndls[currentItem])->purger = lll;				(*areasHndls[currentItem])->areaflags = 0;				GetDialogItem ( linxDlg, areaPass, &iType, &iHandle, &iRect );		(*areasHndls[currentItem])->areaflags |= (GetControlValue ( (ControlHandle) iHandle )) ? AREA_PASSTROUGH : 0;		GetDialogItem ( linxDlg, areaUseAKA, &iType, &iHandle, &iRect );		(*areasHndls[currentItem])->useAKA = GetControlValue ( (ControlHandle) iHandle ) - 1;		iType = CountMItems ((**linksGroupSet).menuHdl);		SetHandleSize ( (Handle) areasHndls[currentItem], sizeof (areaPrefType) + iType * sizeof (ExpItem) );				j = 0;				for (i=1; i<=iType;i++)		{			GetItemMark ((**linksGroupSet).menuHdl, i, &markChar);			if (markChar)			{				(*areasHndls[currentItem])->Export[j].Diodes = 0;				(*areasHndls[currentItem])->Export[j++].Export = i - 1;			}		}		SetHandleSize ( (Handle) areasHndls[currentItem], sizeof (areaPrefType) + j * sizeof (ExpItem) );		(*areasHndls[currentItem])->numExports = j;		GetDialogItem ( linxDlg, areaGroup, &iType, &iHandle, &iRect );		(*areasHndls[currentItem])->group = GetControlValue ( (ControlHandle) iHandle ) - 1;				if ((*areasHndls[currentItem])->group < 0)			(*areasHndls[currentItem])->group = 0;	}		DisposePopUp (linksGroupSet);	DisposeDialog (linxDlg);		return (iHit == linkOK);}static Boolean ProcessOneGroup (short currentItem){	DialogPtr	linxDlg;	short		iHit, links, markChar;	short		iType, i, j, dummy;	Handle		iHandle;	Rect		iRect, rDataBnds;	MenuHandle	mHandle;	Str255		temp, d;	ADDR		address;	long		lll;	addr		tempaddr;			linxDlg = GetNewDialog ( 502, NULL, (WindowPtr) -1L );	SetPort (linxDlg);	linksGroupSet = InitPopUp (linxDlg, 115, groupExports, 1, "\pExport-to", FullLinksMenu);	DrawPopUp (linksGroupSet);		iType = CountMItems ((*linksGroupSet)->menuHdl);		for (i=1; i<=iType;i++)		CheckItem ( (*linksGroupSet)->menuHdl, i, false );		for (i=0; i<(*groupsHndls[currentItem])->numExports; i++)		CheckItem ( (*linksGroupSet)->menuHdl, (*groupsHndls[currentItem])->Export[i].Export + 1, true );		GetDialogItem ( linxDlg, groupNam, &iType, &iHandle, &iRect );	SetDialogItemText ( iHandle, (*groupsHndls[currentItem])->groupName );	GetDialogItem ( linxDlg, groupUseAKA, &iType, &iHandle, &iRect );	mHandle = ((popupPrivateData *)(*(*((ControlHandle) iHandle))->contrlData))->mHandle;		printaddr ( &(*homesystem)->mainAddr.ad, (char *) &temp[1] );	temp[0] = strlen ( (char *) &temp[1] );	AppendMenu ( mHandle, "\pdum" );	SetMenuItemText ( mHandle, 1, temp );	for ( i = 0; i < (*homesystem)->AKAcount; i++ )	{		printaddr ( &(*homesystem)->AKAAddr[i].ad, (char *) &temp[1] );		temp[0] = strlen ( (char *) &temp[1] );		AppendMenu ( mHandle, "\pdum" );		SetMenuItemText ( mHandle, i+2, temp );	}		SetControlMinimum ( (ControlHandle) iHandle, 1 );	SetControlMaximum ( (ControlHandle) iHandle, (*homesystem)->AKAcount + 1 );	SetControlValue ( (ControlHandle) iHandle, (*groupsHndls[currentItem])->useAKA + 1 );	GetDialogItem ( linxDlg, groupPurger, &iType, &iHandle, &iRect );	NumToString ((*groupsHndls[currentItem])->purger, temp);	SetDialogItemText ( iHandle, temp );	GetDialogItem ( linxDlg, groupPass, &iType, &iHandle, &iRect );	SetControlValue ( (ControlHandle) iHandle, ((*groupsHndls[currentItem])->areaflags & AREA_PASSTROUGH) != 0 );	do {			ModalDialog ( groupFilter, &iHit );		switch (iHit)		{		case groupPass:			GetDialogItem ( linxDlg, iHit, &iType, &iHandle, &iRect );			dummy = GetControlValue ( (ControlHandle) iHandle );			SetControlValue ( (ControlHandle) iHandle, !dummy );			break;				case areaOK:					//	area name						GetDialogItem ( linxDlg, groupNam, &iType, &iHandle, &iRect );			GetDialogItemText ( iHandle, temp );						if (!temp[0] || temp[0] > 31)			{				SysBeep (10);				iHit = 0;				break;			}						for (i = 0; i < GroupsNumber; i++ )				if (i == currentItem)					continue;				else					if (!pStrComp (temp, (*groupsHndls[i])->groupName))						break;						if (i < GroupsNumber)			{				SysBeep (10);				iHit = 0;				break;			}						GetDialogItem ( linxDlg, groupPurger, &iType, &iHandle, &iRect );			GetDialogItemText ( iHandle, temp );			StringToNum (temp, &lll);						if (!lll)			{				SysBeep (10);				iHit = 0;				break;			}						break;		}	} while (iHit != linkOK && iHit != linkCancel);		if (iHit == groupOK)	{//	•	Greate OK? Hail eggs? Viva balls?		GetDialogItem ( linxDlg, groupNam, &iType, &iHandle, &iRect );		GetDialogItemText ( iHandle, (*groupsHndls[currentItem])->groupName );				(*groupsHndls[currentItem])->purger = lll;				(*groupsHndls[currentItem])->areaflags = 0;				GetDialogItem ( linxDlg, groupPass, &iType, &iHandle, &iRect );		(*groupsHndls[currentItem])->areaflags |= (GetControlValue ( (ControlHandle) iHandle )) ? AREA_PASSTROUGH : 0;		GetDialogItem ( linxDlg, groupUseAKA, &iType, &iHandle, &iRect );		(*groupsHndls[currentItem])->useAKA = GetControlValue ( (ControlHandle) iHandle ) - 1;		iType = CountMItems ((**linksGroupSet).menuHdl);		SetHandleSize ( (Handle) groupsHndls[currentItem], sizeof (groupPrefType) + iType * sizeof (ExpItem) );				j = 0;				for (i=1; i<=iType;i++)		{			GetItemMark ((**linksGroupSet).menuHdl, i, &markChar);			if (markChar)			{				(*groupsHndls[currentItem])->Export[j].Diodes = 0;				(*groupsHndls[currentItem])->Export[j++].Export = i - 1;			}		}		SetHandleSize ( (Handle) groupsHndls[currentItem], sizeof (groupPrefType) + j * sizeof (ExpItem) );		(*groupsHndls[currentItem])->numExports = j;	}		DisposePopUp (linksGroupSet);	DisposeDialog (linxDlg);		return (iHit == linkOK);}static Boolean ProcessOneEvent (short currentItem){	DialogPtr	linxDlg;	short		iHit, links, markChar;	short		iType, i, j, dummy;	Handle		iHandle;	Rect		iRect, rDataBnds;	MenuHandle	mHandle;	Str255		temp, d;	ADDR		address;	long		lll;	addr		tempaddr;			linxDlg = GetNewDialog ( 503, NULL, (WindowPtr) -1L );	SetPort (linxDlg);	HLock ((Handle)eventsHndls[currentItem]);		for (i = 0; i < 7; i++)	{		print_time ( (*(*eventsHndls[currentItem]))[i].Start, temp );		GetDialogItem ( linxDlg, evtBaseFrom + i, &iType, &iHandle, &iRect );		SetDialogItemText ( iHandle, temp );		print_time ( (*(*eventsHndls[currentItem]))[i].End, temp );		GetDialogItem ( linxDlg, evtBaseTo + i, &iType, &iHandle, &iRect );		SetDialogItemText ( iHandle, temp );	}	do {			ModalDialog ( NULL, &iHit );//		switch (iHit)//		{//		case areaOK:////			break;//		}	} while (iHit != linkOK && iHit != linkCancel);		if (iHit == groupOK)	{		for (i = 0; i < 7; i++)		{			GetDialogItem ( linxDlg, evtBaseFrom + i, &iType, &iHandle, &iRect );			GetDialogItemText ( iHandle, temp );			scan_time ( &(*(*eventsHndls[currentItem]))[i].Start, temp );					GetDialogItem ( linxDlg, evtBaseTo + i, &iType, &iHandle, &iRect );			GetDialogItemText ( iHandle, temp );			scan_time ( &(*(*eventsHndls[currentItem]))[i].End, temp );				}	}		DisposeDialog (linxDlg);	HUnlock ((Handle)eventsHndls[currentItem]);	return (iHit == linkOK);}static Boolean ProcessOneEvtBehave (short currentItem){	DialogPtr	linxDlg;	short		iHit, links, markChar;	short		iType, i, j, dummy;	Handle		iHandle;	Rect		iRect, rDataBnds;	MenuHandle	mHandle;	Str255		temp, t;	ADDR		address;	long		lll;	addr		tempaddr;			linxDlg = GetNewDialog ( 504, NULL, (WindowPtr) -1L );	SetPort (linxDlg);	GetDialogItem (linxDlg, behavEvent, &iType, &iHandle, &iRect);	mHandle = ((popupPrivateData *)(*(*((ControlHandle) iHandle))->contrlData))->mHandle;		for ( i = 0; i < eventsNumber; i++ )	{		NumToString ( i+1, t );				pStrConc (t, "\p, ", t);				print_time ( (*(*eventsHndls[i]))[1].Start, temp );				pStrConc (t, temp, t);		pStrConc (t, "\p - ", t);		print_time ( (*(*eventsHndls[i]))[1].End, temp );		pStrConc (t, temp, t);		AppendMenu ( mHandle, "\pdum" );		SetMenuItemText ( mHandle, i+1, t );	}		SetControlMinimum ( (ControlHandle) iHandle, 1 );	SetControlMaximum ( (ControlHandle) iHandle, eventsNumber );	SetControlValue ( (ControlHandle) iHandle, (*behavior)->behavior[currentItem].evtNum + 1 );	GetDialogItem (linxDlg, behavAction, &iType, &iHandle, &iRect);	SetControlValue ( (ControlHandle) iHandle, (*behavior)->behavior[currentItem].mode + 1 );	GetDialogItem (linxDlg, behavLink, &iType, &iHandle, &iRect);	mHandle = ((popupPrivateData *)(*(*((ControlHandle) iHandle))->contrlData))->mHandle;		for ( i = 0; i < NodesNumber; i++ )	{		printaddr ( &(*nodesHndls[i])->Addr, (char *) &temp[1] );		temp[0] = strlen ( (char *) &temp[1] );		AppendMenu ( mHandle, "\pdum" );		SetMenuItemText ( mHandle, i+1, temp );	}		SetControlMinimum ( (ControlHandle) iHandle, 1 );	SetControlMaximum ( (ControlHandle) iHandle, NodesNumber );	SetControlValue ( (ControlHandle) iHandle, (*behavior)->behavior[currentItem].nodeNum + 1 );	if ((*behavior)->behavior[currentItem].mode != 1)		//	create only affect		HiliteControl ((ControlHandle) iHandle, 255);		if ((*behavior)->behavior[currentItem].mode != 2)		//	launch only affect		(*behavior)->behavior[currentItem].cmd[0] = 0;		GetDialogItem (linxDlg, behavCommand, &iType, &iHandle, &iRect);	strcpy ((char *) &temp[1], (*behavior)->behavior[currentItem].cmd);	temp[0] = strlen ((char *) &temp[1]);	SetDialogItemText (iHandle, temp);	do {			ModalDialog ( NULL, &iHit );		switch (iHit)		{		case areaOK:			GetDialogItem (linxDlg, behavAction, &iType, &iHandle, &iRect);			dummy = GetControlValue ( (ControlHandle) iHandle ) - 1;						if (dummy == 2)		//	sublaunch			{				GetDialogItem (linxDlg, behavCommand, &iType, &iHandle, &iRect);				GetDialogItemText (iHandle, temp);				if (!temp[0] || temp[0] > 8)				{					SysBeep (10);					iHit = -1;				}			}						break;					case behavAction:					GetDialogItem (linxDlg, behavAction, &iType, &iHandle, &iRect);			dummy = GetControlValue ( (ControlHandle) iHandle ) - 1;						GetDialogItem (linxDlg, behavLink, &iType, &iHandle, &iRect);			HiliteControl ((ControlHandle) iHandle, (dummy != 1) ? 255 : 0);				break;		}	} while (iHit != linkOK && iHit != linkCancel);		if (iHit == groupOK)	{		GetDialogItem (linxDlg, behavEvent, &iType, &iHandle, &iRect);		(*behavior)->behavior[currentItem].evtNum = GetControlValue ( (ControlHandle) iHandle ) - 1;					GetDialogItem (linxDlg, behavAction, &iType, &iHandle, &iRect);		(*behavior)->behavior[currentItem].mode = GetControlValue ( (ControlHandle) iHandle ) - 1;					GetDialogItem (linxDlg, behavLink, &iType, &iHandle, &iRect);		(*behavior)->behavior[currentItem].nodeNum = GetControlValue ( (ControlHandle) iHandle )  - 1;		if ((*behavior)->behavior[currentItem].mode == 2)		//	sublaunch		{			GetDialogItem (linxDlg, behavCommand, &iType, &iHandle, &iRect);			GetDialogItemText (iHandle, temp);			temp[temp[0]+1] = 0;			strcpy ((*behavior)->behavior[currentItem].cmd, (char *) &temp[1]);		}	}		DisposeDialog (linxDlg);		return (iHit == linkOK);}static Boolean cmp2mask (addr *ad1, addr *ad2){	if ((unsigned short) ad1->zone != (unsigned short) ad2->zone)		return (unsigned short) ad1->zone > (unsigned short) ad2->zone;	if ((unsigned short) ad1->net != (unsigned short) ad2->net)		return (unsigned short) ad1->net > (unsigned short) ad2->net;	if ((unsigned short) ad1->node != (unsigned short) ad2->node)		return (unsigned short) ad1->node > (unsigned short) ad2->node;	if ((unsigned short) ad1->point != (unsigned short) ad2->point)		return (unsigned short) ad1->point > (unsigned short) ad2->point;	return false;}static Boolean ProcessOneRoute (short currentItem){	DialogPtr	linxDlg;	short		iHit, links, markChar;	short		iType, i, j, dummy;	Handle		iHandle;	Rect		iRect, rDataBnds;	MenuHandle	mHandle;	Str255		temp, d;	ADDR		address;	long		lll;	addr		tempaddr;	routeType	t_r;			linxDlg = GetNewDialog ( 505, NULL, (WindowPtr) -1L );	SetPort (linxDlg);	GetDialogItem (linxDlg, routeTo, &iType, &iHandle, &iRect);	mHandle = ((popupPrivateData *)(*(*((ControlHandle) iHandle))->contrlData))->mHandle;	for ( i = 0; i < NodesNumber; i++ )	{		printaddr ( &(*nodesHndls[i])->Addr, (char *) &temp[1] );		temp[0] = strlen ( (char *) &temp[1] );		AppendMenu ( mHandle, "\pdum" );		SetMenuItemText ( mHandle, i+1, temp );	}	SetControlMinimum ( (ControlHandle) iHandle, 1 );	SetControlMaximum ( (ControlHandle) iHandle, NodesNumber );	SetControlValue ( (ControlHandle) iHandle, (*Routing)->route[currentItem].node + 1 );	if ((*Routing)->route[currentItem].mask.zone == -1)		temp[0] = 0;	else		NumToString ((*Routing)->route[currentItem].mask.zone, temp);	GetDialogItem (linxDlg, routeZone, &iType, &iHandle, &iRect);	SetDialogItemText (iHandle, temp);	if ((*Routing)->route[currentItem].mask.net == -1)		temp[0] = 0;	else		NumToString ((*Routing)->route[currentItem].mask.net, temp);	GetDialogItem (linxDlg, routeNet, &iType, &iHandle, &iRect);	SetDialogItemText (iHandle, temp);	if ((*Routing)->route[currentItem].mask.node == -1)		temp[0] = 0;	else		NumToString ((*Routing)->route[currentItem].mask.node, temp);	GetDialogItem (linxDlg, routeNode, &iType, &iHandle, &iRect);	SetDialogItemText (iHandle, temp);	if ((*Routing)->route[currentItem].mask.point == -1)		temp[0] = 0;	else		NumToString ((*Routing)->route[currentItem].mask.point, temp);	GetDialogItem (linxDlg, routePoint, &iType, &iHandle, &iRect);	SetDialogItemText (iHandle, temp);	do {			ModalDialog ( NULL, &iHit );//		switch (iHit)//		{//		case areaOK:////			break;//			//		}	} while (iHit != linkOK && iHit != linkCancel);		if (iHit == groupOK)	{		GetDialogItem (linxDlg, routeTo, &iType, &iHandle, &iRect);		(*Routing)->route[currentItem].node = GetControlValue ( (ControlHandle) iHandle )  - 1;		GetDialogItem (linxDlg, routeZone, &iType, &iHandle, &iRect);		GetDialogItemText (iHandle, temp);		if (temp[0])		{			StringToNum (temp, &lll);			(*Routing)->route[currentItem].mask.zone = lll;		}		else			(*Routing)->route[currentItem].mask.zone = -1;		GetDialogItem (linxDlg, routeNet, &iType, &iHandle, &iRect);		GetDialogItemText (iHandle, temp);		if (temp[0])		{			StringToNum (temp, &lll);			(*Routing)->route[currentItem].mask.net = lll;		}		else			(*Routing)->route[currentItem].mask.net = -1;		GetDialogItem (linxDlg, routeNode, &iType, &iHandle, &iRect);		GetDialogItemText (iHandle, temp);		if (temp[0])		{			StringToNum (temp, &lll);			(*Routing)->route[currentItem].mask.node = lll;		}		else			(*Routing)->route[currentItem].mask.node = -1;		GetDialogItem (linxDlg, routePoint, &iType, &iHandle, &iRect);		GetDialogItemText (iHandle, temp);		if (temp[0])		{			StringToNum (temp, &lll);			(*Routing)->route[currentItem].mask.point = lll;		}		else			(*Routing)->route[currentItem].mask.point = -1;					for (i = 0; i < (*Routing)->routes - 1; i++)			for (j = 0; j < (*Routing)->routes - 1; j++)				if (cmp2mask (&(*Routing)->route[j].mask, &(*Routing)->route[j+1].mask))				{					t_r = (*Routing)->route[j+1];					(*Routing)->route[j+1] = (*Routing)->route[j];					(*Routing)->route[j] = t_r;				}	}		DisposeDialog (linxDlg);		return (iHit == linkOK);}static short pos2cell (short pos, Rect *lRect, Rect *bRect, short cHeight){	return bRect->top + ((pos - lRect->top) / cHeight);}static Boolean myLClicker (void){	Boolean		res;	Point		where;	Rect		iRect, lRect, bRect;	short		cHeight, cpos;	Cell		theCell, oCell;	PenState	penState;	unsigned char	oldMode = LMGetHiliteMode();	long		finished;		GetPenState (&penState);	PenMode (srcXor);//	Debugger ();	if (!semaphore)	{		semaphore = true;		res = true;	}	else	{		oCell = theCell = LLastClick (linkList);		LRect (&iRect, theCell, linkList);		cpos = -1;				while (StillDown ())		{			GetMouse (&where);			if (PtInRect (where, &(*linkList)->rView))			{				if (!PtInRect (where, &iRect))				{					cpos = pos2cell (where.v, &(*linkList)->rView, &(*linkList)->visible, (*linkList)->cellSize.v);									if (cpos >= (*linkList)->dataBounds.top && cpos < (*linkList)->dataBounds.bottom)					{						if (oCell.v != theCell.v)						{							LMSetHiliteMode (1);							FrameRect (&iRect);						}												SetPt (&theCell, 0, cpos);						LRect (&iRect, theCell, linkList);												if (oCell.v != theCell.v)						{							LMSetHiliteMode (1);							FrameRect (&iRect);						}					}				}			}			else			{				lRect = (*linkList)->rView;				lRect.top -= (*linkList)->cellSize.v;				lRect.bottom += (*linkList)->cellSize.v;//				lRect.top = -32768;//				lRect.bottom = 32767;								if (PtInRect (where, &lRect))				{					cpos = pos2cell (where.v, &(*linkList)->rView, &(*linkList)->visible, (*linkList)->cellSize.v);										if (cpos > (*linkList)->dataBounds.top && cpos < (*linkList)->dataBounds.bottom)					{						if (cpos == theCell.v)							cpos -= 1;												SetPenState (&penState);						LMSetHiliteMode(oldMode);						LScroll (0, cpos - theCell.v, linkList);											PenMode (srcXor);												LRect (&iRect, theCell, linkList);						if (oCell.v != theCell.v)						{							LMSetHiliteMode (1);							FrameRect (&iRect);						}												SetPt (&theCell, 0, cpos);						LRect (&iRect, theCell, linkList);												if (oCell.v != theCell.v)						{							LMSetHiliteMode (1);							FrameRect (&iRect);						}					}				}			}		}				if (oCell.v != theCell.v)		{			LMSetHiliteMode (1);			FrameRect (&iRect);		}//		theCell = LLastClick (linkList);		LRect (&iRect, oCell, linkList);//		if (oCell.v != theCell.v)		if (oCell.v != theCell.v && PtInRect (topLeft(iRect), &(*linkList)->rView))		{			LMSetHiliteMode (1);			FrameRect (&iRect);		}		if (oCell.v != theCell.v)			wasmove = theCell.v;				res = false;	}	SetPenState (&penState);	LMSetHiliteMode(oldMode);		return res;}asm static pascal void myLClick (void){	jsr		myLClicker	tst.b	d0	rts}static ListAndPopUpConstructor ( DialogPtr theDialog ){	short		pane = (((DialogPeek)theDialog)->window.refCon) & 0xFFFF;	short		item = (((DialogPeek)theDialog)->window.refCon) >> 16;	short		iType, i, dummy;	Handle		iHandle;	Rect		iRect, rDataBnds;	Point		cellSize, theCell;	Str255		temp;	Str255		tmp;	MenuHandle	mHandle;	long		lll;		switch (pane)	{	case paneSystem:				//	System setup: AKA list present				GetDialogItem ( theDialog, item + sysName, &iType, &iHandle, &iRect );		SetDialogItemText ( iHandle, (*homesystem)->system );		GetDialogItem ( theDialog, item + sysSysOp, &iType, &iHandle, &iRect );		SetDialogItemText ( iHandle, (*homesystem)->sysop );		printaddr ( &(*homesystem)->mainAddr.ad, (char *) &temp[1] );		temp[0] = strlen ((char *) &temp[1]);				if ((*homesystem)->mainAddr.domain[0])		{			pStrConc ( temp, "\p@", temp );			pStrConc ( temp, (*homesystem)->mainAddr.domain, temp );		}				GetDialogItem ( theDialog, item + sysMainAddr, &iType, &iHandle, &iRect );		SetDialogItemText ( iHandle, temp );		GetDialogItem ( theDialog, item + sysAkaList, &iType, &iHandle, &iRect );		SetRect ( &rDataBnds, 0, 0, 1, 0 );		iRect.right -= 15;		SetPt ( &cellSize, 0, 0 );		akaList = LNew ( &iRect, &rDataBnds, cellSize, 0, theDialog, true, false, false, true );		InsetRect (&iRect, -1, -1);		FrameRect (&iRect);				(*akaList)->selFlags = 0x82;				LSetDrawingMode (false, akaList);		for (i = 0; i < (*homesystem)->AKAcount; i++)		{			printaddr ( &(*homesystem)->AKAAddr[i].ad, (char *) &temp[1] );			temp[0] = strlen ((char *) &temp[1]);			if ((*homesystem)->AKAAddr[i].domain[0])			{				pStrConc ( temp, "\p@", temp );				pStrConc ( temp, (*homesystem)->AKAAddr[i].domain, temp );			}						dummy = LAddRow ( 1, 0x7FFF, akaList );			SetPt ( &theCell, 0, dummy );			LSetCell ( &temp[1], temp[0], theCell, akaList );			}				LSetDrawingMode (true, akaList);		LUpdate (theDialog->visRgn, akaList);				break;		case panePath:			GetDialogItem ( theDialog, item + pathBundle, &iType, &iHandle, &iRect );		SetDialogItemText ( iHandle, workPath );		GetDialogItem ( theDialog, item + pathTemp, &iType, &iHandle, &iRect );		SetDialogItemText ( iHandle, tempPath );		GetDialogItem ( theDialog, item + pathIbound, &iType, &iHandle, &iRect );		SetDialogItemText ( iHandle, inboundPath );		GetDialogItem ( theDialog, item + pathOutbound, &iType, &iHandle, &iRect );		SetDialogItemText ( iHandle, outboundPath );		GetDialogItem ( theDialog, item + pathBase, &iType, &iHandle, &iRect );		SetDialogItemText ( iHandle, basePath );		GetDialogItem ( theDialog, item + pathNodelist, &iType, &iHandle, &iRect );		SetDialogItemText ( iHandle, Pathes[6] );		GetDialogItem ( theDialog, item + pathLogFile, &iType, &iHandle, &iRect );		SetDialogItemText ( iHandle, logPath );		GetDialogItem ( theDialog, item + pathFreq, &iType, &iHandle, &iRect );		SetDialogItemText ( iHandle, Pathes[7] );		break;			case paneComm:			for (i = 0; i < 12; i++)			if ( (*comm_pref)->baud == bauds[i] )				break;				if (i == 12)			i = 0;					i++;				GetDialogItem ( theDialog, item + commBaud, &iType, &iHandle, &iRect );		SetControlValue ( (ControlHandle) iHandle, i );		for (i = 0; i < 3; i++)			if ( (*comm_pref)->stop == stops[i] )				break;				if (i == 3)			i = 0;					i++;				GetDialogItem ( theDialog, item + commStops, &iType, &iHandle, &iRect );		SetControlValue ( (ControlHandle) iHandle, i );				for (i = 0; i < 3; i++)			if ( (*comm_pref)->parity == parities[i] )				break;				if (i == 3)			i = 0;					i++;				GetDialogItem ( theDialog, item + commParity, &iType, &iHandle, &iRect );		SetControlValue ( (ControlHandle) iHandle, i );		for (i = 0; i < 4; i++)			if ( (*comm_pref)->data == datas[i] )				break;				if (i == 4)			i = 0;					i++;				GetDialogItem ( theDialog, item + commData, &iType, &iHandle, &iRect );		SetControlValue ( (ControlHandle) iHandle, i );						GetDialogItem ( theDialog, item + commHSK, &iType, &iHandle, &iRect );		SetControlValue ( (ControlHandle) iHandle, ((*comm_pref)->hanshake & 0xFF) + 1 );				GetDialogItem ( theDialog, item + commLockPort, &iType, &iHandle, &iRect );		SetControlValue ( (ControlHandle) iHandle, ((*comm_pref)->hanshake & 0x0F00) ? 1 : 0 );				GetDialogItem ( theDialog, item + commTone, &iType, &iHandle, &iRect );		SetControlValue ( (ControlHandle) iHandle, ((*comm_pref)->hanshake & 0xF000) ? 1 : 0 );				GetDialogItem ( theDialog, item + commDCD, &iType, &iHandle, &iRect );		SetControlValue ( (ControlHandle) iHandle, ((*comm_pref)->isdcd) ? 1 : 0 );				i = (pStrComp ((*comm_pref)->port_name, "\pModem Port")) ? 2 : 1;		GetDialogItem ( theDialog, item + commPort, &iType, &iHandle, &iRect );		SetControlValue ( (ControlHandle) iHandle, i );				GetDialogItem ( theDialog, item + commInitString, &iType, &iHandle, &iRect );		SetDialogItemText ( iHandle, mdmInitStr );				break;		case paneEMSI:				GetDialogItem ( theDialog, item + emsiLoc, &iType, &iHandle, &iRect );		SetDialogItemText ( iHandle, (*homesystem)->location );		GetDialogItem ( theDialog, item + emsiPhone, &iType, &iHandle, &iRect );		SetDialogItemText ( iHandle, (*homesystem)->phone );		GetDialogItem ( theDialog, item + emsiBaud, &iType, &iHandle, &iRect );		SetDialogItemText ( iHandle, (*homesystem)->baud );		GetDialogItem ( theDialog, item + emsiFlags, &iType, &iHandle, &iRect );		SetDialogItemText ( iHandle, (*homesystem)->emsi_flags );		break;	case paneSession:		GetDialogItem ( theDialog, item + sessNoSEALink, &iType, &iHandle, &iRect );		SetControlValue ( (ControlHandle) iHandle, (*ftsc)->no_sealink );		GetDialogItem ( theDialog, item + sessLog, &iType, &iHandle, &iRect );		SetControlValue ( (ControlHandle) iHandle, (*wazoo)->paranoidal_log );		GetDialogItem ( theDialog, item + sessZedZip, &iType, &iHandle, &iRect );		SetControlValue ( (ControlHandle) iHandle, (*wazoo)->zedzip );		GetDialogItem ( theDialog, item + sessZedZap, &iType, &iHandle, &iRect );		SetControlValue ( (ControlHandle) iHandle, (*wazoo)->zedzap );		GetDialogItem ( theDialog, item + sessDirZap, &iType, &iHandle, &iRect );		SetControlValue ( (ControlHandle) iHandle, (*wazoo)->dirzap );		GetDialogItem ( theDialog, item + sessJanus, &iType, &iHandle, &iRect );		SetControlValue ( (ControlHandle) iHandle, (*wazoo)->janus );				GetDialogItem ( theDialog, item + sessHydra, &iType, &iHandle, &iRect );		SetControlValue ( (ControlHandle) iHandle, (*wazoo)->hydra );				GetDialogItem ( theDialog, item + sessxHydra, &iType, &iHandle, &iRect );		SetControlValue ( (ControlHandle) iHandle, (*ftsc)->xhydra );				GetDialogItem ( theDialog, item + sessEMSI, &iType, &iHandle, &iRect );		SetControlValue ( (ControlHandle) iHandle, (*comm_pref)->disableEMSI );		GetDialogItem ( theDialog, item + sessWaZoo, &iType, &iHandle, &iRect );		SetControlValue ( (ControlHandle) iHandle, (*comm_pref)->disableWaZOO );				NumToString ((*wazoo)->slice, temp);		GetDialogItem ( theDialog, item + sessDelay, &iType, &iHandle, &iRect );		SetDialogItemText (iHandle, temp);				NumToString ((*wazoo)->force_slice, temp);		GetDialogItem ( theDialog, item + sessDelayForce, &iType, &iHandle, &iRect );		SetDialogItemText (iHandle, temp);		NumToString ((*ftsc)->min_baud, temp);		GetDialogItem ( theDialog, item + sessMinBaud, &iType, &iHandle, &iRect );		SetDialogItemText (iHandle, temp);				NumToString ((*wazoo)->badcount, temp);		GetDialogItem ( theDialog, item + sessBads, &iType, &iHandle, &iRect );		SetDialogItemText (iHandle, temp);				//	events			canCall = InitPopUp (theDialog, 110, item + sessCanIssue, 1, "\pEvents", FullEventsMenu);		DrawPopUp (canCall);			lll = 1L;		for (i=0; i<eventsNumber; i++)		{			CheckItem ( (*canCall)->menuHdl, i + 1, ((*wazoo)->issue_calls_mask & lll) != 0 );			lll <<= 1;		}		canAccept = InitPopUp (theDialog, 111, item + sessCanAccept, 1, "\pEvents", FullEventsMenu);		DrawPopUp (canAccept);			lll = 1L;		for (i=0; i<eventsNumber; i++)		{			CheckItem ( (*canAccept)->menuHdl, i + 1, ((*wazoo)->accept_calls_mask & lll) != 0 );			lll <<= 1;		}		canFreq = InitPopUp (theDialog, 112, item + sessCanFreq, 1, "\pEvents", FullEventsMenu);		DrawPopUp (canFreq);			lll = 1L;		for (i=0; i<eventsNumber; i++)		{			CheckItem ( (*canFreq)->menuHdl, i + 1, ((*wazoo)->accept_freqs_mask & lll) != 0 );			lll <<= 1;		}				break;	case paneShufle:		GetDialogItem ( theDialog, item + shflSCAN, &iType, &iHandle, &iRect );		SetControlValue ( (ControlHandle) iHandle, (*comm_pref)->auto_scan );		GetDialogItem ( theDialog, item + shflTOSS, &iType, &iHandle, &iRect );		SetControlValue ( (ControlHandle) iHandle, (*comm_pref)->auto_toss );		switch ((*shufle)->Type2)		{		case 0x0000:	i = shflType1;	break;		case 0x0200:	i = shflType2;	break;		case 0x0201:	i = shflTypeQ;	break;		case 0x02FF:	i = shflType2p;	break;		case 0x0220:	i = shflType22;	break;		default:		i = shflType2;	break;		}		GetDialogItem ( theDialog, item + i, &iType, &iHandle, &iRect );		SetControlValue ( (ControlHandle) iHandle, 1 );		GetDialogItem ( theDialog, item + shflTimeZone, &iType, &iHandle, &iRect );		if ((*shufle)->TimeZone == 'TZ')		{			MachineLocation		loc;					ReadLocation (&loc);					lll = loc.u.gmtDelta & 0x00FFFFFFL;						if (loc.u.gmtDelta & 0x00010000L)				lll |= 0xFF000000L;			lll = lll / 3600L;			if (loc.u.dlsDelta < 0)				lll--;			NumToString ( lll, temp );		}		else			NumToString ( (*shufle)->TimeZone, temp );		SetDialogItemText ( iHandle, temp );				GetDialogItem ( theDialog, item + shflSysTimeZone, &iType, &iHandle, &iRect );		SetControlValue ( (ControlHandle) iHandle, ((*shufle)->TimeZone == 'TZ') );				GetDialogItem ( theDialog, item + shflRealName, &iType, &iHandle, &iRect );		SetDialogItemText ( iHandle, RealName );		GetDialogItem ( theDialog, item + shflPathName, &iType, &iHandle, &iRect );		SetDialogItemText ( iHandle, ShufflerPathName );		GetDialogItem ( theDialog, item + shflMaxSize, &iType, &iHandle, &iRect );		NumToString ( (*shufle)->maxarcsize, temp );		SetDialogItemText ( iHandle, temp );		break;		case paneLinx:				GetDialogItem ( theDialog, item + linxList, &iType, &iHandle, &iRect );		SetRect ( &rDataBnds, 0, 0, 1, 0 );		iRect.right -= 15;		SetPt ( &cellSize, 0, 0 );		linkList = LNew ( &iRect, &rDataBnds, cellSize, 0, theDialog, true, false, false, true );		InsetRect (&iRect, -1, -1);		FrameRect (&iRect);				(*linkList)->selFlags = 0x82;		LSetDrawingMode (false, linkList);				for (i = 0; i < NodesNumber; i++)		{			printaddr ( &(*nodesHndls[i])->Addr, (char *) &temp[1] );			temp[0] = strlen ((char *) &temp[1]);			pStrCopy ((*nodesHndls[i])->nodeName, tmp);			pStrConc (tmp, "\p (", tmp);			pStrConc (tmp, temp, tmp);			pStrConc (tmp, "\p)", tmp);						dummy = LAddRow ( 1, 0x7FFF, linkList );			SetPt ( &theCell, 0, dummy );			LSetCell ( &tmp[1], tmp[0], theCell, linkList );			}		LSetDrawingMode (true, linkList);		LUpdate (theDialog->visRgn, linkList);		break;	case paneAreas:				GetDialogItem ( theDialog, item + areasList, &iType, &iHandle, &iRect );		SetRect ( &rDataBnds, 0, 0, 1, 0 );		iRect.right -= 15;		SetPt ( &cellSize, 0, 0 );		linkList = LNew ( &iRect, &rDataBnds, cellSize, 0, theDialog, true, false, false, true );		InsetRect (&iRect, -1, -1);		FrameRect (&iRect);				(*linkList)->selFlags = 0x82;		(*linkList)->lClickLoop = myLClick;				LSetDrawingMode (false, linkList);		for (i = 0; i < AreasNumber; i++)		{			dummy = LAddRow ( 1, 0x7FFF, linkList );			SetPt ( &theCell, 0, dummy );			LSetCell ( &(*areasHndls[i])->areaName[1], (*areasHndls[i])->areaName[0], theCell, linkList );			}		LSetDrawingMode (true, linkList);		LUpdate (theDialog->visRgn, linkList);		break;	case paneGroups:				GetDialogItem ( theDialog, item + areasList, &iType, &iHandle, &iRect );		SetRect ( &rDataBnds, 0, 0, 1, 0 );		iRect.right -= 15;		SetPt ( &cellSize, 0, 0 );		linkList = LNew ( &iRect, &rDataBnds, cellSize, 0, theDialog, true, false, false, true );		InsetRect (&iRect, -1, -1);		FrameRect (&iRect);				(*linkList)->selFlags = 0x82;		LSetDrawingMode (false, linkList);		for (i = 0; i < GroupsNumber; i++)		{			dummy = LAddRow ( 1, 0x7FFF, linkList );			SetPt ( &theCell, 0, dummy );			LSetCell ( &(*groupsHndls[i])->groupName[1], (*groupsHndls[i])->groupName[0], theCell, linkList );			}		LSetDrawingMode (true, linkList);		LUpdate (theDialog->visRgn, linkList);		break;	case paneEvents:				GetDialogItem ( theDialog, item + areasList, &iType, &iHandle, &iRect );		SetRect ( &rDataBnds, 0, 0, 1, 0 );		iRect.right -= 15;		SetPt ( &cellSize, 0, 0 );		linkList = LNew ( &iRect, &rDataBnds, cellSize, 0, theDialog, true, false, false, true );		InsetRect (&iRect, -1, -1);		FrameRect (&iRect);				(*linkList)->selFlags = 0x82;		LSetDrawingMode (false, linkList);		for ( i = 0; i < eventsNumber; i++ )		{			NumToString ( i+1, tmp );						pStrConc (tmp, "\p, Mo: ", tmp);						print_time ( (*(*eventsHndls[i]))[1].Start, temp );						pStrConc (tmp, temp, tmp);			pStrConc (tmp, "\p - ", tmp);			print_time ( (*(*eventsHndls[i]))[1].End, temp );			pStrConc (tmp, temp, tmp);			pStrConc (tmp, "\p, Su: ", tmp);						print_time ( (*(*eventsHndls[i]))[0].Start, temp );						pStrConc (tmp, temp, tmp);			pStrConc (tmp, "\p - ", tmp);			print_time ( (*(*eventsHndls[i]))[0].End, temp );			pStrConc (tmp, temp, tmp);			dummy = LAddRow ( 1, 0x7FFF, linkList );			SetPt ( &theCell, 0, dummy );			LSetCell ( &tmp[1], tmp[0], theCell, linkList );			}			LSetDrawingMode (true, linkList);		LUpdate (theDialog->visRgn, linkList);		break;	case paneEvtBehave:				GetDialogItem ( theDialog, item + areasList, &iType, &iHandle, &iRect );		SetRect ( &rDataBnds, 0, 0, 1, 0 );		iRect.right -= 15;		SetPt ( &cellSize, 0, 0 );		linkList = LNew ( &iRect, &rDataBnds, cellSize, 0, theDialog, true, false, false, true );		InsetRect (&iRect, -1, -1);		FrameRect (&iRect);				(*linkList)->selFlags = 0x82;		LSetDrawingMode (false, linkList);		for (i = 0; i < (*behavior)->countOfBehave; i++)		{			NumToString ( i+1, tmp );						pStrConc (tmp, "\p, ", tmp);						print_time ( (*(*eventsHndls[(*behavior)->behavior[i].evtNum]))[1].Start, temp );						pStrConc (tmp, temp, tmp);			pStrConc (tmp, "\p - ", tmp);			print_time ( (*(*eventsHndls[(*behavior)->behavior[i].evtNum]))[1].End, temp );			pStrConc (tmp, temp, tmp);			pStrConc (tmp, "\p [", tmp);			switch ((*behavior)->behavior[i].mode)			{			case 0:							pStrConc (tmp, "\pShutDown Mailer", tmp);				break;			case 1:				pStrConc (tmp, "\pPoll ", tmp);				break;			case 2:				pStrConc (tmp, "\pSublaunch", tmp);				break;			}			pStrConc (tmp, "\p]", tmp);			dummy = LAddRow ( 1, 0x7FFF, linkList );			SetPt ( &theCell, 0, dummy );			LSetCell ( &tmp[1], tmp[0], theCell, linkList );			}			LSetDrawingMode (true, linkList);		LUpdate (theDialog->visRgn, linkList);		break;	case paneNetMail:		GetDialogItem ( theDialog, item + netmailPurge, &iType, &iHandle, &iRect );		NumToString ((*mailHndl)->purger, temp);		SetDialogItemText (iHandle, temp);				GetDialogItem ( theDialog, item + netmailUseAKA, &iType, &iHandle, &iRect );		mHandle = ((popupPrivateData *)(*(*((ControlHandle) iHandle))->contrlData))->mHandle;				printaddr ( &(*homesystem)->mainAddr.ad, (char *) &temp[1] );		temp[0] = strlen ( (char *) &temp[1] );		AppendMenu ( mHandle, "\pdum" );		SetMenuItemText ( mHandle, 1, temp );		for ( i = 0; i < (*homesystem)->AKAcount; i++ )		{			printaddr ( &(*homesystem)->AKAAddr[i].ad, (char *) &temp[1] );			temp[0] = strlen ( (char *) &temp[1] );			AppendMenu ( mHandle, "\pdum" );			SetMenuItemText ( mHandle, i+2, temp );		}				SetControlMinimum ( (ControlHandle) iHandle, 1 );		SetControlMaximum ( (ControlHandle) iHandle, (*homesystem)->AKAcount + 1 );		SetControlValue ( (ControlHandle) iHandle, (*mailHndl)->useAKA + 1 );		break;			case paneRouting:		GetDialogItem ( theDialog, item + areasList, &iType, &iHandle, &iRect );				SetRect ( &rDataBnds, 0, 0, 1, 0 );		iRect.right -= 15;		SetPt ( &cellSize, 0, 0 );		linkList = LNew ( &iRect, &rDataBnds, cellSize, 0, theDialog, true, false, false, true );		InsetRect (&iRect, -1, -1);		FrameRect (&iRect);				(*linkList)->selFlags = 0x82;		(*linkList)->lClickLoop = myLClick;		LSetDrawingMode (false, linkList);		for (i = 0; i < (*Routing)->routes; i++)		{//			NumToString (i+1, temp);			NumToString ((*Routing)->route[i].mask.zone, temp);			temp[temp[0]+1] = 0;			strcpy ((char *) &tmp[1], ((*Routing)->route[i].mask.zone == -1) ? "ALL" : (char *) &temp[1]);			strcat ((char *) &tmp[1], ":");			NumToString ((*Routing)->route[i].mask.net, temp);			temp[temp[0]+1] = 0;			strcat ((char *) &tmp[1], ((*Routing)->route[i].mask.net == -1) ? "ALL" : (char *) &temp[1]);			strcat ((char *) &tmp[1], "/");			NumToString ((*Routing)->route[i].mask.node, temp);			temp[temp[0]+1] = 0;			strcat ((char *) &tmp[1], ((*Routing)->route[i].mask.node == -1) ? "ALL" : (char *) &temp[1]);			strcat ((char *) &tmp[1], ".");			NumToString ((*Routing)->route[i].mask.point, temp);			temp[temp[0]+1] = 0;			strcat ((char *) &tmp[1], ((*Routing)->route[i].mask.point == -1) ? "ALL" : (char *) &temp[1]);			strcat ((char *) &tmp[1], " Route to ");			strcat ((char *) &tmp[1], printaddr ( &(*nodesHndls[(*Routing)->route[i].node])->Addr, (char *) &temp[1] ));			dummy = LAddRow ( 1, 0x7FFF, linkList );			SetPt ( &theCell, 0, dummy );			LSetCell ( &tmp[1], strlen ((char *) &tmp[1]), theCell, linkList );			}		LSetDrawingMode (true, linkList);		LUpdate (theDialog->visRgn, linkList);		break;			case paneHydra:		GetDialogItem ( theDialog, item + tptNoResync, &iType, &iHandle, &iRect );		SetControlValue ( (ControlHandle) iHandle, (*ftsc)->no_resync );		GetDialogItem ( theDialog, item + tptNoOverdrive, &iType, &iHandle, &iRect );		SetControlValue ( (ControlHandle) iHandle, (*ftsc)->no_overdrive );		GetDialogItem ( theDialog, item + tptSmallWindow, &iType, &iHandle, &iRect );		SetControlValue ( (ControlHandle) iHandle, (*ftsc)->small_window );		GetDialogItem ( theDialog, item + tptZModem32, &iType, &iHandle, &iRect );		SetControlValue ( (ControlHandle) iHandle, (*hydra)->zmodem32 );		GetDialogItem ( theDialog, item + tptJanus32, &iType, &iHandle, &iRect );		SetControlValue ( (ControlHandle) iHandle, (*hydra)->janus32 );		GetDialogItem ( theDialog, item + tptHydra32, &iType, &iHandle, &iRect );		SetControlValue ( (ControlHandle) iHandle, (*hydra)->hydra32 );		GetDialogItem ( theDialog, item + tptHydraEsc, &iType, &iHandle, &iRect );		SetControlValue ( (ControlHandle) iHandle, (*hydra)->hydra_esc );		break;	}}static Boolean ListAndPopUpDestructor ( DialogPtr theDialog ){	short		pane = (((DialogPeek)theDialog)->window.refCon) & 0xFFFF;	short		item = (((DialogPeek)theDialog)->window.refCon) >> 16;	short		iType, dummy, i, len;	Handle		iHandle;	Rect		iRect;	Str255		temp;	Str255		d;	ADDR		address;	Cell		theCell;	long		tl, lll;	short		markChar;		switch (pane)	{	case paneSystem:				//	System setup: AKA list present				HLock ( (Handle) homesystem );				GetDialogItem ( theDialog, item + sysName, &iType, &iHandle, &iRect );		GetDialogItemText ( iHandle, (*homesystem)->system );		GetDialogItem ( theDialog, item + sysSysOp, &iType, &iHandle, &iRect );		GetDialogItemText ( iHandle, (*homesystem)->sysop );		address.Zone = 0;		address.Net = 0;		address.Node = 0;		address.Point = 0;				GetDialogItem ( theDialog, item + sysMainAddr, &iType, &iHandle, &iRect );		GetDialogItemText ( iHandle, temp );		temp[temp[0]+1] = 0;		find_addr ( (char *) &temp[1], &address, (char *) &d[1] );		d[0] = strlen ((char *) &d[1]);		if (address.Zone == 0 || address.Net == 0)			return false;		(*homesystem)->mainAddr.ad.zone = address.Zone;		(*homesystem)->mainAddr.ad.net = address.Net;		(*homesystem)->mainAddr.ad.node = address.Node;		(*homesystem)->mainAddr.ad.point = address.Point;		pStrCopy ( d, (*homesystem)->mainAddr.domain );				HUnlock ( (Handle) homesystem );		SetHandleSize ( (Handle) homesystem, sizeof (homeType) + (*akaList)->dataBounds.bottom * sizeof (daddr) );		HLock ( (Handle) homesystem );		(*homesystem)->AKAcount = (*akaList)->dataBounds.bottom;				for (i = 0; i < (*homesystem)->AKAcount; i++)		{			SetPt ( &theCell, 0, i );			len = 255;			LGetCell ( &temp[1], &len, theCell, akaList );			temp[0] = len;			temp[len+1] = 0;			address.Zone = 0;			address.Net = 0;			address.Node = 0;			address.Point = 0;					find_addr ( (char *) &temp[1], &address, (char *) &d[1] );			d[0] = strlen ((char *) &d[1]);			if (address.Zone == 0 || address.Net == 0)				return false;			(*homesystem)->AKAAddr[i].ad.zone = address.Zone;			(*homesystem)->AKAAddr[i].ad.net = address.Net;			(*homesystem)->AKAAddr[i].ad.node = address.Node;			(*homesystem)->AKAAddr[i].ad.point = address.Point;			pStrCopy ( d, (*homesystem)->AKAAddr[i].domain );		}				LDispose ( akaList );		break;	case panePath:			GetDialogItem ( theDialog, item + pathBundle, &iType, &iHandle, &iRect );		GetDialogItemText ( iHandle, workPath );		GetDialogItem ( theDialog, item + pathTemp, &iType, &iHandle, &iRect );		GetDialogItemText ( iHandle, tempPath );		GetDialogItem ( theDialog, item + pathIbound, &iType, &iHandle, &iRect );		GetDialogItemText ( iHandle, inboundPath );		GetDialogItem ( theDialog, item + pathOutbound, &iType, &iHandle, &iRect );		GetDialogItemText ( iHandle, outboundPath );		GetDialogItem ( theDialog, item + pathBase, &iType, &iHandle, &iRect );		GetDialogItemText ( iHandle, basePath );		GetDialogItem ( theDialog, item + pathNodelist, &iType, &iHandle, &iRect );		GetDialogItemText ( iHandle, Pathes[6] );		GetDialogItem ( theDialog, item + pathLogFile, &iType, &iHandle, &iRect );		GetDialogItemText ( iHandle, logPath );		GetDialogItem ( theDialog, item + pathFreq, &iType, &iHandle, &iRect );		GetDialogItemText ( iHandle, Pathes[7] );		break;	case paneComm:			GetDialogItem ( theDialog, item + commBaud, &iType, &iHandle, &iRect );		(*comm_pref)->baud = bauds[GetControlValue ( (ControlHandle) iHandle ) - 1];		GetDialogItem ( theDialog, item + commStops, &iType, &iHandle, &iRect );		(*comm_pref)->stop = stops[GetControlValue ( (ControlHandle) iHandle ) - 1];				GetDialogItem ( theDialog, item + commParity, &iType, &iHandle, &iRect );		(*comm_pref)->parity = parities[GetControlValue ( (ControlHandle) iHandle ) - 1];				GetDialogItem ( theDialog, item + commData, &iType, &iHandle, &iRect );		(*comm_pref)->data = datas[GetControlValue ( (ControlHandle) iHandle ) - 1];				GetDialogItem ( theDialog, item + commHSK, &iType, &iHandle, &iRect );		(*comm_pref)->hanshake = GetControlValue ( (ControlHandle) iHandle ) - 1;				GetDialogItem ( theDialog, item + commLockPort, &iType, &iHandle, &iRect );		(*comm_pref)->hanshake |= GetControlValue ( (ControlHandle) iHandle ) << 8;				GetDialogItem ( theDialog, item + commTone, &iType, &iHandle, &iRect );		(*comm_pref)->hanshake |= GetControlValue ( (ControlHandle) iHandle ) << 12;				GetDialogItem ( theDialog, item + commDCD, &iType, &iHandle, &iRect );		(*comm_pref)->isdcd = GetControlValue ( (ControlHandle) iHandle );				GetDialogItem ( theDialog, item + commPort, &iType, &iHandle, &iRect );		pStrCopy ( (GetControlValue ( (ControlHandle) iHandle ) == 1) ?				"\pModem Port" : "\pPrinter Port", (*comm_pref)->port_name );				GetDialogItem ( theDialog, item + commInitString, &iType, &iHandle, &iRect );		GetDialogItemText ( iHandle, mdmInitStr );				break;	case paneEMSI:				GetDialogItem ( theDialog, item + emsiLoc, &iType, &iHandle, &iRect );		GetDialogItemText ( iHandle, (*homesystem)->location );		GetDialogItem ( theDialog, item + emsiPhone, &iType, &iHandle, &iRect );		GetDialogItemText ( iHandle, (*homesystem)->phone );		GetDialogItem ( theDialog, item + emsiBaud, &iType, &iHandle, &iRect );		GetDialogItemText ( iHandle, (*homesystem)->baud );		GetDialogItem ( theDialog, item + emsiFlags, &iType, &iHandle, &iRect );		GetDialogItemText ( iHandle, (*homesystem)->emsi_flags );		break;	case paneSession:		GetDialogItem ( theDialog, item + sessNoSEALink, &iType, &iHandle, &iRect );		(*ftsc)->no_sealink = GetControlValue ( (ControlHandle) iHandle );		GetDialogItem ( theDialog, item + sessLog, &iType, &iHandle, &iRect );		(*wazoo)->paranoidal_log = GetControlValue ( (ControlHandle) iHandle );		GetDialogItem ( theDialog, item + sessZedZip, &iType, &iHandle, &iRect );		(*wazoo)->zedzip = GetControlValue ( (ControlHandle) iHandle );		GetDialogItem ( theDialog, item + sessZedZap, &iType, &iHandle, &iRect );		(*wazoo)->zedzap = GetControlValue ( (ControlHandle) iHandle );		GetDialogItem ( theDialog, item + sessDirZap, &iType, &iHandle, &iRect );		(*wazoo)->dirzap = GetControlValue ( (ControlHandle) iHandle );		GetDialogItem ( theDialog, item + sessJanus, &iType, &iHandle, &iRect );		(*wazoo)->janus = GetControlValue ( (ControlHandle) iHandle );		GetDialogItem ( theDialog, item + sessHydra, &iType, &iHandle, &iRect );		(*wazoo)->hydra = GetControlValue ( (ControlHandle) iHandle );		GetDialogItem ( theDialog, item + sessxHydra, &iType, &iHandle, &iRect );		(*ftsc)->xhydra = GetControlValue ( (ControlHandle) iHandle );		GetDialogItem ( theDialog, item + sessEMSI, &iType, &iHandle, &iRect );		(*comm_pref)->disableEMSI = GetControlValue ( (ControlHandle) iHandle );		GetDialogItem ( theDialog, item + sessWaZoo, &iType, &iHandle, &iRect );		(*comm_pref)->disableWaZOO = GetControlValue ( (ControlHandle) iHandle );		GetDialogItem ( theDialog, item + sessDelay, &iType, &iHandle, &iRect );		GetDialogItemText (iHandle, temp);		StringToNum (temp, &lll);		(*wazoo)->slice = lll;				GetDialogItem ( theDialog, item + sessDelayForce, &iType, &iHandle, &iRect );		GetDialogItemText (iHandle, temp);		StringToNum (temp, &lll);		(*wazoo)->force_slice = lll;				GetDialogItem ( theDialog, item + sessMinBaud, &iType, &iHandle, &iRect );		GetDialogItemText (iHandle, temp);		StringToNum (temp, &lll);		(*ftsc)->min_baud = lll;				GetDialogItem ( theDialog, item + sessBads, &iType, &iHandle, &iRect );		GetDialogItemText (iHandle, temp);		StringToNum (temp, &lll);		(*wazoo)->badcount = lll;				//	events				(*wazoo)->issue_calls_mask = 0;		lll = 1L;		for (i=0; i<eventsNumber; i++)		{			GetItemMark ((**canCall).menuHdl, i+1, &markChar);			if (markChar)				(*wazoo)->issue_calls_mask |= lll;			lll <<= 1;		}			(*wazoo)->accept_calls_mask = 0;		lll = 1L;		for (i=0; i<eventsNumber; i++)		{			GetItemMark ((**canAccept).menuHdl, i+1, &markChar);			if (markChar)				(*wazoo)->accept_calls_mask |= lll;			lll <<= 1;		}			(*wazoo)->accept_freqs_mask = 0;		lll = 1L;		for (i=0; i<eventsNumber; i++)		{			GetItemMark ((**canFreq).menuHdl, i+1, &markChar);			if (markChar)				(*wazoo)->accept_freqs_mask |= lll;			lll <<= 1;		}			DisposePopUp (canCall);		DisposePopUp (canAccept);		DisposePopUp (canFreq);				break;	case paneShufle:		GetDialogItem ( theDialog, item + shflSCAN, &iType, &iHandle, &iRect );		(*comm_pref)->auto_scan = GetControlValue ( (ControlHandle) iHandle );		GetDialogItem ( theDialog, item + shflTOSS, &iType, &iHandle, &iRect );		(*comm_pref)->auto_toss = GetControlValue ( (ControlHandle) iHandle );		GetDialogItem ( theDialog, item + shflType1, &iType, &iHandle, &iRect );		if (GetControlValue ((ControlHandle) iHandle))		{			(*shufle)->Type2 = 0x0000;		}		else		{			GetDialogItem ( theDialog, item + shflType2, &iType, &iHandle, &iRect );			if (GetControlValue ((ControlHandle) iHandle))			{				(*shufle)->Type2 = 0x0200;			}			else			{				GetDialogItem ( theDialog, item + shflType2p, &iType, &iHandle, &iRect );				if (GetControlValue ((ControlHandle) iHandle))				{					(*shufle)->Type2 = 0x02FF;				}				else				{					GetDialogItem ( theDialog, item + shflType22, &iType, &iHandle, &iRect );					if (GetControlValue ((ControlHandle) iHandle))					{						(*shufle)->Type2 = 0x0220;					}					else					{						(*shufle)->Type2 = 0x0201;					}				}			}		}		GetDialogItem ( theDialog, item + shflSysTimeZone, &iType, &iHandle, &iRect );		if (GetControlValue ( (ControlHandle) iHandle ))		{			tl = 'TZ';		}		else		{			GetDialogItem ( theDialog, item + shflTimeZone, &iType, &iHandle, &iRect );			GetDialogItemText ( iHandle, temp );			StringToNum ( temp, &tl );		}				(*shufle)->TimeZone = tl;		GetDialogItem ( theDialog, item + shflRealName, &iType, &iHandle, &iRect );		GetDialogItemText ( iHandle, RealName );				GetDialogItem ( theDialog, item + shflPathName, &iType, &iHandle, &iRect );		GetDialogItemText ( iHandle, ShufflerPathName );		GetDialogItem ( theDialog, item + shflMaxSize, &iType, &iHandle, &iRect );		GetDialogItemText ( iHandle, temp );		StringToNum ( temp, &tl );				(*shufle)->maxarcsize = tl;				break;	case paneLinx:	case paneAreas:	case paneGroups:	case paneEvents:	case paneEvtBehave:	case paneRouting:				LDispose ( linkList );				break;			case paneNetMail:		GetDialogItem ( theDialog, item + netmailPurge, &iType, &iHandle, &iRect );		GetDialogItemText (iHandle, temp);		StringToNum (temp, &lll);				if (!lll)			lll = 31;					(*mailHndl)->purger = lll;				GetDialogItem ( theDialog, item + netmailUseAKA, &iType, &iHandle, &iRect );		(*mailHndl)->useAKA = GetControlValue ( (ControlHandle) iHandle ) - 1;				break;	case paneHydra:		GetDialogItem ( theDialog, item + tptNoResync, &iType, &iHandle, &iRect );		(*ftsc)->no_resync = GetControlValue ( (ControlHandle) iHandle );		GetDialogItem ( theDialog, item + tptNoOverdrive, &iType, &iHandle, &iRect );		(*ftsc)->no_overdrive = GetControlValue ( (ControlHandle) iHandle );		GetDialogItem ( theDialog, item + tptSmallWindow, &iType, &iHandle, &iRect );		(*ftsc)->small_window = GetControlValue ( (ControlHandle) iHandle );		GetDialogItem ( theDialog, item + tptZModem32, &iType, &iHandle, &iRect );		(*hydra)->zmodem32 = GetControlValue ( (ControlHandle) iHandle );		GetDialogItem ( theDialog, item + tptJanus32, &iType, &iHandle, &iRect );		(*hydra)->janus32 = GetControlValue ( (ControlHandle) iHandle );		GetDialogItem ( theDialog, item + tptHydra32, &iType, &iHandle, &iRect );		(*hydra)->hydra32 = GetControlValue ( (ControlHandle) iHandle );		GetDialogItem ( theDialog, item + tptHydraEsc, &iType, &iHandle, &iRect );		(*hydra)->hydra_esc = GetControlValue ( (ControlHandle) iHandle );		break;	}		return true;}static Boolean AlreadyInList (ListHandle list, StringPtr str){	short	dummy;	Str255	temp;	short	len;	Cell	theCell;	for ( dummy = 0; dummy < (*list)->dataBounds.bottom; dummy++ )	{		SetPt ( &theCell, 0, dummy );		len = 255;		LGetCell ( &temp[1], &len, theCell, list );		temp[0] = len;			if (!pStrComp (temp, str))			break;	}		if (dummy == (*list)->dataBounds.bottom)		return false;	else		return true;}static Boolean ListAndPopUpClick ( DialogPtr theDialog, short iHit ){	short		pane = (((DialogPeek)theDialog)->window.refCon) & 0xFFFF;	short		item = (((DialogPeek)theDialog)->window.refCon) >> 16;	Cell		theCell;	short		iType, dummy;	Handle		iHandle;	Rect		iRect;	Str255		temp, d;	ADDR		address;	short		groups, defgrp, i, j, markChar;	MenuHandle	mHandle;	long		lll;	Boolean		res = false;	nodePrefHndl	*nodesHndlsPlus;	areaPrefHndl	*areasHndlsPlus;	groupPrefHndl	*groupsHndlsPlus;	eventsHndl		*eventsHndlsPlus;	routeHndl		routingHndlsPlus;	StringPtr		*ptr_temp;	Boolean			addena;			if (iHit != 666)		iHit -= item;	switch (pane)	{	case paneSystem:				//	System setup: AKA list & buttons present				switch (iHit)		{		case sysAddAka:			GetDialogItem ( theDialog, item + sysAkaAddr, &iType, &iHandle, &iRect );			GetDialogItemText ( iHandle, temp );			temp[temp[0]+1] = 0;			if (temp[0])			{				address.Zone = 0;				address.Net = 0;				address.Node = 0;				address.Point = 0;							find_addr ( (char *) &temp[1], &address, (char *) &d[1] );				d[0] = strlen ((char *) &d[1]);				if (address.Zone == 0 || address.Net == 0)				{					SysBeep (10);					return res;				}								if ( AlreadyInList (akaList, temp) )				{					SysBeep (10);					return res;				}								dummy = LAddRow ( 1, 0x7FFF, akaList );				SetPt ( &theCell, 0, dummy );				LSetCell ( &temp[1], temp[0], theCell, akaList );					SetDialogItemText ( iHandle, "\p" );			}						break;		case sysRmveAka:						SetPt ( &theCell, 0, 0 );				if ( LGetSelect ( 1, &theCell, akaList) )			{				LDelRow ( 1, theCell.v, akaList );			}				break;		}				break;			case paneComm:		switch (iHit)		{		case commLockPort:		case commTone:		case commDCD:			GetDialogItem ( theDialog, item + iHit, &iType, &iHandle, &iRect );			dummy = GetControlValue ( (ControlHandle) iHandle );			SetControlValue ( (ControlHandle) iHandle, !dummy );		}				break;	case paneSession:		switch (iHit)		{		case sessEMSI:		case sessWaZoo:		case sessZedZap:		case sessZedZip:		case sessDirZap:		case sessJanus:		case sessHydra:		case sessxHydra:		case sessNoSEALink:		case sessLog:					GetDialogItem ( theDialog, item + iHit, &iType, &iHandle, &iRect );			dummy = GetControlValue ( (ControlHandle) iHandle );			SetControlValue ( (ControlHandle) iHandle, !dummy );			break;		}				break;	case paneShufle:		switch (iHit)		{		case shflType1:		case shflType2:		case shflTypeQ:		case shflType2p:		case shflType22:			GetDialogItem ( theDialog, item + shflType1, &iType, &iHandle, &iRect );			SetControlValue ( (ControlHandle) iHandle, 0 );			GetDialogItem ( theDialog, item + shflType2, &iType, &iHandle, &iRect );			SetControlValue ( (ControlHandle) iHandle, 0 );			GetDialogItem ( theDialog, item + shflTypeQ, &iType, &iHandle, &iRect );			SetControlValue ( (ControlHandle) iHandle, 0 );			GetDialogItem ( theDialog, item + shflType2p, &iType, &iHandle, &iRect );			SetControlValue ( (ControlHandle) iHandle, 0 );			GetDialogItem ( theDialog, item + shflType22, &iType, &iHandle, &iRect );			SetControlValue ( (ControlHandle) iHandle, 0 );					GetDialogItem ( theDialog, item + iHit, &iType, &iHandle, &iRect );			SetControlValue ( (ControlHandle) iHandle, 1 );			break;				case shflSCAN:		case shflTOSS:		case shflSysTimeZone:					GetDialogItem ( theDialog, item + iHit, &iType, &iHandle, &iRect );			dummy = GetControlValue ( (ControlHandle) iHandle );			SetControlValue ( (ControlHandle) iHandle, !dummy );						if (!dummy && iHit == shflSysTimeZone)			{				MachineLocation		loc;				GetDialogItem ( theDialog, item + shflTimeZone, &iType, &iHandle, &iRect );								ReadLocation (&loc);							lll = loc.u.gmtDelta & 0x00FFFFFFL;								if (loc.u.gmtDelta & 0x00010000L)					lll |= 0xFF000000L;				lll = lll / 3600L;				if (loc.u.dlsDelta < 0)					lll--;				NumToString ( lll, temp );				SetDialogItemText ( iHandle, temp );			}						break;		}				break;			case paneLinx:		SetPt ( &theCell, 0, 0 );				addena = false;				if ( LGetSelect ( 1, &theCell, linkList) || iHit == linxAdd)		{			switch (iHit)			{			case linxAdd:							if (NodesNumber)				{					NodesNumber++;					nodesHndlsPlus = (nodePrefHndl *) NewPtrClear ( NodesNumber * sizeof (Handle) );										for (i=0; i<NodesNumber-1; i++)						nodesHndlsPlus[i] = nodesHndls[i];											DisposePtr ((Ptr) nodesHndls);					nodesHndls = nodesHndlsPlus;				}				else				{					NodesNumber = 1;					nodesHndls = (nodePrefHndl *) NewPtrClear ( sizeof (Handle) );				}								nodesHndls[NodesNumber-1] = (nodePrefHndl) NewHandleClear (sizeof (nodePrefType));								ptr_temp = (StringPtr *) NewPtrClear (sizeof (Ptr) * NodesNumber);								if (commoninits)				{					memcpy (ptr_temp, commoninits, sizeof (Ptr) * (NodesNumber - 1));					DisposePtr ((Ptr) commoninits);				}								commoninits = (StringPtr *) ptr_temp;				addena = true;				theCell.v = NodesNumber - 1;						case linxEdit:							ListAndPopUpDestructor ( theDialog );				DisposeDialog ( theDialog );				if (ProcessOneLink ( theCell.v ))					break;								if (!addena)					break;							case linxRemove:							if (NodesNumber)				{					if (!addena)					{						ListAndPopUpDestructor ( theDialog );						DisposeDialog ( theDialog );					}					NodesNumber--;					//				memcpy (ptr_temp, commoninits, sizeof (Ptr) * (NodesNumber - 1));					if (NodesNumber)					{						nodesHndlsPlus = (nodePrefHndl *) NewPtrClear ( NodesNumber * sizeof (Handle) );						ptr_temp = (StringPtr *) NewPtrClear (sizeof (Ptr) * NodesNumber);											for (i=0, j=0; i<=NodesNumber; i++)							if (i != theCell.v)							{								ptr_temp[j] = commoninits[i];								nodesHndlsPlus[j++] = nodesHndls[i];							}							else							{								if (commoninits[i])									DisposePtr ((Ptr) commoninits[i]);																DisposeHandle ((Handle) nodesHndls[i]);							}													DisposePtr ((Ptr) commoninits);						commoninits = (StringPtr *) ptr_temp;					}					else					{						if (*commoninits)							DisposePtr ((Ptr) *commoninits);						DisposePtr ((Ptr) commoninits);						commoninits = NULL;												DisposeHandle ((Handle) nodesHndls[0]);						nodesHndlsPlus = NULL;					}										DisposePtr ((Ptr) nodesHndls);					nodesHndls = nodesHndlsPlus;				}							break;			}			res = true;		}				break;	case paneAreas:		SetPt ( &theCell, 0, 0 );				addena = false;		if ( LGetSelect (1, &theCell, linkList) || iHit == linxAdd)		{			switch (iHit)			{			case 666:			//				SysBeep (10);							areasHndlsPlus = (areaPrefHndl *) NewPtrClear ( AreasNumber * sizeof (Handle) );								for (i=0, j=0; i<AreasNumber; i++)				{					if (i == theCell.v)						areasHndlsPlus[wasmove] = areasHndls[i];					else					{						if (j == wasmove)							j++;						areasHndlsPlus[j++] = areasHndls[i];					}				}									DisposePtr ((Ptr) areasHndls);				areasHndls = areasHndlsPlus;				break;						case areasAdd:				if (AreasNumber)				{					AreasNumber++;					areasHndlsPlus = (areaPrefHndl *) NewPtrClear ( AreasNumber * sizeof (Handle) );										for (i=0; i<AreasNumber-1; i++)						areasHndlsPlus[i] = areasHndls[i];											DisposePtr ((Ptr) areasHndls);					areasHndls = areasHndlsPlus;				}				else				{					AreasNumber = 1;					areasHndls = (areaPrefHndl *) NewPtrClear ( sizeof (Handle) );				}								areasHndls[AreasNumber-1] = (areaPrefHndl) NewHandleClear (sizeof (areaPrefType));								addena = true;				theCell.v = AreasNumber - 1;			case areasEdit:							ListAndPopUpDestructor ( theDialog );				DisposeDialog ( theDialog );				if (ProcessOneArea ( theCell.v ))					break;								if (!addena)					break;							case areasRemove:				if (AreasNumber)				{					if (!addena)					{						ListAndPopUpDestructor ( theDialog );						DisposeDialog ( theDialog );					}					AreasNumber--;										if (AreasNumber)					{						areasHndlsPlus = (areaPrefHndl *) NewPtrClear ( AreasNumber * sizeof (Handle) );											for (i=0, j=0; i<=AreasNumber; i++)							if (i != theCell.v)								areasHndlsPlus[j++] = areasHndls[i];							else								DisposeHandle ((Handle) areasHndls[i]);					}					else					{						DisposeHandle ((Handle) areasHndls[0]);						areasHndlsPlus = NULL;					}										DisposePtr ((Ptr) areasHndls);					areasHndls = areasHndlsPlus;				}				break;			}			res = true;		}				break;			case paneGroups:		SetPt ( &theCell, 0, 0 );				addena = false;		if ( LGetSelect ( 1, &theCell, linkList) || iHit == linxAdd)		{			switch (iHit)			{			case areasAdd:				if (GroupsNumber)				{					GroupsNumber++;					groupsHndlsPlus = (groupPrefHndl *) NewPtrClear ( GroupsNumber * sizeof (Handle) );										for (i=0; i<GroupsNumber-1; i++)						groupsHndlsPlus[i] = groupsHndls[i];											DisposePtr ((Ptr) groupsHndls);					groupsHndls = groupsHndlsPlus;				}				else				{					GroupsNumber = 1;					groupsHndls = (groupPrefHndl *) NewPtrClear ( sizeof (Handle) );				}								groupsHndls[GroupsNumber-1] = (groupPrefHndl) NewHandleClear (sizeof (groupPrefType));								addena = true;				theCell.v = GroupsNumber - 1;			case areasEdit:							ListAndPopUpDestructor ( theDialog );				DisposeDialog ( theDialog );				if (ProcessOneGroup ( theCell.v ))					break;								if (!addena)					break;							case areasRemove:				if (GroupsNumber)				{					if (!addena)					{						ListAndPopUpDestructor ( theDialog );						DisposeDialog ( theDialog );					}					GroupsNumber--;										if (GroupsNumber)					{						groupsHndlsPlus = (groupPrefHndl *) NewPtrClear ( GroupsNumber * sizeof (Handle) );											for (i=0, j=0; i<=GroupsNumber; i++)							if (i != theCell.v)								groupsHndlsPlus[j++] = groupsHndls[i];							else								DisposeHandle ((Handle) groupsHndls[i]);					}					else					{						DisposeHandle ((Handle) groupsHndls[0]);						groupsHndlsPlus = NULL;					}										DisposePtr ((Ptr) groupsHndls);					groupsHndls = groupsHndlsPlus;				}				break;			}			res = true;		}		break;	case paneEvents:		SetPt ( &theCell, 0, 0 );		addena = false;				if ( LGetSelect ( 1, &theCell, linkList) || iHit == linxAdd)		{			switch (iHit)			{			case areasAdd:				if (eventsNumber)				{					eventsNumber++;					eventsHndlsPlus = (eventsHndl *) NewPtrClear ( eventsNumber * sizeof (Handle) );										for (i=0; i<eventsNumber-1; i++)						eventsHndlsPlus[i] = eventsHndls[i];											DisposePtr ((Ptr) eventsHndls);					eventsHndls = eventsHndlsPlus;				}				else				{					eventsNumber = 1;					eventsHndls = (eventsHndl *) NewPtrClear ( sizeof (Handle) );				}								eventsHndls[eventsNumber-1] = (eventsHndl) NewHandleClear (sizeof (one_evt));								addena = true;				theCell.v = eventsNumber - 1;			case areasEdit:							ListAndPopUpDestructor ( theDialog );				DisposeDialog ( theDialog );				if (ProcessOneEvent ( theCell.v ))					break;								if (!addena)					break;							case areasRemove:				if (eventsNumber)				{					if (!addena)					{						ListAndPopUpDestructor ( theDialog );						DisposeDialog ( theDialog );					}					eventsNumber--;										if (eventsNumber)					{						eventsHndlsPlus = (eventsHndl *) NewPtrClear ( eventsNumber * sizeof (Handle) );											for (i=0, j=0; i<=eventsNumber; i++)							if (i != theCell.v)								eventsHndlsPlus[j++] = eventsHndls[i];							else								DisposeHandle ((Handle) eventsHndls[i]);					}					else					{						DisposeHandle ((Handle) eventsHndls[0]);						eventsHndlsPlus = NULL;					}										DisposePtr ((Ptr) eventsHndls);					eventsHndls = eventsHndlsPlus;				}				break;			}			res = true;		}		break;	case paneEvtBehave:		SetPt ( &theCell, 0, 0 );				addena = false;		if ( LGetSelect ( 1, &theCell, linkList) || iHit == linxAdd)		{			switch (iHit)			{			case areasAdd:								if ((*behavior)->countOfBehave == 31)				{					SysBeep (10);					return false; 				}								(*behavior)->countOfBehave++;								SetHandleSize ((Handle)behavior, sizeof (short) + sizeof (behave) * (*behavior)->countOfBehave);								theCell.v = (*behavior)->countOfBehave - 1;								(*behavior)->behavior[theCell.v].mode = 0;				(*behavior)->behavior[theCell.v].evtNum = 0;				(*behavior)->behavior[theCell.v].nodeNum = 0;				(*behavior)->behavior[theCell.v].cmd[0] = 0;				addena = true;							case areasEdit:							ListAndPopUpDestructor ( theDialog );				DisposeDialog ( theDialog );				if (ProcessOneEvtBehave ( theCell.v ))					break;								if (!addena)					break;							case areasRemove:				if ((*behavior)->countOfBehave)				{					if (!addena)					{						ListAndPopUpDestructor ( theDialog );						DisposeDialog ( theDialog );					}										for (i = 0, j = 0; i < (*behavior)->countOfBehave; i++)						if (i == theCell.v)						{							continue;						}						else						{							(*behavior)->behavior[j++] = (*behavior)->behavior[i];						}					(*behavior)->countOfBehave--;										SetHandleSize ((Handle)behavior, sizeof (short) + sizeof (behave) * (*behavior)->countOfBehave);				}				break;			}			res = true;		}		break;	case paneRouting:		SetPt ( &theCell, 0, 0 );		addena = false;		if ( LGetSelect ( 1, &theCell, linkList) || iHit == linxAdd)		{			switch (iHit)			{			case 666:			//				SysBeep (10);							routingHndlsPlus = (routeHndl) NewHandle (GetHandleSize ((Handle) Routing));								for (i=0, j=0; i<(*Routing)->routes; i++)				{					if (i == theCell.v)						(*routingHndlsPlus)->route[wasmove] = (*Routing)->route[i];					else					{						if (j == wasmove)							j++;						(*routingHndlsPlus)->route[j++] = (*Routing)->route[i];					}				}								(*routingHndlsPlus)->routes = (*Routing)->routes;				DisposeHandle ((Handle) Routing);				Routing = routingHndlsPlus;				break;						case areasAdd:								(*Routing)->routes++;								SetHandleSize ((Handle)Routing, sizeof (short) + sizeof (routeType) * (*Routing)->routes);								theCell.v = (*Routing)->routes - 1;								(*Routing)->route[theCell.v].mask.zone = 0;				(*Routing)->route[theCell.v].mask.net = 0;				(*Routing)->route[theCell.v].mask.node = 0;				(*Routing)->route[theCell.v].mask.point = 0;				(*Routing)->route[theCell.v].node = 0;				addena = true;			case areasEdit:							ListAndPopUpDestructor ( theDialog );				DisposeDialog ( theDialog );				if (ProcessOneRoute ( theCell.v ))					break;								if (!addena)					break;							case areasRemove:				if ((*Routing)->routes)				{					if (!addena)					{						ListAndPopUpDestructor ( theDialog );						DisposeDialog ( theDialog );					}										for (i = 0, j = 0; i < (*Routing)->routes; i++)						if (i == theCell.v)						{							continue;						}						else						{							(*Routing)->route[j++] = (*Routing)->route[i];						}					(*Routing)->routes--;										SetHandleSize ((Handle)Routing, sizeof (short) + sizeof (routeType) * (*Routing)->routes);				}				break;			}			res = true;		}		break;	case paneHydra:		switch (iHit)		{		case tptNoResync:		case tptNoOverdrive:		case tptSmallWindow:		case tptZModem32:		case tptJanus32:		case tptHydra32:		case tptHydraEsc:			GetDialogItem ( theDialog, item + iHit, &iType, &iHandle, &iRect );			dummy = GetControlValue ( (ControlHandle) iHandle );			SetControlValue ( (ControlHandle) iHandle, !dummy );			break;		}				break;	}		return res;}void main (void){		DialogPtr		theDialog;	short			lastID, lastappendedID;	Rect			paneRect;	short			iHit;		short			iCtl;	short			iType, teActive;	ControlHandle	iHandle;	Rect			iRect;			InitToolbox ();		if (!ReadPreference ())		ExitToShell ();		_InstallDITL ( &theDialog, 128, &lastID, &paneRect );	SetPort (theDialog);	((DialogPeek) theDialog)->window.refCon = ((long) lastID) << 16;	_AppendDITL ( theDialog, tmplBase, &lastappendedID, &paneRect );		ListAndPopUpConstructor ( theDialog );		do {		ModalDialog ( ModalFilterProc, &iHit );		if (iHit == tmpPUSelectPane)		{			GetDialogItem ( theDialog, tmpPUSelectPane, &iType, (Handle *) &iHandle, &iRect );			iCtl = GetControlValue (iHandle) - 1;			if (iCtl != (((DialogPeek) theDialog)->window.refCon & 0xFFFF))			{							if (ListAndPopUpDestructor ( theDialog ))				{					ShortenDITL ( theDialog, lastappendedID - lastID );					EraseRect (&paneRect);										((DialogPeek) theDialog)->window.refCon = iCtl + (((long) lastID) << 16);					_AppendDITL ( theDialog, tmplBase, &lastappendedID, &paneRect );					ListAndPopUpConstructor ( theDialog );//					DrawDialog ( theDialog );					BeginUpdate (theDialog);					UpdateDialog (theDialog, theDialog->visRgn);					EndUpdate (theDialog);				}				else				{					SetControlValue (iHandle, ((DialogPeek) theDialog)->window.refCon & 0xFFFF);					SysBeep (10);				}			}		}		else			if (iHit > lastID)			{				GetDialogItem ( theDialog, tmpPUSelectPane, &iType, (Handle *) &iHandle, &iRect );				iCtl = GetControlValue (iHandle) - 1;				if (ListAndPopUpClick ( theDialog, iHit ))				{								//	main dialog was disposed…									_InstallDITL ( &theDialog, 128, &lastID, &paneRect );					SetPort (theDialog);					GetDialogItem ( theDialog, tmpPUSelectPane, &iType, (Handle *) &iHandle, &iRect );					SetControlValue (iHandle, iCtl + 1);					((DialogPeek) theDialog)->window.refCon = iCtl + (((long) lastID) << 16);					_AppendDITL ( theDialog, tmplBase, &lastappendedID, &paneRect );										ListAndPopUpConstructor ( theDialog );				}			}				} while (iHit != 1 && iHit != 2);	ListAndPopUpDestructor ( theDialog );	DisposeDialog ( theDialog );	HUnlock ( (Handle) homesystem );		if (iHit == 1)		WritePreference ();}