#include <string.h>#include "ravel_msg_base.h"#include "Ravel_Prefs.h"#include "PascalStr.h"#include "key.h"#ifndef LITE#ifdef PROTECTED#include "log.h"#define h_uudec(c)         (((c) - '!') & 0x3f)	keyRecord	keys;	Handle		keyHandle;extern	homeHndl	homesystem;			//	¥	Home system structstatic unsigned short	r;			// R-factor for encryption/decription									// r = 55665; /*********************************************************** *															* *	Get Adobe's encoded byte and decode it by Adobe 		* *					encryption algorythm					* *															* ***********************************************************/static unsigned char DeCoding ( unsigned char code ){	unsigned char			newCode;		newCode = ( code ^ ( r >> 8 ) );		r = ( code + r ) * 52845 + 22719;		return newCode;} /* End of CodingEnc */	Boolean CheckKey (){	Boolean		res = false;	Str255		keyStr;	Handle		h;	short				i, j, k;	unsigned char		keyBin[96], *p, *q;	unsigned long		checksum = 0;	addr		keyAddr = (*homesystem)->mainAddr.ad;	StringPtr	keyName = (*homesystem)->sysop;	short		prefResNum;	short		oldResNum;	h = Get1Resource ( 'proc', 129 );	if (h)		DetachResource (h);	else		return false;		MoveHHi (h);	HLock (h);	keys.Invalidater = h;	oldResNum = CurResFile ();	prefResNum = OpenRFPerm ( prefFile, 0, fsRdWrPerm );	do {		if (!keyHandle)			break;				k = GetHandleSize (keyHandle);		BlockMove ( *keyHandle, &keyStr[1], k );		keyStr[0] = 0;		for (i = 1, j = 1; i <= k; i++)			if (keyStr[i] >= 33 && keyStr[i] <= 96)			{				keyStr[j++] = keyStr[i];				keyStr[0]++;			}				if (keyStr[0] != 128)			break;		q = keyBin;		p = &keyStr[1];				for (i = 0; i < 128; i += 4, p += 4)		{			*q++ = (char) ((h_uudec(p[0]) << 2) | (h_uudec(p[1]) >> 4));			*q++ = (char) ((h_uudec(p[1]) << 4) | (h_uudec(p[2]) >> 2));			*q++ = (char) ((h_uudec(p[2]) << 6) | h_uudec(p[3]));		}				r = keyAddr.zone + keyAddr.net + keyAddr.node + keyAddr.point;		for (i=0; i<96; i++)			keyBin[i] = DeCoding (keyBin[i]);				keys.crc = 0L;		for (i=1; i<=keyName[0]; i++)		{			keys.crc += keyName[i] * 678L;			keys.crc = (keys.crc << 3) | (keys.crc >> 29);		}				keys.crc +=	(((unsigned long)(keyAddr.zone & 0xFF))) |				(((unsigned long)(keyAddr.net & 0xFF)) << 8) |				(((unsigned long)(keyAddr.node & 0xFF)) << 16) |				(((unsigned long)(keyAddr.point & 0xFF)) << 24);		keys.cs = ((keys.crc&0xFFFF) ^ (keys.crc / 359));				keys.oldcrc  = (unsigned long) keyBin[10];		keys.oldcrc |= (unsigned long) keyBin[9] << 8;		keys.oldcrc |= (unsigned long) keyBin[8] << 16;		keys.oldcrc |= (unsigned long) keyBin[7] << 24;				strcpy ( (char *) &keys.regName[1], (char *) &keyBin[12] );			keys.regName[0] = strlen ((char *) &keys.regName[1]);				keys.oldcs = (keyBin[12+keys.regName[0]+1] << 8) | keyBin[12+keys.regName[0]+2];				keys.regAddr.zone = (keyBin[12+keys.regName[0]+4] << 8) | keyBin[12+keys.regName[0]+5];		keys.regAddr.net = (keyBin[12+keys.regName[0]+6] << 8) | keyBin[12+keys.regName[0]+7];		keys.regAddr.node = (keyBin[12+keys.regName[0]+8] << 8) | keyBin[12+keys.regName[0]+9];		keys.regAddr.point = (keyBin[12+keys.regName[0]+10] << 8) | keyBin[12+keys.regName[0]+11];				(*homesystem)->mainAddr.ad = keys.regAddr;				putlog (lgNOPE, "Key: %s (%.8lX-%.4X)", (char *) &keys.regName[1], keys.oldcrc, keys.oldcs);				if (keys.crc != keys.oldcrc)			break;		if ((keys.oldcs+1+keys.cs)&0xFFFF)			break;		if (pStrComp (keys.regName, keyName))			break;				j = GetHandleSize (h)/4;		for (i=0;i<j-1;i++)			checksum += ((unsigned long *)*h)[i];				if (checksum == ((unsigned long *)*h)[i])			res = true;	} while (0);	if (!res)	{		Handle	h;				h = Get1Resource ( 'TEXT', 0 );		RemoveResource ( h );		UpdateResFile ( prefResNum );		DisposeHandle (h);	}		UseResFile ( oldResNum );	CloseResFile ( prefResNum );		return res && j>0x1F0/4;}#endif#endif