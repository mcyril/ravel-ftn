#include <ctype.h>#include <string.h>#include <stdio.h>#include <TextUtils.h>#include "Ravel_FTN.h"#include "Ravel_Prefs.h"#include "stringutl.h"#if !defined(powerc) && !defined(__powerc)short strcasecmp ( char *s1, char *s2 ){	char	s11[512],			s12[512];				strncpy ( s11, s1, 511 );	strncpy ( s12, s2, 511 );	s11[511] = 0;	s12[511] = 0;	UprText ( s11, strlen (s11) );	UprText ( s12, strlen (s12) );		return strcmp ( s11, s12 );}short strncasecmp ( char *s1, char *s2, short n ){	char	s11[512],			s12[512];				strncpy ( s11, s1, __min(n, 511) );	strncpy ( s12, s2, __min(n, 511) );	UprText ( s11, strlen (s11) );	UprText ( s12, strlen (s12) );		return strncmp ( s11, s12, n );}char *strupr(char *str){	UprText ( str, strlen (str) );	return str;}#endifvoid exstrcpy ( char *to, char *from ){	char		*buf;	int			a=0;	while (*from==' ' || *from=='\t')		from++;		for ( ; from[a] != 0 && from[a] != 0x0d; a++ );		memcpy ( to, from, a );	to[a] = 0;}/* ----- Get pointer to string ----------------------------------------- */unsigned char *MyString(short id, register short number){	register Handle h;	register Byte *p;	register short i;	register short n;	h = GetResource('STR#', id);	p = (Byte *)*h;	n = *(short *)p;	p += 2;	for (i = 1; i <= n; i++, p += *p + 1)		if (i == number)			return p;	return 0;}char *printmask ( addr *f, char *_ftmp ){	char	tmp[64];	_ftmp[0]=0;		if ( f->zone != -1 )	{		sprintf ( tmp, "%d:", f->zone );		strcat(_ftmp, tmp);	}	else		strcat(_ftmp, "*:");	 	if ( f->net != -1 )	{		sprintf ( tmp, "%d/", f->net );		strcat ( _ftmp, tmp );	}	else		strcat(_ftmp, "*/");		if ( f->node != -1 )	{		sprintf ( tmp, "%d", f->node );		strcat ( _ftmp, tmp );	}	else		strcat(_ftmp, "*");		if ( f->point !=0 )		if ( f->point!=-1 )		{			sprintf ( tmp, ".%d", f->point );			strcat ( _ftmp, tmp );		}		else			strcat(_ftmp, ".*");		return _ftmp;}char *printaddr ( addr *f, char *_ftmp ){	char	tmp[64];	_ftmp[0]=0;		if ( f->zone != -1 )	{		sprintf ( tmp, "%d:", f->zone );		strcat(_ftmp, tmp);	}	 	if ( f->net != -1 )	{		sprintf ( tmp, "%d/", f->net );		strcat ( _ftmp, tmp );	}		if ( f->node != -1 )	{		sprintf ( tmp, "%d", f->node );		strcat ( _ftmp, tmp );	}		if ( f->point !=0 && f->point!=-1 )	{		sprintf ( tmp, ".%d", f->point );		strcat ( _ftmp, tmp );	}		return _ftmp;}char *printaddr1 (ADDR *f, char *_ftmp){	addr	f1;	f1.zone = f->Zone;	f1.net = f->Net;	f1.node = f->Node;	f1.point = f->Point;	return printaddr (&f1, _ftmp);}short parsemask (addr *f, char *s){	long	a,b=0,c=0,r;		for ( ; s[b] && (!isdigit (s[b]) && s[b] != '*'); b++ );		if (s[b])	{		do {						if (s[b] == '*')				a = -1;			else				if ( sscanf ( s+b, "%ld", &a ) !=1 )					break;			for ( ; s[b] && (isdigit (s[b]) || s[b] == '*'); b++ );						if ( s[b] == ':' )				f->zone=a;			else				if ( s[b] == '/' )					f->net=a;				else					if ( s[b] == '.' )					{						f->node=a;						c=1;					}					else						if ( s[b] == '@' || s[b] <= ' ' || s[b] == ')' )						{							if ( c==1 )								f->point=a;							else								f->node=a;							break;						}			b++;				} while(1);				r=b;				if( s[b] == '@' )		{			for ( a = b+1; s[a] > ' '; a++ );				r=a;		}	}		return r;}short parseaddr (addr *f, char *s){	long	a,b=0,c=0,r;		for ( ; s[b] && !isdigit (s[b]); b++ );		if (s[b])	{		do {						if ( sscanf ( s+b, "%ld", &a ) !=1 )				break;			for ( ; isdigit (s[b]); b++ );						if ( s[b] == ':' )				f->zone=a;			else				if ( s[b] == '/' )					f->net=a;				else					if ( s[b] == '.' )					{						f->node=a;						c=1;					}					else						if ( s[b] == '@' || s[b] <= ' ' || s[b] == ')' )						{							if ( c==1 )								f->point=a;							else								f->node=a;							break;						}			b++;				} while(1);				r=b;				if( s[b] == '@' )		{			for ( a = b+1; s[a] > ' '; a++ );				r=a;		}	}		return r;}Boolean addrInmask ( addr *Mask, addr *Addr ){	return ( ((Mask->zone == -1) || (Mask->zone == Addr->zone)) &&			 ((Mask->net == -1) || (Mask->net == Addr->net)) &&			 ((Mask->node == -1) || (Mask->node == Addr->node)) &&			 ((Mask->point == -1) || (Mask->point == Addr->point)) );}char *flnames[20]={ "Pvt", "Cra", "Rcv", "Snt", "Att", "Trn", "Orp", "K/s",					"Loc", "Hld", "Rsv", "Frq", "Rrq", "Rrc", "Arq", "Fup",					"Dir", "Scn", "Kfs", "Cfm" };long string_to_flags (char *s){	long		a=0;	short		b;			while ( *s != 0 && *s != '\n' && *s != 0xd )	{		while ( *s == ' ' || *s == '\t' )			s++;		if ( *s == 0 || *s == '\n' || *s == 0xd )			break;		for ( b = 0; b < 20; b++ )			if ( !strncasecmp (s, flnames[b], 3) )				break;		if( b == 20 )			break;		a |= (1L << b);		s += 3;	}		return a;}char *flags_to_string (long f, char *_flbuf ){	int		a;	_flbuf[0] = 0;		for ( a = 0; a < 20; a++ )		if ((f&(1L<<a))!=0)		{			strcat ( _flbuf, flnames[a] );			strcat(_flbuf, " ");		}	if ( ( a = strlen ( _flbuf ) ) != 0 && _flbuf[a-1] == ' ' )	{		_flbuf[a-1] = 0;		UprText ( _flbuf, a-1 );	}		return _flbuf;}