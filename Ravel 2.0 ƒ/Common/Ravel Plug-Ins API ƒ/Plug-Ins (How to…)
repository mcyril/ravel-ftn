1.			Plug-Ins basics	1.1		Basic principle	1.2		OpCodes	1.3		Data structures1.	Plug-Ins basicsPlug-Ins architecture was designed for easy extension of RavelSHUFFLER features.1.1	Basic principleThe basic principle of each Plug-In operation is "intercept" of primitive RavelSHUFFLER'soperations and performing it own process. For example you can track all incoming NetMailmessages and redirect some of its to BADMAIL (or simply discard its) if you dislike message'sauthor. You should properly choose primitives which you wish to intercept.How it works? It's simply! Each Plug-In from "Plug-Ins" folder is opening by RavelSHUFFLERduring start-up and reading 'Code', ID=0 resources. For each 'Code' resource Shufflerperforms call as for "stand-alone code" (look for info in your compiler's programming samples).The first call of Plug-In is initial. The purpose of initial call is to determinate whatkind of primitives this plug-in can intercept. Plug-in can perform not only one primitive(except this plug-in is compressor/extractor).1.2	OpCodesThe control record for each plug-in is shown in "PlugIns.h"Let's see at the two first "longs" in this record:	long	opCode;			//	Operation code	long	retCode;		//	Result code or acceptable codes mask for plugWelcome"opCode" is the operation code parameter. "retCode" is the result of operation.Plug-in has access to Shuffler's preferences, message wich processing in thismoment and many more data structures. Control record contains several call-backroutine entry points.Here is the list of opCodes that corresponds to primitives which can be intercepted byeach plug-in.#define	plugWelcome				0x00000001L	//	calling when shuffler started (need filling retCode as mask)#define	plugSuicide				0x00000002L	//	calling when shuffler terminatig#define	plugTossMsgEcho			0x00000004L	//	calling when echomail for this system during toss#define	plugTossMsgEchoExp		0x00000008L	//	calling when echomail in transit during toss#define	plugTossMsgMail			0x00000010L	//	calling when netmail for this system during toss#define	plugTossMsgMailTrs		0x00000020L	//	calling when netmail in transit during toss#define	plugScanMsgEcho			0x00000040L	//	calling when fetched unsent echomail from base#define	plugScanMsgMail			0x00000080L	//	calling when fetched unsent netmail from base#define	plugCustomLaunch		0x00000100L	//	calling when shuffler's command is equal plugInvokeName#define	plugPreTossLaunch		0x00000200L	//	calling before processing toss itself#define	plugPreScanLaunch		0x00000400L	//	calling before processing scan itself#define	plugPreNetPackLaunch	0x00000800L	//	calling before processing netmail pack itself#define	plugNotify 				0x00001000L	//	calling for notification if Preferences cahnged#define	plugCustomNames 		0x00002000L	//	calling for obtaining custom names in plugInvokeNames#define	plugMisc 				0x10000000L	//	general purpose call (retCode contains secondary opcode)#define	plugCompExtr			0x80000000L	//	Init opCode only. Plug is compressor and/or extractoropCodes plugWelcome and plugSuicide are mandoritary and calls always. plugWelcome is theinitial call for plug-in.1.2.1 plugWelcomeCalling once during Shuffler's initiation. This opCode means that plug-in should initializeits variables/data-structures, read preferences, etc. Also Shuffler expect that "retCode"will be contains mask of intercepted primitives. For example, if you want to acceptcontrol during all TOSS and SCAN operation you should return value "plugTossMsgEcho |plugTossMsgEchoExp | plugTossMsgMail | plugTossMsgMailTrs | plugScanMsgEcho | plugScanMsgMail"in "retCode".1.2.2 plugSuicideCalling once during Shuffler's terminating. Plug-in should release memory, update preferences,close opened files, etc.1.2.3 plugTossMsgEchoCalling before Shuffler make attempt to store incoming echomessage in base or process itas pass through. Useful for fetching "message to me" and other "carbon copies" likeservices.1.2.4 plugTossMsgEchoExpCalling before Shuffler make attempt to export this incoming echomessage to otherlinks.1.2.5 plugTossMsgMailCalling before Shuffler make attempt to store incoming netmail message in base.1.2.6 plugTossMsgMailTrsCalling before Shuffler make attempt to route this netmail message.1.2.7 plugScanMsgEchoCalling when fetched unsent echomessage from base before export it to other links.1.2.8 plugScanMsgMailCalling when fetched unsent netmail message from base route it.1.2.9 plugCustomLaunchCalling when Shuffler accepted custom command (look for more details in secial chapter)1.2.10 plugPreTossLaunchCalling before processing toss itself1.2.11 plugPreScanLaunchCalling before processing scan itself1.2.12 plugPreNetPackLaunchCalling before processing netmail pack itself1.2.13 plugNotifyCalling for notification if Preferences cahnged. NOT IMPLEMENTED, RESERVED!1.2.14 plugCustomNamesCalling for obtaining custom names which plug-in can perform in plugInvokeNames(look for more details in secial chapter)1.2.15 plugMiscGeneral purpose call. "retCode" contains secondary opcode, see list:secondAutocreated		- Area autocreated		calling if RavelSHUFFLER successfuly created new echoarea.	secondOperationComplete	- Operation completed	calling after ALL performed Shuffler's commands: TOSS, SCAN, NETPACK, etc. Also	after custom calls.1.2.16 plugCompExtrCalling for extractor/compressor plug-ins (look for more details in secial chapter).#define	plugRetNoError		0x00000000L		//	all OK#define	plugRetContinue		0x00000000L		//	proceed with this message (for scan or toss) or all OK#define	plugRetWrongCustom	0x00000001L		//	no such custom name for this plug-in#define	plugRetDropMessage	0x00000001L		//	not proceed with this message (for scan or toss only)#define	plugFatalArch		0x00000002L		//	can't operate with archive//	Archives type#define	arcZIP				0x00000001L		//	Zip archive#define	arcARC				0x00000002L		//	Arc archive#define	arcLZH				0x00000004L		//	Lzh archive#define	arcZOO				0x00000008L		//	Zoo archive#define	arcARJ				0x00000010L		//	Arj archive#define	arcSIT				0x40000000L		//	StuffIt archive//	Archives mode#define	arcCompress			0x00000001L		//	Can compress or compression request#define	arcExpand			0x00000002L		//	Can expand or expander request#define	arcAppend			0x80000000L		//	Only with arcCompress requesttypedef struct _plugsPrefsStruct {		homeHndl		homesystem;			//	Home system struct				mailPrefHndl	mailHndl;			//	Netmail struct				short			AreasNumber;		//	Areas structs list		areaPrefHndl	*areasHndls;				short			GroupsNumber;		//	AreaGroups structs list		groupPrefHndl	*groupsHndls;				short			NodesNumber;		//	Linked Nodes structs list		nodePrefHndl	*nodesHndls;				routeHndl		Routing;			//	Routing		StringPtr		BundlesPath;		//	working folder for bundling outbound		StringPtr		OutboundPath;		//	outbound folder		StringPtr		InboundPath;		//	inbound folder		StringPtr		BasePath;			//	base storage folder		StringPtr		TempPath;			//	temp folder (fe. for unpacking)		StringPtr		NodeLists;			//	Nodelist path		long			reserved[8];		//	reserved for further use} plugsPrefs;typedef struct _plugsControlStruct {	long			opCode;					//	Operation code	long			retCode;				//	Result code or acceptable codes mask for plugWelcome											//			union	{			char		plugInvokeName[16];		//	ASCII name for custom call (if plug can plugCustomLaunch)		struct	{			char		**plugInvokeNames;		//	List of invoke names		long		padd[3];			} names;	struct	{			long		archiveType;			//	Compression type		long		archiveAction;			//	Extract or compress		long		padd[2];	} arc;	} misc;		short			apiRev;					//	API revision (from v1.0fc1): 0x80xx, fc1: xx = 01//	operable information section	pktmsg			*messageIn;				//	Pointer to message for operating	FSSpec			*source;				//	archive name (extract) or list of files to archive (compress)	FSSpec			*destination;			//	archive name (compress) of destination folder (extract)//	preferenses information section	plugsPrefs		Preferences;	StringPtr		thisplugPath;			//	path to this plug-in//	call-back routines set//	plug-ins routines	long	(*CallPlugIns) (long opcode, pktmsg *msg, long secondaryOpCode);	long	(*CallNamedPlugIns) (StringPtr name);	long	(*CallArchiverPlugIns) (Boolean Compress, Boolean Append, long Method, FSSpecPtr srcSpec, FSSpecPtr dstSpec);//	message routing / outbound control / other lowlevel stuffs	void	(*ResolveMessage) (pktmsg *m, addr *from, Boolean toss);	void	(*ExportEchoes) (pktmsg *m, addr *from);	void	(*RouteMessage) (pktmsg *m, Boolean inTransit);	void	(*CreateFoldersChain) (StringPtr base, pktmsg *m, addr *via, char *whatstore, char *resultpath, Boolean kill);	void	(*FlavorMessage) (pktmsg *m, addr *from, addr *via, Boolean inTransit);	void	(*parse_kludges) (short mode, pktmsg *m, pktmsg **d, juncted *newseen, juncted *newpath, addr *currentAka);//	¥	mode://	¥		0	-	1st msg touch. Make internal form (full all fields in _pktmsg_). Rewrite.//	¥		1	-	For posting in base (kill kludges) or extracting from BADMAIL. Duplicate.//	¥		2	-	For posting in outbound (add new seen & path kludges). Duplicate.//	¥		3	-	For post in outbound new message (add all kludges from _pktmsg_). Duplicate.//	¥					(for creation we suppose that pktmsg exist but empty)//	message-base routines	void	(*msgbase_create_unique_name) (StringPtr EchoName, StringPtr BaseName);	short	(*msgbase_open) (short AreaNumber, Boolean needfull);	short	(*msgbase_open_idx) (short AreaNumber, Boolean needfull);	void	(*msgbase_close) (short needupdate);	Boolean	(*msgbase_read_atom) (long msgnum, msgbase_atom *Atom);	Boolean	(*msgbase_write_atom) (long msgnum, msgbase_atom *Atom);	long	(*msgbase_getnummsg) (void);	void	(*msgbase_setnummsg) (long Messages);	long	(*msgbase_getlastread) (void);	void	(*msgbase_setlastread) (long CurrentMsg);	long	(*msgbase_getdirty) (void);	void	(*msgbase_setdirty) (long dirty);	Boolean	(*msgbase_read_message) (long MsgNum, pktmsg **m, short mode);	Boolean	(*msgbase_append_message) (pktmsg *m, Boolean setdirty);	void	(*msgbase_ftn_date) (char *date, DateTimeRec *dtr);	Boolean (*msgbase_scanforme) (long from, Boolean (*myname)(StringPtr));	long	(*msgbase_scanunread) (long Num, short mode);	void	(*msgbase_allread) (void);	void	(*msgbase_prep_reply) (pktmsg *original, pktmsg *destination);	void	(*msgbase_prep_msgid) (pktmsg *destination);	long	(*msgbase_new_msgid) (void);	void	(*msgbase_insert_message) (long msgnum);	void	(*msgbase_delete_message) (long msgnum, long mode);	void	(*FreePktMsg) (pktmsg *p);//	temp-message-base routines	Boolean	(*tmpbase_open) (void);	short	(*tmpbase_add) (pktmsg *m);	void	(*tmpbase_close) (void);//	misc routines#if defined(powerc) || defined(__powerc)	void	(*putlog) (char status, char *loginfo);#else	void	(*putlog) (char status, char *loginfo, ... );#endif	short	(*parseaddr) (addr *f, char *s);	char	*(*printaddr) (addr *f, char *_ftmp);	OSErr	(*FindAProcess) (OSType typeToFind, OSType creatorToFind, ProcessSerialNumberPtr processSN);	void	(*Slice) (void);								//	call Shuffler's event loop//	functional routines	void	(*_Toss) (void);								//	call TOSS command	void	(*_Scan) (void);								//	call SCAN command	void	(*_NetPack) (void);								//	call NETPACK command	void	(*_Purge) (void);								//	call PURGE command	void	(*_Pack) (void);								//	call PACK command	void	(*_Link) (void);								//	call LINK command//	show progress	void	(*InitProgress) (float howmuch);	void	(*DrawProgress) (long i);	void	(*putProgressName) (Str255 name);//	nodelist	Boolean	(*GetNodeInfo) (addr *, StringPtr);	Boolean	(*GetNameFromAddr) (addr *, StringPtr);	Boolean	(*GetInfoFromAddr) (addr *address, StringPtr result);	Boolean	(*IsNodelistOK) (void);//	others	short	(*LookForAreaNumber) (char *areaname);	short	(*LookForLinkNumber) (addr *to);	Boolean	(*cmp2addrs) (addr *my1, addr *my2);	Boolean	(*addrInmask) (addr *Mask, addr *Addr);	Boolean	(*IsItMyAddr) (addr *quest);	addr	*(*FindRouteTo) (addr *Addr);	short	(*FindRouteToN) (addr *Addr);	void	(*add_to_other) (pktmsg *m, char *dest, addr *from, char *reason);	Boolean	(*get_flo_pathname) (addr *oper, StringPtr base, StringPtr flo);//	busy semaphores stuff	Boolean	(*bsy_check) (addr *oper, StringPtr base);	Boolean	(*bsy_raise) (addr *oper, StringPtr base);	void	(*bsy_clear) (addr *oper, StringPtr base);	Boolean	(*base_bsy_check) (void);	void	(*base_bsy_raise) (void);	void	(*base_bsy_clear) (void);} PlugsControl, *PlugsControlPtr;