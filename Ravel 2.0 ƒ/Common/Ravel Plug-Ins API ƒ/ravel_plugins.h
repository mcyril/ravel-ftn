#ifndef _RAVEL_SHUFFLER_PLUG_H#define _RAVEL_SHUFFLER_PLUG_H#define	kCurrentPlugAPI			0x8002//	Plug-Ins orders retCodes & initialization opCodes#define	plugWelcome				0x00000001L	//	calling when shuffler started (need filling retCode as mask)#define	plugSuicide				0x00000002L	//	calling when shuffler terminatig#define	plugTossMsgEcho			0x00000004L	//	calling when echomail for this system during toss#define	plugTossMsgEchoExp		0x00000008L	//	calling when echomail in transit during toss#define	plugTossMsgMail			0x00000010L	//	calling when netmail for this system during toss#define	plugTossMsgMailTrs		0x00000020L	//	calling when netmail in transit during toss#define	plugScanMsgEcho			0x00000040L	//	calling when fetched unsent echomail from base#define	plugScanMsgMail			0x00000080L	//	calling when fetched unsent netmail from base#define	plugCustomLaunch		0x00000100L	//	calling when shuffler perform custom command (plug-in should recognize it)#define	plugPreTossLaunch		0x00000200L	//	calling before processing toss itself#define	plugPreScanLaunch		0x00000400L	//	calling before processing scan itself#define	plugPreNetPackLaunch	0x00000800L	//	calling before processing netmail pack itself#define	plugNotify 				0x00001000L	//	calling for notification if Preferences cahnged#define	plugCustomNames 		0x00002000L	//	calling for obtaining custom names in plugInvokeNames#define	plugMisc 				0x10000000L	//	general purpose call (retCode contains secondary opcode)#define	plugCompExtr			0x80000000L	//	Init opCode only. Plug is compressor and/or extractor#define	secondAutocreated		0x00000001L	//	secondary opCode: Area autocreated#define	secondOperationComplete	0x00000002L	//	secondary opCode: operation from internal Shuffler's queue complete #define	plugRetNoError			0x00000000L	//	all OK#define	plugRetContinue			0x00000000L	//	proceed with this message (for scan or toss) or all OK#define	plugRetWrongCustom		0x00000001L	//	no such custom name for this plug-in#define	plugRetDropMessage		0x00000001L	//	not proceed with this message (for scan or toss only)#define	plugFatalArch			0x00000002L	//	can't operate with archive//	Archives type#define	arcZIP					0x00000001L	//	Zip archive#define	arcARC					0x00000002L	//	Arc archive#define	arcLZH					0x00000004L	//	Lzh archive#define	arcZOO					0x00000008L	//	Zoo archive#define	arcARJ					0x00000010L	//	Arj archive#define arc0001					0x00000020L	//	reserved bit archive#define arcRAR					0x00000040L	//	RAR archive (*)#define arcHA					0x00000080L	//	HA archive#define	arcSIT					0x40000000L	//	StuffIt archive// (*)	NOTE: Not implemented in RavelSHUFFLER recognition//	Archives mode#define	arcCompress				0x00000001L	//	Can compress or compression request#define	arcExpand				0x00000002L	//	Can expand or expander request#define	arcAppend				0x80000000L	//	Only with arcCompress requesttypedef struct _plugsPrefsStruct {		homeHndl		homesystem;			//	Home system struct				mailPrefHndl	mailHndl;			//	Netmail struct				short			AreasNumber;		//	Areas structs list		areaPrefHndl	*areasHndls;				short			GroupsNumber;		//	AreaGroups structs list		groupPrefHndl	*groupsHndls;				short			NodesNumber;		//	Linked Nodes structs list		nodePrefHndl	*nodesHndls;				routeHndl		Routing;			//	Routing		StringPtr		BundlesPath;		//	working folder for bundling outbound		StringPtr		OutboundPath;		//	outbound folder		StringPtr		InboundPath;		//	inbound folder		StringPtr		BasePath;			//	base storage folder		StringPtr		TempPath;			//	temp folder (fe. for unpacking)		StringPtr		NodeLists;			//	Nodelist path		StringPtr		LogPath;			//	log path		long			reserved[7];		//	reserved for further use} plugsPrefs;typedef struct _plugsControlStruct {	long			opCode;					//	Operation code	long			retCode;				//	Result code or acceptable codes mask for plugWelcome											//			union	{			char		plugInvokeName[16];		//	ASCII name for custom call (if plug can plugCustomLaunch)		struct	{			char		**plugInvokeNames;		//	List of invoke names		long		padd[3];			} names;	struct	{			long		archiveType;			//	Compression type		long		archiveAction;			//	Extract or compress		long		padd[2];	} arc;	} misc;	unsigned short	apiRev;					//	API revision (from v1.0fc1): 0x80xx, fc1: xx = 01											//	0x8001 - v1.0fc1 [initial rev.]											//	0x8002 - v1.1b1  [PPC aware, "parsemask" added, etc.]//	operable information section	pktmsg			*messageIn;				//	Pointer to message for operating	FSSpec			*source;				//	archive name (extract) or list of files to archive (compress)	FSSpec			*destination;			//	archive name (compress) of destination folder (extract)//	preferenses information section	plugsPrefs		Preferences;	StringPtr		thisplugPath;			//	path to this plug-in//	call-back routines set//	apiRev == 0x8001 or 0x0000//	plug-ins routines	long	(*CallPlugIns) (long opcode, pktmsg *msg, long secondaryOpCode);	long	(*CallNamedPlugIns) (StringPtr name);	long	(*CallArchiverPlugIns) (Boolean Compress, Boolean Append, long Method, FSSpecPtr srcSpec, FSSpecPtr dstSpec);//	message routing / outbound control / other lowlevel stuffs	void	(*ResolveMessage) (pktmsg *m, addr *from, Boolean toss);	void	(*ExportEchoes) (pktmsg *m, addr *from);	void	(*RouteMessage) (pktmsg *m, Boolean inTransit);	void	(*CreateFoldersChain) (StringPtr base, pktmsg *m, addr *via, char *whatstore, char *resultpath, Boolean kill);	void	(*FlavorMessage) (pktmsg *m, addr *from, addr *via, Boolean inTransit);	void	(*parse_kludges) (short mode, pktmsg *m, pktmsg **d, juncted *newseen, juncted *newpath, addr *currentAka);//	¥	mode://	¥		0	-	1st msg touch. Make internal form (full all fields in _pktmsg_). Rewrite.//	¥		1	-	For posting in base (kill kludges) or extracting from BADMAIL. Duplicate.//	¥		2	-	For posting in outbound (add new seen & path kludges). Duplicate.//	¥		3	-	For post in outbound new message (add all kludges from _pktmsg_). Duplicate.//	¥					(for creation we suppose that pktmsg exist but empty)//	message-base routines	void	(*msgbase_create_unique_name) (StringPtr EchoName, StringPtr BaseName);	short	(*msgbase_open) (short AreaNumber, Boolean needfull);	short	(*msgbase_open_idx) (short AreaNumber, Boolean needfull);	void	(*msgbase_close) (short needupdate);	Boolean	(*msgbase_read_atom) (long msgnum, msgbase_atom *Atom);	Boolean	(*msgbase_write_atom) (long msgnum, msgbase_atom *Atom);	long	(*msgbase_getnummsg) (void);	void	(*msgbase_setnummsg) (long Messages);	long	(*msgbase_getlastread) (void);	void	(*msgbase_setlastread) (long CurrentMsg);	long	(*msgbase_getdirty) (void);	void	(*msgbase_setdirty) (long dirty);	Boolean	(*msgbase_read_message) (long MsgNum, pktmsg **m, short mode);	Boolean	(*msgbase_append_message) (pktmsg *m, Boolean setdirty);	void	(*msgbase_ftn_date) (char *date, DateTimeRec *dtr);	Boolean (*msgbase_scanforme) (long from, Boolean (*myname)(StringPtr));	long	(*msgbase_scanunread) (long Num, short mode);	void	(*msgbase_allread) (void);	void	(*msgbase_prep_reply) (pktmsg *original, pktmsg *destination);	void	(*msgbase_prep_msgid) (pktmsg *destination);	long	(*msgbase_new_msgid) (void);	void	(*msgbase_insert_message) (long msgnum);	void	(*msgbase_delete_message) (long msgnum, long mode);	void	(*FreePktMsg) (pktmsg *p);//	temp-message-base routines	Boolean	(*tmpbase_open) (void);	short	(*tmpbase_add) (pktmsg *m);	void	(*tmpbase_close) (void);//	misc routines	void	(*putlog) (char status, char *loginfo);	short	(*parseaddr) (addr *f, char *s);	long	(*printaddr) (addr *f, char *_ftmp);	//	IN FACT: char*	OSErr	(*FindAProcess) (OSType typeToFind, OSType creatorToFind, ProcessSerialNumberPtr processSN);	void	(*Slice) (void);								//	call Shuffler's event loop//	functional routines	void	(*_Toss) (void);								//	call TOSS command	void	(*_Scan) (void);								//	call SCAN command	void	(*_NetPack) (void);								//	call NETPACK command	void	(*_Purge) (void);								//	call PURGE command	void	(*_Pack) (void);								//	call PACK command	void	(*_Link) (void);								//	call LINK command//	show progress	void	(*InitProgress) (float howmuch);	void	(*DrawProgress) (long i);	void	(*putProgressName) (Str255 name);//	nodelist	Boolean	(*GetNodeInfo) (addr *, StringPtr);	Boolean	(*GetNameFromAddr) (addr *, StringPtr);	Boolean	(*GetInfoFromAddr) (addr *address, StringPtr result);	Boolean	(*IsNodelistOK) (void);//	others	short	(*LookForAreaNumber) (char *areaname);	short	(*LookForLinkNumber) (addr *to);	Boolean	(*cmp2addrs) (addr *my1, addr *my2);	Boolean	(*addrInmask) (addr *Mask, addr *Addr);	Boolean	(*IsItMyAddr) (addr *quest);	long	(*FindRouteTo) (addr *Addr);		//	IN FACT addr*	short	(*FindRouteToN) (addr *Addr);	void	(*add_to_other) (pktmsg *m, char *dest, addr *from, char *reason);	Boolean	(*get_flo_pathname) (addr *oper, StringPtr base, StringPtr flo);//	busy semaphores stuff	Boolean	(*bsy_check) (addr *oper, StringPtr base);	Boolean	(*bsy_raise) (addr *oper, StringPtr base);	void	(*bsy_clear) (addr *oper, StringPtr base);	Boolean	(*base_bsy_check) (void);	void	(*base_bsy_raise) (void);	void	(*base_bsy_clear) (void);//	other	void	(*_PurgeNonDstr) (void);						//	call non destructive PURGE command	long	(*obtainHBase) (void);							//	IN FACT: msgbase_index_h															//	get handle to current opened msgbase index	void	(*_Undel) (void);								//	call UNDEL command	void	(*Resolver) (long process);	void	(*UpdatePreference_Links) (void);				//	update Ravel.PREF with nodesHndls	void	(*UpdatePreference_Areas) (void);				//	update Ravel.PREF with areasHndls	void	(*ExportEchoesOnlyTo) (pktmsg *m, addr *from, addr *to);	//	export echo message to one link 'to'//	call-back routines set//	apiRev == 0x8002		short	(*parsemask) (addr *f, char *s);	long	(*ClonePktMsg) (pktmsg *);		//	IN FACT pktmsg *	long	(*printmask) (addr *f, char *_ftmp);	//	IN FACT: char*	} PlugsControl, *PlugsControlPtr;#endif