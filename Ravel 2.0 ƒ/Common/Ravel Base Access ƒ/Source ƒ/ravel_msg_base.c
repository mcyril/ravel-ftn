//	ravel_msg_base.c/*	Copyright © 1997 Cyril Moorzin	All rights reserved		Ravel 1.0 PUBLIC DOMAIN part.	Ravel is FTN software for Macintosh	"ravel_msg_base.h" & "ravel_msg_base.c" is Ravel 1.0 Message Base specification*/#include <stdio.h>#include <string.h>#include <Sound.h>#include "ravel_msg_base.h"#include "ravel_internal.h"#include "ravel_asciiz.h"#include "PascalStr.h"#include "Ravel_Prefs.h"#include "stringutl.h"#include "Pathes.h"#include "pktparse.h"#include "myEnv.h"#define	pASCIIZ(x)	((x)[(x)[0]+1]=0)static	short	CurrentBaseNumber;		Str255	CurrentArea;		short	BaseVRef;		long	BaseDirID;		short	CBIndexRef;		short	CBHeadRef;		short	CBTextRef;static	msgbase_index_h	HBase;static char	*mnt[12] = { "Jan", "Feb", "Mar",						 "Apr", "May", "Jun",						 "Jul", "Aug", "Sep",						 "Oct", "Nov", "Dec" };extern	homeHndl		homesystem;			//	¥	Home system structextern	mailPrefHndl	mailHndl;			//	¥	Netmail structextern	short			AreasNumber;		//	¥	Areas structs listextern	areaPrefHndl	*areasHndls;extern	short			GroupsNumber;		//	¥	AreaGroups structs listextern	groupPrefHndl	*groupsHndls;extern	short			NodesNumber;		//	¥	Linked Nodes structs listextern	nodePrefHndl	*nodesHndls;short msgbase_init (void){	CurrentBaseNumber = -1;		return get_folder (basePath, &BaseVRef, &BaseDirID);}short msgbase_dispose (void){	return true;}//	Create messagebase's filename from echonamevoid msgbase_create_unique_name (StringPtr EchoName, StringPtr BaseName){	unsigned long	ccc;	short			ii;	pStrCopy ( EchoName, BaseName );		if (BaseName[0] > 16)	{		ccc = 0L;		for (ii=0; ii < BaseName[0]; ii++)		{			ccc += BaseName[ii];			ccc = (ccc << 1) | (ccc >> 31);		}		sprintf ((char *) &BaseName[17], "%.8lX", ccc);		BaseName[0] = strlen ((char *) &BaseName[1]);	}}short msgbase_open ( short AreaNumber, Boolean needfull ){	short		iErr, ii;	Str255		CBIndexName, CBHeadName, CBTextName, sss;	long		indexSize, ccc;				if ( CurrentBaseNumber != -1 )		return CurrentBaseNumber;		if ( AreaNumber > AreasNumber )		return -1;		switch ( AreaNumber )	{		case BADAREA:	pStrCopy ( "\pBADMAIL", CurrentArea );								break;		case NETMAIL:	pStrCopy ( "\pNETMAIL", CurrentArea );								break;		default:		pStrCopy ( (*areasHndls[AreaNumber-1])->areaName, CurrentArea );	break;	}	pASCIIZ(CurrentArea);	msgbase_create_unique_name (CurrentArea, CBIndexName);		pStrConc ( CBIndexName, "\p.HDR", CBHeadName );	pStrConc ( CBIndexName, "\p.TXT", CBTextName );	pStrConc ( CBIndexName, "\p.INX", CBIndexName );	if ((iErr = HOpen (BaseVRef, BaseDirID, CBIndexName, fsRdWrPerm, &CBIndexRef)) != noErr)	{		if ( iErr == fnfErr )		{			msgbase_header	HeaderBase;			long			counter;									iErr = HCreate (BaseVRef, BaseDirID, CBIndexName, 'Ravl', 'BasI');			if ( iErr )				return -1;							iErr = HOpen (BaseVRef, BaseDirID, CBIndexName, fsRdWrPerm, &CBIndexRef);			if ( iErr )				return -1;						memset ( &HeaderBase, 0, sizeof (msgbase_header) );						HeaderBase.base_sign = 'Rvl1';		//	new base format signature. always 'Rvl1'			HeaderBase.base_flags = 0;			//	messagebase common flags			HeaderBase.base_lastread = 0;			HeaderBase.base_dirtstart = -1;			HeaderBase.base_msg_number = 0;		//	number of messages in base			HeaderBase.base_atom_number = 0;	//	number of atoms in base (msg + deleted msg)			counter = sizeof (msgbase_header);			if ( FSWrite (CBIndexRef, &counter, &HeaderBase) )			{				FSClose ( CBIndexRef );				return -1;			}		}		else			return -1;	}		GetEOF ( CBIndexRef, &indexSize );	if ((iErr = HOpen (BaseVRef, BaseDirID, CBHeadName, fsRdWrPerm, &CBHeadRef)) != noErr)	{		if ( iErr == fnfErr )		{			iErr = HCreate (BaseVRef, BaseDirID, CBHeadName, 'Ravl', 'BasT');			if ( iErr )			{				FSClose ( CBIndexRef );				return -1;			}						iErr = HOpen (BaseVRef, BaseDirID, CBHeadName, fsRdWrPerm, &CBHeadRef);			if ( iErr )			{				FSClose ( CBIndexRef );				return -1;			}		}		else		{			FSClose ( CBIndexRef );			return -1;		}	}		if ((iErr = HOpen (BaseVRef, BaseDirID, CBTextName, fsRdWrPerm, &CBTextRef)) != noErr)	{		if ( iErr == fnfErr )		{			iErr = HCreate (BaseVRef, BaseDirID, CBTextName, 'Ravl', 'BasT');			if ( iErr )			{				FSClose ( CBHeadRef );				FSClose ( CBIndexRef );				return -1;			}						iErr = HOpen (BaseVRef, BaseDirID, CBTextName, fsRdWrPerm, &CBTextRef);			if ( iErr )			{				FSClose ( CBHeadRef );				FSClose ( CBIndexRef );				return -1;			}		}		else		{			FSClose ( CBHeadRef );			FSClose ( CBIndexRef );			return -1;		}	}	if (!needfull)		indexSize = sizeof (msgbase_header);	HBase = (msgbase_index_h) NewHandle (indexSize);	HLock ((Handle) HBase);		SetFPos (CBIndexRef, fsFromStart, 0L);		if (FSRead (CBIndexRef, &indexSize, (Ptr) *HBase) != noErr || (*HBase)->head.base_sign != 'Rvl1')	{		FSClose ( CBIndexRef );		FSClose ( CBHeadRef );		FSClose ( CBTextRef );				DisposeHandle ( (Handle) HBase );				return -1;	}	CurrentBaseNumber = AreaNumber;	return AreaNumber;}short msgbase_open_idx ( short AreaNumber, Boolean needfull ){	register short	res;		if (AreaNumber == AreasNumber+1)	{		res = msgbase_open ( BADAREA, true );			if (res == BADAREA)			res = AreaNumber;	}	else		res = msgbase_open (AreaNumber, true);/*if (res == -1)	DebugStr ("\pBASE: fault!");if (res != AreaNumber)	DebugStr ("\pBASE: not closed!");*/	return res;}void msgbase_close (short needupdate){	long	counter;	if (CurrentBaseNumber == -1)		return;	if (needupdate)	{		SetFPos (CBIndexRef, fsFromStart, 0L);				if (needupdate != 2)		{			SetEOF (CBIndexRef, 0L);			counter = sizeof (msgbase_header) + sizeof (msgbase_atom) * (*HBase)->head.base_atom_number;		}		else			counter = sizeof (msgbase_header);		FSWrite (CBIndexRef, &counter, (Ptr) *HBase);	}		FSClose (CBIndexRef);	FSClose (CBHeadRef);	FSClose (CBTextRef);		DisposeHandle ((Handle) HBase);	CurrentBaseNumber = -1;}static long RealNum (long Num){	long	counter1 = (*HBase)->head.base_atom_number;	long	counter = (*HBase)->head.base_msg_number;	long	i, j;	for ( j = 0, i = 0; (i < counter1) && (j < counter); i++ )	{		if ( ((*HBase)->atom[i].base_flags & (ATOM_HARDDELETED | ATOM_DELETED)) == 0 )		{			if ( j == Num )				return i;			else				j++;		}	}		return 0x7FFFFFFF;}Boolean msgbase_read_atom (long msgnum, msgbase_atom *Atom){	short		iErr;	long		counter = RealNum (msgnum);	if (counter == 0x7FFFFFFF)		return false;		if ( msgnum >= (*HBase)->head.base_msg_number )		return false;	*Atom = (*HBase)->atom[counter];	return true;}Boolean msgbase_write_atom (long msgnum, msgbase_atom *Atom){	short		iErr;	long		counter, rowBytes;	Handle		h;	if ( msgnum > (*HBase)->head.base_msg_number )		return false;	if ( msgnum == (*HBase)->head.base_msg_number )			//	Append	{		counter = (*HBase)->head.base_atom_number;		HUnlock ((Handle) HBase);		SetHandleSize ( (Handle) HBase, sizeof (msgbase_header) + sizeof (msgbase_atom) * (counter + 1));				if (MemError () != noErr)		{			SysBeep (10);			SysBeep (10);						MaxMem (&rowBytes);			SetHandleSize ( (Handle) HBase, sizeof (msgbase_header) + sizeof (msgbase_atom) * (counter + 1));						if (MemError () == noErr)				goto doit;						SysBeep (10);			SysBeep (10);			SysBeep (10);						h = NewHandleClear (sizeof (msgbase_header) + sizeof (msgbase_atom) * (counter + 1));					if (h)			{				HLock (h);				HLock ((Handle) HBase);								BlockMove (*((Handle) HBase), *h, sizeof (msgbase_header) + sizeof (msgbase_atom) * counter);				DisposeHandle ((Handle) HBase);				HBase = (msgbase_index_h) h;								goto doit2;			}			else			{				ParamText ("\pNot enough memory for operation [add_atom]", "\p", "\p", "\p");				Alert (500, NULL);			}		}		else		{		doit:					HLock ((Handle) HBase);		doit2:			(*HBase)->atom[counter] = *Atom;			(*HBase)->head.base_msg_number++;			(*HBase)->head.base_atom_number++;		}	}	else	{		counter = RealNum (msgnum);		(*HBase)->atom[counter] = *Atom;	}}long msgbase_getnummsg (void){	return (*HBase)->head.base_msg_number;}void msgbase_setnummsg (long Messages){	(*HBase)->head.base_msg_number = Messages;}long msgbase_getlastread (void){	return (*HBase)->head.base_lastread;}void msgbase_setlastread (long CurrentMsg){	(*HBase)->head.base_lastread = CurrentMsg;}long msgbase_getdirty (void){	long	res;		res = (((*HBase)->head.base_flags & BASE_DIRTY) != 0) ? (*HBase)->head.base_dirtstart : -1;		return res;}void msgbase_setdirty (long dirty){	(*HBase)->head.base_flags &= ~BASE_DIRTY;		if (dirty != -1)	{		(*HBase)->head.base_flags |= BASE_DIRTY;			if ((*HBase)->head.base_dirtstart == -1 || (*HBase)->head.base_dirtstart > dirty)			(*HBase)->head.base_dirtstart = dirty;	}	else		(*HBase)->head.base_dirtstart = -1;}Boolean msgbase_read_message (long MsgNum, pktmsg **m, short mode){	msgbase_atom	Atom;	long			baseTextSize;	long			counter;	char			fromname[MName+1],					toname[MName+1];	char			date[MDate+1],					subj[MSubject+1];	char			msgid[128],					reply[128];	Handle			h;		if (!msgbase_read_atom (MsgNum, &Atom))		return false;	if (SetFPos (CBHeadRef, fsFromStart, Atom.offset_header))		return false;	if (!get_ASCIIZ (CBHeadRef, fromname, MName) ||		!get_ASCIIZ (CBHeadRef, toname, MName) ||		!get_ASCIIZ (CBHeadRef, date, MDate) ||		!get_ASCIIZ (CBHeadRef, subj, MSubject))		return false;	if (mode & READMODE_REPLY)	{		if ((Atom.base_flags & ATOM_MSGID) != 0)		{			if (!get_ASCIIZ (CBHeadRef, msgid, 127))				return false;		}		else			msgid[0] = 0;		if ((Atom.base_flags & ATOM_REPLY) != 0)		{			if (!get_ASCIIZ (CBHeadRef, reply, 127))				return false;		}		else			reply[0] = 0;	}	if (mode & READMODE_TEXT)	{		if (SetFPos (CBTextRef, fsFromStart, Atom.offset_text))			return false;		h = NewHandle (0L);		if (!get_msg_text (CBTextRef, h))			return false;	}	else		h = NULL;		*m = (pktmsg *) NewPtrClear (sizeof (pktmsg));		(*m)->flags = Atom.flags;	(*m)->flags_rsv = Atom.flags_rsv;	(*m)->base_flags = Atom.base_flags;		(*m)->from = Atom.from;	(*m)->to = Atom.to;	(*m)->reply = Atom.reply;	(*m)->msgid_num = Atom.msgid_num;	(*m)->reply_num = Atom.reply_num;	(*m)->msgid_crc = Atom.msgid_crc;	(*m)->reply_crc = Atom.reply_crc;	(*m)->msg_reply_prev = Atom.msg_reply_prev;	(*m)->msg_reply_next = Atom.msg_reply_next;	(*m)->storedtime = Atom.stored_time;	strcpy ((*m)->date, date);	strcpy ((*m)->toname, toname);	strcpy ((*m)->fromname, fromname);	strcpy ((*m)->subj, subj);	if (mode & READMODE_REPLY)	{		if (msgid[0])		{			(*m)->msgid_str = NewPtr (strlen (msgid) + 1);			strcpy ((*m)->msgid_str, msgid);		}		if (reply[0])		{			(*m)->reply_str = NewPtr (strlen (reply) + 1);			strcpy ((*m)->reply_str, reply);		}	}	(*m)->text = h;	if (CurrentBaseNumber)		strcpy ( (*m)->area, (char *) &CurrentArea[1] );	else		(*m)->area[0] = 0;	(*m)->seenby.nodes = (*m)->seenby.nets = NULL;	(*m)->path.nodes = (*m)->path.nets = NULL;	(*m)->path.items = (*m)->seenby.items = 0;	return true;}Boolean msgbase_append_message (pktmsg *m, Boolean setdirty){	msgbase_atom	Atom;	msgbase_text	txt;	long			baseTextSize;	long			counter;	char			tmp[8];		memset (&Atom, 0, sizeof (msgbase_atom));	Atom.base_flags = m->base_flags;	Atom.flags = m->flags;	Atom.flags_rsv = m->flags_rsv;	Atom.from = m->from;	Atom.to = m->to;	Atom.reply = m->reply;		Atom.msgid_num = m->msgid_num;	Atom.reply_num = m->reply_num;	Atom.msgid_crc = m->msgid_crc;	Atom.reply_crc = m->reply_crc;	Atom.msg_reply_prev = m->msg_reply_prev;	Atom.msg_reply_next = m->msg_reply_next;	GetEOF (CBHeadRef, &baseTextSize);	Atom.offset_header = baseTextSize;	SetFPos (CBHeadRef, fsFromLEOF, 0L);	counter = strlen (m->fromname) + 1;	FSWrite (CBHeadRef, &counter, m->fromname);	counter = strlen (m->toname) + 1;	FSWrite (CBHeadRef, &counter, m->toname);	counter = strlen (m->date) + 1;	FSWrite (CBHeadRef, &counter, m->date);	counter = strlen (m->subj) + 1;	FSWrite (CBHeadRef, &counter, m->subj);	if (m->msgid_str)	{		Atom.base_flags |= ATOM_MSGID;		counter = strlen (m->msgid_str) + 1;		FSWrite (CBHeadRef, &counter, m->msgid_str);	}//	else//	{//		tmp[0] = 0;//		counter = 1;//		FSWrite (CBHeadRef, &counter, tmp);//	}		if (m->reply_str)	{		Atom.base_flags |= ATOM_REPLY;		counter = strlen (m->reply_str) + 1;		FSWrite (CBHeadRef, &counter, m->reply_str);	}//	else//	{//		tmp[0] = 0;//		counter = 1;//		FSWrite (CBHeadRef, &counter, tmp);//	}		GetEOF (CBTextRef, &baseTextSize );	Atom.offset_text = baseTextSize;	SetFPos (CBTextRef, fsFromLEOF, 0);	txt.text_sign = 'PL';	txt.text_length = GetHandleSize (m->text);	txt.text_len_cmp = 0L;	counter = sizeof (msgbase_text);	FSWrite (CBTextRef, &counter, &txt);	counter = txt.text_length;	HLock (m->text);	FSWrite (CBTextRef, &counter, *(m->text));	HUnlock (m->text);	if (!m->storedtime)	{		GetDateTime ( (unsigned long *) &Atom.stored_time );		m->storedtime = Atom.stored_time;	}	else		Atom.stored_time = m->storedtime;	msgbase_write_atom ((*HBase)->head.base_msg_number, &Atom);		if (setdirty)		msgbase_setdirty ((*HBase)->head.base_msg_number - 1);		msgbase_insert_message ((*HBase)->head.base_msg_number - 1);	return true;}void msgbase_ftn_date (char *date, DateTimeRec *dtr1){	DateTimeRec	 dtr;	if (!dtr1)		GetTime ( &dtr );	else		dtr = *dtr1;		dtr.year %= 100;	sprintf ( date, "%.2d %s %.2d  %.2d:%.2d:%.2d",					dtr.day, mnt[dtr.month-1], dtr.year, dtr.hour, dtr.minute, dtr.second );}Boolean msgbase_scanforme (long from, Boolean (*myname)(StringPtr)){	pktmsg		*m;	long		locked;	Boolean		res = false;	char		tmp[64];			long		counter1 = (*HBase)->head.base_atom_number;	long		counter = (*HBase)->head.base_msg_number;	long		i, j;	long		r = RealNum (from);	for ( j = from, i = r; (i < counter1) && (j < counter); i++ )	{		if ( ((*HBase)->atom[i].base_flags & (ATOM_HARDDELETED | ATOM_DELETED)) == 0 )		{			if ( ((*HBase)->atom[i].base_flags & (ATOM_WASREAD)) == 0 )			{				if (!msgbase_read_message (j, &m, READMODE_ONLY))					break;									strcpy ( &tmp[1], m->toname );				tmp[0] = strlen ( &tmp[1] );				if (myname ((StringPtr) tmp))				{					res = true;					FreePktMsg (m);					break;				}								FreePktMsg (m);			}			j++;		}	}		return res;}long msgbase_scanunread (long Num, short mode){	long	counter = (*HBase)->head.base_atom_number;	long	r = RealNum (Num);	long	i, j = (*HBase)->head.base_msg_number - 1;	long	k = (mode) ? Num : 0;		if (counter)	{		i = (mode) ? r + mode : 0;				for (; i >= 0 && i < counter; i += (mode) ? mode : 1)		{			if (((*HBase)->atom[i].base_flags & (ATOM_HARDDELETED | ATOM_DELETED)) != 0)				continue;			if (((*HBase)->atom[i].base_flags & (ATOM_WASREAD)) == 0)				if (mode)				{					j = k + mode;										if (!mode)						j++;					break;				}				else				{					j = k;					break;				}					k += (mode) ? mode : 1;		}	}		return j;}void msgbase_allread (void){	long	i;	long	counter = (*HBase)->head.base_atom_number;	if (counter)	{		for (i = 0; i < counter; i++)		{			if (((*HBase)->atom[i].base_flags & (ATOM_HARDDELETED | ATOM_DELETED)) != 0)				continue;			(*HBase)->atom[i].base_flags |= ATOM_WASREAD;		}	}}void msgbase_undelete (void){	long	i;	long	counter = (*HBase)->head.base_atom_number;	if (counter)	{		for (i = 0; i < counter; i++)		{			if (((*HBase)->atom[i].base_flags & ATOM_HARDDELETED) != 0)				continue;			(*HBase)->atom[i].msg_reply_prev = -1;			(*HBase)->atom[i].msg_reply_next = -1;			if (((*HBase)->atom[i].base_flags & ATOM_DELETED) != 0)			{				(*HBase)->head.base_msg_number++;				(*HBase)->atom[i].base_flags &= ~ATOM_DELETED;			}		}	}}void msgbase_prep_reply (pktmsg *original, pktmsg *destination){	if (original->msgid_str)	{		destination->reply_num = original->msgid_num;		destination->reply_crc = original->msgid_crc;		destination->reply = original->from;		destination->reply_str = NewPtr (strlen (original->msgid_str) + 1);		strcpy (destination->reply_str, original->msgid_str);				destination->base_flags |= ATOM_REPLY |							(((original->base_flags & ATOM_NONFTNMSGID) != 0) ? ATOM_NONFTNREPLY : 0);	}	else	{		destination->reply_num = 0;		destination->reply_crc = 0;		destination->reply_str = NULL;	}}void msgbase_prep_msgid (pktmsg *destination){	char	temp[128], ttt[128];	if (!destination->msgid_num)		destination->msgid_num = msgbase_new_msgid ();	sprintf (temp, "%s %.8lx", printaddr (&destination->from, ttt), destination->msgid_num);	if (destination->msgid_str)		DisposePtr (destination->msgid_str);		destination->msgid_str = NewPtr (strlen (temp) + 1);	strcpy (destination->msgid_str, temp);	destination->msgid_crc = 0;	destination->base_flags |= ATOM_MSGID;}long msgbase_new_msgid (void){	static	long	msgid = 0;	if (!msgid)		msgid = (LMGetTime () << 7) + (LMGetTicks () & 0x0000003FL);	else		msgid++;	return msgid;}void msgbase_insert_message (long msgnum)	//	for append only{	msgbase_atom	Atom, Atom_temp;	long			i;	msgbase_read_atom (msgnum, &Atom);		if (Atom.msg_reply_prev != -1)	{		msgbase_read_atom (i = Atom.msg_reply_prev, &Atom_temp);			while (Atom_temp.msg_reply_next != -1)		{			msgbase_read_atom (i = Atom_temp.msg_reply_next, &Atom_temp);		}		Atom_temp.msg_reply_next = msgnum;		msgbase_write_atom (i, &Atom_temp);		Atom.msg_reply_prev = i;		msgbase_write_atom (msgnum, &Atom);	}}void msgbase_delete_message (long msgnum, long mode){	msgbase_atom	Atom, Atom_temp;	long			i;	Boolean			dirty;			i = msgbase_getdirty ();		if (i != -1)	{		if (msgnum < i)			msgbase_setdirty (i - 1);	}		msgbase_read_atom (msgnum, &Atom);		if (Atom.msg_reply_prev != -1)	{		msgbase_read_atom (Atom.msg_reply_prev, &Atom_temp);		Atom_temp.msg_reply_next = Atom.msg_reply_next;		msgbase_write_atom (Atom.msg_reply_prev, &Atom_temp);	}	if (Atom.msg_reply_next != -1)	{		msgbase_read_atom (Atom.msg_reply_next, &Atom_temp);		Atom_temp.msg_reply_prev = Atom.msg_reply_prev;		msgbase_write_atom (Atom.msg_reply_next, &Atom_temp);	}		Atom.base_flags |= mode;	msgbase_write_atom (msgnum, &Atom);		msgbase_setnummsg ((*HBase)->head.base_msg_number - 1);		for (i = 0; i < (*HBase)->head.base_msg_number; i++)	{		dirty = false;		msgbase_read_atom (i, &Atom);		if (i >= msgnum)	//	correct back		{			if (Atom.msg_reply_prev != -1 && Atom.msg_reply_prev >= msgnum)			{				Atom.msg_reply_prev--;				dirty = true;			}						if (Atom.msg_reply_next != -1)			{				Atom.msg_reply_next--;				dirty = true;			}		}		else				//	correct forth		{			if (Atom.msg_reply_next != -1 && Atom.msg_reply_next >= msgnum)			{				Atom.msg_reply_next--;				dirty = true;			}		}		if (dirty)			msgbase_write_atom (i, &Atom);	}}msgbase_index_h	obtainHBase (void){	return HBase;}