#include <stdio.h>#include <string.h>#include "ravel_ftn.h"#include "busy.h"#include "PascalStr.h"#include "log.h"extern	Boolean		multiline_flag;extern	short		multiline_line;static	short	homeVRef = 0;static	long	homeDirID = 0;#define	pASCIIZ(x)	((x)[(x)[0]+1]=0)//еееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееее//е//е Synth the path for current outbound (path is storing in globals)//е//еееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееBoolean get_flo_pathname (addr *oper, StringPtr base, StringPtr flo){	char	tmp[256], tmp1[256];	FSSpec	spec;	long	dummy;		pStrCopy (base, (StringPtr) tmp);	pASCIIZ(tmp);								//	prepare base	sprintf (tmp1, "Zone_%.4X:", oper->zone );	strcat (&tmp[1], tmp1);						//	base + zone folder	tmp[0] = strlen (&tmp[1]);		//	е	Finding zone subfolder╔	if (FSMakeFSSpec (homeVRef, homeDirID, (StringPtr) tmp, &spec))	{		if (DirCreate (homeVRef, homeDirID, (StringPtr) tmp, &dummy))		{			return false;		}	}		if ( oper->point != 0 )	{	//	е	Finding point subfolder╔		sprintf (tmp1, "%.4lX%.4lX.PTS:", (long) oper->net, (long) oper->node);		strcat (&tmp[1], tmp1);						//	base + zone folder + points folder		tmp[0] = strlen (&tmp[1]);		if (FSMakeFSSpec (homeVRef, homeDirID, (StringPtr) tmp, &spec))		{			if (DirCreate (homeVRef, homeDirID, (StringPtr) tmp, &dummy))			{				return false;			}		}		sprintf (tmp1, "%.8lX", (long) oper->point );		strcat (&tmp[1], tmp1);						//	base + zone folder + points folder + flo		tmp[0] = strlen (&tmp[1]);	}	else	{		sprintf (tmp1, "%.4lX%.4lX", (long) oper->net, (long) oper->node);		strcat (&tmp[1], tmp1);						//	base + zone folder + flo		tmp[0] = strlen (&tmp[1]);	}	pStrCopy ((StringPtr) tmp, flo);		pASCIIZ(flo);		return true;}Boolean bsy_check (addr *oper, StringPtr base){	char	bsy_path[256];	FSSpec	spec;	if (get_flo_pathname (oper, base, (StringPtr) bsy_path))	{		strcat (&bsy_path[1], ".BSY");		bsy_path[0] = strlen (&bsy_path[1]);			if (FSMakeFSSpec (homeVRef, homeDirID, (StringPtr) bsy_path, &spec))		{			return false;		}		else		{			return true;		}	}	else		return true;}Boolean bsy_raise (addr *oper, StringPtr base){	char	bsy_path[256];	FSSpec	spec;	if (get_flo_pathname (oper, base, (StringPtr) bsy_path))	{		strcat (&bsy_path[1], ".BSY");		bsy_path[0] = strlen (&bsy_path[1]);		if (FSMakeFSSpec (homeVRef, homeDirID, (StringPtr) bsy_path, &spec))		{			putlog ('~', "Create BSY for %d:%d/%d.%d", oper->zone, oper->net, oper->node, oper->point);			HCreate (homeVRef, homeDirID, (StringPtr) bsy_path, 'RvlS', 'BSY0'+multiline_line);			return false;		}		else		{			return true;		}	}	else		return true;}void bsy_clear (addr *oper, StringPtr base){	char	bsy_path[256];	FSSpec	spec;	if (get_flo_pathname (oper, base, (StringPtr) bsy_path))	{		strcat (&bsy_path[1], ".BSY");		bsy_path[0] = strlen (&bsy_path[1]);		if (FSMakeFSSpec (homeVRef, homeDirID, (StringPtr) bsy_path, &spec) == noErr)		{			putlog ('~', "Remove BSY for %d:%d/%d.%d", oper->zone, oper->net, oper->node, oper->point);			HDelete (homeVRef, homeDirID, (StringPtr) bsy_path);		}	}}Boolean base_bsy_check (void){	Str255	bsy_path;	FSSpec	spec;	pStrCopy ("\pBASE.BSY", bsy_path);	if (FSMakeFSSpec (homeVRef, homeDirID, bsy_path, &spec))	{		return false;	}	else	{		return true;	}}void base_bsy_raise (void){	Str255	bsy_path;	FSSpec	spec;		pStrCopy ("\pBASE.BSY", bsy_path);	if (FSMakeFSSpec (homeVRef, homeDirID, bsy_path, &spec))	{		HCreate (homeVRef, homeDirID, bsy_path, 'RvlS', 'BUSY');	}}void base_bsy_clear (void){	Str255	bsy_path;	FSSpec	spec;		pStrCopy ("\pBASE.BSY", bsy_path);	if (FSMakeFSSpec (homeVRef, homeDirID, (StringPtr) bsy_path, &spec) == noErr)	{		HDelete (homeVRef, homeDirID, (StringPtr) bsy_path);	}}