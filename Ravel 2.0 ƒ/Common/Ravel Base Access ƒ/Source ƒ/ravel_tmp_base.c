/*	Copyright © 1997-1999 Cyril Moorzin	All rights reserved		Ravel 1.0 / Ravel 2.0 PUBLIC DOMAIN part.	Ravel is FTN software for Macintosh	"ravel_msg_base.h" & "ravel_msg_base.c" is Ravel 1.0 Message Base specification*/#include <stdio.h>#include <string.h>#include "ravel_msg_base.h"#include "ravel_internal.h"#include "ravel_asciiz.h"#include "ravel_tmp_base.h"#include "PascalStr.h"#include "Ravel_Prefs.h"#include "stringutl.h"//#include "Templates.h"#include "pktparse.h"#include "AreaUtils.h"#include "busy.h"#include "Pathes.h"#include "myEnv.h"#include "log.h"#define	pASCIIZ(x)	((x)[(x)[0]+1]=0)#define	FASTFLUSHstatic	short	t_BaseVRef;static	long	t_BaseDirID;static	short	t_fRef;Boolean	gBaseBusy;void	putProgressName (Str255 name);void	InitProgress ( float );void	DrawProgress ( long );void	DoSlice (void);short tmpbase_init (void){	t_fRef = -1;	return get_folder (workPath, &t_BaseVRef, &t_BaseDirID);}Boolean tmpbase_open (void){	Boolean		res = false;	OSErr		iErr;		if ((iErr = HOpen (t_BaseVRef, t_BaseDirID, "\p$BASE$", fsRdWrPerm, &t_fRef)) != noErr)	{		if ( iErr == fnfErr )		{			iErr = HCreate (t_BaseVRef, t_BaseDirID, "\p$BASE$", 'Ravl', 'BasI');			if ( iErr )				return res;							iErr = HOpen (t_BaseVRef, t_BaseDirID, "\p$BASE$", fsRdWrPerm, &t_fRef);			if ( iErr )				return res;		}	}				SetFPos (t_fRef, fsFromLEOF, 0L);	res = true;		return res;}short tmpbase_add (pktmsg *m){	long		counter;	long		ttt;	OSErr		iErr;// • Store main info…		counter = sizeof (pktmsg);	iErr = FSWrite (t_fRef, &counter, m);// • Store addena (msgid and reply) strings	if (m->msgid_str)	{		ttt = strlen (m->msgid_str) + 1;			counter = sizeof (long);		iErr = FSWrite (t_fRef, &counter, &ttt);				counter = ttt;		iErr = FSWrite (t_fRef, &counter, m->msgid_str);	}	else	{		ttt = 0;			counter = sizeof (long);		iErr = FSWrite (t_fRef, &counter, &ttt);	}	if (m->reply_str)	{		ttt = strlen (m->reply_str) + 1;			counter = sizeof (long);		iErr = FSWrite (t_fRef, &counter, &ttt);				counter = ttt;		iErr = FSWrite (t_fRef, &counter, m->reply_str);	}	else	{		ttt = 0;			counter = sizeof (long);		iErr = FSWrite (t_fRef, &counter, &ttt);	}	// • Store message text	ttt = GetHandleSize (m->text);	counter = sizeof (long);	iErr = FSWrite (t_fRef, &counter, &ttt);	HLock (m->text);	counter = ttt;	iErr = FSWrite (t_fRef, &counter, *m->text);	HUnlock (m->text);		return 0;}void tmpbase_close (void){	long		counter;	long		ttt;	OSErr		iErr;	pktmsg		m;	short		aNum;#ifdef FASTFLUSH	short		last_aNum;#endif	gBaseBusy = false;	GetEOF (t_fRef, &ttt);		if (ttt == 0)	{		FSClose (t_fRef);		HDelete (t_BaseVRef, t_BaseDirID, "\p$BASE$");	}	else		if (!base_bsy_check ())		{			base_bsy_raise ();					putProgressName ("\pImporting messages…");						InitProgress ((float)ttt);						SetFPos (t_fRef, fsFromStart, 0L);			#ifdef FASTFLUSH			last_aNum = BADAREA;			if (msgbase_open (last_aNum, true) != last_aNum)			{				putlog ( lgALRT, "Internal [BADAREA] opening fault." );				FSClose (t_fRef);				return;			}#endif			while (1)			{				DoSlice ();						//	Read header							counter = sizeof (pktmsg);				iErr = FSRead (t_fRef, &counter, &m);				if (counter != sizeof (pktmsg) || iErr != noErr)					break;			//	Read msgid				counter = sizeof (long);				iErr = FSRead (t_fRef, &counter, &ttt);				if (counter != sizeof (long) || iErr != noErr)					break;								if (ttt != 0)				{					m.msgid_str = NewPtr (ttt);									counter = ttt;					iErr = FSRead (t_fRef, &counter, m.msgid_str);					if (counter != ttt || iErr != noErr)						break;				}				else				{					m.msgid_str = NULL;				}			//	Read reply				counter = sizeof (long);				iErr = FSRead (t_fRef, &counter, &ttt);				if (counter != sizeof (long) || iErr != noErr)					break;								if (ttt != 0)				{					m.reply_str = NewPtr (ttt);									counter = ttt;					iErr = FSRead (t_fRef, &counter, m.reply_str);					if (counter != ttt || iErr != noErr)						break;				}				else				{					m.reply_str = NULL;				}			//	Read text							counter = sizeof (long);				iErr = FSRead (t_fRef, &counter, &ttt);				if (counter != sizeof (long) || iErr != noErr)					break;								m.text = NewHandle (ttt);				HLock (m.text);								counter = ttt;				iErr = FSRead (t_fRef, &counter, *m.text);				if (counter != ttt || iErr != noErr)					break;								if (m.area[0])				{					aNum = LookForAreaNumber ( m.area );										if (aNum == -1)						aNum = BADAREA;				}				else					aNum = NETMAIL;				#ifndef FASTFLUSH				if (msgbase_open (aNum, true) != aNum)				{					putlog ( lgALRT, "Internal %s opening fault.", m.area );					FSClose (t_fRef);					return;				}#else				if (aNum != last_aNum)				{					msgbase_close (CLOSE_UPDATE);					if (msgbase_open (aNum, true) != aNum)					{						putlog ( lgALRT, "Internal %s opening fault.", m.area );						FSClose (t_fRef);						return;					}										last_aNum = aNum;				}#endif				m.seenby.nets = NULL;				m.seenby.nodes = NULL;				m.seenby.items = 0;								m.path.nets = NULL;				m.path.nodes = NULL;				m.path.items = 0;								m.msg_reply_prev = -1;				m.msg_reply_next = -1;								msgbase_append_message ( &m, false );				FreePktMsg ( &m );#ifndef FASTFLUSH				msgbase_close (CLOSE_UPDATE);#endif								GetFPos (t_fRef, &ttt);				DrawProgress (ttt);			}#ifdef FASTFLUSH			msgbase_close (CLOSE_UPDATE);#endif			base_bsy_clear ();			FSClose (t_fRef);			HDelete (t_BaseVRef, t_BaseDirID, "\p$BASE$");		}		else		{			gBaseBusy = true;			FSClose (t_fRef);		}			t_fRef = -1;}