#include <stdio.h>#include <stdlib.h>#include <string.h>#include <ctype.h>#include "ravel_asciiz.h"#include "ravel_msg_base.h"#include "ravel_tmp_base.h"#include "stringutl.h"#include "pktparse.h"#include "Ravel_Prefs.h"#include "hashing.h"#include "myEnv.h"#include "log.h"#include "AreaUtils.h"#include "key.h"extern	Str255	RealName;extern	Str63	MacModel;extern	short	timezone;			// ¥ Time Zone number.extern	short			AreasNumber;		//	¥	Areas structs listextern	areaPrefHndl	*areasHndls;/************************************************************														   **  Parse message text for kludges & full addenum internal  **	           	message's structures					   **														   ************************************************************///static	char	tempBuffer[0x8000];extern	char	*tempBuffer;typedef struct _kludge {	char	kl[16];	short	klen;	} kludge;#ifdef PROTECTEDstatic	char	*sn_fingerprint1 = "%.8lX";static	char	*sn_fingerprint2 = "%.4X";#endifstatic	kludge	kludges[] = {	"AREA:", 5,				//	0								"SEEN-BY:", 8,			//	1								"\1PATH:", 6,			//	2								"\1FMPT", 5,			//	3								"\1TOPT", 5,			//	4								"\1INTL", 5,			//	5								"\1MSGID: ", 8,			//	6								"\1FLAGS: ", 8,			//	7								"\1CHRS: ", 7,			//	8								"\1SEEN-BY:", 9,		//	9								"\1PID: ", 6,			//	10								"\1Via ", 5,			//	11								"\1REPLY: ", 8,			//	12								"\1REPLYTO: ", 10,		//	13								"\1REPLYTO ", 9,		//	14								" * Origin: ", 11,		//	15								"\1FLAGS : ", 9,		//	16								"\1AREA: ", 7,			//	17	-	internal								"\1FROM: ", 7,			//	18	-	internal								"\1REASON: ", 9,		//	19	-	internal								"\1NETMAIL", 8,			//	20	-	internal								"\1FLAGS ", 7,			//	21								"", 0							};/************************************************************														   **  Making chained list of PATH & SEEN-BY from char string  **														   ************************************************************/static void dokfalist ( juncted *kf, char *s ){	int		lastnet=-1;	int		a, b;		if ( !kf->nets )	kf->nets = (short **) NewHandle (0);	if ( !kf->nodes )	kf->nodes = (short **) NewHandle (0);		for ( a=0; s[a] != 0 && s[a] != '\xD'; )	{		while ( !isdigit (s[a]) && s[a] != '-' && s[a] != 0 && s[a] != '\xD')			a++;					if (s[a] == 0 || s[a] == '\xD')			break;				b = atoi (s+a);		while ( isdigit (s[a]) || s[a] == '-')			a++;		if(s[a]=='/')		{			lastnet = b;			a++;			b = atoi (s+a);			while ( isdigit (s[a]) || s[a] == '-')				a++;		}		kf->items++;				SetHandleSize ( (Handle) kf->nets, (long) ((unsigned short) kf->items) * sizeof(short) );		SetHandleSize ( (Handle) kf->nodes, (long) ((unsigned short) kf->items) * sizeof(short) );				(*kf->nets)[kf->items-1] = lastnet;		(*kf->nodes)[kf->items-1] = b;				while ( s[a]==' ' || s[a]=='\t' )			a++;	}}/************************************************************														   **  				Is address in PATH & SEEN-BY ?			   **														   ************************************************************/Boolean iskfalist ( juncted *kf, addr *f ){	short		a;	for ( a = 0; a < kf->items; a++ ) 		if ( (*kf->nets)[a] == f->net && (*kf->nodes)[a] == f->node )			return TRUE;	return FALSE;}static void addkfalist ( juncted *kf, addr *f, short sbmode ){	short		a, b;	if ( !kf->nets )	kf->nets = (short **) NewHandle (0);	if ( !kf->nodes )	kf->nodes = (short **) NewHandle (0);		if(!sbmode)									// ¥ Not need sorting for ^aPATH (append)	{ 		if ( kf->items != 0 )			if ( (*kf->nets)[kf->items-1] == f->net && (*kf->nodes)[kf->items-1] == f->node ) 				return; 		 		a=kf->items;	}	else										// ¥ SEEN-BY must be major-sorted (look for mediana)		for ( a=0; a < kf->items; a++ )		{			if ( (*kf->nets)[a] > f->net )				break;			else				if ( (*kf->nets)[a] == f->net )				{					if ( (*kf->nodes)[a] > f->node )		break;	 				if ( (*kf->nodes)[a] == f->node )		return;				}		}		kf->items++;		SetHandleSize ( (Handle) kf->nets, kf->items * sizeof(short) );	SetHandleSize ( (Handle) kf->nodes, kf->items * sizeof(short) );		for ( b = kf->items-1; b > a; b-- )	{		(*kf->nets)[b] = (*kf->nets)[b-1];		(*kf->nodes)[b] = (*kf->nodes)[b-1];	}		(*kf->nets)[a] = f->net;	(*kf->nodes)[a] = f->node;}static void freekfalist ( juncted *kf ){	if ( kf->nets )		DisposeHandle ( (Handle) kf->nets );		if ( kf->nodes )		DisposeHandle ( (Handle) kf->nodes );}static char **printkfalist(char *tag, juncted *kf ){	char	**mbuf = NULL;	char	s[128], tm[64];	short	a, b, c, nalloc;	if ( kf->items == 0 ) 		return mbuf;	mbuf = NewHandle (1);	**mbuf = 0;		nalloc = 0;	b = 0;		for ( a=0; a < kf->items; a++ )	{		s[b] = 0;				if ( b == 0 )			sprintf ( tm, "%s%d/%d", tag, (*kf->nets)[a], (*kf->nodes)[a] );		else			if ( a==0 )				sprintf ( tm, "%d/%d", (*kf->nets)[a], (*kf->nodes)[a] );			else				if ( (*kf->nets)[a] != (*kf->nets)[a-1] )					sprintf ( tm, "%d/%d", (*kf->nets)[a], (*kf->nodes)[a] ); 				else					sprintf ( tm, "%d", (*kf->nodes)[a] );		if ( strlen ( s ) + strlen ( tm ) < 75 )		{			for ( c = 0; tm[c] != 0; c++ )				s[b++] = tm[c];				s[b++] = ' ';			s[b] = 0;		}		else		{			if ( b != 0 )				if ( s[b-1] == ' ' )					s[--b] = 0;	 	 		s[b++] = '\xD';	 		s[b] = 0;				nalloc += strlen (s) +1;				SetHandleSize ( mbuf, nalloc );			strcat ( *mbuf, s );			b=0;			a--;		}	}	if ( b != 0 )	{		if ( s[b-1] == ' ' )			s[--b] = 0;			s[b++] = '\xD';		s[b] = 0;			nalloc += strlen (s) + 1;				SetHandleSize ( mbuf, nalloc );				strcat ( *mbuf, s );	}	return mbuf;}//¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥/************************************************************														   **		Kill trashing 0x0A from message text body		   **														   ************************************************************/static void KillDelimiters ( char  ***txt ){	char	*src, *dst;	char	**h;	long	len;			h = NewHandle ( GetHandleSize ( *txt ) );		src = **txt;	dst = *h;	len = 0L;		do  {		if ( *src != 0x0A )		{			len++;			*(dst++) = *(src++);		}			} while ( *src );		*dst = 0;	SetHandleSize ( h, len+1 );	DisposeHandle ( *txt );	*txt = h;}static short LookForKL ( char *beg ){	short		i;		for ( i = 0; ; i++ )		if ( !kludges[i].klen )			return -1;		else			if ( !strncmp ( beg, kludges[i].kl, kludges[i].klen ) )				return i;}//	¥	mode://	¥		0	-	1st msg touch. Make internal form (full all fields in _pktmsg_). Rewrite.//	¥		1	-	For posting in base (kill kludges) or extracting from BADMAIL. Duplicate.//	¥		2	-	For posting in outbound (add new seen & path kludges). Duplicate.//	¥		3	-	For post in outbound new message (add all kludges from _pktmsg_). Duplicate.//	¥					(for creation we suppose that pktmsg exist but empty)void parse_kludges (short mode, pktmsg *m, pktmsg **d, juncted *newseen, juncted *newpath, addr *currentAka){	char			*src, *dst;	Handle			spool, h;	long			TextLen, ParaLen;	short			i, r;	long			addenum;	addr			a_temp;	unsigned long	secs;	char			temp1[64];	Handle			hVia = NULL;	long			viaPos;	DateTimeRec		dtr;	Boolean			firstvisible, isarcmail;			switch (mode)	{	case PMODE_TOUCH:	case PMODE_FORBASE:			addenum = 0;		break;	case PMODE_TRANSIT:	case PMODE_PREPNEW:			addenum = 2048;		break;	}		HLock ( m->text );	src = *m->text;		spool = NewHandleClear ( GetHandleSize (m->text) + addenum );	HLock ( spool );	dst = *spool;		if (mode == PMODE_TOUCH)				//	¥ Init free seen-by	{		m->seenby.items =	0;		m->seenby.nets =	NULL;		m->seenby.nodes =	NULL;				m->path.items =	0;		m->path.nets =		NULL;		m->path.nodes =		NULL;				m->storedtime =		0;				m->reply.zone =		0;		m->reply.net =		0;		m->reply.node =		0;		m->reply.point =	0;				m->reply_num =		0;		m->msgid_num =		0;				m->reply_str =		NULL;		m->msgid_str =		NULL;				m->reply_crc =		0;		m->msgid_crc =		0;				m->area[0] =		0;				m->base_flags =		0;	}	else	{		if ( m->seenby.items )		{			(*d)->seenby.items = m->seenby.items;			h = (Handle) m->seenby.nets;	HandToHand (&h);	(*d)->seenby.nets = (short **) h;			h = (Handle) m->seenby.nodes;	HandToHand (&h);	(*d)->seenby.nodes = (short **) h;		}		else		{			(*d)->seenby.items = 0;			(*d)->seenby.nets = NULL;			(*d)->seenby.nodes = NULL;		}				if ( m->path.items )		{			(*d)->path.items = m->path.items;			h = (Handle) m->path.nets;	HandToHand (&h);	(*d)->path.nets = (short **) h;			h = (Handle) m->path.nodes;	HandToHand (&h);	(*d)->path.nodes = (short **) h;		}		else		{			(*d)->path.items = 0;			(*d)->path.nets = NULL;			(*d)->path.nodes = NULL;		}				strcpy ( (*d)->date, m->date );		strcpy ( (*d)->subj, m->subj );		strcpy ( (*d)->area, m->area );		strcpy ( (*d)->fromname, m->fromname );		(*d)->from = m->from;		strcpy ( (*d)->toname, m->toname );		(*d)->to = m->to;		(*d)->reply = m->reply;		(*d)->storedtime = m->storedtime;				(*d)->msgid_num = m->msgid_num;		(*d)->reply_num = m->reply_num;		(*d)->msgid_crc = m->msgid_crc;		(*d)->reply_crc = m->reply_crc;		if (m->msgid_str)		{			(*d)->msgid_str = NewPtr (strlen (m->msgid_str) + 1);			strcpy ((*d)->msgid_str, m->msgid_str);		}		else			(*d)->msgid_str = NULL;				if (m->reply_str)		{			(*d)->reply_str = NewPtr (strlen (m->reply_str) + 1);			strcpy ((*d)->reply_str, m->reply_str);		}		else			(*d)->reply_str = NULL;				(*d)->base_flags = m->base_flags;				(*d)->flags = m->flags & (MSGPRIVATE | MSGCRASH |									MSGFILE | MSGUNUSED |									MSGRRREQ | MSGISRR | MSGAREQ | 0xFFFF0000L);	}		TextLen = 0;		if (mode == PMODE_PREPNEW)			//	¥	Deflorate new message :-E~	{		//	¥	Insert AreaName AREA:AREANAME\n		if ( (*d)->area[0] )		{			sprintf ( tempBuffer, "AREA:%s\xD", (*d)->area );			strcpy ( dst, tempBuffer );						i = strlen (tempBuffer);			dst += i;			TextLen += i;		}//	¥	Insert INTL... to<->from		if ( !(*d)->area[0] )		{			sprintf ( tempBuffer, "\1INTL %d:%d/%d %d:%d/%d\xD",				(*d)->to.zone, (*d)->to.net, (*d)->to.node,				(*d)->from.zone, (*d)->from.net, (*d)->from.node );				strcpy ( dst, tempBuffer );				i = strlen (tempBuffer);			dst += i;			TextLen += i;		}	//	¥	Insert to point		if ( !(*d)->area[0] && (*d)->to.point )		{			sprintf ( tempBuffer, "\1TOPT %d\xD", (*d)->to.point );				strcpy ( dst, tempBuffer );				i = strlen (tempBuffer);			dst += i;			TextLen += i;		}//	¥	Insert from point		if ( !(*d)->area[0] && (*d)->from.point )		{			sprintf ( tempBuffer, "\1FMPT %d\xD", (*d)->from.point );				strcpy ( dst, tempBuffer );				i = strlen (tempBuffer);			dst += i;			TextLen += i;		}//	¥	Set ^aMSGID		if ((*d)->msgid_str)		{			sprintf ( tempBuffer, "\1MSGID: %s\xD", (*d)->msgid_str );					strcpy ( dst, tempBuffer );			i = strlen (tempBuffer);			dst += i;			TextLen += i;		}		else		{			DebugStr ("\pSOMETHING WRONG IN 'parse_kludges'");		}		//	¥	Set ^aREPLY		if ((*d)->reply_str)		{			sprintf ( tempBuffer, "\1REPLY: %s\xD", (*d)->reply_str);			strcpy ( dst, tempBuffer );			i = strlen (tempBuffer);			dst += i;			TextLen += i;		}	//	¥	Insert flags		if (!(*d)->area[0] && ((*d)->flags & 0x7FFF0000L))		{			sprintf ( tempBuffer, "\1FLAGS %s\xD",					flags_to_string ((*d)->flags & 0x7FFF0000L, temp1 ) );				strcpy ( dst, tempBuffer );				i = strlen (tempBuffer);			dst += i;			TextLen += i;		}//	¥	Insert PID		#ifndef LITE		{			sprintf (tempBuffer, "\1PID: %s %s ", RAVELNAME, RAVELVERS);			strcpy ( dst, tempBuffer );			i = strlen (tempBuffer);			dst += i;			TextLen += i;#ifdef PROTECTED			if (*sn_fingerprint1 != '%')				ExitToShell();			sprintf (tempBuffer, sn_fingerprint1, keys.oldcrc);			strcpy ( dst, tempBuffer );			i = strlen (tempBuffer);			dst += i;			TextLen += i;			*dst = '-';			dst++;			TextLen++;			if (*sn_fingerprint2 != '%')				ExitToShell();			sprintf (tempBuffer, sn_fingerprint2, keys.oldcs);			strcpy ( dst, tempBuffer );			i = strlen (tempBuffer);			dst += i;			TextLen += i;#else			sprintf (tempBuffer, "00000000-0000");			strcpy ( dst, tempBuffer );			i = strlen (tempBuffer);			dst += i;			TextLen += i;#endif						*dst = '\xD';			dst++;			TextLen++;		}#else		{			sprintf ( tempBuffer, "\1PID: %s %s\xD", RAVELNAME, RAVELVERS );			strcpy ( dst, tempBuffer );					i = strlen (tempBuffer);			dst += i;			TextLen += i;		}#endif		//	¥	Insert fuzz		sprintf ( tempBuffer, "\1Macintosh %#s\xD", MacModel );		strcpy ( dst, tempBuffer );			i = strlen (tempBuffer);		dst += i;		TextLen += i;//	¥	Insert RealName		if (RealName[0])		{			sprintf ( tempBuffer, "\1RealName: %s\xD", &RealName[1] );			strcpy ( dst, tempBuffer );			i = strlen (tempBuffer);			dst += i;			TextLen += i;		}	}	firstvisible = true;	isarcmail = false;	while ( 1 )	{			for ( ParaLen = 0; (ParaLen < 0x8000L) && (*src != 0 && *src != 0x0D); )													// ¥ Read 32K (max) paragraph			if ( *src != 0x0A && *src != 0x8D )				tempBuffer[ParaLen++] = *(src++);	// ¥ Store all except LFs & soft LFs			else				src++;								// ¥ Skip bad chars				if ( ParaLen == 0x8000 )					// ¥ Ambigous big paragraph (>32K)...			break;				if ( *src )		{			tempBuffer[ParaLen++] = *(src++);			tempBuffer[ParaLen] = 0;		}//		else//			break;				if ( ParaLen != 0 )							// ¥ Process paragraph		{			switch ( mode )			{			case PMODE_TOUCH:		//	¥	1st touchÉ							switch ( LookForKL ( tempBuffer ) )		// ¥ Process Kludges				{	/*AREA*/	case 0:		if (firstvisible)							{								exstrcpy ( m->area, tempBuffer+5 );								strupr(m->area);								firstvisible = false;								isarcmail = true;							}							break;								/*SEEN*/	case 1:		if (isarcmail)							{								dokfalist ( &(m->seenby), tempBuffer+8 );							}							break;								/*PATH*/	case 2:		if (isarcmail)							{								dokfalist ( &(m->path), tempBuffer+6 );							}							break;								/*FMPT*/	case 3:		if (!isarcmail)							{								long	l_l;																if (sscanf(tempBuffer+6, "%ld", &l_l) > 0)									m->from.point = l_l;							}							break;	/*TOPT*/	case 4:		if (!isarcmail)							{								long	l_l;																if (sscanf(tempBuffer+6, "%ld", &l_l) > 0)									m->to.point = l_l;							}							break;	/*INTL*/	case 5:		if (!isarcmail)							{								long	l_1, l_2, l_3, l_4, l_5, l_6, num_of_args;																num_of_args = sscanf(tempBuffer+6, "%ld:%ld/%ld %ld:%ld/%ld",													&l_1, &l_2, &l_3, &l_4, &l_5, &l_6);//								sscanf(tempBuffer+6, "%d:%d/%d %d:%d/%d", &(m->to.zone),//													&(m->to.net), &(m->to.node), &(m->from.zone),//													&(m->from.net), &(m->from.node));																if (num_of_args == 6)								{									m->to.zone = l_1;									m->to.net = l_2;									m->to.node = l_3;									m->from.zone = l_4;									m->from.net = l_5;									m->from.node = l_6;								}							}							break;	/*MSGID*/	case 6:		a_temp.zone = -1;							a_temp.net = -1;							a_temp.node = -1;							a_temp.point = 0;														r = parseaddr ( &a_temp, tempBuffer+8 );														m->base_flags |= ATOM_MSGID;							m->msgid_str = NewPtr (ParaLen - 8);							memcpy (m->msgid_str, tempBuffer+8, ParaLen - 8);							m->msgid_str[ParaLen - 8 - 1] = 0;														if (a_temp.zone != -1 && a_temp.net != -1 && a_temp.node != -1)							{								m->from = a_temp;								sscanf ( tempBuffer+8+r, "%lX", &(m->msgid_num) );							}							else							{								m->msgid_crc = hash (m->msgid_str, strlen (m->msgid_str));								m->base_flags |= ATOM_NONFTNMSGID;																for (i=8; i<ParaLen; i++)									if (!tempBuffer[i] || tempBuffer[i] == ' ' || tempBuffer[i] == 0x0D)										break;																		if (tempBuffer[i] == ' ')								{									sscanf ( tempBuffer+i+1, "%lX", &(m->msgid_num) );								}							}							break;	/*REPLY*/	case 12:	a_temp.zone = -1;							a_temp.net = -1;							a_temp.node = -1;							a_temp.point = 0;														r = parseaddr ( &a_temp, tempBuffer+8 );														m->base_flags |= ATOM_REPLY;							m->reply_str = NewPtr (ParaLen - 8);							memcpy (m->reply_str, tempBuffer+8, ParaLen - 8);							m->reply_str[ParaLen - 8 - 1] = 0;														if (a_temp.zone != -1 && a_temp.net != -1 && a_temp.node != -1)							{								m->reply = a_temp;								sscanf ( tempBuffer+8+r, "%lX", &(m->reply_num) );							}							else							{								m->reply_crc = hash (m->reply_str, strlen (m->reply_str));								m->base_flags |= ATOM_NONFTNREPLY;								for (i=8; i<ParaLen; i++)									if (!tempBuffer[i] || tempBuffer[i] == ' ' || tempBuffer[i] == 0x0D)										break;																		if (tempBuffer[i] == ' ')								{									sscanf ( tempBuffer+i+1, "%lX", &(m->reply_num) );								}							}							break;	/*FLAGS*/	case 7:		m->flags |= string_to_flags ( tempBuffer+8 ); break;	/*FLAGS*/	case 16:	m->flags |= string_to_flags ( tempBuffer+9 ); break;	/*FLAGS*/	case 21:	m->flags |= string_to_flags ( tempBuffer+7 ); break;	/*CHRC*/	case 8:		ParaLen = 0; break;	/*SEEN*/	case 9:		if (isarcmail)							{								dokfalist ( &(m->seenby), tempBuffer+9 );								for (i=1; tempBuffer[i-1]; i++ )			// ¥ kill ^a									tempBuffer[i-1] = tempBuffer[i];								ParaLen--;							}							break;//¥	/*REPLYTO*/	case 13:	r = parseaddr ( &(m->from), tempBuffer+10 ); break;//¥	/*REPLYTO*/	case 14:	r = parseaddr ( &(m->from), tempBuffer+9 ); break;	/*Origin*/	case 15:	if (!isarcmail)								break;														for (i = ParaLen-1; i >= 0; i--)								if (tempBuffer[i] == '(')									break;														if (i >= 0)							{								i++;								while (!isdigit (tempBuffer[i]) && tempBuffer[i] != ')' && tempBuffer[i] != 0x0D)									i++;																if (isdigit (tempBuffer[i]))								{									m->from.zone = 0;									m->from.net = 0;									m->from.node = 0;									m->from.point = 0;									r = parseaddr ( &(m->from), tempBuffer+i );								}							}							break;											default:	if (*tempBuffer != 1)								firstvisible = false;							break;				}				break;							case PMODE_FORBASE:		//	¥	prepare for baseÉ			//								"\1AREA: ", 7,			//	17	-	internal//								"\1FROM: ", 7,			//	18	-	internal//								"\1REASON: ", 9,		//	19	-	internal//								"\1NETMAIL", 8,			//	20	-	internal				switch ( LookForKL ( tempBuffer ) )		// ¥ Process Kludges				{	/*~AREA*/	case 17:						if (currentAka)						{							exstrcpy ( (*d)->area, tempBuffer+7 );							strupr((*d)->area);							sprintf ( tempBuffer, "AREA:%s\xD", (*d)->area );							ParaLen = strlen (tempBuffer);						}						else							ParaLen = 0;												break;	/*NETM*/	case 20:						if (currentAka)						{							(*d)->area[0] = 0;						}												ParaLen = 0;						break;	/*FROM*/	case 18:						if (currentAka)						{							parseaddr ( currentAka, tempBuffer+7 );						}						ParaLen = 0;						break;				case 19:								//	kill reason	/*AREA*/	case 0:	ParaLen = 0; break;	/*SEEN*/	case 9:	/*SEEN*/	case 1:												if (!currentAka)						{							if ((*d)->area[0])							{								i = LookForAreaNumber ((*d)->area);																if (i != -1)								{									if ((*areasHndls[i-1])->areaflags & AREA_STRIPSEEN)									{										ParaLen = 0;									}								}							}						}												break;							/*PATH*/	case 2:	/*FMPT*/	case 3:	/*TOPT*/	case 4:	/*INTL*/	case 5:	/*MSGID*/	case 6:	/*FLAGS*/	case 7:	/*CHRC*/	case 8:	/*Via*/		case 11:	/*REPLY*/	case 12:	/*FLAGS*/	case 16:				default:	break;				}				break;							case PMODE_TRANSIT:		//	¥	prepare for next transactionÉ							switch ( LookForKL ( tempBuffer ) )		// ¥ Process Kludges				{	/*AREA*/	case 0:		break;	/*SEEN*/	case 1:	/*PATH*/	case 2:		ParaLen = 0; break;	/*FMPT*/	case 3:	/*TOPT*/	case 4:	/*INTL*/	case 5:	/*MSGID*/	case 6:	/*FLAGS*/	case 7:	/*FLAGS*/	case 16:	/*CHRC*/	case 8:		break;	/*SEEN*/	case 9:		ParaLen = 0; break;	/*Via*/		case 11:	//	¥ Catch Vias for future substitution...														if ( m->area[0] )								break;														if ( hVia )							{								viaPos = GetHandleSize ( hVia );								SetHandleSize ( hVia, viaPos + ParaLen );							}							else							{								viaPos = 0;								hVia = NewHandle ( ParaLen );							}														memcpy ( *hVia + viaPos, tempBuffer, ParaLen );							ParaLen = 0;														break;					default:	break;				}								break;							case PMODE_PREPNEW:		//	¥	introduce message in big crazy world				switch ( LookForKL ( tempBuffer ) )		// ¥ Process Kludges				{	/*AREA*/	case 0:	/*SEEN*/	case 1:	/*PATH*/	case 2:	/*FMPT*/	case 3:	/*TOPT*/	case 4:	/*INTL*/	case 5:	/*MSGID*/	case 6:	/*FLAGS*/	case 7:	/*FLAGS*/	case 16:	/*CHRC*/	case 8:	/*SEEN*/	case 9:		ParaLen = 0; break;				default:	break;				}				break;			}				//	¥	Copy-copy-copyÉ						if ( ParaLen )							// ¥ If kludge not killed			{										// ¥ Store paragraph				memcpy ( dst, tempBuffer, ParaLen );								dst += ParaLen;				TextLen += ParaLen;					// + 1;								if ( !*src )					break;							// ¥ NULL terminated...			}			else									// ¥ If kludge killed				if ( !*src )					break;		}		else		{			if ( !*src )				break;								// ¥ NULL terminated...			TextLen += 1;							//	20.04.97 this line swapped													//	after break for null body?		}													// ¥ Next paragraph...	}//	¥	make 2 & 3 modes with seen-by & path + add ^aVia	*(dst++) = 0;	TextLen++;	switch ( mode )	{	case 2:	case 3:			dst--;		tempBuffer[0] = 0;		if ( m->area[0] )		{			if ( newseen )					//	Need addenum seen-by?			{				for ( i = 0; i < newseen->items; i++ )				{					a_temp.net = (*newseen->nets)[i];					a_temp.node = (*newseen->nodes)[i];					addkfalist ( &(*d)->seenby, &a_temp, 1 );				}			}						if ( (*d)->seenby.items )		//	Anyway staore old seen-by.. if any.			{				if ( (h = printkfalist ( "SEEN-BY: ", &(*d)->seenby )) != NULL )				{					strcat ( tempBuffer, *h );					DisposeHandle ( h );				}			}									if ( newpath )					//	Need addenum path?			{				for ( i = 0; i < newpath->items; i++ )				{					a_temp.net = (*newpath->nets)[i];					a_temp.node = (*newpath->nodes)[i];					addkfalist ( &(*d)->path, &a_temp, 0 );				}			}						if ( (*d)->path.items )		//	Anyway store old path.. if any.			{				if ( (h = printkfalist ( "\1PATH: ", &(*d)->path )) != NULL )				{					strcat ( tempBuffer, *h );					DisposeHandle ( h );				}			}									if ( tempBuffer[0] )			{				strcpy ( dst, tempBuffer );								viaPos = strlen ( tempBuffer );				TextLen += viaPos;				dst += viaPos;			}		}		else		{			if ( hVia )			{				if ( *dst )					DebugStr ( "\pStrange incrementationÉ" );								viaPos = GetHandleSize ( hVia );				memcpy ( dst, *hVia, viaPos );								TextLen += viaPos;				dst += viaPos;								DisposeHandle ( hVia );			}			GetTime ( &dtr );			if (timezone)				sprintf ( dst, "\1Via %s @%.4d%.2d%.2d.%.2d%.2d%.2d.00.UTC%+d " SHUFFLERNAME " " RAVELVERS "\xD",						printaddr ( currentAka, tempBuffer ),						dtr.year, dtr.month, dtr.day, dtr.hour, dtr.minute, dtr.second, timezone );			else				sprintf ( dst, "\1Via %s @%.4d%.2d%.2d.%.2d%.2d%.2d.00.UTC " SHUFFLERNAME " " RAVELVERS "\xD",						printaddr ( currentAka, tempBuffer ),						dtr.year, dtr.month, dtr.day, dtr.hour, dtr.minute, dtr.second );			TextLen += strlen ( dst );		}				break;		default:			break;	}		HUnlock ( spool );	SetHandleSize ( spool, TextLen );		if ( mode == 0 )	{		DisposeHandle ( m->text );		m->text = spool;	}	else	{		(*d)->text = spool;	}}/************************************************************														   **				 Dispose message from memory			   **														   ************************************************************/void FreePktMsg ( pktmsg *p ){	if ( p )	{		if ( p->seenby.nets )	DisposeHandle ( (Handle) p->seenby.nets );		if ( p->seenby.nodes )	DisposeHandle ( (Handle) p->seenby.nodes );		if ( p->path.nets )		DisposeHandle ( (Handle) p->path.nets );		if ( p->path.nodes )	DisposeHandle ( (Handle) p->path.nodes );		if ( p->text )			DisposeHandle ( p->text );		if ( p->msgid_str )		DisposePtr ( p->msgid_str );		if ( p->reply_str )		DisposePtr ( p->reply_str );				DisposePtr ( (Ptr) p );	}}pktmsg *ClonePktMsg(pktmsg *m){	pktmsg	*res;	Handle	h;	res = (pktmsg *) NewPtrClear (sizeof (pktmsg));	memcpy(res, m, sizeof(pktmsg));		if (res->text)	{		HandToHand(&res->text);		HLock(res->text);	}	if ( m->seenby.items )	{		res->seenby.items = m->seenby.items;		h = (Handle) m->seenby.nets;	HandToHand (&h);	res->seenby.nets = (short **) h;		h = (Handle) m->seenby.nodes;	HandToHand (&h);	res->seenby.nodes = (short **) h;	}		if ( m->path.items )	{		res->path.items = m->path.items;		h = (Handle) m->path.nets;	HandToHand (&h);	res->path.nets = (short **) h;		h = (Handle) m->path.nodes;	HandToHand (&h);	res->path.nodes = (short **) h;	}		if (m->msgid_str)	{		res->msgid_str = NewPtr (strlen (m->msgid_str) + 1);		strcpy (res->msgid_str, m->msgid_str);	}		if (m->reply_str)	{		res->reply_str = NewPtr (strlen (m->reply_str) + 1);		strcpy (res->reply_str, m->reply_str);	}		return res;}/******************************************										 **	Get	next message from open file.	 **	Translate it into internal format.	 **										 ******************************************/pktmsg *GetPktMsg ( short fp, pktheader *ph ){	pktmsg		*p;	FTS1PKTMSG	Msg;	long		counter;	char		date[32],				to[64],				from[64],				subj[128];	Handle		h;			counter = sizeof (FTS1PKTMSG);	FSRead ( fp, &counter, &Msg );			if ( counter != sizeof (FTS1PKTMSG) )	{//		if (counter == 2 && Msg.Version == 0)		if (Msg.Version == 0)			return ((pktmsg *) -1);		else			return NULL;	}		p = (pktmsg *) NewPtr ( sizeof(pktmsg) );	if ( !p )		return NULL;	p->fromname[0] =	0;	p->from.point =		0;		//	-1;	p->from.node =		0;		//	-1;	p->from.net =		0;		//	-1;	p->toname[0] =		0;	p->to.point =		0;		//	-1;	p->to.node =		0;		//	-1;	p->to.net =			0;		//	-1;	p->from.zone =		ph->from.zone;	p->to.zone =		ph->to.zone;	p->reply.zone =		0;		//	-1;	p->reply.point =	0;		//	-1;	p->reply.node =		0;		//	-1;	p->reply.net =		0;		//	-1;	p->flags =			0;	p->date[0] =		0;	p->subj[0] =		0;	p->text =			NULL;	p->area[0] =		0;		p->seenby.items =	0;	p->path.items =		0;		p->seenby.nets =	NULL;	p->seenby.nodes =	NULL;	p->path.nets =		NULL;	p->path.nodes =		NULL;	p->storedtime = 0;	if ( endshort (Msg.Version) != 2 )	{		putlog (lgALRT, "Bad message version (%d) inside PKT. Flush to rest.", endshort (Msg.Version));		DisposePtr ( (Ptr) p );		if ( !get_ASCIIZ ( fp, date, MDate ) ||			 !get_ASCIIZ ( fp, to, MName ) ||			 !get_ASCIIZ ( fp, from, MName ) ||			 !get_ASCIIZ ( fp, subj, MSubject ) )			return NULL;		h = (char **) NewHandle ( 0 );		if ( !get_pkt_text ( fp, h ) )			return NULL;		DisposeHandle (h);		return NULL;	}	p->from.node =		endshort (Msg.OrigNode);	p->to.node =		endshort (Msg.DestNode);	p->from.net =		endshort (Msg.OrigNet);	p->to.net =			endshort (Msg.DestNet);	p->flags =			((long)(endshort (Msg.Attr))) & 0x0000FFFFL;	if ( !get_ASCIIZ ( fp, date, MDate ) ||		 !get_ASCIIZ ( fp, to, MName ) ||		 !get_ASCIIZ ( fp, from, MName ) ||		 !get_ASCIIZ ( fp, subj, MSubject ) )	{		DisposePtr ( (Ptr) p );		return NULL;	}		p->text = (char **) NewHandle ( 0 );		if ( !get_pkt_text ( fp, p->text ) )	{		DisposeHandle ( p->text );		DisposePtr ( (Ptr) p );		return NULL;	}	strcpy ( p->date, date );	strcpy ( p->toname, to );	strcpy ( p->fromname, from );	strcpy ( p->subj, subj );	parse_kludges ( PMODE_TOUCH, p, NULL, NULL, NULL, NULL );	p->flags &= ~(MSGLOCAL | MSGSENT | MSGREAD);	return p;}/************************************************************														   **    Add message to opened PKT file message from memory	   **														   ************************************************************/void AddMessageToPKTFile ( short pktRefNum, pktmsg *m, addr *from ){	FTS1PKTMSG		Msg;	long			counter;	unsigned short	tmp;				GetEOF ( pktRefNum, &counter );	SetFPos ( pktRefNum, fsFromStart, counter );	//	¥ Write MSG header.		Msg.Version		= endshort (0x0002);	Msg.OrigNode	= endshort (m->from.node);	Msg.DestNode	= endshort (m->to.node);	Msg.OrigNet		= endshort (m->from.net);	Msg.DestNet		= endshort (m->to.net);		tmp				= m->flags;	Msg.Attr		= endshort (tmp);		Msg.Cost		= 0;		counter = sizeof (FTS1PKTMSG);	FSWrite ( pktRefNum, &counter, &Msg );	counter = strlen ( m->date ) + 1;	FSWrite ( pktRefNum, &counter, m->date );	counter = strlen ( m->toname ) + 1;	FSWrite ( pktRefNum, &counter, m->toname );	counter = strlen ( m->fromname ) + 1;	FSWrite ( pktRefNum, &counter, m->fromname );	counter = strlen ( m->subj ) + 1;	FSWrite ( pktRefNum, &counter, m->subj );//	¥ Write msg body text	counter = GetHandleSize ( m->text );		if (counter != strlen (*m->text) + 1)		putlog (lgALRT, "Internal massage's text size mismatch (%ld ­ %ld)! Call CyrilÉ", counter, strlen (*m->text));		FSWrite ( pktRefNum, &counter, *m->text );}void AddPKTHeadToPKTFile ( short pktRefNum, pktheader *p ){	struct _pkthdr		packet;	struct _pkthdr39	*pkt0039;	struct _pkthdr45	*pkt0045;	long		counter;	short		a;//	putlog (lgALRT, "MAKING %.4X", p->pkttype);	memset ((char *) &packet, 0, sizeof (struct _pkthdr));	packet.ver = endshort (2);	packet.orig_zone = endshort (p->from.zone);	packet.dest_zone = endshort (p->to.zone);		packet.orig_net = endshort (p->from.net);	packet.dest_net = endshort (p->to.net);	packet.orig_node = endshort (p->from.node);	packet.dest_node = endshort (p->to.node);	for ( a=0; a<8; a++ )		packet.password[a] = p->passwd[a];	switch (p->pkttype)	{	case 0x0000:		//	FTS-0001	case 0x0200:		//	Type 2	case 0x02FF:		//	Type 2+	case 0x0201:		//	QMail			packet.year = endshort (p->year);		packet.month = endshort (p->month-1);		packet.day = endshort (p->day);		packet.hour = endshort (p->hour);		packet.minute = endshort (p->min);		packet.second = endshort (p->sec);		packet.orig_zone = endshort (p->from.zone);		packet.dest_zone = endshort (p->to.zone);		packet.product = PRODUCT_LO;		packet.serial = MAJOR_VRS;		if (p->pkttype == 0x0000)			break;			pkt0039 = (struct _pkthdr39 *) &packet;			pkt0039->orig_point = endshort (p->from.point);		pkt0039->dest_point = endshort (p->to.point);		pkt0039->orig_zone = endshort (p->from.zone);		pkt0039->dest_zone = endshort (p->to.zone);		pkt0039->product_low = PRODUCT_LO;		pkt0039->product_hi = PRODUCT_HI;		pkt0039->prod_rev_hi = MAJOR_VRS;		pkt0039->prod_rev_low = MINOR_VRS;		pkt0039->CapWord = endshort (0x0001);		pkt0039->CapValid = 0x0001;		pkt0039->qm_orig_zone = endshort (p->from.zone);		pkt0039->qm_dest_zone = endshort (p->to.zone);			if (p->pkttype == 0x02FF)		{			if (p->from.point != 0)			{				packet.orig_net = -1;				pkt0039->auxnet = endshort (p->from.net);			}		}				if (p->pkttype != 0x0201)			break;		pkt0039->orig_point = 0;		pkt0039->dest_point = 0;				break;		case 0x0220:		//	Type 2.2						//	Put screw upto Domains.			pkt0045 = (struct _pkthdr45 *) &packet;		pkt0045->orig_point = endshort (p->from.point);		pkt0045->dest_point = endshort (p->to.point);		pkt0045->orig_zone = endshort (p->from.zone);		pkt0045->dest_zone = endshort (p->to.zone);		pkt0045->subver = endshort (2);		break;	}	counter = sizeof (struct _pkthdr);	FSWrite ( pktRefNum, &counter, &packet );}/************************************************************														   **	Read PKT header	from opened	file and dismantle it to   **	internal dynamical structures						   **														   ************************************************************/pktheader *GetPktHeader ( short fp ){	pktheader	*p;	short		a;	struct _pkthdr		packet;	struct _pkthdr39	*pkt0039;	struct _pkthdr45	*pkt0045;		long		counter;			counter = sizeof (struct _pkthdr);	FSRead ( fp, &counter, &packet );	if ( counter != sizeof (struct _pkthdr) )		return NULL;	if ( endshort (packet.ver) != 2 )	{		putlog (lgALRT, "Bad PKT version (%d)", endshort (packet.ver));		return NULL;	}		p = (pktheader *) NewPtrClear ( sizeof (pktheader) );		p->from.point =		0;		//	-1;;	p->from.node =		0;		//	-1;;	p->from.zone =		0;		//	-1;;	p->from.net =		0;		//	-1;;	p->to.point =		0;		//	-1;;	p->to.node =		0;		//	-1;;	p->to.zone =		0;		//	-1;;	p->to.net =			0;		//	-1;;	//	¥	In all PKT's is here		p->from.node =	endshort (packet.orig_node);	p->to.node =	endshort (packet.dest_node);	p->from.net =	endshort (packet.orig_net);	p->to.net =		endshort (packet.dest_net);	p->passwd[8]=0; 	for ( a=0; a<8; a++ )		if (packet.password[a] && packet.password[a] != ' ')			p->passwd[a] = packet.password[a];		else			p->passwd[a] = 0;		if (endshort (packet.rate) == 2)	{//	¥	Type 2.2 Packet (FSC-0045)			p->pkttype = 0x0220;		pkt0045 = (struct _pkthdr45 *) &packet;			p->from.zone = endshort (pkt0045->orig_zone);		p->from.point = endshort (pkt0045->orig_point);		p->to.zone = endshort (pkt0045->dest_zone);		p->to.point = endshort (pkt0045->dest_point);		p->year = 0;		p->month = 0;		p->day = 0;		p->hour = 0;		p->min = 0;		p->sec = 0;		p->productCode = (unsigned short) pkt0045->product;		p->productRev = (unsigned short) pkt0045->serial;	}	else	{//	¥	Type 2 Pakcet (ariations)			pkt0039 = (struct _pkthdr39 *) &packet;			p->year = endshort (pkt0039->year);		p->month = endshort (pkt0039->month);		p->day = endshort (pkt0039->day);		p->hour = endshort (pkt0039->hour);		p->min = endshort (pkt0039->minute);		p->sec = endshort (pkt0039->second);		if ((endshort ((pkt0039->CapWord) & 0x7F7F) == ((pkt0039->CapValid) & 0x7F7F)) &&			(((pkt0039->CapValid) & 0x0001) == 0x0001))		{//	¥	Type 2 or Type 2+ Packet					p->pkttype = 0x0200;//	¥	FSC-0039////	Code Name - Uses QOrg/QDstZone Orig/DestZone Orig/DestPoint//	---- ----------- ------------- ------------- --------------//	0x0C  FrontDoor  Reads/Updates      Yes           Yes//	0x1A  DBridge        ?????          Yes           Yes//	0x45  XRS        Reads/Updates      Yes           Yes//	0x29  QMail           Yes          ?????      Not point-aware//	0x35  ZMailQ          Yes          ?????      Not point-aware//	0x3F  TosScan    Reads/Updates      Yes           Yes			if (pkt0039->orig_zone)				p->from.zone = endshort (pkt0039->orig_zone);			else				p->from.zone = endshort (packet.orig_zone);			if (pkt0039->dest_zone)				p->to.zone = endshort (pkt0039->dest_zone);			else				p->to.zone = endshort (packet.dest_zone);						p->from.point = endshort (pkt0039->orig_point);			p->to.point = endshort (pkt0039->dest_point);			p->productCode = (pkt0039->product_hi << 8) | pkt0039->product_low;			p->productRev = (pkt0039->prod_rev_hi << 8) | pkt0039->prod_rev_low;						if (p->productCode == 0x0029 ||				p->productCode == 0x0035)			{				p->pkttype = 0x0201;					//	Overwrite to QMail Type 2				p->from.zone = endshort (pkt0039->qm_orig_zone);				p->to.zone = endshort (pkt0039->qm_dest_zone);				p->from.point = 0;				p->to.point = 0;			}			else			{				if (p->from.net == -1 && p->from.point != 0)				{		//	¥	Type 2+	Overwrite orig_net							p->pkttype = 0x02FF;					p->from.net = endshort (pkt0039->auxnet);				}			}		}		else		{			p->pkttype = 0x0000;		//	FTS-0001					p->from.zone = endshort (packet.orig_zone);			p->to.zone = endshort (packet.dest_zone);			p->from.point = 0;			p->to.point = 0;//			p->from.point = packet.orig_point;//			p->to.point = packet.dest_point;			p->productCode = (unsigned short) packet.product;			p->productRev = (unsigned short) packet.serial;		}	}	return p;}/************************************************************														   **				Dispose PKT header from memory			   **														   ************************************************************/void FreePktHeader ( pktheader *p ){	DisposePtr ( (Ptr) p );}void add_to_other (pktmsg *m, char *dest, addr *from, char *reason){	pktmsg	*m2nd;	char	tmp[256], temp[128];	Handle	text;		m2nd = (pktmsg *) NewPtr ( sizeof (pktmsg) );	strcpy (tmp, m->area);		//¥	preserve old area	strcpy (m->area, dest);		//¥	make as we operate with other		parse_kludges (PMODE_FORBASE, m, &m2nd, NULL, NULL, NULL);	strcpy (m->area, tmp);		//¥	restore, ñóêà-áëßäü-íàõóé, äîñòàëî!	text = NewHandle (0L);	if (m->area[0])	{		sprintf (tmp, "\1AREA: %s\r", m->area);		PtrAndHand (tmp, text, strlen (tmp));	}	else	{		sprintf (tmp, "\1NETMAIL\r");		PtrAndHand (tmp, text, strlen (tmp));	}		if (from)	{		sprintf (tmp, "\1FROM: %s\r", printaddr (from, temp));		PtrAndHand (tmp, text, strlen (tmp));	}	if (reason)	{		sprintf (tmp, "\1REASON: %s\r", reason);		PtrAndHand (tmp, text, strlen (tmp));	}	HLock (m2nd->text);		PtrAndHand (*(m2nd->text), text, strlen (*(m2nd->text))+1);		DisposeHandle (m2nd->text);		m2nd->text = text;	tmpbase_add (m2nd);	FreePktMsg ( m2nd );}Boolean cmp2addrs ( addr *my1, addr *my2 ){	return ( my1->zone == my2->zone &&			 my1->net == my2->net &&			 my1->node == my2->node &&			 my1->point == my2->point );}