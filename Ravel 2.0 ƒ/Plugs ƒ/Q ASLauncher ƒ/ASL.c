/*•••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••	Copyright © 1996-1997 Cyril Moorzin		При использовании исходных текстов SDK указание Copyright © 1996-1997 Cyril Moorzin		обязательно.		Так же при генерации писем обязательно упоминание название пакета Ravel в tearline.				Ravel SDK поставляется в виде "as is". Автор не несет ответственности за		несовместимость Plug-Ins в будущих версиях RavelSHUFFLER при использовании		undewater приемов программирования.				Не существует НИКАКОЙ документации по Ravel SDK.		Так же автор пока отказался от распространения исходных текстов не только работы		с базой сообщений, но и старых релизов RavelQUILL.  •••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••*/#include <Sound.h>#include <stdio.h>#include <stdlib.h>#include <string.h>#include <A4Stuff.h>#include "ravel_msg_base.h"#include "stringutl.h"#include "Prefs.h"#include "PascalStr.h"#include "Ravel_Quill_PlugIns.h"#include "ReadConfig.h"#define kFinderSig			'FNDR'#define kAEFinderEvents		'FNDR'#define kSystemType			'MACS'#define	kAEOpenSelection	'sope'#define keySelection		'fsel'static	char				**invokers = NULL;static	Boolean				gAllowUnlock = false;static	char				*gForceUnlock = "RESTORE LOCK";static	PlugsQControlPtr	gPC = NULL;static OSErr ApplicationLaunch (FSSpec *spec, Boolean canSwitch){	short				iErr;	LaunchParamBlockRec	myLaunchParams;	AppleEvent		event, reply;	AEAddressDesc	address;	myLaunchParams.launchBlockID = extendedBlock;	myLaunchParams.launchEPBLength = extendedBlockLen;	myLaunchParams.launchFileFlags = 0;	myLaunchParams.launchControlFlags = launchContinue | launchNoFileFlags | ((canSwitch) ? launchDontSwitch : 0);	myLaunchParams.launchAppSpec = spec;	myLaunchParams.launchAppParameters = NULL;	iErr = LaunchApplication (&myLaunchParams);	return iErr;}#pragma mark -static OSErr SendFinderOpenAE(FSSpec *theDoc, Boolean canSwitch){AppleEvent			aeEvent;AEDesc				myAddressDesc;AEDesc				aeDirDesc;AEDesc				listElem;AEDescList			fileList;FSSpec				dirSpec;AliasHandle			dirAlias;AliasHandle			fileAlias;ProcessSerialNumber	process;OSErr				myErr;OSType				FndrType = 'MACS';		if (gPC == NULL)		return -1;		/*	 * Get the psn of the Finder and create the target address for the AE	 */		if ( gPC->FindAProcess( kFinderSig, kSystemType, &process) )		return( procNotFound );	myErr = AECreateDesc( typeProcessSerialNumber, (Ptr)&process, 							sizeof(process), &myAddressDesc);	if (myErr) return(myErr);		/*	 * Create an empty Apple Event	 */		myErr = AECreateAppleEvent( kAEFinderEvents, kAEOpenSelection, &myAddressDesc,								kAutoGenerateReturnID, kAnyTransactionID, &aeEvent);		if (myErr) return(myErr);		/*	 * Make and FSSpec for the parent folder and an alias of the file.	 */		FSMakeFSSpec( theDoc->vRefNum, theDoc->parID, 0L, &dirSpec);	NewAlias( nil, &dirSpec, &dirAlias);	NewAlias( nil, theDoc, &fileAlias);			/*	 * Create the File list.	 *	 */		HLockHi( (Handle)dirAlias);	AECreateDesc( typeAlias, (Ptr)*dirAlias, GetHandleSize( (Handle)dirAlias), &aeDirDesc);	HUnlock( (Handle)dirAlias);	DisposeHandle( (Handle)dirAlias);		if ( (myErr=AEPutParamDesc(&aeEvent, keyDirectObject, &aeDirDesc)) == noErr )	{		AEDisposeDesc( &aeDirDesc );				AECreateList(nil, 0, false, &fileList);		HLockHi( (Handle)fileAlias);		myErr = AECreateDesc( typeAlias, (Ptr)*fileAlias, 									GetHandleSize( (Handle)fileAlias), &listElem);		HUnlock( (Handle)fileAlias);		DisposeHandle( (Handle)fileAlias);			myErr = AEPutDesc( &fileList, 0L, &listElem);				if (myErr) return(myErr);			}	if (myErr) return(myErr);		AEDisposeDesc(&listElem);		myErr = AEPutParamDesc(&aeEvent, keySelection, &fileList);	if (myErr) return(myErr);	myErr = AEDisposeDesc( &fileList);	if (myErr) return(myErr);		myErr = AESend( &aeEvent, 0L, kAENoReply | kAEAlwaysInteract | ((!canSwitch)? kAECanSwitchLayer : 0),					kAENormalPriority, kAEDefaultTimeout, 0L, 0L);					AEDisposeDesc(&aeEvent);		myErr = SetFrontProcess( &process );		return(myErr);}#pragma mark -static OSErr _AEGetDescData(	const AEDesc	*inDesc,	void*			inDataPtr,	Size			inMaxSize){#if ACCESSOR_CALLS_ARE_FUNCTIONS	return ::AEGetDescData(inDesc, inDataPtr, inMaxSize);	#else		// We need to extract the data ourselves by directly accessing		// the Handle within the AE descriptor	OSErr	err = errAEDescIsNull;		if (inDesc->dataHandle != nil) {		Size	bytesToCopy	= inMaxSize;		Size	dataSize	= GetHandleSize(inDesc->dataHandle);				if (dataSize < bytesToCopy) {			bytesToCopy = dataSize;		}				BlockMoveData(*(inDesc->dataHandle), inDataPtr, bytesToCopy);		err = noErr;	}		return err;#endif}static OSStatus GetData(AEDesc *inDesc, DescType inDescType, void* inDataPtr, Size inMaxSize){	OSStatus err = noErr;	AEDesc*	descPtr = inDesc;	AEDesc	coerceDesc;		if (inDesc->descriptorType != inDescType) {				// Input descriptor has a type that is different from			// the desired data type. Try to coerce it.			if ((err = AECoerceDesc(inDesc, inDescType, &coerceDesc)) != noErr)		{			return err;	// Coercion failed		}				descPtr = &coerceDesc;				// Use coerced descriptor	}		err = _AEGetDescData(descPtr, inDataPtr, inMaxSize);		return err;}static OSErr DoScript(char *theScript, AEDesc *resultText, Boolean canSwitch){	ComponentInstance	scriptingComponent;	AEDesc				componentName, scriptText;	OSAID				scriptID, resultID;	OSAError			myOSAError, ignoreErr;	OSErr				err;		scriptingComponent = OpenDefaultComponent( kOSAComponentType, kOSAGenericScriptingComponentSubtype );	myOSAError = OSAScriptingComponentName( scriptingComponent, &componentName );	if( myOSAError == noErr )	{		err = AECreateDesc( typeChar, theScript, strlen( theScript ), &scriptText );		if( err == noErr )		{			scriptID = kOSANullScript;			myOSAError = OSACompile( scriptingComponent, &scriptText, kOSAModeNull, &scriptID );					if( myOSAError == noErr )			{				myOSAError = OSAExecute( scriptingComponent, scriptID, kOSANullScript, kOSAModeCanInteract | ((!canSwitch)? 0 : kOSAModeCantSwitchLayer) /*kOSAModeNull*/, &resultID );				ignoreErr = OSADispose( scriptingComponent, scriptID );				if( myOSAError == noErr )				{					myOSAError = OSADisplay(scriptingComponent, resultID, typeChar, kOSAModeDisplayForHumans, resultText);					ignoreErr = OSADispose( scriptingComponent, resultID );				}			}			ignoreErr = AEDisposeDesc( &scriptText );		}	}		return myOSAError;}static	Str255	gScripts;static OSErr LoadScript(char *theScriptName, char **scriptSource){	Str255	scrpath;	short	fRefNum;	long	len, counter;	OSErr	result = -1;		*scriptSource = NULL;		pStrCopy(gScripts, scrpath);	memcpy(&scrpath[scrpath[0]+1], theScriptName, strlen(theScriptName));	scrpath[0] += strlen(theScriptName);		if (FSOpen (scrpath, 0, &fRefNum))		return -1;	GetEOF (fRefNum, &len);		if (len > 0 && (*scriptSource = NewPtrClear (len+1)))	{		counter = len;		FSRead (fRefNum, &counter, *scriptSource);		result = noErr;	}	FSClose ( fRefNum );	return result;}#pragma mark -void main (PlugsQControlPtr plugcontrol){	long		res;	short		ownFile, oldRes;	Handle		h;	pktmsg		*m;	DateTimeRec	dtr;	char		stemp[512];	Str255		plugcfg;	EnterCodeResource ();	gPC = plugcontrol;	switch (plugcontrol->opCode)	{	case plugWelcome:		//	StartUp call of plug-ins. We make order and init. prefs.				pStrCopy (plugcontrol->thisplugPath, plugcfg);		pStrConc (plugcfg, "\p.cfg", plugcfg);		pStrCopy (plugcontrol->thisplugPath, gScripts);		pStrConc (gScripts, "\p.scripts:", gScripts);				if (ReadConfig(plugcfg) >= 0 &&			gLexData != NULL &&			count_lex_data(gLexData) > 0)		{			lex_data	*ld = gLexData;			short		j, i, k, items = count_lex_data(gLexData);			invokers = calloc(items + 1, sizeof(char *));			for (i = 0, k = 0; i < items && ld != NULL; i++)			{				if (ld->mode > 3)				{					gAllowUnlock = true;					invokers[k++] = gForceUnlock;				}				else				{					invokers[k++] = ld->menuname;										for (j = 0; j < 16 && ld->menuname[j] != 0 && ld->menuname[j] != '/'; j++)						ld->cmpname[j] = ld->menuname[j];					ld->cmpname[j] = 0;				}				ld = ld->next;			}						plugcontrol->putlog ('=', "<ASL " RAVELISA "> Installed.");			res = plugCustomLaunch | plugCustomNames;		}		break;		case plugSuicide:				free_lex_data(gLexData);		break;		case plugCustomNames:			plugcontrol->misc.names.plugInvokeNames = invokers;		res = plugRetContinue;		break;		case plugCustomLaunch:				{			if (gAllowUnlock &&				strcasecmp(plugcontrol->misc.plugInvokeName, gForceUnlock) == 0)			{				if ((plugcontrol->apiRev & 0x8000) == 0 ||					plugcontrol->apiRev < kCurrentQPlugAPI)				{					plugcontrol->putlog('!', "<ASL> requeres newer version of RavelQUILL to unlock base.");				}				else				{					plugcontrol->SimulateScanComplete();				}			}			else			{				lex_data *ld = find_lex_data(gLexData, plugcontrol->misc.plugInvokeName);				if (ld)				{					char	*scriptcode = NULL;					FSSpec	exeSpec;					Str255	exePath;					OSErr	err = noErr;										switch (ld->mode)					{					case 1:											if ((err = LoadScript(ld->exename, &scriptcode)) == noErr)						{							AEDesc	resultText;														if ((ld->flags & 2) != 0)							{								if ((plugcontrol->apiRev & 0x8000) == 0 ||									plugcontrol->apiRev < kCurrentQPlugAPI)								{									plugcontrol->putlog('!', "<ASL> requeres newer version of RavelQUILL to unlock base.");								}								else								{									plugcontrol->PrepareUnlock();									plugcontrol->PerformUnlock();								}							}														err = DoScript(scriptcode, &resultText, (ld->flags & 1) != 0);							if (err == noErr)							{								memset(stemp, 0, 512);								if (GetData(&resultText, typeChar, stemp, 511) == noErr &&										strlen(stemp) > 0)								{									long	areanumber, fieldid;																		fieldid = plugcontrol->getFrontWindowType(&areanumber);									if (fieldid == wIDMsgEdit)									{										WinCom	WCP;										struct _TECommand	TEC;																			WCP.arg.TEC = &TEC;										WCP.command = teCmdGetFieldID;										plugcontrol->sendCommandToWindow (fieldid, areanumber, &WCP);																				if (WCP.arg.TEC->fieldnumber == 0)										{											WCP.command = teCmdInsertText;											WCP.arg.TEC->text = stemp;											WCP.arg.TEC->textlen = strlen(stemp);											plugcontrol->sendCommandToWindow (fieldid, areanumber, &WCP);											WCP.command = teCmdScrollToVisible;											plugcontrol->sendCommandToWindow (fieldid, areanumber, &WCP);										}									}								}								AEDisposeDesc(&resultText);							}							DisposePtr(scriptcode);							if ((ld->flags & 2) != 0)							{								if ((plugcontrol->apiRev & 0x8000) == 0x8000 &&									plugcontrol->apiRev >= kCurrentQPlugAPI)								{									plugcontrol->SimulateScanComplete();								}							}						}						else							err = 1;						break;										case 2:												memcpy(&exePath[1], ld->exename, exePath[0] = strlen(ld->exename));						if ((err = FSMakeFSSpec(0, 0, exePath, &exeSpec)) == noErr)						{							if (gAllowUnlock)								if ((ld->flags & 2) != 0)								{									if ((plugcontrol->apiRev & 0x8000) == 0 ||										plugcontrol->apiRev < kCurrentQPlugAPI)									{										plugcontrol->putlog('!', "<ASL> requeres newer version of RavelQUILL to unlock base.");									}									else									{										plugcontrol->PrepareUnlock();										plugcontrol->PerformUnlock();									}								}							err = SendFinderOpenAE(&exeSpec, (ld->flags & 1) != 0);						}						else							err = 2;												break;					case 3:												memcpy(&exePath[1], ld->exename, exePath[0] = strlen(ld->exename));						if ((err = FSMakeFSSpec(0, 0, exePath, &exeSpec)) == noErr)						{							if (gAllowUnlock)								if ((ld->flags & 2) != 0)								{									if ((plugcontrol->apiRev & 0x8000) == 0 ||										plugcontrol->apiRev < kCurrentQPlugAPI)									{										plugcontrol->putlog('!', "<ASL> requeres newer version of RavelQUILL to unlock base.");									}									else									{										plugcontrol->PrepareUnlock();										plugcontrol->PerformUnlock();									}								}							err = ApplicationLaunch(&exeSpec, (ld->flags & 1) != 0);						}						else							err = 3;												break;					}										if (err != noErr)					{						if (err > 0)							sprintf(stemp, "<ASL> Mode: %ld, Executable file/script not found", ld->mode);						else							sprintf(stemp, "<ASL> Mode: %ld, OSErr: %ld", ld->mode, (long)err);						plugcontrol->putlog('!', stemp);						SysBeep(10);					}					res = plugRetNoError;				}				else					res = plugRetWrongCustom;			}		}		break;		default:				//	We're ignoring all other opCodes							//	(by the way, it's impossible unordered calls)			res = plugRetContinue;		break;	}		plugcontrol->retCode = res;	ExitCodeResource ();	}