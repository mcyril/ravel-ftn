/*•••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••	Copyright © 1996-1997 Cyril Moorzin		При использовании исходных текстов SDK указание Copyright © 1996-1997 Cyril Moorzin		обязательно.		Так же при генерации писем обязательно упоминание название пакета Ravel в tearline.				Ravel SDK поставляется в виде "as is". Автор не несет ответственности за		несовместимость Plug-Ins в будущих версиях RavelSHUFFLER при использовании		undewater приемов программирования.				Не существует НИКАКОЙ документации по Ravel SDK.		Так же автор пока отказался от распространения исходных текстов не только работы		с базой сообщений, но и старых релизов RavelQUILL.  •••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••*/#include <string.h>//#include <stdio.h>#include <A4Stuff.h>#include "ravel_msg_base.h"#include "Ravel_Prefs.h"#include "PascalStr.h"#include "Ravel_PlugIns.h"#include "StuffItEngineLib.h"static	SInt32	gMagicCookie = 0;void main (PlugsControlPtr plugcontrol){	long		cummulative;	OSErr		err;	SInt16		version, theArcType;	short		oldRes;	EnterCodeResource ();	oldRes = CurResFile ();//	Debugger ();	switch (plugcontrol->opCode)	{	case plugWelcome:		//	StartUp call of plug-ins. We make order and init. prefs.				plugcontrol->retCode = 0L;			//	Decompressor failed		while (StuffItEngineAvailable())		{			cummulative = 0;						err = OpenSITEngine (kUseExternalEngine, &gMagicCookie);			if (err != noErr)				break;						version = GetSITEngineVersion(gMagicCookie);			if (version < 0x0400)				break;			else if (version < 0x0500)				cummulative = arcZIP | arcARC;			else if (version < 0x0600)				cummulative = arcZIP | arcARC | arcLZH;			else				cummulative = arcZIP | arcARC | arcLZH | arcRAR;						if (cummulative)			{				plugcontrol->retCode = plugCompExtr;			//	Decompressor				plugcontrol->misc.arc.archiveType = cummulative;				plugcontrol->misc.arc.archiveAction = arcExpand;			}					break;		}				if (plugcontrol->retCode)		{			char	tmp[256];			strcpy (tmp, "<SIE™ Extract " RAVELISA "> Installed (");						if (plugcontrol->misc.arc.archiveType & arcZIP)				strcat (tmp, " ZIP");			if (plugcontrol->misc.arc.archiveType & arcRAR)				strcat (tmp, " RAR");			if (plugcontrol->misc.arc.archiveType & arcARC)				strcat (tmp, " ARC");			if (plugcontrol->misc.arc.archiveType & arcLZH)				strcat (tmp, " LHA");						strcat (tmp, " ).");			plugcontrol->putlog ('±', tmp);		}		else		{			plugcontrol->putlog ('±', "<SIE™ Extract " RAVELISA "> failed.");		}		break;			case plugCompExtr:	//	We ordered only one call - Extract archive				err = -1;		theArcType = kFileTypeUnknown;		if (plugcontrol->misc.arc.archiveType == arcZIP)			theArcType = kFileTypeZIP;		else if (plugcontrol->misc.arc.archiveType == arcRAR)			theArcType = kFileTypeRar;		else if (plugcontrol->misc.arc.archiveType == arcARC)			theArcType = kFileTypeARC;		else if (plugcontrol->misc.arc.archiveType == arcLZH)			theArcType = kFileTypeLHa;		if (theArcType != kFileTypeUnknown)			err = ExpandFSSpec (gMagicCookie,								theArcType,								plugcontrol->source,								plugcontrol->destination,								NULL,								kCreateFolderNever,								false,								kTextConvertNever);		plugcontrol->retCode = (err == noErr) ? plugRetContinue : plugFatalArch;		break;	case plugSuicide:		//	Ignore in this case.			if (gMagicCookie)			CloseSITEngine(gMagicCookie);		break;	default:				//	We're ignoring all other opCodes							//	(by the way, it's impossible unordered calls)		plugcontrol->retCode = plugFatalArch;		break;	}	UseResFile(oldRes);	ExitCodeResource ();	}