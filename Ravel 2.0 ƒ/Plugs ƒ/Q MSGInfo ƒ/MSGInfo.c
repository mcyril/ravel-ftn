/*•••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••	Copyright © 1996-1997 Cyril Moorzin		При использовании исходных текстов SDK указание Copyright © 1996-1997 Cyril Moorzin		обязательно.		Так же при генерации писем обязательно упоминание название пакета Ravel в tearline.				Ravel SDK поставляется в виде "as is". Автор не несет ответственности за		несовместимость Plug-Ins в будущих версиях RavelSHUFFLER при использовании		undewater приемов программирования.				Не существует НИКАКОЙ документации по Ravel SDK.		Так же автор пока отказался от распространения исходных текстов не только работы		с базой сообщений, но и старых релизов RavelQUILL.  •••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••*/#include <Sound.h>#include <stdio.h>#include <stdlib.h>#include <string.h>#include <A4Stuff.h>#include "ravel_msg_base.h"#include "stringutl.h"#include "Prefs.h"#include "PascalStr.h"#include "Ravel_Quill_PlugIns.h"#include "DialogLib.h"#include "MoreDialogs.h"static	char				*gInvokers[] = {"Message Info/=", NULL};static	char				*gComporator = "Message Info";static	PlugsQControlPtr	gPC = NULL;static	FSSpec				gThisPlugSpec;void main (PlugsQControlPtr plugcontrol){	long		res = 0;	short		ownFile, oldRes;	Handle		h;	pktmsg		*m;	DateTimeRec	dtr;	char		stemp[512];	Str255		plugcfg;	EnterCodeResource ();	gPC = plugcontrol;	switch (plugcontrol->opCode)	{	case plugWelcome:		//	StartUp call of plug-ins. We make order and init. prefs.				if (FSMakeFSSpec(0, 0, plugcontrol->thisplugPath, &gThisPlugSpec) != noErr)		{			plugcontrol->putlog('!', "<MSGInfo> cannot find itself's resources.");			res = 0;			break;		}		plugcontrol->putlog ('=', "<MSGInfo " RAVELISA "> Installed.");		res = plugCustomLaunch | plugCustomNames;		break;		case plugSuicide:				break;		case plugCustomNames:			plugcontrol->misc.names.plugInvokeNames = gInvokers;		res = plugRetContinue;		break;		case plugCustomLaunch:				if (strcasecmp(plugcontrol->misc.plugInvokeName, gComporator) == 0)		{			short		homeResFile, oldResFile = CurResFile();			GrafPtr		oldPort;			DialogPtr	dlg;			short		result;			WinCom		WCP;			struct _MSGCommand	MSG;			long		areanumber, fieldid;						fieldid = plugcontrol->getFrontWindowType(&areanumber);			if (fieldid != wIDMsgView && fieldid != wIDSubjects)				break;			WCP.arg.MSG = &MSG;			MSG.msg = NULL;			WCP.command = msgCmdGetMessage;			res = plugcontrol->sendCommandToWindow (fieldid, areanumber, &WCP);			if (res < 0 || MSG.msg == NULL)				break;						homeResFile = FSpOpenResFile (&gThisPlugSpec, fsRdPerm);			if (homeResFile != -1)			{				UseResFile(homeResFile);				GetPort(&oldPort);				dlg = MoreGetNewDialog (-128);								if (dlg)				{					Str255	orgDate;					Str255	strDate;					DateTimeRec dtr;										memcpy(&orgDate[1], MSG.msg->date, orgDate[0] = strlen(MSG.msg->date));										SecondsToDate(MSG.msg->storedtime, &dtr);					plugcontrol->msgbase_ftn_date((char *)&strDate[1], &dtr);					strDate[0] = strlen((char *)&strDate[1]);										PutText(dlg, 2, orgDate);					PutText(dlg, 3, strDate);					SetDLong(dlg, 4, GetHandleSize(MSG.msg->text));										ShowWindow(dlg);					do {											ModalDialog (NULL, &result);										} while (result != 1);										DisposeDialog(dlg);					SetPort(oldPort);				}				CloseResFile(homeResFile);				UseResFile(oldResFile);			}			if (res > 0)				plugcontrol->FreePktMsg(MSG.msg);						res = plugRetContinue;		}		break;		default:				//	We're ignoring all other opCodes							//	(by the way, it's impossible unordered calls)			res = plugRetContinue;		break;	}		plugcontrol->retCode = res;	ExitCodeResource ();	}