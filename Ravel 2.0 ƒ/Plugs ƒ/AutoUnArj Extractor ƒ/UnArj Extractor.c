/*•••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••	Copyright © 1996-1998 Cyril Moorzin		При использовании исходных текстов SDK указание Copyright © 1996-1998 Cyril Moorzin		обязательно.		Так же при генерации писем обязательно упоминание название пакета Ravel в tearline.				Ravel SDK поставляется в виде "as is". Автор не несет ответственности за		несовместимость Plug-Ins в будущих версиях RavelSHUFFLER при использовании		undewater приемов программирования.				Не существует НИКАКОЙ документации по Ravel SDK.		Так же автор пока отказался от распространения исходных текстов не только работы		с базой сообщений, но и старых релизов RavelQUILL.  •••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••*/#include <A4Stuff.h>#include "ravel_msg_base.h"#include "Ravel_Prefs.h"#include "PascalStr.h"#include "Ravel_PlugIns.h"static	PlugsControlPtr	g_plugcontrol;static	Str31			UnAjName;static	Str255			newPlace;static Boolean ApplicationLaunch ( FSSpecPtr spec ){	short				iErr;	LaunchParamBlockRec	myLaunchParams;	ProcessSerialNumber	launchedProcessSN;	myLaunchParams.launchBlockID = extendedBlock;	myLaunchParams.launchEPBLength = extendedBlockLen;	myLaunchParams.launchFileFlags = 0;	myLaunchParams.launchControlFlags = launchContinue + launchNoFileFlags;	myLaunchParams.launchAppSpec = spec;	myLaunchParams.launchAppParameters = NULL;	iErr = LaunchApplication ( &myLaunchParams );	if (!iErr)		launchedProcessSN = myLaunchParams.launchProcessSN;	else	{		return FALSE;	}	return TRUE;}static OSErr UnArjLaunch (void){	OSErr		theErr;	Str255		UnArjFullName;	FSSpec		launchSpec;		pStrConc (g_plugcontrol->Preferences.TempPath, UnAjName, UnArjFullName);		theErr = FSMakeFSSpec ( 0, 0, UnArjFullName, &launchSpec );	return (theErr) ? theErr : ApplicationLaunch ( &launchSpec );}static short myOpenWD ( StringPtr workPath ){	WDPBRec		pbr;							/* local pb */	pbr.ioNamePtr = workPath;	pbr.ioWDProcID = 0L;	pbr.ioWDDirID = 0L;	pbr.ioVRefNum = 0;		if ( PBOpenWDSync (&pbr) )	{		return 0;	}		return pbr.ioVRefNum;}static void myCloseWD ( short wdRefNum ){	WDPBRec		pbr;							/* local pb */	pbr.ioVRefNum = wdRefNum;	PBCloseWDSync (&pbr);}void main (PlugsControlPtr plugcontrol){	Boolean		res, done;	ProcessSerialNumber	processSN;	OSErr		theErr, iErr;	Boolean		UnArjExist;	CMovePBRec	cmpb;	CInfoPBRec	cipbr;						/* local pb */	HFileInfo	*fpb = (HFileInfo *)&cipbr;	/* to pointers */	OSErr		rc;	short		mdir, idx, vRefNum, srcref, dstref;	long		dirID, ioCount;	Str31		filename;	FSSpec		spec;	char		buf[512];	EnterCodeResource ();	g_plugcontrol = plugcontrol;		switch (plugcontrol->opCode)	{	case plugWelcome:		//	StartUp call of plug-ins. We make order and init. prefs.					//	find Auto UnArj in Temp folder (temp is using for unpacking by RavelSHUFFLER)…		UnArjExist = false;				if ( ( mdir = myOpenWD ( plugcontrol->Preferences.TempPath ) ) == 0 )		{			plugcontrol->putlog ( '±', "Unable to open `Temp` directory." );		}		else		{			fpb->ioNamePtr = filename;			fpb->ioVRefNum = mdir;		// • Searching loop...					for ( idx=1; true; idx++)			{											/* indexing loop */				fpb->ioDirID = 0L;						/* must set on each loop */				fpb->ioFDirIndex = idx;				filename[0] = 0;								rc = PBGetCatInfoSync (&cipbr);				if (rc)					break;								/* exit when no more entries */						if ( !(fpb->ioFlAttrib & 16) &&						fpb->ioFlFndrInfo.fdType == 'APPL' &&						fpb->ioFlFndrInfo.fdCreator == 'OSC2')				{					pStrCopy (filename, UnAjName);					UnArjExist = true;					break;				}			}			myCloseWD ( mdir );		}				if (UnArjExist)		{			pStrConc (plugcontrol->Preferences.TempPath, "\pdoit.arj", newPlace);					plugcontrol->retCode = plugCompExtr;			//	Decompressor			plugcontrol->misc.arc.archiveType = arcARJ;			plugcontrol->misc.arc.archiveAction = arcExpand;						plugcontrol->putlog ('±', "<Arj Extractor" RAVELISA "> Installed.");		}		else		{			plugcontrol->putlog ('±', "AutoUnArj must be in 'Temp' folder.");			plugcontrol->retCode = 0L;		}				break;			case plugCompExtr:	//	We ordered only one call - Extract archive				iErr = FSpOpenDF ( plugcontrol->source, fsRdPerm, &srcref );		iErr = Create ( newPlace, 0, '????', 'ARJa' );		iErr = FSOpen (newPlace, 0, &dstref);				do {					ioCount = 512L;			FSRead (srcref, &ioCount, buf);			FSWrite (dstref, &ioCount, buf);				} while (ioCount);				FSClose (srcref);		FSClose (dstref);				UnArjLaunch ();				do {					plugcontrol->Slice ();			done = (plugcontrol->FindAProcess ( 'APPL', 'OSC2', &processSN ) != noErr);		} while (!done);		iErr = FindFolder ( kOnSystemDisk, kTrashFolderType, kDontCreateFolder, &vRefNum, &dirID );		if (iErr == noErr)		{			iErr = FSMakeFSSpec ( vRefNum, dirID, "\pdoit.arj", &spec);			if (iErr)			{				plugcontrol->putlog ( '±', "Can't find 'doit.arj' in Trash." );				break;			}						iErr = FSpDelete (&spec);			if (iErr)			{				plugcontrol->putlog ( '±', "Can't kill 'doit.arj' in Trash." );				break;			}		}		else			plugcontrol->putlog ( '±', "Can't find Trash." );		plugcontrol->retCode = plugRetContinue;		break;	case plugSuicide:		//	Ignore in this case.			break;	default:				//	We're ignoring all other opCodes							//	(by the way, it's impossible unordered calls)		plugcontrol->retCode = plugFatalArch;		break;	}	ExitCodeResource ();	}