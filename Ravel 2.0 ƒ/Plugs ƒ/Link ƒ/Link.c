/*•••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••	Copyright © 1996-1997 Cyril Moorzin		При использовании исходных текстов SDK указание Copyright © 1996-1997 Cyril Moorzin		обязательно.		Так же при генерации писем обязательно упоминание название пакета Ravel в tearline.				Ravel SDK поставляется в виде "as is". Автор не несет ответственности за		несовместимость Plug-Ins в будущих версиях RavelSHUFFLER при использовании		undewater приемов программирования.				Не существует НИКАКОЙ документации по Ravel SDK.		Так же автор пока отказался от распространения исходных текстов не только работы		с базой сообщений, но и старых релизов RavelQUILL.  •••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••*/#include <string.h>//#include <stdio.h>#include <A4Stuff.h>#include "ravel_msg_base.h"#include "Ravel_Prefs.h"#include "PascalStr.h"#include "Ravel_PlugIns.h"static	Boolean	wasTOSS;static	Boolean	wasStoredMsg;void main (PlugsControlPtr plugcontrol){	EnterCodeResource ();	switch (plugcontrol->opCode)	{	case plugWelcome:		//	StartUp call of plug-ins. We make order and init. prefs.				plugcontrol->retCode = plugPreTossLaunch |			//	intercept toss								plugSuicide |				//	and suicide (don't care - calls								 							//	always but mark for compatibility)								plugTossMsgEcho |			//	one message stored in base								plugTossMsgMail |			//	one message stored in base								plugMisc;					//	we should know when operation completed		plugcontrol->putlog ('=', "<Linker> Installed.");				wasTOSS = false;		wasStoredMsg = false;				break;		case plugPreTossLaunch:			wasTOSS = true;		plugcontrol->retCode = plugRetContinue;		break;		case plugTossMsgEcho:			wasStoredMsg = true;		plugcontrol->retCode = plugRetContinue;		break;		case plugTossMsgMail:			wasStoredMsg = true;		plugcontrol->retCode = plugRetContinue;		break;		case plugMisc:			if ((secondOperationComplete == plugcontrol->retCode) && wasStoredMsg && wasTOSS)		{			if (!plugcontrol->base_bsy_check ())			{				plugcontrol->base_bsy_raise ();				plugcontrol->putlog ( '=', "<Linker> Processing LINK.");				plugcontrol->_Link ();				plugcontrol->base_bsy_clear ();			}			else				plugcontrol->putlog ('=', "<Linker> Can`t LINK, `case base is busy.");		}				wasTOSS = false;		wasStoredMsg = false;		plugcontrol->retCode = plugRetContinue;	case plugSuicide:				break;		default:				//	We're ignoring all other opCodes							//	(by the way, it's impossible unordered calls)			plugcontrol->retCode = plugRetContinue;		break;	}	ExitCodeResource ();	}