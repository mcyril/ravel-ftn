/*•••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••	Copyright © 1996-1999 Cyril Moorzin		При использовании исходных текстов SDK указание Copyright © 1996-1999 Cyril Moorzin		обязательно.		Так же при генерации писем обязательно упоминание название пакета Ravel в tearline.				Ravel SDK поставляется в виде "as is". Автор не несет ответственности за		несовместимость Plug-Ins в будущих версиях RavelSHUFFLER при использовании		undewater приемов программирования.				Не существует НИКАКОЙ документации по Ravel SDK.		Так же автор пока отказался от распространения исходных текстов не только работы		с базой сообщений, но и старых релизов RavelQUILL.  •••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••*/#include <Sound.h>#include <string.h>//#include <stdio.h>#ifdef THINK_C#include <processes.h>#include <gestaltequ.h>#include <eppc.h>#include <appleevents.h>#include <SetUpA4.h>#define	EnterCodeResource()	do { RememberA0(); SetUpA4(); } while (0)#define	ExitCodeResource()	do { RestoreA4(); } while (0)#else#include <A4Stuff.h>#endif#include "ravel_msg_base.h"#include "ravel_prefs.h"#include "ravel_plugins.h"#define	SIGNATURE		'IZip'#define	kCMDEventClass	'DCMD'#define	kCMDEvent    	'DCMD'static	Boolean				MacZipWasLaunched;static	ProcessSerialNumber	gProcessSN;static Boolean TestGestalt (OSType selector, char which){	long	response;		if (Gestalt(selector, &response))		return FALSE;	else		return BitTst(&response, 31-which);}static void pstrcat(StringPtr dst, StringPtr src){	/* copy string in */	BlockMove(src + 1, dst + *dst + 1, *src);	/* adjust length byte */	*dst += *src;}static void pstrinsert(StringPtr dst, StringPtr src){	/* make room for new string */	BlockMove(dst + 1, dst + *src + 1, *dst);	/* copy new string in */	BlockMove(src + 1, dst + 1, *src);	/* adjust length byte */	*dst += *src;}static void PathNameFromDirID(long dirID, short vRefNum, StringPtr fullPathName){	DirInfo	block;	Str255	directoryName;	OSErr	err;	fullPathName[0] = '\0';	block.ioDrParID = dirID;	block.ioNamePtr = directoryName;	do {			block.ioVRefNum = vRefNum;			block.ioFDirIndex = -1;			block.ioDrDirID = block.ioDrParID;			err = PBGetCatInfo((CInfoPBPtr)&block, FALSE);			pstrcat(directoryName, (StringPtr)"\p:");			pstrinsert(fullPathName, directoryName);	} while (block.ioDrDirID != 2);}static OSErr FindMacZip(short volume, FSSpec *app){	IOParam					pb1;	DTPBRec					pb2;	GetVolParmsInfoBuffer	volInfo;	OSErr					error;	Str255					name;		/* We must find MacZip's FSSpec from the desktop database. */	/* First, does the specified volume HAVE a desktop database? */	pb1.ioCompletion = NULL;	pb1.ioVRefNum = volume;	pb1.ioNamePtr = NULL;	pb1.ioBuffer = (Ptr)&volInfo;	pb1.ioReqCount = sizeof(GetVolParmsInfoBuffer);	error = PBHGetVolParmsSync ((HParamBlockRec *)&pb1);	if (!error && (BitTst(&volInfo.vMAttrib, 31 - bHasDesktopMgr))) {		pb2.ioNamePtr = NULL;		pb2.ioVRefNum = volume;		error = PBDTGetPath(&pb2);				if (!error) {					pb2.ioNamePtr = name;			pb2.ioIndex = 0;			pb2.ioFileCreator = SIGNATURE;						error = PBDTGetAPPLSync(&pb2);						if (!error)				error = FSMakeFSSpec(volume, pb2.ioAPPLParID, name, app);		}	} else if (!error)		error = paramErr;		return error;}			static OSErr MacZipLaunch(const FSSpec *application, Boolean inBackground, ProcessSerialNumber *psn, Boolean doLaunch){	OSErr				error, error2;	ProcessInfoRec		info;	FSSpec				MacZip;	LaunchParamBlockRec	lpb;		if (application)		MacZip = *application;		if (!psn)		return paramErr;			if (TestGestalt(gestaltOSAttr, gestaltLaunchControl)) {				/* Search for a process with MacZip's signature. If one is found, then MacZip			is running, and we do not have to launch it or do anything except return			its PSN.		*/				psn->highLongOfPSN = 0;		psn->lowLongOfPSN = kNoProcess;		info.processInfoLength = sizeof(info);		info.processName = NULL;		info.processAppSpec = NULL;		do {			error = GetNextProcess(psn);			if (!error)				GetProcessInformation(psn, &info);		} while (!error && (info.processSignature != SIGNATURE));					if (!error)			return noErr;				}		if (!application) {			HVolumeParam	pb;				pb.ioNamePtr = NULL;		pb.ioVolIndex = 0;		pb.ioVRefNum = 0;				do {			++pb.ioVolIndex;			error = PBHGetVInfoSync((HParamBlockRec *)&pb);			if (!error)				error2 = FindMacZip(pb.ioVRefNum, &MacZip);		} while (!error && error2);				if (error2)			return fnfErr;	}		if (!doLaunch)		return noErr;		if (!TestGestalt(gestaltOSAttr, gestaltLaunchFullFileSpec))		return paramErr;			lpb.launchBlockID = extendedBlock;	lpb.launchEPBLength = extendedBlockLen;	lpb.launchFileFlags = 0;	lpb.launchControlFlags = launchContinue + launchNoFileFlags + (inBackground ? launchDontSwitch : 0);	lpb.launchAppSpec = &MacZip;	lpb.launchAppParameters = NULL;		error = LaunchApplication(&lpb);		if (!error)		*psn = lpb.launchProcessSN;			return error;}static OSErr MacZipCommand (char *command, const ProcessSerialNumber *psn){	AppleEvent		event, reply;	OSErr			error;	AEAddressDesc	address;		address.descriptorType = typeNull;	event.descriptorType = typeNull;	reply.descriptorType = typeNull;		error = AECreateDesc(typeProcessSerialNumber, psn, sizeof(*psn), &address);	if (error)		return error;		error = AECreateAppleEvent(kCMDEventClass, kCMDEvent, &address,								kAutoGenerateReturnID, kAnyTransactionID, &event);									if (error)		goto cleanup;			error = AEPutParamPtr(&event, keyDirectObject, typeChar, command, strlen(command));		if (error)		goto cleanup;			error = AESend(&event, &reply, kAENeverInteract + kAEWaitReply,					kAENormalPriority, kAEDefaultTimeout, NULL, NULL);	cleanup:	AEDisposeDesc(&event);	AEDisposeDesc(&address);	AEDisposeDesc(&reply);	return error;}static OSErr MacZipQuit (const ProcessSerialNumber *psn){	AppleEvent		event, reply;	AEAddressDesc	address;	OSErr			error;		error = AECreateDesc(typeProcessSerialNumber, psn, sizeof(*psn), &address);	if (error)		return error;		error = AECreateAppleEvent(kCoreEventClass, kAEQuitApplication, &address,								kAutoGenerateReturnID, kAnyTransactionID, &event);									if (error)		goto cleanup;			error = AESend(&event, &reply, kAENeverInteract + kAEWaitReply,					kAENormalPriority, kAEDefaultTimeout, NULL, NULL);	cleanup:								AEDisposeDesc(&event);	AEDisposeDesc(&address);	AEDisposeDesc(&reply);	return error;}#define	CMD_NOWARN	"NoWarningBoxes"#define	CMD_1		"unzip -q "void main (PlugsControlPtr plugcontrol){	DTPBRec				pbDeskBase;	Str255				ZipName;	OSErr				theErr;	Boolean				MacZipExist;	FSSpec				launchSpec;	char				cmd_line[2048];	Str255				temp;	short				i;		EnterCodeResource ();	switch (plugcontrol->opCode)	{	case plugWelcome:		//	StartUp call of plug-ins. We make order and init. prefs.					//	find MacZip…		MacZipExist = (MacZipLaunch (NULL, true, &gProcessSN, false) == noErr);		if (MacZipExist)		{			plugcontrol->retCode = plugCompExtr;				//	Compressor/Decompressor			plugcontrol->misc.arc.archiveType = arcZIP;			//	ZIP method			plugcontrol->misc.arc.archiveAction = arcExpand;	//	Decompressor only part						plugcontrol->putlog ('±', "<MacZip Expander> Installed.");			MacZipWasLaunched = (plugcontrol->FindAProcess ( 'APPL', SIGNATURE, &gProcessSN ) == noErr);		}		else			plugcontrol->retCode = 0L;				break;			case plugCompExtr:	//	We ordered only one call - Extract archive//		DebugStr ("\pGET READY FOR MacZip");				MacZipLaunch (NULL, true, &gProcessSN, true);		MacZipCommand (CMD_NOWARN, &gProcessSN);		strcpy (cmd_line, CMD_1);		PathNameFromDirID (	plugcontrol->source->parID,							plugcontrol->source->vRefNum, temp);		pstrcat (temp, plugcontrol->source->name);		temp[temp[0]+1] = 0;		strcat (cmd_line, "\"");		strcat (cmd_line, (char *)&temp[1]);		strcat (cmd_line, "\"");		PathNameFromDirID (	plugcontrol->destination->parID,							plugcontrol->destination->vRefNum, temp);		pstrcat (temp, plugcontrol->destination->name);		temp[temp[0]+1] = 0;		strcat (cmd_line, " \"");		strcat (cmd_line, (char *)&temp[1]);		strcat (cmd_line, "\"");				MacZipCommand (cmd_line, &gProcessSN);				plugcontrol->retCode = plugRetContinue;				break;	case plugSuicide:		//	Terminate MacZip if we launched it.			if (!MacZipWasLaunched)			MacZipQuit (&gProcessSN);			break;	default:				//	We're ignoring all other opCodes							//	(by the way, it's impossible unordered calls)		plugcontrol->retCode = plugFatalArch;		break;	}		ExitCodeResource ();	}