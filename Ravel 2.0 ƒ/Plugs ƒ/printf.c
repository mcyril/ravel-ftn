/*  Metrowerks Standard Library  Version 2.1  1996 December 29  *//* *	printf.c *	 *		Copyright © 1995-1996 Metrowerks, Inc. *		All rights reserved. *	 *	Routines *	-------- *		vfprintf *		fprintf * *		vprintf *		printf * *		vsprintf *		sprintf * * */#include <ansi_fp.h>#include <ctype.h>#include <float.h>#include <limits.h>#include <stdarg.h>#include <stdio.h>#include <string.h>#include "string_io.h"#define conversion_buff_size	512#define conversion_max				509#define bad_conversion				0xFFenum justification_options {	left_justification,	right_justification,	zero_fill};enum sign_options {	only_minus,	sign_always,	space_holder};enum argument_options {	normal_argument,	short_argument,	long_argument,#ifdef MSIPL_64LONGLONG                   /*mm 961219*/	long_long_argument,                 /* mm 961219 */#endif	long_double_argument};typedef struct {	unsigned char	justification_options;	unsigned char sign_options;	unsigned char precision_specified;	unsigned char	alternate_form;	unsigned char argument_options;	unsigned char	conversion_char;	int						field_width;	int						precision;} print_format;static const char * parse_format(const char * format_string, va_list * arg, print_format * format){	print_format	f;	const char *	s = format_string;	int						c;	int						flag_found;		f.justification_options	= right_justification;	f.sign_options			= only_minus;	f.precision_specified   = 0;	f.alternate_form		= 0;	f.argument_options		= normal_argument;	f.field_width						= 0;	f.precision							= 0;		if ((c = *++s) == '%')	{		f.conversion_char = c;		*format = f;		return((const char *) s + 1);	}		for (;;)	{		flag_found = 1;				switch (c)		{			case '-':								f.justification_options = left_justification;								break;						case '+':								f.sign_options = sign_always;								break;						case ' ':								if (f.sign_options != sign_always)					f.sign_options = space_holder;									break;						case '#':								f.alternate_form = 1;								break;						case '0':								if (f.justification_options != left_justification)					f.justification_options = zero_fill;								break;						default:								flag_found = 0;		}				if (flag_found)			c = *++s;		else			break;	}		if (c == '*')	{		if ((f.field_width = va_arg(*arg, int)) < 0)		{			f.justification_options = left_justification;			f.field_width           = -f.field_width;		}				c = *++s;	}	else		while (isdigit(c))		{			f.field_width = (f.field_width * 10) + (c - '0');			c = *++s;		}		if (f.field_width > conversion_max)	{		f.conversion_char = bad_conversion;		*format = f;		return((const char *) s + 1);	}		if (c == '.')	{		f.precision_specified = 1;				if ((c = *++s) == '*')		{			if ((f.precision = va_arg(*arg, int)) < 0)				f.precision_specified = 0;						c = *++s;		}		else			while (isdigit(c))			{				f.precision = (f.precision * 10) + (c - '0');				c = *++s;			}	}		flag_found = 1;		switch (c)	{		case 'h':						f.argument_options = short_argument;						break;				case 'l':						f.argument_options = long_argument;						break;				case 'L':						f.argument_options = long_double_argument;						break;				default:						flag_found = 0;	}		if (flag_found)		c = *++s;		f.conversion_char = c;		switch (c)	{		case 'd':		case 'i':		case 'u':		case 'o':		case 'x':		case 'X':						if (f.argument_options == long_double_argument)			{#ifdef MSIPL_64LONGLONG                                   /*mm 961219*/				f.argument_options = long_long_argument; /*mm 961219*/#else                                                    /*mm 961220*/				f.conversion_char = bad_conversion;      /*mm 961219*/				break;                                   /*mm 961219*/#endif                                                   /*mm 961219*/			}					if (!f.precision_specified)				f.precision = 1;			else if (f.justification_options == zero_fill)				f.justification_options = right_justification;						break;				case 'g':		case 'G':						if (!f.precision)				f.precision = 1;				case 'f':		case 'e':		case 'E':						if (f.argument_options == short_argument || f.argument_options == long_argument)			{				f.conversion_char = bad_conversion;				break;			}						if (!f.precision_specified)				f.precision = 6;						break;				case 'p':						f.argument_options = long_argument;			f.alternate_form   = 1;			f.conversion_char  = 'x';			f.precision        = 8;						break;					case 'c':						if (f.precision_specified || f.argument_options != normal_argument)				f.conversion_char = bad_conversion;						break;					case 's':						if (f.argument_options != normal_argument)				f.conversion_char = bad_conversion;						break;					case 'n':						if (f.argument_options == long_double_argument)#ifdef MSIPL_64LONGLONG                                      /*mm 961219*/				f.argument_options = long_long_argument;    /*mm 961219*/#else                                                       /*mm 961220*/				f.conversion_char = bad_conversion;         /*mm 961219*/#endif                                                      /*mm 961220*/						break;					default:						f.conversion_char = bad_conversion;						break;	}		*format = f;		return((const char *) s + 1);}static char * long2str(long num, char * buff, print_format format){	unsigned long unsigned_num, base;	char *				p;	int						n, digits;	int						minus = 0;		unsigned_num = num;	minus        =   0;		p = buff;		*--p = 0;		digits = 0;		if (!num && !format.precision && !(format.alternate_form && format.conversion_char == 'o'))		return(p);		switch (format.conversion_char)	{		case 'd':		case 'i':						base =  10;				if (num < 0)			{				unsigned_num = -unsigned_num;				minus        = 1;			}						break;					case 'o':						base =   8;						format.sign_options = only_minus;									break;					case 'u':						base =  10;						format.sign_options = only_minus;						break;					case 'x':		case 'X':						base =  16;						format.sign_options = only_minus;						break;	}		do	{		n = unsigned_num % base;				unsigned_num /= base;				if (n < 10)			n += '0';		else		{			n -= 10;						if (format.conversion_char == 'x')				n += 'a';			else				n += 'A';		}				*--p = n;				++digits;	}	while (unsigned_num != 0);		if (base == 8 && format.alternate_form && *p != '0')	{		*--p = '0';		++digits;	}		if (format.justification_options == zero_fill)	{		format.precision = format.field_width;				if (minus || format.sign_options != only_minus)			--format.precision;				if (base == 16 && format.alternate_form)			format.precision -= 2;	}		if (buff - p + format.precision > conversion_max)		return(NULL);		while (digits < format.precision)	{		*--p = '0';		++digits;	}		if (base == 16 && format.alternate_form)	{		*--p = format.conversion_char;		*--p = '0';	}		if (minus)		*--p = '-';	else if (format.sign_options == sign_always)		*--p = '+';	else if (format.sign_options == space_holder)		*--p = ' ';		return(p);}#ifdef MSIPL_64LONGLONG                          /*mm 961219*/static char * longlong2str(long long num, char * buff, print_format format){	unsigned long long      unsigned_num, base;	char *				    p;	int						n, digits;	int						minus = 0;		unsigned_num = num;	minus        =   0;		p = buff;		*--p = 0;		digits = 0;		if (!num && !format.precision && !(format.alternate_form && format.conversion_char == 'o'))		return(p);		switch (format.conversion_char)	{		case 'd':		case 'i':						base =  10;				if (num < 0)			{				unsigned_num = -unsigned_num;				minus        = 1;			}						break;					case 'o':						base =   8;						format.sign_options = only_minus;									break;					case 'u':						base =  10;						format.sign_options = only_minus;						break;					case 'x':		case 'X':						base =  16;						format.sign_options = only_minus;						break;	}		do	{		n = unsigned_num % base;				unsigned_num /= base;				if (n < 10)			n += '0';		else		{			n -= 10;						if (format.conversion_char == 'x')				n += 'a';			else				n += 'A';		}				*--p = n;				++digits;	}	while (unsigned_num != 0);		if (base == 8 && format.alternate_form && *p != '0')	{		*--p = '0';		++digits;	}		if (format.justification_options == zero_fill)	{		format.precision = format.field_width;				if (minus || format.sign_options != only_minus)			--format.precision;				if (base == 16 && format.alternate_form)			format.precision -= 2;	}		if (buff - p + format.precision > conversion_max)		return(NULL);		while (digits < format.precision)	{		*--p = '0';		++digits;	}		if (base == 16 && format.alternate_form)	{		*--p = format.conversion_char;		*--p = '0';	}		if (minus)		*--p = '-';	else if (format.sign_options == sign_always)		*--p = '+';	else if (format.sign_options == space_holder)		*--p = ' ';		return(p);}#endifstatic void round_decimal(decimal * dec, int new_length){	char		c;	char *	p;	int			carry;		if (new_length < 0)	{return_zero:		dec->sgn         =  0 ;		dec->exp         =  0 ;		dec->sig.length  =  1 ;		*dec->sig.text   = '0';		return;	}		if (new_length >= dec->sig.length)		return;		p     = (char *) dec->sig.text + new_length + 1;	c     = *--p - '0';	carry = (c >= 5);		while (new_length)	{		c = *--p - '0' + carry;				if ((carry = (c > 9)) != 0)			--new_length;		else		{			*p = c + '0';			break;		}	}		if (carry)	{		dec->exp        +=  1 ;		dec->sig.length  =  1 ;		*dec->sig.text   = '1';		return;	}	else if (new_length == 0)		goto return_zero;		dec->sig.length = new_length;}static char * float2str(long double num, char * buff, print_format format){	decimal		dec;	decform		form;	char *		p;	char *		q;	int				n, digits, sign;	int				int_digits, frac_digits;		if (format.precision > conversion_max)							/* might as well punt asap */		return(NULL);/* *	Note: If you look at <ansi_fp.h> you'll see that __num2dec only supports double. *				If you look at <float.h> you'll see that long double == double. Ergo, the *				difference is moot *until* a truly long double type is supported. */		form.style  = FLOATDECIMAL;	form.digits = DBL_DIG;		__num2dec(&form, num, &dec);		p = (char *) dec.sig.text + dec.sig.length;					/* strip off trailing zeroes */		while (dec.sig.length > 1 && *--p == '0')	{		--dec.sig.length;		++dec.exp;	}		switch (*dec.sig.text)	{		case '0':						dec.sgn = 0;																		/* force plus */			dec.exp = 0;																		/* __num2dec doesn't guarantee */																											/* this for zeroes             */			break;					case 'I':						p = buff - 4;																		/* special cases */						strcpy(p, "Inf");						return(p);					case 'N':						p = buff - 4;						strcpy(p, "NaN");						return(p);	}		dec.exp += dec.sig.length - 1;											/* shift decimal point to */																											/* follow first digit	    */	p = buff;		*--p = 0;		switch (format.conversion_char)	{		case 'g':		case 'G':						if (dec.sig.length > format.precision)				round_decimal(&dec, format.precision);						if (dec.exp < -4 || dec.exp >= format.precision)			{				if (format.alternate_form)					--format.precision;				else					format.precision = dec.sig.length - 1;								if (format.conversion_char == 'g')					format.conversion_char = 'e';				else					format.conversion_char = 'E';								goto e_format;			}						if (format.alternate_form)				format.precision -= dec.exp + 1;			else				if ((format.precision = dec.sig.length - (dec.exp + 1)) < 0)					format.precision = 0;						goto f_format;				case 'e':		case 'E':		e_format:						if (dec.sig.length > format.precision + 1)				round_decimal(&dec, format.precision + 1);						n    = dec.exp;			sign = '+';						if (n < 0)			{				n    = -n;				sign = '-';			}						for (digits = 0; n || digits < 2; ++digits)			{				*--p  = n % 10 + '0';				n    /= 10;			}						*--p = sign;			*--p = format.conversion_char;						if (buff - p + format.precision > conversion_max)				return(NULL);						if (dec.sig.length < format.precision + 1)				for (n = format.precision + 1 - dec.sig.length + 1; --n;)					*--p = '0';						for (n = dec.sig.length, q = (char *) dec.sig.text + dec.sig.length; --n;)				*--p = *--q;						if (format.precision || format.alternate_form)				*--p = '.';						*--p = *dec.sig.text;						if (dec.sgn)				*--p = '-';			else if (format.sign_options == sign_always)				*--p = '+';			else if (format.sign_options == space_holder)				*--p = ' ';						break;				case 'f':		f_format:						if ((frac_digits = -dec.exp + dec.sig.length - 1) < 0)				frac_digits = 0;						if (frac_digits > format.precision)			{				round_decimal(&dec, dec.sig.length - (frac_digits - format.precision));								if ((frac_digits = -dec.exp + dec.sig.length - 1) < 0)					frac_digits = 0;			}						if ((int_digits = dec.exp + 1) < 0)				int_digits = 0;						if (int_digits + frac_digits > conversion_max)				return(NULL);						q = (char *) dec.sig.text + dec.sig.length;						for (digits = 0; digits < (format.precision - frac_digits); ++digits)				*--p = '0';						for (digits = 0; digits < frac_digits && digits < dec.sig.length; ++digits)				*--p = *--q;						for (; digits < frac_digits; ++digits)				*--p = '0';						if (format.precision || format.alternate_form)				*--p = '.';						if (int_digits)			{				for (digits = 0; digits < int_digits - dec.sig.length; ++digits)					*--p = '0';								for (; digits < int_digits; ++digits)					*--p = *--q;			}			else				*--p = '0';						if (dec.sgn)				*--p = '-';			else if (format.sign_options == sign_always)				*--p = '+';			else if (format.sign_options == space_holder)				*--p = ' ';						break;	}		return(p);}int fprintf(FILE * file, const char * format, ...){	return(vfprintf(file, format, __va_start(format)));}int vprintf(const char * format, va_list arg){	return(vfprintf(stdout, format, arg));}int printf(const char * format, ...){	return(vfprintf(stdout, format, __va_start(format)));}int vsprintf(char * s, const char * format, va_list arg){	FILE	file;	int		n;		__open_string_file(&file, s, ULONG_MAX, __writing);		n = vfprintf(&file, format, arg);		if (n >= 0)		s[n] = 0;		return(n);}int sprintf(char * s, const char * format, ...){	return(vsprintf(s, format, __va_start(format)));}/*  Change Record *	18-Sep-95 JFH  First code release. *	29-Sep-95 JFH  Fixed bug in 'f' format where a zero fractional part would be suppressed *								 regardless of the precision. *	10-Oct-95 JFH  Changed long2str to comply with Standard saying: "The result of converting *								 a zero value with a precision of zero is no characters." *	30-Oct-95 JFH  Corrected handling of 'g','G' conversions using the alternate form (#). *  22-Jan-96 JFH  Added casts from (void *) for C++ compatibility. *	19-Feb-96 JFH  Added #ifndef around area that handles floating point output. If disabled, you *								 can get away with not including MathLib just because you wanted to use printf. *								 There is also some ANSI lib code savings as well. *	 7-Mar-96 JFH  Fixed bug in round_decimal where it *wasn't* rounding anything if all the *								 precision digits were zero. *	19-Mar-96 JFH  Changed handling of '+' flag so it doesn't affect how unsigned values (i.e., *								 o,u,x,X) are displayed. *	24-Mar-96 JFH  Changed "round_decimal" to do rounding using more conventional rules of *								 arithmetic. :-) *  96Jul22   MM   Fill with zeros when required. *  96aug29   bkoz add l.you's changes for powertv, defines for no floating point *  960930    mm   Removed bitfields from printformat structure to compile with ANSI strict *  961220    mm   Support for long long.*/