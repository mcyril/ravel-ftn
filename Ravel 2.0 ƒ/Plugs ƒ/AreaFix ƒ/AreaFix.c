/*•••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••	Copyright © 1998 Cyril Moorzin		При использовании исходных текстов SDK указание Copyright © 1996-1997 Cyril Moorzin		обязательно.		Так же при генерации писем обязательно упоминание название пакета Ravel в tearline.				Ravel SDK поставляется в виде "as is". Автор не несет ответственности за		несовместимость Plug-Ins в будущих версиях RavelSHUFFLER при использовании		undewater приемов программирования.				Не существует НИКАКОЙ документации по Ravel SDK.		Так же автор пока отказался от распространения исходных текстов не только работы		с базой сообщений, но и старых релизов RavelQUILL.  •••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••*/#include <ctype.h>#include <string.h>#include <stdio.h>#include <A4Stuff.h>#include "strning.h"#include "PascalStr.h"#include "Config.h"#include "ravel_msg_base.h"#include "Ravel_Prefs.h"#include "PascalStr.h"#include "Ravel_PlugIns.h"		Boolean	debug;		char	local_area[256];char	*invokers[] = {"AFGENST", NULL};static	PlugsControlPtr	pc;static	short			link;static	long			max_messages;static	long			max_days;typedef struct _acts {	struct _acts	*next;	short			subs;	char			area[256];		short			flag;	} t_acts, *p_acts;static char		*af_tokens[] = {								"%list",		//	list of all								"%query",		//	list of subscribed								"%help",		//	help								"%rescan",		//	rescan								"%password",	//	password								"%maxmessages",	//	for rescan								"%maxdays",		//	for rescan								""							};#define isMaskDone()    ((Boolean)!*mask)#define	EOS				0static Boolean wildcmp (char *mask, char *name){	char	*last;	char	ch;	for(;; mask++, name++)	{		ch = *name;				if (*mask != '?' && *mask != ch)			break;		if (ch == EOS)			return isMaskDone();	}	if(*mask != '*') return false;	for(;; mask++, name++)	{		while(*mask == '*')		{			last = mask;			mask++;			if(*mask == EOS)				return isMaskDone();		}		ch = *name;		if(ch == EOS)			return isMaskDone();		if(*mask != '?' && *mask != ch)		{			name -= (size_t)(mask - last) - 1;			mask = last;		}			if (isMaskDone ())			DebugStr ("\pCall Cyril. Report #0001");	}}static char		*dlm = " -------------------------------------------------------------------------\r\r";static char		*tln = "\xD--- " SHUFFLERNAME " " RAVELVERS "\xD";static char		*hlp = "No help available, sorry.\xD";static void generate_list (Handle *hText){	Handle		h;	char		tmp[512], temp[512];	short		i, j, k, l, m;		h = NewHandle (0);	for (i=0; i<(*(pc->Preferences.nodesHndls[link]))->GroupsNumber; i++)	{		k = (*(pc->Preferences.nodesHndls[link]))->group[i];			sprintf (tmp, "\r\r  Echoareas from group '%#s':\r", (*(pc->Preferences.groupsHndls[k]))->groupName);				PtrAndHand (tmp, h, strlen (tmp));		PtrAndHand (dlm, h, strlen (dlm));		for (j=0; j<pc->Preferences.AreasNumber; j++)		{			if ((*(pc->Preferences.areasHndls[j]))->group == k)			{				for (l=0; l<(*(pc->Preferences.areasHndls[j]))->numExports; l++)					if ((*(pc->Preferences.areasHndls[j]))->Export[l].Export == link)						break;								sprintf (tmp, "%c %#s\r",						(l<(*(pc->Preferences.areasHndls[j]))->numExports) ?							(((*(pc->Preferences.areasHndls[j]))->Export[l].Diodes & LINK_DIODE) ? 'r' : '*') : ' ',							(*(pc->Preferences.areasHndls[j]))->areaName);				PtrAndHand (tmp, h, strlen (tmp));			}		}	}		sprintf (tmp, "\r\r");	PtrAndHand (tmp, h, strlen (tmp));		*hText = h;}static void generate_totallist (Handle *hText){	Handle		h;	char		tmp[512], temp[512];	short		i, j, k, l;		h = NewHandle (0);	l = 0;	for (i=0; i<pc->Preferences.GroupsNumber; i++)	{		sprintf (tmp, "\r\r  Echoareas from group '%#s':\r", (*(pc->Preferences.groupsHndls[i]))->groupName);		k = 0;				PtrAndHand (tmp, h, strlen (tmp));		PtrAndHand (dlm, h, strlen (dlm));		for (j=0; j<pc->Preferences.AreasNumber; j++)		{			if ((*(pc->Preferences.areasHndls[j]))->group == i)			{				sprintf (tmp, " %#s\r", (*(pc->Preferences.areasHndls[j]))->areaName);				PtrAndHand (tmp, h, strlen (tmp));							k++;			}		}				sprintf (tmp, "\r  Total ehoareas in group: %d\r", k);		PtrAndHand (tmp, h, strlen (tmp));		l += k;	}		PtrAndHand (dlm, h, strlen (dlm));	sprintf (tmp, "\r  Total ehoareas: %d\r", l);	PtrAndHand (tmp, h, strlen (tmp));	sprintf (tmp, "\r");	PtrAndHand (tmp, h, strlen (tmp));		*hText = h;}static void generate_query (Handle *hText){	Handle		h;	char		tmp[512], temp[512];	short		i, j, k, l, m;		h = NewHandle (0);	sprintf (tmp, "\r\r  List of subscribed areas:\r");			PtrAndHand (tmp, h, strlen (tmp));	PtrAndHand (dlm, h, strlen (dlm));	for (j=0; j<pc->Preferences.AreasNumber; j++)	{		for (l=0; l<(*(pc->Preferences.areasHndls[j]))->numExports; l++)			if ((*(pc->Preferences.areasHndls[j]))->Export[l].Export == link)				break;				if (l<(*(pc->Preferences.areasHndls[j]))->numExports)		{			sprintf (temp, "%#s", (*(pc->Preferences.areasHndls[j]))->areaName);			sprintf (tmp, "%-60s %c\r", temp, ((*(pc->Preferences.areasHndls[j]))->Export[l].Diodes & LINK_DIODE) ? 'r' : ' ');			PtrAndHand (tmp, h, strlen (tmp));		}	}	sprintf (tmp, "\r\r");	PtrAndHand (tmp, h, strlen (tmp));		*hText = h;}static void generate_help (Handle *hText){	Handle		h;	char		tmp[512], temp[512];	short		href;	Str255		hname;	long		len;	pStrCopy (pc->thisplugPath, hname);	pStrConc (hname, "\p.hlp", hname);		if (FSOpen (hname, 0, &href))	{		h = NewHandle (0);		PtrAndHand (hlp, h, strlen (hlp));	}	else	{		GetEOF (href, &len);		h = NewHandle (len);		HLock (h);		FSRead (href, &len, *h);		HUnlock (h);	}		sprintf (tmp, "\r\r");	PtrAndHand (tmp, h, strlen (tmp));		*hText = h;}static void SendMessage (char *subj, Handle text){	pktmsg		*m;	m = (pktmsg *) NewPtrClear (sizeof (pktmsg));	m->from = (pc->messageIn)->to;	m->to = (pc->messageIn)->from;	pc->msgbase_prep_msgid (m);	pc->msgbase_prep_reply (pc->messageIn, m);	m->area[0] = 0;	m->flags = MSGPRIVATE;		strcpy (m->fromname, "AreaFix");	strcpy (m->toname, (pc->messageIn)->fromname);	strcpy (m->subj, subj);		pc->msgbase_ftn_date (m->date, NULL);	m->seenby.nets = NULL;	m->seenby.nodes = NULL;	m->seenby.items = 0;	m->path.nets = NULL;	m->path.nodes = NULL;	m->path.items = 0;	m->text = text;	PtrAndHand (tln, m->text, strlen (tln) + 1);		pc->RouteMessage (m, false);	pc->FreePktMsg (m);}static void SendAlertMessage (char *subj, char *text){	Handle	h;	char	tmp[32];			h = NewHandleClear (strlen (text));	HLock (h);	memcpy (*h, text, strlen (text));	HUnlock (h);	sprintf (tmp, "\r\r");	PtrAndHand (tmp, h, strlen (tmp)+1);	SendMessage (subj, h);}static void RescanArea (short areanum){	long			i, j, amm, ii, nm, start;	pktmsg 			*m;	msgbase_atom	Atom;	char			tmp[512];	Handle			h;		unsigned long	nowis, addon;	GetDateTime ( &nowis );	addon = 60L*60L*24L*max_days;		sprintf (tmp, "<AreaFix> Rescans %#s", (*(pc->Preferences.areasHndls[areanum-1]))->areaName);	pc->putlog ('=', tmp);	pc->base_bsy_raise ();	pc->putProgressName ((*(pc->Preferences.areasHndls[areanum-1]))->areaName);	if (pc->msgbase_open_idx (areanum, true))	{		amm = pc->msgbase_getnummsg ();		if (amm)		{			pc->InitProgress ( (float) amm );						start = (max_messages) ?				((amm > max_messages) ? amm - max_messages : 0) : 0;						for ( j=start; ; j++ )			{				pc->Slice ();				pc->DrawProgress (j);					if (pc->msgbase_read_atom (j, &Atom))				{					if (addon == 0 || ((unsigned long)Atom.stored_time) >= nowis-addon)					{						pc->msgbase_read_message (j, &m, READMODE_REPLY | READMODE_TEXT);												if ((Atom.flags & MSGLOCAL) != 0)						{							pc->ExportEchoesOnlyTo (m, NULL, &(*(pc->Preferences.nodesHndls[link]))->Addr);						}						else						{							h = NewHandle (0);							sprintf (tmp, "AREA:%s\r", m->area);														PtrAndHand (tmp, h, strlen (tmp));							HandAndHand (m->text, h);														DisposeHandle (m->text);							m->text = h;														pc->ExportEchoesOnlyTo (m, (addr *) -1, &(*(pc->Preferences.nodesHndls[link]))->Addr);						}						pc->FreePktMsg (m);					}				}				else					break;			}		}				pc->msgbase_close (CLOSE_ONLY);	}		pc->putProgressName ("\p");	pc->InitProgress ( 1 );	pc->base_bsy_clear ();}static void ParseQuery (char *in){	char		*p, *ttt;	short		i, j, t, ii;	short		flag;		p_acts		acts, cur_acts;		char		temp[512];			Handle		h, h1;	acts = NULL;	flag = 0;		p = in;		while (*p)	{		if (*p == 0x0d)			p++;		else			switch (*p)			{			case '%':	//	Command here				t = fndtoken (af_tokens, p);								switch (t)				{				case 0:		//	%LIST										generate_list (&h);					SendMessage ("You requested available areas list.", h);										if (debug)					{						sprintf (temp, "<AreaFix> %LIST.");						pc->putlog ('=', temp);					}										break;								case 1:		//	%QUERY									generate_query (&h);					SendMessage ("You requested subscribed areas list.", h);					if (debug)					{						sprintf (temp, "<AreaFix> %QUERY.");						pc->putlog ('=', temp);					}					break;								case 2:		//	%HELP									generate_help (&h);					SendMessage ("You requested AreaFix help.", h);					if (debug)					{						sprintf (temp, "<AreaFix> %HELP.");						pc->putlog ('=', temp);					}					break;								case 3:		//	$RESCAN										p += strlen (af_tokens[t]);										while (*p == ' ') p++;										if (*p && *p != '\r')					{						pushtoeoln ( &ttt, &p );						p--;												if (strlen (ttt) < 1)							break;												UprText (ttt, strlen (ttt));														if (debug)						{							sprintf (temp, "<AreaFix> %REASCAN %s.", ttt);							pc->putlog ('=', temp);						}						t = pc->LookForAreaNumber (ttt);										DisposePtr (ttt);						if (t == -1)						{							SendAlertMessage ("Can't rescan area.", "You ordered rescan for area which not found at this system.");							if (debug)							{								sprintf (temp, "<AreaFix> Can't rescan area (not found).");								pc->putlog ('=', temp);							}							break;						}												t--;												for (i=0; i<(*(pc->Preferences.areasHndls[t]))->numExports; i++)							if ((*(pc->Preferences.areasHndls[t]))->Export[i].Export == link)								break;												if (i>=(*(pc->Preferences.areasHndls[t]))->numExports)						{							SendAlertMessage ("Can't rescan area.", "You ordered rescan for area on which you was not subscribed.");							if (debug)							{								sprintf (temp, "<AreaFix> Can't rescan area (not subscribed).");								pc->putlog ('=', temp);							}							break;						}												if ((*(pc->Preferences.areasHndls[t]))->areaflags & (AREA_PASSTROUGH | AREA_STRIPSEEN))						{							SendAlertMessage ("Can't rescan area.", "This area cannot be rescanned.");							if (debug)							{								sprintf (temp, "<AreaFix> Can't rescan area.");								pc->putlog ('=', temp);							}							break;						}												t++;												if (!pc->base_bsy_check ())						{							RescanArea (t);							sprintf (temp, "Area '%#s' has been rescanned.", (*(pc->Preferences.areasHndls[t-1]))->areaName);							SendAlertMessage ("You requested rescan.", temp);						}						else						{							SendAlertMessage ("Can't rescan area.", "Try later. The message base is busy now, sorry.");							if (debug)							{								sprintf (temp, "<AreaFix> Can't rescan area (busy).");								pc->putlog ('=', temp);							}							break;						}					}					else					{						p--;												flag = 2 - flag;						if (debug)						{							sprintf (temp, "<AreaFix> %RESCAN %s.", (flag&2)?"On":"Off");							pc->putlog ('=', temp);						}					}										break;								case 4:		//	%PASSWORD										p += strlen (af_tokens[t]);										while (*p && *p == ' ') p++;										if (*p && *p != '\r')					{						pushtoeoln ( &ttt, &p );						p--;												if (strlen (ttt) > 8 || strlen (ttt) < 1)						{							SendAlertMessage ("You requested password changing", "Too long or empty password requested");							if (debug)							{								sprintf (temp, "<AreaFix> Too long or empty password.");								pc->putlog ('=', temp);							}							break;						}												UprText (ttt, strlen (ttt));						strcpy ((*(pc->Preferences.nodesHndls[link]))->AreaFix_pwd, ttt);						pc->UpdatePreference_Links ();											DisposePtr (ttt);						SendAlertMessage ("You requested password changing", "Password changed succesfuly");						if (debug)						{							sprintf (temp, "<AreaFix> Password changed.");							pc->putlog ('=', temp);						}					}					else					{						p--;						SendAlertMessage ("You requested password changing", "Empty password requested");						if (debug)						{							sprintf (temp, "<AreaFix> Password empty.");							pc->putlog ('=', temp);						}					}										break;								case 5:		//	%MAXMESSAGES										p += strlen (af_tokens[t]);										while (*p && *p == ' ') p++;										if (*p && *p != '\r')					{						pushtoeoln ( &ttt, &p );						p--;												if (sscanf (ttt, "%ld", &max_messages) == 1)						{							if (debug)							{								sprintf (temp, "<AreaFix> Max. messages changed to %ld.", max_messages);								pc->putlog ('=', temp);							}						}						else						{							max_messages = 0;														if (debug)							{								sprintf (temp, "<AreaFix> Attempt to change max. messages. Reset to default.");								pc->putlog ('=', temp);							}						}												DisposePtr (ttt);					}										break;								case 6:		//	%MAXDAYS										p += strlen (af_tokens[t]);										while (*p && *p == ' ') p++;										if (*p && *p != '\r')					{						pushtoeoln ( &ttt, &p );						p--;												if (sscanf (ttt, "%ld", &max_days) == 1)						{							if (debug)							{								sprintf (temp, "<AreaFix> Max. days changed to %ld.", max_days);								pc->putlog ('=', temp);							}						}						else						{							max_days = 14;														if (debug)							{								sprintf (temp, "<AreaFix> Attempt to change max. days. Reset to default.");								pc->putlog ('=', temp);							}						}												DisposePtr (ttt);					}										break;								default:	//	all others										break;				}							passtoeoln (&p);				break;						case '-':	//	unsubscribe								if (!strncmp (p, "---\r", 4) || !strncmp (p, "--- ", 4))				{//					passtoeoln (&p);//					break;									goto nottheend;				}								p++;								pushtoeoln ( &ttt, &p );								if (acts)				{					cur_acts->next = (p_acts) NewPtrClear (sizeof (t_acts));					cur_acts = cur_acts->next;				}				else				{					cur_acts = acts = (p_acts) NewPtrClear (sizeof (t_acts));				}								UprText (ttt, i = strlen (ttt));				strcpy (cur_acts->area, ttt);				cur_acts->flag = flag | 1;								while (i)					if (isalnum(cur_acts->area[i-1]))						break;					else						cur_acts->area[--i] = 0;								DisposePtr (ttt);				break;						case '+':	//	subscribe								p++;							default:	//	default subscribe							if (!isalnum(*p))				{					passtoeoln (&p);					break;				}								pushtoeoln ( &ttt, &p );				if (acts)				{					cur_acts->next = (p_acts) NewPtrClear (sizeof (t_acts));					cur_acts = cur_acts->next;				}				else				{					cur_acts = acts = (p_acts) NewPtrClear (sizeof (t_acts));				}								UprText (ttt, i = strlen (ttt));								strcpy (cur_acts->area, ttt);								cur_acts->flag = flag;								while (i)					if (isalnum(cur_acts->area[i-1]))						break;					else						cur_acts->area[--i] = 0;								DisposePtr (ttt);								break;			}	}	nottheend:		if (cur_acts = acts)	{//	•	Perform subscribing/unsubscribing				h = NewHandle (0);				while (cur_acts)		{			if ((cur_acts->flag & 1) == 1)			{				t = pc->LookForAreaNumber (cur_acts->area);						if (debug)				{					sprintf (temp, "<AreaFix> -%s.", cur_acts->area);					pc->putlog ('=', temp);				}				if (t == -1)				{//	•	No such area										if (strchr (cur_acts->area, '*') || strchr (cur_acts->area, '?'))					{						for (ii=0; ii<pc->Preferences.AreasNumber; ii++)						{							(*(pc->Preferences.areasHndls[ii]))->areaName[(*(pc->Preferences.areasHndls[ii]))->areaName[0]+1] = 0;							if (wildcmp (cur_acts->area, (char *)&(*(pc->Preferences.areasHndls[ii]))->areaName[1]))							{								for (i=0; i<(*(pc->Preferences.areasHndls[ii]))->numExports; i++)									if ((*(pc->Preferences.areasHndls[ii]))->Export[i].Export == link)										break;															if (i<(*(pc->Preferences.areasHndls[ii]))->numExports)								{									(*(pc->Preferences.areasHndls[ii]))->numExports--;																	for (j=i; j<(*(pc->Preferences.areasHndls[ii]))->numExports; j++)									{										(*(pc->Preferences.areasHndls[ii]))->Export[ii] = (*(pc->Preferences.areasHndls[ii]))->Export[j+1];									}									HUnlock ((Handle) pc->Preferences.areasHndls[t]);									SetHandleSize ((Handle) pc->Preferences.areasHndls[ii],										sizeof (areaPrefType) +											sizeof (ExpItem) * (*(pc->Preferences.areasHndls[ii]))->numExports);									MoveHHi ((Handle) pc->Preferences.areasHndls[ii]);									HLock ((Handle) pc->Preferences.areasHndls[ii]);																		sprintf (temp, " %-40s Unlinked\r", (char *)&(*(pc->Preferences.areasHndls[ii]))->areaName[1]);									PtrAndHand (temp, h, strlen (temp));								}							}						}												temp[0] = 0;					}					else						sprintf (temp, " %-40s No such area name\r", cur_acts->area);				}				else				{					t--;										for (i=0; i<(*(pc->Preferences.areasHndls[t]))->numExports; i++)						if ((*(pc->Preferences.areasHndls[t]))->Export[i].Export == link)							break;									if (i<(*(pc->Preferences.areasHndls[t]))->numExports)					{						(*(pc->Preferences.areasHndls[t]))->numExports--;											for (j=i; j<(*(pc->Preferences.areasHndls[t]))->numExports; j++)						{							(*(pc->Preferences.areasHndls[t]))->Export[j] = (*(pc->Preferences.areasHndls[t]))->Export[j+1];						}						HUnlock ((Handle) pc->Preferences.areasHndls[t]);						SetHandleSize ((Handle) pc->Preferences.areasHndls[t],							sizeof (areaPrefType) +								sizeof (ExpItem) * (*(pc->Preferences.areasHndls[t]))->numExports);						MoveHHi ((Handle) pc->Preferences.areasHndls[t]);						HLock ((Handle) pc->Preferences.areasHndls[t]);												sprintf (temp, " %-40s Unlinked\r", cur_acts->area);					}					else					{//	•	Not linked area						sprintf (temp, " %-40s Was not linked. Ignore.\r", cur_acts->area);					}				}							PtrAndHand (temp, h, strlen (temp));			}					cur_acts = cur_acts->next;		}				cur_acts = acts;				while (cur_acts)		{			if ((cur_acts->flag & 1) == 0)			{				t = pc->LookForAreaNumber (cur_acts->area);								if (debug)				{					sprintf (temp, "<AreaFix> +%s.", cur_acts->area);					pc->putlog ('=', temp);				}				if (t == -1)				{//	•	No such area										if (strchr (cur_acts->area, '*') || strchr (cur_acts->area, '?'))					{						for (ii=0; ii<pc->Preferences.AreasNumber; ii++)						{							(*(pc->Preferences.areasHndls[ii]))->areaName[(*(pc->Preferences.areasHndls[ii]))->areaName[0]+1] = 0;							if (wildcmp (cur_acts->area, (char *)&(*(pc->Preferences.areasHndls[ii]))->areaName[1]))							{								for (i=0; i<(*(pc->Preferences.areasHndls[ii]))->numExports; i++)									if ((*(pc->Preferences.areasHndls[ii]))->Export[i].Export == link)										break;															if (i<(*(pc->Preferences.areasHndls[ii]))->numExports)								{			//	•	Linked area			//						sprintf (temp, " %-40s Already linked. Ignore.\r", cur_acts->area);								}								else								{									for (i=0; i<(*(pc->Preferences.nodesHndls[link]))->GroupsNumber; i++)										if ((*(pc->Preferences.nodesHndls[link]))->group[i] ==												(*(pc->Preferences.areasHndls[ii]))->group)											break;																		if (i<(*(pc->Preferences.nodesHndls[link]))->GroupsNumber)									{										(*(pc->Preferences.areasHndls[ii]))->numExports++;																			HUnlock ((Handle) pc->Preferences.areasHndls[ii]);										SetHandleSize ((Handle) pc->Preferences.areasHndls[ii],											sizeof (areaPrefType) +												sizeof (ExpItem) * (*(pc->Preferences.areasHndls[ii]))->numExports);										MoveHHi ((Handle) pc->Preferences.areasHndls[ii]);										HLock ((Handle) pc->Preferences.areasHndls[ii]);																				(*(pc->Preferences.areasHndls[ii]))->Export[(*(pc->Preferences.areasHndls[ii]))->numExports-1].Export = link;										(*(pc->Preferences.areasHndls[ii]))->Export[(*(pc->Preferences.areasHndls[ii]))->numExports-1].Diodes = 0;																				if (cur_acts->flag & 2)										{											if ((*(pc->Preferences.areasHndls[ii]))->areaflags & (AREA_PASSTROUGH | AREA_STRIPSEEN))											{												SendAlertMessage ("Can't rescan area.", "This area cannot be rescanned.");												sprintf (temp, " %-40s Linked\r", (char *)&(*(pc->Preferences.areasHndls[ii]))->areaName[1]);											}											else												if (!pc->base_bsy_check ())												{													RescanArea (t+1);													sprintf (temp, " %-40s Linked and rescanned\r", (char *)&(*(pc->Preferences.areasHndls[ii]))->areaName[1]);												}												else												{													SendAlertMessage ("Can't rescan area.", "Try later. The message base is busy now, sorry.");													sprintf (temp, " %-40s Linked\r", (char *)&(*(pc->Preferences.areasHndls[ii]))->areaName[1]);												}										}										else											sprintf (temp, " %-40s Linked\r", (char *)&(*(pc->Preferences.areasHndls[ii]))->areaName[1]);										PtrAndHand (temp, h, strlen (temp));									}									else									{			//	•	No such area in available groups											//							sprintf (temp, " %-40s No such area in available groups.\r", cur_acts->area);									}								}							}						}												temp[0] = 0;					}					else						sprintf (temp, " %-40s No such area name\r", cur_acts->area);				}				else				{					t--;										for (i=0; i<(*(pc->Preferences.areasHndls[t]))->numExports; i++)						if ((*(pc->Preferences.areasHndls[t]))->Export[i].Export == link)							break;									if (i<(*(pc->Preferences.areasHndls[t]))->numExports)					{//	•	Linked area						sprintf (temp, " %-40s Already linked. Ignore.\r", cur_acts->area);					}					else					{						for (i=0; i<(*(pc->Preferences.nodesHndls[link]))->GroupsNumber; i++)							if ((*(pc->Preferences.nodesHndls[link]))->group[i] ==									(*(pc->Preferences.areasHndls[t]))->group)								break;												if (i<(*(pc->Preferences.nodesHndls[link]))->GroupsNumber)						{							(*(pc->Preferences.areasHndls[t]))->numExports++;													HUnlock ((Handle) pc->Preferences.areasHndls[t]);							SetHandleSize ((Handle) pc->Preferences.areasHndls[t],								sizeof (areaPrefType) +									sizeof (ExpItem) * (*(pc->Preferences.areasHndls[t]))->numExports);							MoveHHi ((Handle) pc->Preferences.areasHndls[t]);							HLock ((Handle) pc->Preferences.areasHndls[t]);														(*(pc->Preferences.areasHndls[t]))->Export[(*(pc->Preferences.areasHndls[t]))->numExports-1].Export = link;							(*(pc->Preferences.areasHndls[t]))->Export[(*(pc->Preferences.areasHndls[t]))->numExports-1].Diodes = 0;														if (cur_acts->flag & 2)							{								if ((*(pc->Preferences.areasHndls[t]))->areaflags & (AREA_PASSTROUGH | AREA_STRIPSEEN))								{									SendAlertMessage ("Can't rescan area.", "This area cannot be rescanned.");									sprintf (temp, " %-40s Linked\r", cur_acts->area);								}								else									if (!pc->base_bsy_check ())									{										RescanArea (t+1);										sprintf (temp, " %-40s Linked and rescanned\r", cur_acts->area);									}									else									{										SendAlertMessage ("Can't rescan area.", "Try later. The message base is busy now, sorry.");										sprintf (temp, " %-40s Linked\r", cur_acts->area);									}							}							else								sprintf (temp, " %-40s Linked\r", cur_acts->area);						}						else						{//	•	No such area in available groups												sprintf (temp, " %-40s No such area in available groups.\r", cur_acts->area);						}					}				}				PtrAndHand (temp, h, strlen (temp));			}						acts = cur_acts->next;			DisposePtr ((Ptr) cur_acts);			cur_acts = acts;		}			pc->UpdatePreference_Areas ();		generate_query (&h1);				HandAndHand (h1, h);		DisposeHandle (h1);				SendMessage ("Change subscribed list.", h);	}}static void PostNotificationAutocreated (void){	pktmsg		*m;	char		temp[512], tmp[128];	m = (pktmsg *) NewPtrClear (sizeof (pktmsg));	m->from = (*(pc->Preferences.homesystem))->mainAddr.ad;//	m->to;	pc->msgbase_prep_msgid (m);	strcpy (m->area, local_area);		strcpy (m->fromname, "AreaFix");	strcpy (m->toname, "All");	strcpy (m->subj, "New area has been autocreated.");		pc->msgbase_ftn_date (m->date, NULL);	m->seenby.nets = NULL;	m->seenby.nodes = NULL;	m->seenby.items = 0;	m->path.nets = NULL;	m->path.nodes = NULL;	m->path.items = 0;	sprintf (temp, "Hello All,\r\r new echo %s has been autocreated.\r", (pc->messageIn)->area);	PtrToHand (temp ,&m->text, strlen (temp));	sprintf (temp, "\rHave a nice day,\r--- " SHUFFLERNAME " " RAVELVERS);	PtrAndHand (temp, m->text, strlen (temp));		sprintf (temp, "\r * Origin: %#s (%s)\r",		(*(pc->Preferences.homesystem))->system,			(char *)pc->printaddr (&(*(pc->Preferences.homesystem))->mainAddr.ad, tmp));				PtrAndHand (temp, m->text, strlen (temp)+1);		pc->ExportEchoes (m, NULL);	m->flags = MSGREAD;	pc->tmpbase_add (m);	pc->FreePktMsg (m);}static void PostTotal (void){	pktmsg		*m;	char		temp[512], tmp[128];	Handle		h;	m = (pktmsg *) NewPtrClear (sizeof (pktmsg));	m->from = (*(pc->Preferences.homesystem))->mainAddr.ad;//	m->to;	pc->msgbase_prep_msgid (m);	strcpy (m->area, local_area);		strcpy (m->fromname, "AreaFix");	strcpy (m->toname, "All");	strcpy (m->subj, "Total list of areas.");		pc->msgbase_ftn_date (m->date, NULL);	m->seenby.nets = NULL;	m->seenby.nodes = NULL;	m->seenby.items = 0;	m->path.nets = NULL;	m->path.nodes = NULL;	m->path.items = 0;	sprintf (temp, "Hello All,\r\r");	PtrToHand (temp ,&m->text, strlen (temp));	generate_totallist (&h);	HandAndHand (h, m->text);	DisposeHandle (h);		sprintf (temp, "\rHave a nice day,\r--- " SHUFFLERNAME " " RAVELVERS);	PtrAndHand (temp, m->text, strlen (temp));		sprintf (temp, "\r * Origin: %#s (%s)\r",		(*(pc->Preferences.homesystem))->system,			(char *)pc->printaddr (&(*(pc->Preferences.homesystem))->mainAddr.ad, tmp));				PtrAndHand (temp, m->text, strlen (temp)+1);		pc->ExportEchoes (m, NULL);	m->flags = MSGREAD;	pc->tmpbase_add (m);	pc->FreePktMsg (m);}static void PostNotificationOrphan (Str255 echo){	pktmsg		*m;	char		temp[512], tmp[128];	m = (pktmsg *) NewPtrClear (sizeof (pktmsg));	m->from = (*(pc->Preferences.homesystem))->mainAddr.ad;//	m->to;	pc->msgbase_prep_msgid (m);	strcpy (m->area, local_area);		strcpy (m->fromname, "AreaFix");	strcpy (m->toname, "All");	strcpy (m->subj, "Area should be deleted as soon as possible.");		pc->msgbase_ftn_date (m->date, NULL);	m->seenby.nets = NULL;	m->seenby.nodes = NULL;	m->seenby.items = 0;	m->path.nets = NULL;	m->path.nodes = NULL;	m->path.items = 0;	sprintf (temp, "Hello All,\r\r the orphan echo %#s will be deleted from system as soon as possible.\r", echo);	PtrToHand (temp ,&m->text, strlen (temp));	sprintf (temp, "\rHave a nice day,\r--- " SHUFFLERNAME " " RAVELVERS);	PtrAndHand (temp, m->text, strlen (temp));		sprintf (temp, "\r * Origin: %#s (%s)\r",		(*(pc->Preferences.homesystem))->system,			(char *)pc->printaddr (&(*(pc->Preferences.homesystem))->mainAddr.ad, tmp));				PtrAndHand (temp, m->text, strlen (temp)+1);		pc->ExportEchoes (m, NULL);	m->flags = MSGREAD;	pc->tmpbase_add (m);	pc->FreePktMsg (m);}static void CheckOrphans (void){	short		i, j, k, l, m;	for (j=0; j<pc->Preferences.AreasNumber; j++)	{		if (((*(pc->Preferences.areasHndls[j]))->areaflags & AREA_PASSTROUGH) &&			(*(pc->Preferences.areasHndls[j]))->numExports <= 1)		{			PostNotificationOrphan ((*(pc->Preferences.areasHndls[j]))->areaName);		}	}}void main (PlugsControlPtr plugcontrol){	long		res;	short		i, j, k;	addr		tempaddr;			char		stmp[512], stemp[128];//	pktmsg		*m;//	DateTimeRec	dtr;	Str255		plugcfg;	EnterCodeResource ();	pc = plugcontrol;	switch (pc->opCode)	{	case plugWelcome:		//	StartUp call of plug-ins. We make order and init. prefs.				res = plugCustomLaunch | plugCustomNames | plugTossMsgMail | plugMisc;		pStrCopy (pc->thisplugPath, plugcfg);		pStrConc (plugcfg, "\p.cfg", plugcfg);				local_area[0] = 0;				ReadTemplates (plugcfg);		if (local_area[0])			UprText (local_area, strlen (local_area));		if (debug)			pc->putlog ('=', "<AreaFix " RAVELISA "> Installed (DEBUG mode).");		else			pc->putlog ('=', "<AreaFix " RAVELISA "> Installed.");		break;		case plugMisc:				switch (pc->retCode)		{		case secondAutocreated:					if (local_area[0])			{				PostNotificationAutocreated ();			}						break;		}				res = plugRetContinue;		break;		case plugCustomNames:			pc->misc.names.plugInvokeNames = invokers;		res = plugRetContinue;		break;		case plugTossMsgMail:			res = plugRetContinue;		if (strcasecmp ((pc->messageIn)->toname, "AreaFix") &&			strcasecmp ((pc->messageIn)->toname, "AreaMgr") &&			strcasecmp ((pc->messageIn)->toname, "AreaManager"))		{	//	•	Not for AreaFix			break;		}				sprintf (stmp, "<AreaFix> Operate request from %s (%s).",			(pc->messageIn)->fromname, (char *)pc->printaddr (&(pc->messageIn)->from, stemp) );		pc->putlog ('=', stmp);		if (debug)		{			pc->add_to_other (pc->messageIn, "BADAREA", NULL, "Debugging mirror");		}		res = plugRetDropMessage;				if ((link = pc->LookForLinkNumber (&(pc->messageIn)->from)) == -1)		{	//	•	Unlisted system assertion! >8-E~			pc->putlog ('=', "<AreaFix> Request from unlisted system.");			SendAlertMessage ("Intruder!!! Intrueder!!!!", "Request to AreaFix from unlisted system.");			pc->add_to_other (pc->messageIn, "BADAREA", NULL, "Request from unlisted system");			break;		}		tempaddr = ((*(pc->Preferences.nodesHndls[link]))->yourAka) ?			(*(pc->Preferences.homesystem))->AKAAddr[(*(pc->Preferences.nodesHndls[link]))->yourAka-1].ad :			(*(pc->Preferences.homesystem))->mainAddr.ad;		if (!pc->cmp2addrs (&tempaddr, &(pc->messageIn)->to))		{	//	•	Listed system to wrong boss assertion! >8-E~			pc->putlog ('=', "<AreaFix> Request to wrong boss.");			SendAlertMessage ("Wrong node address.", "Request to AreaFix on wrong address.");			pc->add_to_other (pc->messageIn, "BADAREA", NULL, "Request to wrong boss");			break;		}		if (!(*(pc->Preferences.nodesHndls[link]))->AreaFix_pwd[0])		{	//	•	Maintance for this system not allowed assertion! >8-E~			pc->putlog ('=', "<AreaFix> Remote maintance for this system not allowed.");			SendAlertMessage ("You can't requerst AreaFix", "Remote areas maintance for you is not allowed.");			pc->add_to_other (pc->messageIn, "BADAREA", NULL, "Maintance for this system not allowed");			break;		}		if (strncasecmp ((*(pc->Preferences.nodesHndls[link]))->AreaFix_pwd,							(pc->messageIn)->subj, 8))		{	//	•	Wrong password assertion! >8-E~			pc->putlog ('=', "<AreaFix> Wrong password.");			SendAlertMessage ("Intruder!!! Intrueder!!!!", "Wrong password.");			pc->add_to_other (pc->messageIn, "BADAREA", NULL, "Wrong password");			break;		}			//	•	Allright now, proceed…			max_messages = 0;		//	default 0 last messages in base, i.e. whole base		max_days = 14;			//	default scan for messages arrived for last 14 days			HLock ((pc->messageIn)->text);		ParseQuery (*(pc->messageIn)->text);		CheckOrphans ();		pc->Resolver (MOVE_ARCMAIL);		HUnlock ((pc->messageIn)->text);		break;		case plugCustomLaunch:				if (!strcasecmp (invokers[0], pc->misc.plugInvokeName))		{			CheckOrphans ();			PostTotal ();						pc->Resolver (MOVE_ARCMAIL);			res = plugRetNoError;		}		else			res = plugRetWrongCustom;		break;		default:				//	We're ignoring all other opCodes							//	(by the way, it's impossible unordered calls)			res = plugRetContinue;		break;	}	pc->retCode = res;	ExitCodeResource ();	}