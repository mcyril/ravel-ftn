/*•••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••	Copyright © 1996-1997 Cyril Moorzin		При использовании исходных текстов SDK указание Copyright © 1996-1997 Cyril Moorzin		обязательно.		Так же при генерации писем обязательно упоминание название пакета Ravel в tearline.				Ravel SDK поставляется в виде "as is". Автор не несет ответственности за		несовместимость Plug-Ins в будущих версиях RavelSHUFFLER при использовании		undewater приемов программирования.				Не существует НИКАКОЙ документации по Ravel SDK.		Так же автор пока отказался от распространения исходных текстов не только работы		с базой сообщений, но и старых релизов RavelQUILL.  •••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••*////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// PLEASE NOTE! LHA RESOURCE WAS CHANGED SINCE SIE 6.0. FIX IT ;)///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////#include <string.h>//#include <stdio.h>#include <A4Stuff.h>#include "ravel_msg_base.h"#include "Ravel_Prefs.h"#include "PascalStr.h"#include "Ravel_PlugIns.h"void main (PlugsControlPtr plugcontrol){	typedef struct {			FSSpec		*source;		FSSpec		*destination;				Boolean		One;		Boolean		Two;		Boolean		Tri;			} SEParam;		pascal short (*SEngEntry)( SEParam *par1, FSSpec *par2 );	char		tmp[128];	Handle		h;	SEParam		sep;	Boolean		res;	FSSpec		temp;	short		iErr, vRefNum, wdRefNum, EngResFile, oldRes, module;	long		dirID, cummulative;		Boolean		StuffItExist;		EnterCodeResource ();//Debugger ();	switch (plugcontrol->opCode)	{	case plugWelcome:		//	StartUp call of plug-ins. We make order and init. prefs.						StuffItExist = false;				oldRes = CurResFile ();				iErr = FindFolder ( kOnSystemDisk, kExtensionFolderType, kDontCreateFolder, &vRefNum, &dirID );		if (iErr)			return;				cummulative = 0;				iErr = OpenWD ( vRefNum, dirID, 'Cyrl', &wdRefNum );		if (!iErr)		{			EngResFile = OpenRFPerm ( "\pStuffIt Engine™", wdRefNum, fsRdPerm );						if ( EngResFile != -1 )			{								UseResFile (EngResFile);								h = Get1Resource ( 'Eng ', 3 );	// for ZIP == #3				if (h)				{					ReleaseResource (h);					cummulative |= arcZIP;				}								h = Get1Resource ( 'Eng ', 4 );	//     ARC == #4				if (h)				{					ReleaseResource (h);					cummulative |= arcARC;				}				h = Get1Resource ( 'Eng ', 11 );	//     LHA == #11				if (h)				{					ReleaseResource (h);					cummulative |= arcLZH;				}				CloseResFile ( EngResFile );				UseResFile (oldRes);			}						CloseWD ( wdRefNum );		}		if (cummulative)			StuffItExist = true;		if (StuffItExist)		{			plugcontrol->retCode = plugCompExtr;			//	Decompressor			plugcontrol->misc.arc.archiveType = cummulative;			plugcontrol->misc.arc.archiveAction = arcExpand;						strcpy (tmp, "<StuffIt Engine™ Bridge> Installed (");						if (cummulative & arcZIP)				strcat (tmp, " ZIP");						if (cummulative & arcARC)				strcat (tmp, " ARC");						if (cummulative & arcLZH)				strcat (tmp, " LHA");						strcat (tmp, " )");			plugcontrol->putlog ('±', tmp);		}		else			plugcontrol->retCode = 0L;			//	Decompressor				break;			case plugCompExtr:	//	We ordered only one call - Extract archive				res = false;				while (1)		{			iErr = FindFolder ( kOnSystemDisk, kExtensionFolderType, kDontCreateFolder, &vRefNum, &dirID );			if (iErr)				break;						iErr = OpenWD ( vRefNum, dirID, 'Cyrl', &wdRefNum );			if (iErr)				break;						oldRes = CurResFile ();			EngResFile = OpenRFPerm ( "\pStuffIt Engine™", wdRefNum, fsRdPerm );						if ( EngResFile != -1 )			{				UseResFile ( EngResFile );								if (plugcontrol->misc.arc.archiveType == arcZIP)					module = 3;				else					if (plugcontrol->misc.arc.archiveType == arcARC)						module = 4;					else						if (plugcontrol->misc.arc.archiveType == arcLZH)							module = 11;						else							break;								h = Get1Resource ( 'Eng ', module );				if (h)				{					HLock ( h );					(char *) SEngEntry = StripAddress ( *h );										sep.source = plugcontrol->source;					sep.destination = plugcontrol->destination;										sep.One = false;					// Create folder					sep.Two = false; 					// Kill original					sep.Tri = false;					// LF translation										iErr = SEngEntry ( &sep, &temp );										res = (iErr == noErr);										ReleaseResource ( h );				}								UseResFile ( oldRes );								CloseResFile ( EngResFile );			}						CloseWD ( wdRefNum );						break;		}				plugcontrol->retCode = (res) ? plugRetContinue : plugFatalArch;				break;	case plugSuicide:		//	Ignore in this case.			break;	default:				//	We're ignoring all other opCodes							//	(by the way, it's impossible unordered calls)		plugcontrol->retCode = plugFatalArch;		break;	}	ExitCodeResource ();	}