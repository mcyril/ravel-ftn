#include <string.h>#include <stdio.h>#include <A4Stuff.h>#include "ravel_msg_base.h"#include "Ravel_Prefs.h"#include "PascalStr.h"#include "myEnv.h"#include "stringutl.h"#include "Ravel_PlugIns.h"//	far QDGlobals	qd;typedef struct _TICStruct {	Str31		AreaName;	Str255		AreaPath;	long		AreaFlags;} TICType;typedef struct _TICList {	short		TICs;	TICType		TIC[];	} *TICTypePtr, **TICTypeHndl;typedef struct _StatStruct {	short		Area;	Str31		FileName;	Str255		FileComment;} StatType;typedef struct _StatList {	short		Sts;	StatType	St[];	} *StatTypePtr, **StatTypeHndl;TICTypeHndl		AreaListHndl;StatTypeHndl	Stat;Str255			Default;short	tic, fil;static char	*mnt[12] = { "Jan", "Feb", "Mar",						 "Apr", "May", "Jun",						 "Jul", "Aug", "Sep",						 "Oct", "Nov", "Dec" };static char	*greate1 = "Dear SysOp!\xD\xDThe following files has been arrived to your system:\xD\xD";static char	*greate2 = "In area: ";static char	*greate3 = "\xD\xDThank you.\xD\xD--- ExoTIC 1.0b for Ravel\xD";static Boolean fillStat ( PlugsControlPtr plugcontrol, StatType *stt, char *ttt ){	char		temp[256];	Str31		areaName;	Str31		fileName;	Str255		fileDesc, st;	char		*s;	short		i;	FSSpec		specSrc, specDst;	long		dummy;				s = ttt;		areaName[0] = 0;	fileName[0] = 0;	fileDesc[0] = 0;	while (*s)	{		if (*s == 0x0A)		{			s++;			continue;		}			if ( !strncmp ( "Area ", s, 5) )		{			s += 5;						i = 1;			while ( *s != 0x0D )			{				areaName[i] = *s;				i++;				s++;			}						areaName[0] = i-1;		}		else			if ( !strncmp ( "Desc ", s, 5) )			{				s += 5;								i = 1;				while ( *s != 0x0D )				{					fileDesc[i] = *s;					i++;					s++;				}								fileDesc[0] = i-1;			}			else				if ( !strncmp ( "File ", s, 5) )				{					s += 5;										i = 1;					while ( *s != 0x0D )					{						fileName[i] = *s;						i++;						s++;					}										fileName[0] = i-1;				}				while (*s && *s != 0x0D)			s++;				if (*s == 0x0D)			s++;	}	if (areaName[0] && fileName[0])	{				for (i=0; i<(*AreaListHndl)->TICs; i++)			if (!pStrComp ((*AreaListHndl)->TIC[i].AreaName, areaName))				break;				if (i>=(*AreaListHndl)->TICs)		{			HUnlock ((Handle) AreaListHndl);			(*AreaListHndl)->TICs++;			SetHandleSize ( (Handle) AreaListHndl, sizeof (short) + (*AreaListHndl)->TICs * sizeof (TICType) );						HLock ((Handle) AreaListHndl);			i = (*AreaListHndl)->TICs - 1;			(*AreaListHndl)->TIC[i].AreaFlags = 0;			pStrCopy (areaName, (*AreaListHndl)->TIC[i].AreaName);			pStrConc (Default, areaName, (*AreaListHndl)->TIC[i].AreaPath);			pStrConc ((*AreaListHndl)->TIC[i].AreaPath, "\p:", (*AreaListHndl)->TIC[i].AreaPath);		}				stt->Area = i;				pStrCopy ( fileName, stt->FileName );		stt->FileName[stt->FileName[0]+1] = 0;				pStrCopy ( fileDesc, stt->FileComment );		stt->FileComment[stt->FileComment[0]+1] = 0;				pStrConc ( plugcontrol->Preferences.InboundPath, fileName, st );				if (!FSMakeFSSpec ( 0, 0, st, &specSrc ))		{			if (FSMakeFSSpec ( 0, 0, (*AreaListHndl)->TIC[i].AreaPath, &specDst ))			{				if (DirCreate ( 0, 0, (*AreaListHndl)->TIC[i].AreaPath, &dummy ))				{					sprintf (temp, "<ExoTIC> Cannot create destination folder: #s", (*AreaListHndl)->TIC[i].AreaPath );					plugcontrol->putlog ('=', temp);					return false;				}			}						fil++;			FSpCatMove ( &specSrc, &specDst );						return true;		}				plugcontrol->putlog ('=', "<ExoTIC> TIC file without file itself");		return false;	}	else	{		plugcontrol->putlog ('=', "<ExoTIC> Bad TIC file");		return false;	}}static void ParseFolder (PlugsControlPtr plugcontrol, StringPtr dir){	short			mdir;						// working directory reference number╔	CInfoPBRec		cipbr;						/* local pb */	HFileInfo		*fpb = (HFileInfo *)&cipbr;	/* to pointers */	short			rc, idx;	Str32			filename;	Boolean			alldone;	short			refnum;	char			temp[256];		int		a;	dir[dir[0]+1] = 0;	if ( ( mdir = myOpenWD ( dir ) ) == 0 )	{		sprintf (temp, "<ExoTIC> Unable to open directory %s", &dir[1]);		plugcontrol->putlog ('=', temp);		return;	}	fpb->ioNamePtr = filename;	fpb->ioVRefNum = mdir;// е Killing loop...	do {		alldone = TRUE;				for ( idx=1; TRUE; idx++)		{											/* indexing loop */			plugcontrol->Slice ();					//	make chance for other applications			fpb->ioDirID = 0L;						/* must set on each loop */			fpb->ioFDirIndex = idx;			filename[0] = 0;						rc = PBGetCatInfoSync (&cipbr);			if (rc) break;							/* exit when no more entries */				if ( !(fpb->ioFlAttrib & 16) && filename[0] == 12 )			{										/* not folder */				filename[filename[0]+1] = 0;								if ( !strcasecmp ( (char *) &filename[filename[0]-3], ".TIC" ) )				{	//				ProcessPacket ( filename, mdir );						// еееееееееееееееее										if ( FSOpen (filename, mdir, &refnum) == noErr )					{						Handle		ttt;						long		length;						StatType	zzz;						tic++;												GetEOF ( refnum, &length );						ttt = NewHandleClear (length+1);						HLock (ttt);						FSRead ( refnum, &length, *ttt );						FSClose ( refnum );						if (fillStat (plugcontrol, &zzz, *ttt))						{							(*Stat)->Sts++;							SetHandleSize ( (Handle) Stat, sizeof (short) + (*Stat)->Sts * sizeof (StatType) );													(*Stat)->St[(*Stat)->Sts-1] = zzz;						}						DisposeHandle (ttt);					}						// еееееееееееееееее					alldone = FALSE;					FSDelete ( filename, mdir );				}			}		}	} while (!alldone);		myCloseWD ( mdir );}void main (PlugsControlPtr plugcontrol){	Boolean		res;	short		ownFile, oldRes, i, j;	Handle		h;	pktmsg		*m;	DateTimeRec	dtr;	char		stemp[256];	long		dummy;	Boolean		was;	EnterCodeResource ();	oldRes = CurResFile ();	switch (plugcontrol->opCode)	{	case plugWelcome:		//	StartUp call of plug-ins. We make order and init. prefs.				res = true;				plugcontrol->retCode = (res) ? plugPreTossLaunch : 0;				if (res)			plugcontrol->putlog ('=', "<ExoTIC " RAVELISA "> Installed.");		break;			case plugPreTossLaunch:			res = false;			ownFile = OpenRFPerm ( plugcontrol->thisplugPath, 0, fsRdPerm );		if (ownFile != -1)		{			res = true;						UseResFile (ownFile);						h = Get1Resource ( 'STR ', 0 );			if (h)			{				pStrCopy ( (StringPtr) *h, Default );				ReleaseResource ( h );								DirCreate ( 0, 0, Default, &dummy );				h = Get1Resource ( 'pref', 0 );				if (h)				{					DetachResource (h);					MoveHHi (h);					HLock (h);						AreaListHndl = (TICTypeHndl) h;				}				else				{					AreaListHndl = (TICTypeHndl) NewHandle (sizeof (short));										if (!AreaListHndl)						goto bailout;										MoveHHi (h);					HLock (h);						(*AreaListHndl)->TICs = 0;				}			}			else				res = false;						UseResFile (oldRes);			CloseResFile (ownFile);		}bailout:		if (res)		{			plugcontrol->putlog ('=', "<ExoTIC> is scanning for inbound TICs.");						Stat = (StatTypeHndl) NewHandle (sizeof (short));			(*Stat)->Sts = 0;			tic = 0;			fil = 0;						ParseFolder (plugcontrol, plugcontrol->Preferences.InboundPath);						if ((*Stat)->Sts)			{				m = (pktmsg *) NewPtrClear (sizeof (pktmsg));				m->from = (*(plugcontrol->Preferences.homesystem))->mainAddr.ad;				m->to = (*(plugcontrol->Preferences.homesystem))->mainAddr.ad;								m->area[0] = 0;				m->flags = MSGPRIVATE | MSGREAD;	// | MSGKILL;								strcpy (m->fromname, "ExoTIC");				(*(plugcontrol->Preferences.homesystem))->sysop[(*(plugcontrol->Preferences.homesystem))->sysop[0]+1] = 0;				strcpy (m->toname, (char *) &(*(plugcontrol->Preferences.homesystem))->sysop[1]);				strcpy (m->subj, "ExoTIC file receiving report.");								plugcontrol->msgbase_prep_msgid (m);				plugcontrol->msgbase_ftn_date (m->date, NULL);				m->seenby.nets = NULL;				m->seenby.nodes = NULL;				m->seenby.items = 0;				m->path.nets = NULL;				m->path.nodes = NULL;				m->path.items = 0;				m->text = NewHandle (0);								PtrAndHand ( greate1, m->text, strlen (greate1) );								for (i=0; i<(*AreaListHndl)->TICs; i++)				{									was = false;										for (j=0; j<(*Stat)->Sts; j++)						if ((*Stat)->St[j].Area == i)						{							if (!was)							{								PtrAndHand ( "\xD", m->text, 1 );								PtrAndHand ( greate2, m->text, strlen (greate2) );								PtrAndHand ( &(*AreaListHndl)->TIC[i].AreaName[1], m->text, (*AreaListHndl)->TIC[i].AreaName[0] );								PtrAndHand ( "\xD\xD", m->text, 2 );								was = true;							}													sprintf ( stemp, "     %-20s    %-40s\xD", &(*Stat)->St[j].FileName[1], &(*Stat)->St[j].FileComment[1] );														PtrAndHand ( stemp, m->text, strlen (stemp) );				//			(*Stat)->St[j].Area = -1;						}				}				PtrAndHand ( greate3, m->text, strlen (greate3) );				SetHandleSize (m->text, GetHandleSize (m->text) + 1);				(*(m->text))[GetHandleSize (m->text) - 1] = 0;				plugcontrol->tmpbase_add (m);				plugcontrol->FreePktMsg (m);			}						DisposeHandle ((Handle) Stat);						ownFile = OpenRFPerm ( plugcontrol->thisplugPath, 0, fsRdWrPerm );			if (ownFile != -1)			{				res = true;								UseResFile (ownFile);								h = Get1Resource ( 'pref', 0 );				if (h)				{					RemoveResource (h);				}				UpdateResFile (ownFile);								AddResource ( (Handle) AreaListHndl, 'pref', 0, "\p" );				WriteResource ( (Handle) AreaListHndl );				UpdateResFile (ownFile);								ReleaseResource ( (Handle) AreaListHndl );								UseResFile (oldRes);				CloseResFile (ownFile);			}						sprintf (stemp, "<ExoTIC> TICs processed: %3d   Files moved: %3d", tic, fil);			plugcontrol->putlog ('=', stemp);		}		plugcontrol->retCode = plugRetContinue;		break;		case plugCustomLaunch:			//	HATCH here !!!!!!!!!!!! (not implemented)			plugcontrol->retCode = plugRetWrongCustom;		break;		case plugSuicide:		//	Destructive call of plug-ins.			break;			default:				//	We're ignoring all other opCodes (by the way, it's impossible calls)			plugcontrol->retCode = plugRetContinue;		break;	}	ExitCodeResource ();	}