//#define DEBUG 1/* * ZipItAppleEvents.c * * This module contains all the function calls necessary to control ZipIt * via AppleEvents. Hence, it requires System 7. * * Public functions: * *	OSErr ZipLaunch(const FSSpec *application, Boolean inBackground, *					ProcessSerialNumber *psn); * *		Launches ZipIt. You may pass NULL as the 'application' parameter if you want *		the module to attempt to find ZipIt on its own; otherwise, you should pass *		a pointer to an FSSpec record pointing to ZipIt. If ZipIt is already running, *		this function will not attempt to launch another copy. The function will *		return the process serial number in the 'psn' parameter. You need this variable *		for other calls. 'inBackground' lets you specify whether or not ZipIt should *		be launched into the background. * *	OSErr ZipCompress(const FSSpec files[], short numFiles, *					  const FSSpec *archive, Boolean addToArchive, Boolean canInteract, *					  const ProcessSerialNumber *psn); * *		'files' is an array of 'numFiles' FSSpec records. This function tells ZipIt *		to compress those files. If addToArchive is true, then 'archive' must exist. *		ZipIt will append the files specified to the archive specified. If addToArchive *		is false, then archive must not exist. ZipIt will create a new archive with *		only the files specified. psn is the process serial number returnd by ZipLaunch. * *	OSErr ZipDecompress(const FSSpec *archive, const FSSpec *folder, Boolean canInteract, *						const ProcessSerialNumber *psn); * *		This function decompresses all files from the specified archive. There is *		currently no supported method to tell ZipIt to only decompress certain files. * *	OSErr ZipQuit(Boolean canInteract, const ProcessSerialNumber *psn); * *		Tells ZipIt to quit. * */ #include "ZipItAppleEvents.h"#include <Gestalt.h>#include <AppleEvents.h>#define SIGNATURE	'ZIP 'static Boolean TestGestalt (OSType selector, char which){	long	response;		if (Gestalt(selector, &response))		return FALSE;	else		return BitTst(&response, 31-which);}static OSErr FindZipIt(short volume, FSSpec *app){	IOParam					pb1;	DTPBRec					pb2;	GetVolParmsInfoBuffer	volInfo;	OSErr					error;	Str255					name;		/* We must find ZipIt's FSSpec from the desktop database. */	/* First, does the specified volume HAVE a desktop database? */	pb1.ioCompletion = NULL;	pb1.ioVRefNum = volume;	pb1.ioNamePtr = NULL;	pb1.ioBuffer = (Ptr)&volInfo;	pb1.ioReqCount = sizeof(GetVolParmsInfoBuffer);	error = PBHGetVolParmsSync ((HParamBlockRec *)&pb1);	if (!error && (BitTst(&volInfo.vMAttrib, 31 - bHasDesktopMgr))) {		pb2.ioNamePtr = NULL;		pb2.ioVRefNum = volume;		error = PBDTGetPath(&pb2);				if (!error) {					pb2.ioNamePtr = name;			pb2.ioIndex = 0;			pb2.ioFileCreator = SIGNATURE;						error = PBDTGetAPPLSync(&pb2);						if (!error)				error = FSMakeFSSpec(volume, pb2.ioAPPLParID, name, app);		}	} else if (!error)		error = paramErr;		return error;}			OSErr ZipSearch(const FSSpec *application, Boolean inBackground, ProcessSerialNumber *psn){	OSErr				error, error2;	ProcessInfoRec		info;	FSSpec				zipit;	LaunchParamBlockRec	lpb;		if (application)		zipit = *application;		if (!psn)		return paramErr;			if (TestGestalt(gestaltOSAttr, gestaltLaunchControl)) {				/* Search for a process with ZipIt's signature. If one is found, then ZipIt			is running, and we do not have to launch it or do anything except return			its PSN.		*/				psn->highLongOfPSN = 0;		psn->lowLongOfPSN = kNoProcess;		info.processInfoLength = sizeof(info);		info.processName = NULL;		info.processAppSpec = NULL;		do {			error = GetNextProcess(psn);			if (!error)				GetProcessInformation(psn, &info);		} while (!error && (info.processSignature != SIGNATURE));					if (!error)			return noErr;				}		if (!application) {			HVolumeParam	pb;				pb.ioNamePtr = NULL;		pb.ioVolIndex = 0;		pb.ioVRefNum = 0;				do {			++pb.ioVolIndex;			error = PBHGetVInfoSync((HParamBlockRec *)&pb);			if (!error)				error2 = FindZipIt(pb.ioVRefNum, &zipit);		} while (!error && error2);				if (error2)			return fnfErr;	}				return noErr;}OSErr ZipLaunch(const FSSpec *application, Boolean inBackground, ProcessSerialNumber *psn){	OSErr				error, error2;	ProcessInfoRec		info;	FSSpec				zipit;	LaunchParamBlockRec	lpb;		if (application)		zipit = *application;		if (!psn)		return paramErr;			if (TestGestalt(gestaltOSAttr, gestaltLaunchControl)) {				/* Search for a process with ZipIt's signature. If one is found, then ZipIt			is running, and we do not have to launch it or do anything except return			its PSN.		*/				psn->highLongOfPSN = 0;		psn->lowLongOfPSN = kNoProcess;		info.processInfoLength = sizeof(info);		info.processName = NULL;		info.processAppSpec = NULL;		do {			error = GetNextProcess(psn);			if (!error)				GetProcessInformation(psn, &info);		} while (!error && (info.processSignature != SIGNATURE));					if (!error)			return noErr;				}		if (!application) {			HVolumeParam	pb;				pb.ioNamePtr = NULL;		pb.ioVolIndex = 0;		pb.ioVRefNum = 0;				do {			++pb.ioVolIndex;			error = PBHGetVInfoSync((HParamBlockRec *)&pb);			if (!error)				error2 = FindZipIt(pb.ioVRefNum, &zipit);		} while (!error && error2);				if (error2)			return fnfErr;	}		if (!TestGestalt(gestaltOSAttr, gestaltLaunchFullFileSpec))		return paramErr;			lpb.launchBlockID = extendedBlock;	lpb.launchEPBLength = extendedBlockLen;	lpb.launchFileFlags = 0;	lpb.launchControlFlags = launchContinue + launchNoFileFlags + (inBackground ? launchDontSwitch : 0);	lpb.launchAppSpec = &zipit;	lpb.launchAppParameters = NULL;		error = LaunchApplication(&lpb);		if (!error)		*psn = lpb.launchProcessSN;			return error;}OSErr ZipCompress(const FSSpec files[], short numFiles,				  const FSSpec *archive, Boolean addToArchive, Boolean canInteract,				  const ProcessSerialNumber *psn){	AppleEvent		event, reply;	AEDesc			desc;	OSErr			error;	AEAddressDesc	address;	short			counter;		address.descriptorType = typeNull;	event.descriptorType = typeNull;	desc.descriptorType = typeNull;	reply.descriptorType = typeNull;		error = AECreateDesc(typeProcessSerialNumber, psn, sizeof(*psn), &address);	if (error)		return error;		if (!addToArchive) {		error = AECreateAppleEvent(kCompressionClass, kAENewWindow, &address,									kAutoGenerateReturnID, kAnyTransactionID, &event);									//		if (error)//			goto cleanup;					/* No parameters for this event */				error = AESend(&event, &reply, (canInteract ? kAECanInteract : kAENeverInteract) + kAEWaitReply,						kAENormalPriority, kAEDefaultTimeout, NULL, NULL);								AEDisposeDesc(&event);		AEDisposeDesc(&reply);	} else {			error = AECreateAppleEvent(kCoreEventClass, kAEOpenDocuments, &address,									kAutoGenerateReturnID, kAnyTransactionID, &event);									//		if (error)//			goto cleanup;					error = AEPutParamPtr(&event, keyDirectObject, typeFSS, archive, sizeof(FSSpec));		//		if (error)//			goto cleanup;					error = AESend(&event, &reply, (canInteract ? kAECanInteract : kAENeverInteract) + kAEWaitReply,						kAENormalPriority, kAEDefaultTimeout, NULL, NULL);								AEDisposeDesc(&event);		AEDisposeDesc(&reply);	}	#ifdef DEBUG	if (event.descriptorType != typeNull)		Debugger();#endif					//	if (error)//		goto cleanup;			error = AECreateAppleEvent(kCompressionClass, kAEAddFiles, &address,								kAutoGenerateReturnID, kAnyTransactionID, &event);								//	if (error)//		goto cleanup;		error = AECreateList(NULL, 0, FALSE, &desc);	//	if (error)//		goto cleanup;			for (counter = 0; counter < numFiles; counter++) {		error = AEPutPtr(&desc, 0, typeFSS, &files[counter], sizeof(FSSpec));//		if (error)//			goto cleanup;	}		error = AEPutParamDesc(&event, keyDirectObject, &desc);	//	if (error)//		goto cleanup;		/* We should be able to get away with a five-minute timeout, because if it takes		longer, ZipIt will reset the timer. But you can feel free to modify this number.	*/		error = AESend(&event, &reply, (canInteract ? kAECanInteract : kAENeverInteract) + kAEWaitReply,					kAENormalPriority, 18000, NULL, NULL);						AEDisposeDesc(&desc);	AEDisposeDesc(&event);	AEDisposeDesc(&reply);	//	if (error)//		goto cleanup;				/* Save file. Archive is optional parameter. */		error = AECreateAppleEvent(kCompressionClass, kAESaveFile, &address,								kAutoGenerateReturnID, kAnyTransactionID, &event);								//	if (error)//		goto cleanup;			if (!addToArchive && archive) {			error = AEPutParamPtr(&event, keyFile, typeFSS, archive, sizeof(FSSpec));		//		if (error)//			goto cleanup;				}		error = AESend(&event, &reply, (canInteract ? kAECanInteract : kAENeverInteract) + kAEWaitReply,					kAENormalPriority, 18000, NULL, NULL);						AEDisposeDesc(&event);	AEDisposeDesc(&reply);					//	if (error)//		goto cleanup;	error = AECreateAppleEvent(kCompressionClass, kAECloseWindow, &address,								kAutoGenerateReturnID, kAnyTransactionID, &event);								//	if (error)//		goto cleanup;	error = AESend(&event, &reply, (canInteract ? kAECanInteract : kAENeverInteract) + kAEWaitReply,					kAENormalPriority, kAEDefaultTimeout, NULL, NULL);	//cleanup:	AEDisposeDesc(&event);	AEDisposeDesc(&desc);	AEDisposeDesc(&address);	AEDisposeDesc(&reply);		return error;				}OSErr ZipDecompress(const FSSpec *archive, const FSSpec *folder, Boolean canInteract,					const ProcessSerialNumber *psn){	AppleEvent		event, reply;	OSErr			error;	AEAddressDesc	address;		address.descriptorType = typeNull;	event.descriptorType = typeNull;	reply.descriptorType = typeNull;		error = AECreateDesc(typeProcessSerialNumber, psn, sizeof(*psn), &address);	if (error)		return error;		error = AECreateAppleEvent(kCompressionClass, kAEExtractFiles, &address,								kAutoGenerateReturnID, kAnyTransactionID, &event);								//	if (error)//		goto cleanup;			error = AEPutParamPtr(&event, keyFolder, typeFSS, folder, sizeof(FSSpec));	//	if (error)//		goto cleanup;			error = AEPutParamPtr(&event, keyOpenFile, typeFSS, archive, sizeof(FSSpec));	//	if (error)//		goto cleanup;			error = AESend(&event, &reply, (canInteract ? kAECanInteract : kAENeverInteract) + kAEWaitReply,					kAENormalPriority, kAEDefaultTimeout, NULL, NULL);			//cleanup:	AEDisposeDesc(&event);	AEDisposeDesc(&address);	AEDisposeDesc(&reply);	return error;				}OSErr ZipQuit(Boolean canInteract, const ProcessSerialNumber *psn){	AppleEvent		event, reply;	AEAddressDesc	address;	OSErr			error;		error = AECreateDesc(typeProcessSerialNumber, psn, sizeof(*psn), &address);	if (error)		return error;		error = AECreateAppleEvent(kCoreEventClass, kAEQuitApplication, &address,								kAutoGenerateReturnID, kAnyTransactionID, &event);								//	if (error)//		goto cleanup;			error = AESend(&event, &reply, (canInteract ? kAECanInteract : kAENeverInteract) + kAEWaitReply,					kAENormalPriority, kAEDefaultTimeout, NULL, NULL);	//cleanup:								AEDisposeDesc(&event);	AEDisposeDesc(&address);	AEDisposeDesc(&reply);	return error;								}