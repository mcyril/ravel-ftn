/*•••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••	Copyright © 1996-1997 Cyril Moorzin		При использовании исходных текстов SDK указание Copyright © 1996-1997 Cyril Moorzin		обязательно.		Так же при генерации писем обязательно упоминание название пакета Ravel в tearline.				Ravel SDK поставляется в виде "as is". Автор не несет ответственности за		несовместимость Plug-Ins в будущих версиях RavelSHUFFLER при использовании		undewater приемов программирования.				Не существует НИКАКОЙ документации по Ravel SDK.		Так же автор пока отказался от распространения исходных текстов не только работы		с базой сообщений, но и старых релизов RavelQUILL.  •••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••*///#include <string.h>//#include <stdio.h>#include <A4Stuff.h>#include <EPPC.h>#include "ZipItAppleEvents.h"#include "ravel_msg_base.h"#include "Ravel_Prefs.h"#include "PascalStr.h"#include "Ravel_PlugIns.h"static	PlugsControlPtr	g_plugcontrol;static	Boolean			ZipItWasLaunched;/*static Boolean ApplicationLaunch ( FSSpecPtr spec ){	short				iErr;	LaunchParamBlockRec	myLaunchParams;	ProcessSerialNumber	launchedProcessSN;	myLaunchParams.launchBlockID = extendedBlock;	myLaunchParams.launchEPBLength = extendedBlockLen;	myLaunchParams.launchFileFlags = 0;	myLaunchParams.launchControlFlags = launchContinue + launchNoFileFlags + launchDontSwitch;	myLaunchParams.launchAppSpec = spec;	myLaunchParams.launchAppParameters = NULL;	iErr = LaunchApplication ( &myLaunchParams );	if (!iErr)		launchedProcessSN = myLaunchParams.launchProcessSN;	else	{		return FALSE;	}	return TRUE;}static OSErr ZIP_NEW_Event (void){	AppleEvent	theAppleEvent;	AppleEvent	reply;	DescType	returnedType;	long		actualSize;	OSErr		myErr;	Str255		errStr;	long		errNumber;	OSType		zipper = 'ZIP ';	AEAddressDesc	serverAddress;	myErr = AECreateDesc ( 'sign', &zipper, 4, &serverAddress );	myErr = AECreateAppleEvent ( 'COMP', 'NEW ', &serverAddress, kAutoGenerateReturnID,				kAnyTransactionID, &theAppleEvent );	myErr = AESend ( &theAppleEvent, &reply, kAEWaitReply, kAEHighPriority, kNoTimeOut, NULL, NULL );	myErr = AEDisposeDesc ( &theAppleEvent );	myErr = AEDisposeDesc ( &serverAddress );		return myErr;}static OSErr ZIP_ALL_Event (void){	AppleEvent	theAppleEvent;	AppleEvent	reply;	DescType	returnedType;	long		actualSize;	OSErr		myErr;	Str255		errStr;	long		errNumber;	OSType		zipper = 'ZIP ';	AEAddressDesc	serverAddress;	myErr = AECreateDesc ( 'sign', &zipper, 4, &serverAddress );	myErr = AECreateAppleEvent ( 'COMP', 'SALL', &serverAddress, kAutoGenerateReturnID,				kAnyTransactionID, &theAppleEvent );	myErr = AESend ( &theAppleEvent, &reply, kAEWaitReply, kAEHighPriority, kNoTimeOut, NULL, NULL );	myErr = AEDisposeDesc ( &theAppleEvent );	myErr = AEDisposeDesc ( &serverAddress );		return myErr;}static OSErr ZIP_ADD_Event (FSSpecPtr whattoadd){	AppleEvent	theAppleEvent;	AppleEvent	reply;	DescType	returnedType;	long		actualSize;	OSErr		myErr;	Str255		errStr;	long		errNumber;	OSType		zipper = 'ZIP ';	AEAddressDesc	serverAddress;	AEDescList		theAEDescList;	AEDesc			specDesc;	myErr = AECreateDesc ( 'sign', &zipper, 4, &serverAddress );	myErr = AECreateDesc ( 'fss ', whattoadd, sizeof (FSSpec), &specDesc );	myErr = AECreateList ( NULL, 0, false, &theAEDescList );	myErr = AEPutDesc ( &theAEDescList, 0, &specDesc );	myErr = AECreateAppleEvent ( 'COMP', 'ADD ', &serverAddress, kAutoGenerateReturnID,				kAnyTransactionID, &theAppleEvent );	myErr = AEPutParamDesc ( &theAppleEvent, keyDirectObject, &theAEDescList );	myErr = AESend ( &theAppleEvent, &reply, kAEWaitReply, kAEHighPriority, kNoTimeOut, NULL, NULL );	myErr = AEDisposeDesc ( &specDesc );	myErr = AEDisposeDesc ( &theAEDescList );	myErr = AEDisposeDesc ( &theAppleEvent );	myErr = AEDisposeDesc ( &serverAddress );	return myErr;}static OSErr ZIP_OPEN_Event (FSSpecPtr whattoopen){	AppleEvent	theAppleEvent;	AppleEvent	reply;	DescType	returnedType;	long		actualSize;	OSErr		myErr;	Str255		errStr;	long		errNumber;	OSType		zipper = 'ZIP ';	AEAddressDesc	serverAddress;	AEDescList		theAEDescList;	AEDesc			specDesc;	myErr = AECreateDesc ( 'sign', &zipper, 4, &serverAddress );	myErr = AECreateDesc ( 'fss ', whattoopen, sizeof (FSSpec), &specDesc );	myErr = AECreateList ( NULL, 0, false, &theAEDescList );	myErr = AEPutDesc ( &theAEDescList, 0, &specDesc );	myErr = AECreateAppleEvent ( kCoreEventClass, kAEOpenDocuments, &serverAddress, kAutoGenerateReturnID,				kAnyTransactionID, &theAppleEvent );	myErr = AEPutParamDesc ( &theAppleEvent, keyDirectObject, &theAEDescList );	myErr = AESend ( &theAppleEvent, &reply, kAEWaitReply, kAEHighPriority, kNoTimeOut, NULL, NULL );	myErr = AEDisposeDesc ( &specDesc );	myErr = AEDisposeDesc ( &theAEDescList );	myErr = AEDisposeDesc ( &theAppleEvent );	myErr = AEDisposeDesc ( &serverAddress );	return myErr;}static OSErr ZIP_COMPRESS_Event (FSSpecPtr whereput, Boolean already){	AppleEvent	theAppleEvent;	AppleEvent	reply;	DescType	returnedType;	long		actualSize;	OSErr		myErr;	Str255		errStr;	long		errNumber;	OSType		zipper = 'ZIP ';	AEAddressDesc	serverAddress;	AEDesc			specDesc;	myErr = AECreateDesc ( 'sign', &zipper, 4, &serverAddress );	myErr = AECreateDesc ( 'fss ', whereput, sizeof (FSSpec), &specDesc );	myErr = AECreateAppleEvent ( 'COMP', 'COMP', &serverAddress, kAutoGenerateReturnID,				kAnyTransactionID, &theAppleEvent );	if (!already)		myErr = AEPutParamDesc ( &theAppleEvent, 'FILE', &specDesc );	myErr = AESend ( &theAppleEvent, &reply, kAEWaitReply, kAEHighPriority, kNoTimeOut, NULL, NULL );	myErr = AEDisposeDesc ( &specDesc );	myErr = AEDisposeDesc ( &theAppleEvent );	myErr = AEDisposeDesc ( &serverAddress );		return myErr;}static OSErr ZIP_EXTRACT_Event (FSSpecPtr whereput){	AppleEvent	theAppleEvent;	AppleEvent	reply;	DescType	returnedType;	long		actualSize;	OSErr		myErr;	Str255		errStr;	long		errNumber;	OSType		zipper = 'ZIP ';	AEAddressDesc	serverAddress;	AEDesc			specDesc;	myErr = AECreateDesc ( 'sign', &zipper, 4, &serverAddress );	myErr = AECreateDesc ( 'fss ', whereput, sizeof (FSSpec), &specDesc );	myErr = AECreateAppleEvent ( 'COMP', 'EXTR', &serverAddress, kAutoGenerateReturnID,				kAnyTransactionID, &theAppleEvent );	myErr = AEPutParamDesc ( &theAppleEvent, 'FOLD', &specDesc );	myErr = AESend ( &theAppleEvent, &reply, kAEWaitReply, kAEHighPriority, kNoTimeOut, NULL, NULL );	myErr = AEDisposeDesc ( &specDesc );	myErr = AEDisposeDesc ( &theAppleEvent );	myErr = AEDisposeDesc ( &serverAddress );		return myErr;}static OSErr ZIP_CLOSE_Event (void){	AppleEvent	theAppleEvent;	AppleEvent	reply;	DescType	returnedType;	long		actualSize;	OSErr		myErr;	Str255		errStr;	long		errNumber;	OSType		zipper = 'ZIP ';	OSType		always = 'YES ';	AEAddressDesc	serverAddress;	myErr = AECreateDesc ( 'sign', &zipper, 4, &serverAddress );	myErr = AECreateAppleEvent ( 'COMP', 'CLOS', &serverAddress, kAutoGenerateReturnID,				kAnyTransactionID, &theAppleEvent );	myErr = AEPutParamPtr ( &theAppleEvent, 'SAVE', typeEnumerated, &always, 4 );	myErr = AESend ( &theAppleEvent, &reply, kAEWaitReply, kAEHighPriority, kNoTimeOut, NULL, NULL );	myErr = AEDisposeDesc ( &theAppleEvent );	myErr = AEDisposeDesc ( &serverAddress );		return myErr;}static OSErr ZipItLaunch (void){	OSErr		theErr;	DTPBRec		pbDeskBase;	Str255		ZipName;	FSSpec		launchSpec;			pbDeskBase.ioCompletion = 0L;	ZipName[0] = 0;	pbDeskBase.ioNamePtr = ZipName;	pbDeskBase.ioVRefNum = -1;	theErr = PBDTOpenInform ( &pbDeskBase );	if (theErr)	{		DebugStr ( "\pCan't get DTBase…" );		return theErr;	}		pbDeskBase.ioCompletion = 0L;	pbDeskBase.ioIndex = 0;	pbDeskBase.ioNamePtr = ZipName;	pbDeskBase.ioFileCreator = 'ZIP ';	theErr = PBDTGetAPPL ( &pbDeskBase, FALSE );	if (theErr)	{		DebugStr ( "\pCan't find target APPLy folder…" );		return theErr;	}		theErr = FSMakeFSSpec ( -1, pbDeskBase.ioAPPLParID, pbDeskBase.ioNamePtr, &launchSpec );	return (theErr) ? theErr : ApplicationLaunch ( &launchSpec );}static Boolean MakeCompression ( StringPtr arcName, FSSpecPtr fileToAdd ){	FSSpec		spec;	Boolean				done;	ProcessSerialNumber	processSN;		if (g_plugcontrol->FindAProcess ( 'APPL', 'ZIP ', &processSN ) != noErr)	{		ZipItLaunch ();			do {					g_plugcontrol->Slice ();			done = (g_plugcontrol->FindAProcess ( 'APPL', 'ZIP ', &processSN ) == noErr);			} while (!done);	}	FSMakeFSSpec ( 0, 0, arcName, &spec );	ZIP_OPEN_Event ( &spec );	ZIP_ADD_Event ( fileToAdd );	ZIP_COMPRESS_Event ( &spec, true );	ZIP_CLOSE_Event ();//	ZipItQuit ();	//	do {	//		DoSlice ();//		done = (FindAProcess ( 'APPL', 'ZIP ', &processSN ) != noErr);//	} while (!done);}static Boolean MakeNewCompression ( StringPtr arcName, FSSpecPtr fileToAdd ){	FSSpec				spec;	Boolean				done;	ProcessSerialNumber	processSN;		if (g_plugcontrol->FindAProcess ( 'APPL', 'ZIP ', &processSN ) != noErr)	{		ZipItLaunch ();			do {					g_plugcontrol->Slice ();			done = (g_plugcontrol->FindAProcess ( 'APPL', 'ZIP ', &processSN ) == noErr);			} while (!done);	}		ZIP_NEW_Event ();	ZIP_ADD_Event ( fileToAdd );	Create ( arcName, 0, '????', '????' );	FSMakeFSSpec ( 0, 0, arcName, &spec );	FSDelete ( arcName, 0 );	ZIP_COMPRESS_Event ( &spec, false );	ZIP_CLOSE_Event ();//	ZipItQuit ();	//	do {	//		DoSlice ();//		done = (FindAProcess ( 'APPL', 'ZIP ', &processSN ) != noErr);//	} while (!done);}static Boolean MakeDecompression ( FSSpecPtr arcSpec, FSSpecPtr foldToExt ){	Boolean				done;	ProcessSerialNumber	processSN;			if (g_plugcontrol->FindAProcess ( 'APPL', 'ZIP ', &processSN ) != noErr)	{		ZipItLaunch ();			do {					g_plugcontrol->Slice ();			done = (g_plugcontrol->FindAProcess ( 'APPL', 'ZIP ', &processSN ) == noErr);			} while (!done);	}	ZIP_OPEN_Event ( arcSpec );	ZIP_ALL_Event ();	ZIP_EXTRACT_Event ( foldToExt );	ZIP_CLOSE_Event ();//	ZipItQuit ();	//	do {	//		DoSlice ();//		done = (FindAProcess ( 'APPL', 'ZIP ', &processSN ) != noErr);//	} while (!done);}*//*static OSErr ZipItQuit (void){	OSErr		theErr;	EventRecord	theEvent;		theEvent.what = kHighLevelEvent;	theEvent.message = 'aevt';	*((long *)&theEvent.where) = 'quit';		theErr = PostHighLevelEvent ( &theEvent, (void *) 'ZIP ', 0L, NULL, 0L, nAttnMsg + receiverIDisSignature );//	WaitNextEvent ( everyEvent, &theEvent, 300, NULL );}*/static void KillZipProcess (void){	Boolean				done;	ProcessSerialNumber	processSN;	if (g_plugcontrol->FindAProcess ( 'APPL', 'ZIP ', &processSN ) == noErr)	{		ZipQuit (true, &processSN);				do {					g_plugcontrol->Slice ();			done = (g_plugcontrol->FindAProcess ( 'APPL', 'ZIP ', &processSN ) != noErr);		} while (!done);	}}void main (PlugsControlPtr plugcontrol){	Boolean		res;	ProcessSerialNumber	processSN;	OSErr		theErr;	DTPBRec		pbDeskBase;	Str255		ZipName;	FSSpec		launchSpec;	Boolean		ZipItExist;	EnterCodeResource ();	g_plugcontrol = plugcontrol;		switch (plugcontrol->opCode)	{	case plugWelcome:		//	StartUp call of plug-ins. We make order and init. prefs.					//	find ZipIt…/*		pbDeskBase.ioCompletion = 0L;		ZipName[0] = 0;		pbDeskBase.ioNamePtr = ZipName;		pbDeskBase.ioVRefNum = -1;		theErr = PBDTOpenInform ( &pbDeskBase );		if (theErr)		{			plugcontrol->putlog ('±', "Fatal error with opening DTDB");//			DebugStr ( "\pCan't get DTBase…" );			ExitToShell ();		}				pbDeskBase.ioCompletion = 0L;		pbDeskBase.ioIndex = 0;		pbDeskBase.ioNamePtr = ZipName;		pbDeskBase.ioFileCreator = 'ZIP ';		theErr = PBDTGetAPPLSync (&pbDeskBase);*/		theErr = ZipSearch (NULL, true, &processSN);		ZipItExist = (theErr == noErr);//		if (theErr)//			ZipItExist = false;//		else//		{//			theErr = FSMakeFSSpec ( -1, pbDeskBase.ioAPPLParID, pbDeskBase.ioNamePtr, &launchSpec );//			ZipItExist = (theErr == noErr);//		}		if (ZipItExist)		{			plugcontrol->retCode = plugCompExtr;			//	Decompressor			plugcontrol->misc.arc.archiveType = arcZIP;			plugcontrol->misc.arc.archiveAction = arcExpand;						plugcontrol->putlog ('±', "<ZipIt Extractor> Installed.");			ZipItWasLaunched = (g_plugcontrol->FindAProcess ( 'APPL', 'ZIP ', &processSN ) == noErr);		}		else			plugcontrol->retCode = 0L;				break;			case plugCompExtr:	//	We ordered only one call - Extract archive		//		MakeDecompression ( &plugcontrol->source, &plugcontrol->destination );		ZipLaunch (NULL, true, &processSN);		ZipDecompress (plugcontrol->source, plugcontrol->destination, false, &processSN);		plugcontrol->retCode = plugRetContinue;				break;	case plugSuicide:		//	Ignore in this case.			if (!ZipItWasLaunched)			KillZipProcess ();			break;	default:				//	We're ignoring all other opCodes							//	(by the way, it's impossible unordered calls)		plugcontrol->retCode = plugFatalArch;		break;	}	ExitCodeResource ();	}