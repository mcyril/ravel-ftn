#include "Cookies.h"#include "PascalStr.h"#include <string.h>extern char		g_cookiesfile[128];extern char		g_prefix[128];static	Handle	txtCook = NULL;static	Handle	hshCook = NULL;static	long	numCook = 0;void ReadCookies (void){	short			fRefNum, t;	long			len = 0, counter;	Ptr				p;	unsigned long	hash;	Str255			cookname;			numCook = 0;	if (!g_cookiesfile[0])		pStrCopy (cookname, "\pCookies");	else		memcpy (&cookname[1], g_cookiesfile, cookname[0] = strlen(g_cookiesfile));			if (FSOpen ( cookname, 0, &fRefNum ) != noErr)		return;		GetEOF ( fRefNum, &len );		if (len > 0 && len < 64000 && (txtCook = NewHandleClear ( len+1 )))	{		counter = len;				MoveHHi (txtCook);		HLock (txtCook);		FSRead ( fRefNum, &counter, *txtCook );				p = *txtCook;		p[len] = 0x00;				hshCook = NewHandle (0);		hash = 0;		while (*p)		{			numCook++;			SetHandleSize (hshCook, numCook*sizeof (unsigned long));						((unsigned long *)(*hshCook))[numCook-1] = hash;					while (*p && *p != 0x0D)			{				hash++;				p++;			}						if (*p == 0x0D)			{				hash++;				p++;			}		}	}		MoveHHi (hshCook);	HLock (hshCook);		FSClose ( fRefNum );}void dealCookie (Handle hndl){	unsigned short	qdRdm;	long	q;	long	whow;	char	*p, *r;			if (numCook)	{		qdRdm = Random();		whow = (qdRdm * numCook) / 65536L; 	/* now 0 <= t < range */				if (whow >= numCook)			whow = numCook - 1;				p = r = (*txtCook) + ((unsigned long *)(*hshCook))[whow];				q = 2;		while (*p != 0x0D)		{			q++;			p++;		}				q++;				if (q != 3)		{			if (!g_prefix[0])				PtrAndHand ( "\xFE ", hndl, 2 );			else				PtrAndHand ( g_prefix, hndl, strlen(g_prefix) );						PtrAndHand ( r, hndl, q-2 );		}	}}