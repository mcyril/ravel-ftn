/*•••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••	Copyright © 1996-1997 Cyril Moorzin		При использовании исходных текстов SDK указание Copyright © 1996-1997 Cyril Moorzin		обязательно.		Так же при генерации писем обязательно упоминание название пакета Ravel в tearline.				Ravel SDK поставляется в виде "as is". Автор не несет ответственности за		несовместимость Plug-Ins в будущих версиях RavelSHUFFLER при использовании		undewater приемов программирования.				Не существует НИКАКОЙ документации по Ravel SDK.		Так же автор пока отказался от распространения исходных текстов не только работы		с базой сообщений, но и старых релизов RavelQUILL.  •••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••*///#include <string.h>//#include <stdio.h>#include <A4Stuff.h>//#include "PKT.h"#include "ravel_msg_base.h"#include "Ravel_Prefs.h"#include "PascalStr.h"#include "Ravel_PlugIns.h"static	PlugsControlPtr	g_plugcontrol;static	Boolean			ZipItWasLaunched;static Boolean ApplicationLaunch ( FSSpecPtr spec ){	short				iErr;	LaunchParamBlockRec	myLaunchParams;	ProcessSerialNumber	launchedProcessSN;	myLaunchParams.launchBlockID = extendedBlock;	myLaunchParams.launchEPBLength = extendedBlockLen;	myLaunchParams.launchFileFlags = 0;	myLaunchParams.launchControlFlags = launchContinue + launchNoFileFlags + launchDontSwitch;	myLaunchParams.launchAppSpec = spec;	myLaunchParams.launchAppParameters = NULL;	iErr = LaunchApplication ( &myLaunchParams );	if (!iErr)		launchedProcessSN = myLaunchParams.launchProcessSN;	else	{		return FALSE;	}	return TRUE;}static OSErr ZIP_OPEN_Event (FSSpecPtr whattoopen){	AppleEvent	theAppleEvent;	AppleEvent	reply;	DescType	returnedType;	long		actualSize;	OSErr		myErr;	Str255		errStr;	long		errNumber;	OSType		zipper = 'LHAx';	AEAddressDesc	serverAddress;	AEDescList		theAEDescList;	AEDesc			specDesc;	myErr = AECreateDesc ( 'sign', &zipper, 4, &serverAddress );	myErr = AECreateDesc ( 'fss ', whattoopen, sizeof (FSSpec), &specDesc );	myErr = AECreateList ( NULL, 0, false, &theAEDescList );	myErr = AEPutDesc ( &theAEDescList, 0, &specDesc );	myErr = AECreateAppleEvent ( kCoreEventClass, kAEOpenDocuments, &serverAddress, kAutoGenerateReturnID,				kAnyTransactionID, &theAppleEvent );	myErr = AEPutParamDesc ( &theAppleEvent, keyDirectObject, &theAEDescList );	myErr = AESend ( &theAppleEvent, &reply, kAEWaitReply, kAEHighPriority, kNoTimeOut, NULL, NULL );	myErr = AEDisposeDesc ( &specDesc );	myErr = AEDisposeDesc ( &theAEDescList );	myErr = AEDisposeDesc ( &theAppleEvent );	myErr = AEDisposeDesc ( &serverAddress );	return myErr;}static OSErr ZipItLaunch (void){	OSErr		theErr;	DTPBRec		pbDeskBase;	Str255		ZipName;	FSSpec		launchSpec;			pbDeskBase.ioCompletion = 0L;	ZipName[0] = 0;	pbDeskBase.ioNamePtr = ZipName;	pbDeskBase.ioVRefNum = -1;	theErr = PBDTOpenInform ( &pbDeskBase );	if (theErr)	{		DebugStr ( "\pCan't get DTBase…" );		return theErr;	}		pbDeskBase.ioCompletion = 0L;	pbDeskBase.ioIndex = 0;	pbDeskBase.ioNamePtr = ZipName;	pbDeskBase.ioFileCreator = 'LHAx';	theErr = PBDTGetAPPLSync (&pbDeskBase);	if (theErr)	{		DebugStr ( "\pCan't find target APPLy folder…" );		return theErr;	}		theErr = FSMakeFSSpec ( -1, pbDeskBase.ioAPPLParID, pbDeskBase.ioNamePtr, &launchSpec );	return (theErr) ? theErr : ApplicationLaunch ( &launchSpec );}static Boolean MakeDecompression ( FSSpecPtr arcSpec, FSSpecPtr foldToExt ){	Boolean				done;	ProcessSerialNumber	processSN;			if (g_plugcontrol->FindAProcess ( 'APPL', 'LHAx', &processSN ) != noErr)	{		ZipItLaunch ();			do {					g_plugcontrol->Slice ();			done = (g_plugcontrol->FindAProcess ( 'APPL', 'LHAx', &processSN ) == noErr);			} while (!done);	}	ZIP_OPEN_Event ( arcSpec );}static OSErr ZipItQuit (void){	OSErr		theErr;	EventRecord	theEvent;		theEvent.what = kHighLevelEvent;	theEvent.message = 'aevt';	*((long *)&theEvent.where) = 'quit';#warning "was right for old UH"	theErr = PostHighLevelEvent ( &theEvent, (void *)'LHAx', 0L, 0L, 0L, nAttnMsg + receiverIDisSignature );//	WaitNextEvent ( everyEvent, &theEvent, 300, NULL );}static void KillZipProcess (void){	Boolean				done;	ProcessSerialNumber	processSN;	if (g_plugcontrol->FindAProcess ( 'APPL', 'LHAx', &processSN ) == noErr)	{		ZipItQuit ();				do {					g_plugcontrol->Slice ();			done = (g_plugcontrol->FindAProcess ( 'APPL', 'LHAx', &processSN ) != noErr);		} while (!done);	}}void main (PlugsControlPtr plugcontrol){	Boolean		res;	ProcessSerialNumber	processSN;	OSErr		theErr;	DTPBRec		pbDeskBase;	Str255		ZipName;	FSSpec		launchSpec;	Boolean		ZipItExist;	FInfo		fInfo;	EnterCodeResource ();	g_plugcontrol = plugcontrol;		switch (plugcontrol->opCode)	{	case plugWelcome:		//	StartUp call of plug-ins. We make order and init. prefs.					//	find ZipIt…		pbDeskBase.ioCompletion = 0L;		ZipName[0] = 0;		pbDeskBase.ioNamePtr = ZipName;		pbDeskBase.ioVRefNum = -1;		theErr = PBDTOpenInform ( &pbDeskBase );		if (theErr)		{			plugcontrol->putlog ('±', "Fatal error with opening DTDB");//			DebugStr ( "\pCan't get DTBase…" );			ExitToShell ();		}				pbDeskBase.ioCompletion = 0L;		pbDeskBase.ioIndex = 0;		pbDeskBase.ioNamePtr = ZipName;		pbDeskBase.ioFileCreator = 'LHAx';		theErr = PBDTGetAPPLSync (&pbDeskBase);		if (theErr)			ZipItExist = false;		else		{			theErr = FSMakeFSSpec ( -1, pbDeskBase.ioAPPLParID, pbDeskBase.ioNamePtr, &launchSpec );			ZipItExist = (theErr == noErr);		}		if (ZipItExist)		{			plugcontrol->retCode = plugCompExtr;			//	Decompressor			plugcontrol->misc.arc.archiveType = arcLZH;			plugcontrol->misc.arc.archiveAction = arcExpand;						plugcontrol->putlog ('±', "<LHA Expander Bridge> Installed.");			ZipItWasLaunched = (g_plugcontrol->FindAProcess ( 'APPL', 'LHAx', &processSN ) == noErr);		}		else			plugcontrol->retCode = 0L;				break;			case plugCompExtr:	//	We ordered only one call - Extract archive				MakeDecompression ( plugcontrol->source, plugcontrol->destination );				while (FSpGetFInfo (plugcontrol->source, &fInfo) == noErr)			g_plugcontrol->Slice ();				plugcontrol->retCode = plugRetContinue;				break;	case plugSuicide:		//	Ignore in this case.			if (!ZipItWasLaunched)			KillZipProcess ();			break;	default:				//	We're ignoring all other opCodes							//	(by the way, it's impossible unordered calls)		plugcontrol->retCode = plugFatalArch;		break;	}	ExitCodeResource ();	}