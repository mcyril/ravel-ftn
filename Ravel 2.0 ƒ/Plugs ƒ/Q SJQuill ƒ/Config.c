#include <string.h>#include "ravel_msg_base.h"#include "Ravel_Prefs.h"#include "Ravel_Quill_PlugIns.h"#define	min(a,b)	((a<b)?a:b)static char		*tokens[] = {								"prefix",			//	0								"idle",				//	1								"signature",		//	2								"tearline",			//	3								""							};extern	char	g_prefix[128];extern	char	g_idle[128];extern	Boolean	g_tearline;extern	OSType	SIGNATURE;void ReadTemplates (StringPtr prefname, PlugsQControlPtr plugcontrol);static short strcasecmp ( char *s1, char *s2 ){	char	s11[128],			s12[128];				strcpy ( s11, s1 );	strcpy ( s12, s2 );	UprText ( s11, strlen (s11) );	UprText ( s12, strlen (s12) );		return strcmp ( s11, s12 );}static short strncasecmp ( char *s1, char *s2, short n ){	char	s11[256],			s12[256];				strncpy ( s11, s1, n );	strncpy ( s12, s2, n );	UprText ( s11, strlen (s11) );	UprText ( s12, strlen (s12) );		return strncmp ( s11, s12, n );}static short fndtoken (char **tt, char *from){	short	res = 0;		while (tt[res][0])		if (!strncasecmp ( from, tt[res], strlen (tt[res]) ))			return res;		else			res++;		return -1;}static void pushtojail ( char **storage, char **from ){	char		tmp[512];	short		i;//	while ( **from && **from != 0x0D )//		(*from)++;	if (!**from)	{		*storage = NewPtrClear (1);		return;	}//	(*from)++;	i=0;	while ( **from && **from != '#' && i < 511 )	{		tmp[i++] = **from;		(*from)++;	}	if (**from == '#')	{		tmp[i] = 0;		*storage = NewPtr (i+1);		strcpy ( *storage, tmp );		(*from)++;	}	else		**from = 0;}static void pushtoeoln ( char **storage, char **from ){	char		tmp[512];	short		i;	while ( **from && **from == ' ' )		(*from)++;	if (!**from)	{		*storage = NewPtrClear (1);		return;	}		i=0;	while ( **from && **from != 0x0d && i < 511 )	{		tmp[i++] = **from;		(*from)++;	}	if (**from == 0x0d)	{		tmp[i] = 0;		*storage = NewPtr (i+1);		strcpy ( *storage, tmp );		(*from)++;	}	else		**from = 0;}static passtoeoln ( char **from ){	while ( **from && **from != 0xd )		(*from)++;	if (!**from)		return;	(*from)++;}void ReadTemplates (StringPtr prefname, PlugsQControlPtr plugcontrol){	short		fRefNum, t, tt;	long		len = 0, counter;	Handle		txt;	Ptr			p, ttt;		char		tmp[128];		long		l_1, l_2, l_3, l_4, l_5, l_6;			if ( FSOpen ( prefname, 0, &fRefNum ) )	{		return;	}	GetEOF ( fRefNum, &len );		if (len > 0 && (txt = NewHandle ( len+1 )))	{		counter = len;				HLock (txt);		FSRead ( fRefNum, &counter, *txt );				p = *txt;		p[len] = 0;				while (*p)		{			if (*p == 0x0d)				p++;			else				if (*p != ';')				{					t = fndtoken (tokens, p);										switch (t)					{					case 0:		//	prefix												p += strlen (tokens[t]);						pushtoeoln ( &ttt, &p );												strcpy (g_prefix, ttt);												DisposePtr (ttt);												break;					case 1:		//	idle												p += strlen (tokens[t]);						pushtoeoln ( &ttt, &p );												strcpy (g_idle, ttt);												DisposePtr (ttt);												break;										case 2:		//	signature												p += strlen (tokens[t]);						pushtoeoln ( &ttt, &p );												memset (&SIGNATURE, 0x20, sizeof(OSType));						memcpy (&SIGNATURE, ttt, min(sizeof(OSType), strlen(ttt)));												DisposePtr (ttt);												break;										case 3:		//	tearline												g_tearline = true;						passtoeoln (&p);						break;										default:	//	all others												passtoeoln (&p);						break;					}				}				else					passtoeoln (&p);		}				DisposeHandle (txt);	}	FSClose ( fRefNum );}