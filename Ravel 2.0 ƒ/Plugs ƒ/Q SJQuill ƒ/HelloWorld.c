/* *  Copyright © 1997-2001 Metrowerks Corporation.  All Rights Reserved. * *  Questions and comments to: *       <mailto:support@metrowerks.com> *       <http://www.metrowerks.com/> */#include <stdio.h>#include <string.h>#include <AEDataModel.h>#define	SIGNATURE	'SJAM'static Boolean TestGestalt (OSType selector, char which){	long	response;		if (Gestalt(selector, &response))		return FALSE;	else		return BitTst(&response, 31-which);}static OSErr FindSJ(short volume, FSSpec *app){	IOParam					pb1;	DTPBRec					pb2;	GetVolParmsInfoBuffer	volInfo;	OSErr					error;	Str255					name;		/* We must find SJ's FSSpec from the desktop database. */	/* First, does the specified volume HAVE a desktop database? */	pb1.ioCompletion = NULL;	pb1.ioVRefNum = volume;	pb1.ioNamePtr = NULL;	pb1.ioBuffer = (Ptr)&volInfo;	pb1.ioReqCount = sizeof(GetVolParmsInfoBuffer);	error = PBHGetVolParmsSync ((HParamBlockRec *)&pb1);	if (!error && (BitTst(&volInfo.vMAttrib, 31 - bHasDesktopMgr))) {		pb2.ioNamePtr = NULL;		pb2.ioVRefNum = volume;		error = PBDTGetPath(&pb2);				if (!error) {					pb2.ioNamePtr = name;			pb2.ioIndex = 0;			pb2.ioFileCreator = SIGNATURE;						error = PBDTGetAPPLSync(&pb2);						if (!error)				error = FSMakeFSSpec(volume, pb2.ioAPPLParID, name, app);		}	} else if (!error)		error = paramErr;		return error;}			static OSErr SJSearch(const FSSpec *application, ProcessSerialNumber *psn){	OSErr				error, error2;	ProcessInfoRec		info;	FSSpec				SJ;		if (application)		SJ = *application;		if (!psn)		return paramErr;			if (TestGestalt(gestaltOSAttr, gestaltLaunchControl)) {				/* Search for a process with SJ's signature. If one is found, then SJ			is running, and we do not have to launch it or do anything except return			its PSN.		*/				psn->highLongOfPSN = 0;		psn->lowLongOfPSN = kNoProcess;		info.processInfoLength = sizeof(info);		info.processName = NULL;		info.processAppSpec = NULL;		do {			error = GetNextProcess(psn);			if (!error)				GetProcessInformation(psn, &info);		} while (!error && (info.processSignature != SIGNATURE));					if (!error)			return noErr;				}		if (!application) {			HVolumeParam	pb;				pb.ioNamePtr = NULL;		pb.ioVolIndex = 0;		pb.ioVRefNum = 0;				do {			++pb.ioVolIndex;			error = PBHGetVInfoSync((HParamBlockRec *)&pb);			if (!error)				error2 = FindSJ(pb.ioVRefNum, &SJ);		} while (!error && error2);				if (error2)			return fnfErr;	}				return noErr;}static OSErr SJLaunch(const FSSpec *application, Boolean inBackground, ProcessSerialNumber *psn){	OSErr				error, error2;	ProcessInfoRec		info;	FSSpec				SJ;	LaunchParamBlockRec	lpb;		if (application)		SJ = *application;		if (!psn)		return paramErr;			if (TestGestalt(gestaltOSAttr, gestaltLaunchControl)) {				/* Search for a process with SJ's signature. If one is found, then SJ			is running, and we do not have to launch it or do anything except return			its PSN.		*/				psn->highLongOfPSN = 0;		psn->lowLongOfPSN = kNoProcess;		info.processInfoLength = sizeof(info);		info.processName = NULL;		info.processAppSpec = NULL;		do {			error = GetNextProcess(psn);			if (!error)				GetProcessInformation(psn, &info);		} while (!error && (info.processSignature != SIGNATURE));					if (!error)			return noErr;				}		if (!application) {			HVolumeParam	pb;				pb.ioNamePtr = NULL;		pb.ioVolIndex = 0;		pb.ioVRefNum = 0;				do {			++pb.ioVolIndex;			error = PBHGetVInfoSync((HParamBlockRec *)&pb);			if (!error)				error2 = FindSJ(pb.ioVRefNum, &SJ);		} while (!error && error2);				if (error2)			return fnfErr;	}		if (!TestGestalt(gestaltOSAttr, gestaltLaunchFullFileSpec))		return paramErr;			lpb.launchBlockID = extendedBlock;	lpb.launchEPBLength = extendedBlockLen;	lpb.launchFileFlags = 0;	lpb.launchControlFlags = launchContinue + launchNoFileFlags + (inBackground ? launchDontSwitch : 0);	lpb.launchAppSpec = &SJ;	lpb.launchAppParameters = NULL;		error = LaunchApplication(&lpb);		if (!error)		*psn = lpb.launchProcessSN;			return error;}static OSErr SJLaunched(ProcessSerialNumber *psn, StringPtr name){	OSErr				error;	ProcessInfoRec		info;		if (!psn)		return paramErr;			if (TestGestalt(gestaltOSAttr, gestaltLaunchControl)) {				/* Search for a process with SJ's signature. If one is found, then SJ			is running, and we do not have to launch it or do anything except return			its PSN.		*/				psn->highLongOfPSN = 0;		psn->lowLongOfPSN = kNoProcess;		info.processInfoLength = sizeof(info);		info.processName = name;		info.processAppSpec = NULL;		do {			error = GetNextProcess(psn);			if (!error)				GetProcessInformation(psn, &info);		} while (!error && (info.processSignature != SIGNATURE));					if (!error)			return noErr;	}		return -1;	}static OSErr DoScript( char *theScript, AEDesc *resultText){	ComponentInstance	scriptingComponent;	AEDesc				componentName, scriptText;	OSAID				scriptID, resultID;	OSAError			myOSAError, ignoreErr;	OSErr				err;		scriptingComponent = OpenDefaultComponent( kOSAComponentType, kOSAGenericScriptingComponentSubtype );	myOSAError = OSAScriptingComponentName( scriptingComponent, &componentName );	if( myOSAError == noErr )	{		err = AECreateDesc( typeChar, theScript, strlen( theScript ), &scriptText );		if( err == noErr )		{			scriptID = kOSANullScript;			myOSAError = OSACompile( scriptingComponent, &scriptText, kOSAModeNull, &scriptID );					if( myOSAError == noErr )			{				myOSAError = OSAExecute( scriptingComponent, scriptID, kOSANullScript, kOSAModeNull, &resultID );				ignoreErr = OSADispose( scriptingComponent, scriptID );				if( myOSAError == noErr )				{					myOSAError = OSADisplay(scriptingComponent, resultID, typeChar, kOSAModeDisplayForHumans, resultText);					ignoreErr = OSADispose( scriptingComponent, resultID );				}			}			ignoreErr = AEDisposeDesc( &scriptText );		}	}		return myOSAError;}static OSErr _AEGetDescData(	const AEDesc	*inDesc,	void*			inDataPtr,	Size			inMaxSize){#if ACCESSOR_CALLS_ARE_FUNCTIONS	return ::AEGetDescData(inDesc, inDataPtr, inMaxSize);	#else		// We need to extract the data ourselves by directly accessing		// the Handle within the AE descriptor	OSErr	err = errAEDescIsNull;		if (inDesc->dataHandle != nil) {		Size	bytesToCopy	= inMaxSize;		Size	dataSize	= GetHandleSize(inDesc->dataHandle);				if (dataSize < bytesToCopy) {			bytesToCopy = dataSize;		}				BlockMoveData(*(inDesc->dataHandle), inDataPtr, bytesToCopy);		err = noErr;	}		return err;#endif}static OSStatus GetData(AEDesc *inDesc, DescType inDescType, void* inDataPtr, Size inMaxSize){	OSStatus err = noErr;	AEDesc*	descPtr = inDesc;	AEDesc	coerceDesc;		if (inDesc->descriptorType != inDescType) {				// Input descriptor has a type that is different from			// the desired data type. Try to coerce it.			if ((err = AECoerceDesc(inDesc, inDescType, &coerceDesc)) != noErr)		{			return err;	// Coercion failed		}				descPtr = &coerceDesc;				// Use coerced descriptor	}		err = _AEGetDescData(descPtr, inDataPtr, inMaxSize);		return err;}char *thescript = "tell application \"%#s\"\r""	set thistrack to current track\r""	set thisartistname to artist of thistrack\r""	set thisalbumname to album of thistrack\r""	set thistrackname to name of thistrack\r""	set result to thisartistname & \" - \" & thisalbumname & \" - \" & thistrackname\r""end tell\r""return result\r";int main(void){	AEDesc		res;	ProcessSerialNumber	psn;	OSErr				err;//	AppleEvent			event, reply;//	AEAddressDesc		address;//	long				Size, res;//	OSType				typeCode;		char				name[256];	char				script[1024];	//	printf("Hello World, this is CodeWarrior!\n");		err = SJLaunched(&psn, (StringPtr)name);	if (err == noErr)	{		printf("launched!\n");		sprintf(script, thescript, name);		err = DoScript( script, &res );		if (err == noErr)		{			memset(name, 0, 256);			GetData(&res, typeChar, name, 255);			printf("%s\n", name);		}		else			printf("silent\n");/*			err = AECreateDesc(typeProcessSerialNumber, &psn, sizeof(psn), &address);		if (err != noErr)			goto bailout;		err = AECreateAppleEvent(kCoreEventClass, kAEGetData, &address,								kAutoGenerateReturnID, kAnyTransactionID, &event);		if (err != noErr)			goto bailout;		err = AEPutParamPtr(&event, keyDirectObject, 'pnam', name, sizeof(name));//		err = AEPutParamDesc(&event, keyDirectObject, &desc);//typeProperty				err = AESend(&event, &reply, kAENeverInteract + kAEWaitReply,					kAENormalPriority, kAEDefaultTimeout, NULL, NULL);		err = AEGetParamPtr(&reply, keyErrorNumber, typeSInt32, &typeCode, &res, sizeof(long), &Size);		err = AEGetParamPtr(&reply, keyDirectObject, 'pnam', &typeCode, name, 256, &Size);*/	}	else	{		printf("not launched!\n");	}	bailout:			return 0;}