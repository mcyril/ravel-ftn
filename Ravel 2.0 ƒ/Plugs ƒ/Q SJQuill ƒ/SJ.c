/*•••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••	Copyright © 1996-1997 Cyril Moorzin		При использовании исходных текстов SDK указание Copyright © 1996-1997 Cyril Moorzin		обязательно.		Так же при генерации писем обязательно упоминание название пакета Ravel в tearline.				Ravel SDK поставляется в виде "as is". Автор не несет ответственности за		несовместимость Plug-Ins в будущих версиях RavelSHUFFLER при использовании		undewater приемов программирования.				Не существует НИКАКОЙ документации по Ravel SDK.		Так же автор пока отказался от распространения исходных текстов не только работы		с базой сообщений, но и старых релизов RavelQUILL.  •••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••*/#include <Sound.h>#include <string.h>#include <stdio.h>#include <A4Stuff.h>#include <extras.h>#include "ravel_msg_base.h"#include "Ravel_Prefs.h"#include "PascalStr.h"#include "Ravel_Quill_PlugIns.h"static char *thescript = NULL;static char *thescript0 = "tell application \"%#s\"\r""	set thistrack to current track\r""	set thisartistname to artist of thistrack\r""	set thisalbumname to album of thistrack\r""	set thistrackname to name of thistrack\r""	set result to thisartistname & \" ъ \" & thisalbumname & \" ъ \" & thistrackname\r""end tell\r""return result\r";char		g_prefix[128];char		g_idle[128];Boolean		g_tearline = false;OSType		SIGNATURE =	'SJAM';void ReadTemplates (StringPtr prefname, PlugsQControlPtr plugcontrol);static Boolean TestGestalt (OSType selector, char which){	long	response;		if (Gestalt(selector, &response))		return FALSE;	else		return BitTst(&response, 31-which);}static OSErr DoScript( char *theScript, AEDesc *resultText){	ComponentInstance	scriptingComponent;	AEDesc				componentName, scriptText;	OSAID				scriptID, resultID;	OSAError			myOSAError, ignoreErr;	OSErr				err;		scriptingComponent = OpenDefaultComponent( kOSAComponentType, kOSAGenericScriptingComponentSubtype );	myOSAError = OSAScriptingComponentName( scriptingComponent, &componentName );	if( myOSAError == noErr )	{		err = AECreateDesc( typeChar, theScript, strlen( theScript ), &scriptText );		if( err == noErr )		{			scriptID = kOSANullScript;			myOSAError = OSACompile( scriptingComponent, &scriptText, kOSAModeNull, &scriptID );					if( myOSAError == noErr )			{				myOSAError = OSAExecute( scriptingComponent, scriptID, kOSANullScript, kOSAModeNull, &resultID );				ignoreErr = OSADispose( scriptingComponent, scriptID );				if( myOSAError == noErr )				{					myOSAError = OSADisplay(scriptingComponent, resultID, typeChar, kOSAModeDisplayForHumans, resultText);					ignoreErr = OSADispose( scriptingComponent, resultID );				}			}			ignoreErr = AEDisposeDesc( &scriptText );		}	}		return myOSAError;}static OSErr _AEGetDescData(	const AEDesc	*inDesc,	void*			inDataPtr,	Size			inMaxSize){#if ACCESSOR_CALLS_ARE_FUNCTIONS	return ::AEGetDescData(inDesc, inDataPtr, inMaxSize);	#else		// We need to extract the data ourselves by directly accessing		// the Handle within the AE descriptor	OSErr	err = errAEDescIsNull;		if (inDesc->dataHandle != nil) {		Size	bytesToCopy	= inMaxSize;		Size	dataSize	= GetHandleSize(inDesc->dataHandle);				if (dataSize < bytesToCopy) {			bytesToCopy = dataSize;		}				BlockMoveData(*(inDesc->dataHandle), inDataPtr, bytesToCopy);		err = noErr;	}		return err;#endif}static OSStatus GetData(AEDesc *inDesc, DescType inDescType, void* inDataPtr, Size inMaxSize){	OSStatus err = noErr;	AEDesc*	descPtr = inDesc;	AEDesc	coerceDesc;		if (inDesc->descriptorType != inDescType) {				// Input descriptor has a type that is different from			// the desired data type. Try to coerce it.			if ((err = AECoerceDesc(inDesc, inDescType, &coerceDesc)) != noErr)		{			return err;	// Coercion failed		}				descPtr = &coerceDesc;				// Use coerced descriptor	}		err = _AEGetDescData(descPtr, inDataPtr, inMaxSize);		return err;}static OSErr SJLaunched(ProcessSerialNumber *psn, StringPtr name){	OSErr				error;	ProcessInfoRec		info;		if (!psn)		return paramErr;			if (TestGestalt(gestaltOSAttr, gestaltLaunchControl)) {				/* Search for a process with SJ's signature. If one is found, then SJ			is running, and we do not have to launch it or do anything except return			its PSN.		*/				psn->highLongOfPSN = 0;		psn->lowLongOfPSN = kNoProcess;		info.processInfoLength = sizeof(info);		info.processName = name;		info.processAppSpec = NULL;		do {			error = GetNextProcess(psn);			if (!error)				GetProcessInformation(psn, &info);		} while (!error && (info.processSignature != SIGNATURE));					if (!error)			return noErr;	}		return -1;	}static void ReadScript(StringPtr plugscript){	short	fRefNum;	long	len, counter;	if ( FSOpen ( plugscript, 0, &fRefNum ) )	{		return;	}	GetEOF ( fRefNum, &len );		if (len > 0 && (thescript = NewPtrClear ( len+1 )))	{		counter = len;		FSRead ( fRefNum, &counter, thescript );	}	FSClose ( fRefNum );}static void form_tagline(char *text){	OSErr				err;	ProcessSerialNumber	psn;	char				name[256];	char				script[1024];	AEDesc				restxt;	if (g_prefix[0])		strcpy (text, g_prefix);	else		strcpy (text, "np: ");	err = SJLaunched(&psn, (StringPtr)name);	if (err == noErr)	{		sprintf(script, thescript, name);		err = DoScript( script, &restxt );		if (err == noErr)		{			memset(name, 0, 256);			GetData(&restxt, typeChar, name, 255);			AEDisposeDesc( &restxt );			strcat (text, name);		}		else			if (g_idle[0])			{				strcat (text, g_idle);			}			else				strcat (text, "nothing");	}	else		if (g_idle[0])		{			strcat (text, g_idle);		}		else			strcat (text, "nothing");}void main (PlugsQControlPtr plugcontrol){	long		res;	short		ownFile, oldRes, i;	Handle		h;		char		text[1024];	Str255		plugcfg;	Str255		plugscript;		EnterCodeResource ();	switch (plugcontrol->opCode)	{	case plugWelcome:		//	StartUp call of plug-ins. We make order and init. prefs.				pStrCopy (plugcontrol->thisplugPath, plugcfg);		pStrConc (plugcfg, "\p.script", plugscript);		pStrConc (plugcfg, "\p.cfg", plugcfg);		g_prefix[0] = 0;		g_idle[0] = 0;		ReadTemplates (plugcfg, plugcontrol);		ReadScript(plugscript);		if (thescript == NULL)		{			thescript = NewPtrClear(strlen(thescript0)+1);			memcpy(thescript, thescript0, strlen(thescript0));		}				plugcontrol->putlog ('=', "<PlayTag Quill " RAVELISA "> Installed.");		res = (g_tearline) ? plugMsgBodyAskTearline : plugMsgBodyDone;		break;		case plugSuicide:				DisposePtr(thescript);		break;	case plugMsgBodyAskTearline:				form_tagline(text);		plugcontrol->misc.string.stringActualSize = __min(strlen(text), plugcontrol->misc.string.stringBuffSize);		memcpy(plugcontrol->misc.string.stringBuff, text, plugcontrol->misc.string.stringActualSize);		res = plugRetProcessed;		break;			case plugMsgBodyDone:				form_tagline(text);		strcat(text, "\r");		PtrAndHand(text, plugcontrol->messageIn->text, strlen(text));		res = plugRetContinue;		break;			default:				//	We're ignoring all other opCodes							//	(by the way, it's impossible unordered calls)			res = plugRetContinue;		break;	}		plugcontrol->retCode = res;		ExitCodeResource ();	}