/*	Ravel 0.0dx	"ZModem.c"*/#include <setjmp.h>#include <string.h>#include <ctype.h>#include "PascalStr.h"#include "Main.h"#include "Port.h"#include "crc.h"#include "ZModem.h"#include "ZMisc.h"#include "log.h"#include "myEnv.h"#include "PKT.h"#include "Prefs.h"#include "Pathes.h"#include "pmain.h"#include "Timing.h"#include "wazoo.h"#include "stringutl.h"extern	short	remote_capabilities;extern Boolean	busy;				/* output don't complete */Boolean			Sending = FALSE;	/* Sending in progress */short			Transfer = 0;		/* File transfer in progress */extern	short	gotta_mail;			// somewhat received with ZedZapstatic short	FILENUMBER;static Str255	special;extern	short	ZMAXSPLEN;			//	tuning now!extern	char	YesZedZap;extern	short	zrecv_start_retry;/* ----- Special characters -------------------------------------------- */#define BS			0x08	/* Backspace */#define	LF			0x0A	/* Linefeed */#define CR			0x0D	/* Carriage return */#define DLE			0x10	/* Data link escape *///	#define XON			0x11	/* Flow control *///	#define XOFF		0x13	/* Flow control */#define CAN			0x18	/* Cancel */#define DEL			0x7F	/* Delete */#define ZPAD		'*'		/* Padding character begins frames */#define ZDLE		0x18	/* Zmodem escape character ctrl-X */#define ZBIN		'A'		/* Binary header indicator (CRC-16) */#define ZHEX		'B'		/* HEX header indicator *//* ----- Frame types --------------------------------------------------- */#define ZRQINIT		0		/* Request receive init */#define ZRINIT		1		/* Receive init */#define ZSINIT		2		/* Send init sequence (optional) */#define ZACK		3		/* ACK to above */#define ZFILE		4		/* File name from sender */#define ZSKIP		5		/* To sender: skip this file */#define ZNAK		6		/* Last packet was garbled */#define ZABORT		7		/* Abort batch transfers */#define ZFIN		8		/* Finish session */#define ZRPOS		9		/* Resume data trans at this position */#define ZDATA		10		/* Data packet(s) follow */#define ZEOF		11		/* End of file */#define ZFERR		12		/* Fatal Read or Write error Detected */#define ZCRC		13		/* Request for file CRC and response */#define ZCHALLENGE	14		/* Receiver's Challenge */#define ZCOMPL		15		/* Request is complete */#define ZCAN		16		/* Other end canned session with 5 CANs */#define ZFREECNT	17		/* Request for free bytes on filesystem */#define ZCOMMAND	18		/* Command from sending program */#define ZSTDERR		19		/* Output to standard error, data follows *//* ----- ZDLE sequences ------------------------------------------------ */#define ZCRCE		'h'		/* CRC next, frame ends, header follows */#define ZCRCG		'i'		/* CRC next, frame continues nonstop */#define ZCRCQ		'j'		/* CRC next, frame continues, ZACK expected */#define ZCRCW		'k'		/* CRC next, ZACK expected, end of frame */#define ZRUB0		'l'		/* Translate to DEL 0x7F */#define ZRUB1		'm'		/* Translate to DEL 0xFF *//* ----- Header structures --------------------------------------------- */typedef struct {	unsigned long: 24;	unsigned long command: 8;	/* 0 or ZCOMMAND */} ZRQINITflags;typedef struct {	unsigned long bufsize: 16;	/* Receiver's buffer size (bytes swapped) */	unsigned long: 7;	unsigned long canvhdr: 1;	/* Variable headers OK */	unsigned long esc8: 1;		/* Rx expects 8th bit to be escaped */	unsigned long escctl: 1;	/* Rx expects ctl chars to be escaped */	unsigned long canfc32: 1;	/* Rx can use 32 bit CRC */	unsigned long canlzw: 1;	/* Rx can uncompress */	unsigned long canrle: 1;	/* Rx can decode RLE */	unsigned long canbrk: 1;	/* Rx can send a break signal */	unsigned long canovio: 1;	/* Rx can receive data during disk I/O */	unsigned long canfdx: 1;	/* Rx can send and receive true FDX */} ZRINITflags;typedef struct {	unsigned long: 24;	unsigned long esc8: 1;		/* Tx expects 8th bit to be escaped */	unsigned long escctl: 1;	/* Tx expects ctl chars to be escaped */	unsigned long: 6;} ZSINITflags;typedef struct {	unsigned long: 1;	unsigned long sparse: 1;	/* Encoding for sparse file operations */	unsigned long: 5;	unsigned long canvhdr: 1;	/* Variable headers OK */	unsigned long transport: 8;	/* Transport options */	unsigned long skip: 1;		/* Skip file if not present at rx */	unsigned long: 2;	unsigned long manage: 5;	/* Management options */	unsigned long conv: 8;		/* Conversion options */} ZFILEflags;typedef struct {	unsigned long: 31;	unsigned long ack: 1;		/* Acknowledge, then do command */} ZCOMMANDflags;typedef union {	unsigned char b[4];	unsigned long position;		/* File position (low byte first) */	ZRQINITflags zrqinit;	ZRINITflags zrinit;	ZSINITflags zsinit;	ZFILEflags zfile;	ZCOMMANDflags zcommand;} HEADER;/* ----- Conversion options, ZFILE frame ------------------------------- */#define ZCBIN		1		/* Binary transfer - inhibit conversion */#define ZCNL		2		/* Convert NL to local eol convention */#define ZCRESUM		3		/* Resume interrupted file transfer *//* ----- Management options, ZFILE frame ------------------------------- */#define ZMNEWL		1		/* Transfer if source newer or longer */#define ZMCRC		2		/* Transfer if different file CRC or length */#define ZMAPND		3		/* Append contents to existing file (if any) */#define ZMCLOB		4		/* Replace existing file */#define ZMNEW		5		/* Transfer if source newer */#define ZMDIFF		6		/* Transfer if dates or lengths different */#define ZMPROT		7		/* Protect destination file *//* ----- Transport options, ZFILE frame -------------------------------- */#define ZTLZW		1		/* Lempel-Ziv compression */#define ZTRLE		3		/* Run Length encoding *//* ----- Other constants ----------------------------------------------- */#define ZATTNLEN	32		/* Max length of attention string *///#define ZMAXSPLEN	1024	/* Max subpacket length *///#define ZMAXSPLEN	8192	/* Max subpacket length *//* ----- Return values (internal) -------------------------------------- */#define GOTOR	0x0100#define GOTCRCE (GOTOR | ZCRCE)	/* ZDLE-ZCRCE received */#define GOTCRCG (GOTOR | ZCRCG)	/* ZDLE-ZCRCG received */#define GOTCRCQ (GOTOR | ZCRCQ)	/* ZDLE-ZCRCQ received */#define GOTCRCW (GOTOR | ZCRCW)	/* ZDLE-ZCRCW received *//* ----- Globals ------------------------------------------------------- */Byte ZAutoReceiveString[] = {	ZPAD, ZDLE, ZHEX,	'0', '0',									/* Type: ZRQINIT */	'0', '0', '0', '0', '0', '0', '0', '0',	'0', '0', '0', '0',							/* CRC1 CRC2 */	CR,	0};Byte ZLastRx[] = { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 };#define GARBAGE 1400+2400		/* Garbage count before header */static jmp_buf CancelEnv;		/* Long jump if cancel or abort */static Boolean Zctlesc;			/* TRUE: escape all control characters */static Byte	*TxBuffer = 0;		/* Transmit buffer */static Byte	*TxPtr;				/* Pointer into transmit buffer *//* Shared by transmit and receive */static short RefNum;			/* File reference number */static unsigned long Mark;		/* Current file position */static unsigned long Length;	/* Length of file */static unsigned long StartPos;	/* Start file position */static unsigned long StartTime;	/* Start time */static short Vers;				/* MacBinary version */static Byte *Buffer;			/* Block buffer + attention string + ... *//* Transmit only */static unsigned long Txwindow;	/* Size of the transmitted window */static unsigned long Txwspac;	/* Spacing between ZCRCQ requests */static unsigned short Rxbuflen;	/* Receiver's max buffer length */static unsigned long Lastsync;	/* Last offset to which we got a ZRPOS */static unsigned long Lrxpos;	/* Receiver's last reported offset */static short BeenHereB4;		/* How many times ZRPOS same place *//* Receive only */static Byte TryZhdrType;		/* Header type to send */static unsigned short Count;	/* Bytes in block buffer */#define Attn (Buffer+ZMAXSPLEN)	/* Sender's attention string */static unsigned short AttnLen;	/* Bytes in attention string */#define BinHdr (Attn+ZATTNLEN)	/* MacBinary header received */#define BUFFERSIZE (ZMAXSPLEN+ZATTNLEN)static Boolean ConvertNL;		/* Convert newline to local eol *//* ===== COMMON FUNCTIONS ============================================== */static	char	*ValidExt[7] = { "mo", "tu", "th", "we", "fr", "sa", "su" };#ifdef MONITOR/* ----- Translate ZModem constants ------------------------------------ */static char *FrameTypes[] = {	"\pZRQINIT",	"\pZRINIT",	"\pZSINIT",	"\pZACK",	"\pZFILE",	"\pZSKIP",	"\pZNAK",	"\pZABORT",	"\pZFIN",	"\pZRPOS",	"\pZDATA",	"\pZEOF",	"\pZFERR",	"\pZCRC",	"\pZCHALLENGE",	"\pZCOMPL",	"\pZCAN",	"\pZFREECNT",	"\pZCOMMAND",	"\pZSTDERR"};static char *ZFrameType (register short x){	static char s[10];	if (x < sizeof(FrameTypes)/sizeof(char *))		return FrameTypes[x];	NumToString(x, s);	return s;}typedef struct {	Byte	c;	char	*s;} FRAMEND;static FRAMEND ZFrameEnds[] = {	ZCRCE, "\pZCRCE",	ZCRCG, "\pZCRCG",	ZCRCQ, "\pZCRCQ",	ZCRCW, "\pZCRCW",	ZRUB0, "\pZRUB0",	ZRUB1, "\pZRUB1",	0, 0};static char *ZFrameEnd (register Byte x){	register FRAMEND *p = ZFrameEnds;	static char s[10];		while (p->s) {		if (p->c == x)			return p->s;		++p;	}	NumToString(x, s);	return s;}#endif/* ----- Open file (data fork) ----------------------------------------- */static short OpenFile(	register short volume,	register long directory,	register Byte *name,	register short *ref){	register short err;	HFileParam p;	memset(&p, 0, sizeof(p));	p.ioVRefNum = volume;	p.ioDirID = directory;	p.ioNamePtr = (StringPtr)name;	*ref = (err = PBHOpen((HParmBlkPtr)&p, FALSE)) ? 0 : p.ioFRefNum;	return err;}/* ----- Create file --------------------------------------------------- */static short CreateFile(	register short volume,	register long directory,	register Byte *name,	register long creator,	register long type){	register short err;	HFileParam p;	name[name[0]+1] = 0;	memset(&p, 0, sizeof(p));	p.ioNamePtr = (StringPtr)name;	p.ioVRefNum = volume;	p.ioDirID = directory;	if (err = PBHCreate((HParmBlkPtr)&p, FALSE))		return err;	memset(&p, 0, sizeof(p));	p.ioNamePtr = (StringPtr)name;	p.ioVRefNum = volume;	p.ioDirID = directory;	if (err = PBHGetFInfo((HParmBlkPtr)&p, FALSE))		return err;	p.ioNamePtr = (StringPtr)name;	p.ioVRefNum = volume;	p.ioDirID = directory;	p.ioFlFndrInfo.fdCreator = creator;	p.ioFlFndrInfo.fdType = type;	return PBHSetFInfo((HParmBlkPtr)&p, FALSE);}/* ----- Get file info ------------------------------------------------- */static short InfoFile(	register short volume,		/* <- Volume reference number */	register long directory,	/* <- Directory id */	register Byte *name,		/* <- File name */	OSType *creator,			/* -> File creator */	OSType *type,				/* -> File type */	long *create,				/* -> File creation date */	long *modif)				/* -> File modification date */{	register short err;	HParamBlockRec p;	memset(&p, 0, sizeof(p));	p.fileParam.ioNamePtr = (StringPtr)name;	p.fileParam.ioVRefNum = volume;	p.fileParam.ioDirID = directory;	if (err = PBHGetFInfo(&p, FALSE))		return err;	*creator = p.fileParam.ioFlFndrInfo.fdCreator;	*type = p.fileParam.ioFlFndrInfo.fdType;	*create = p.fileParam.ioFlCrDat;	*modif = p.fileParam.ioFlMdDat;	return err;}/* ----- Set file info ------------------------------------------------- */static short SetInfoFile(	register short volume,		/* <- Volume reference number */	register long directory,	/* <- Directory id */	register Byte *name,		/* <- File name */	OSType creator,				/* <- File creator */	OSType type,				/* <- File type */	long create,				/* <- File creation date */	long modif)					/* <- File modification date */{	register short err;	HParamBlockRec p;	memset(&p, 0, sizeof(p));	p.fileParam.ioNamePtr = (StringPtr)name;	p.fileParam.ioVRefNum = volume;	p.fileParam.ioDirID = directory;	if (err = PBHGetFInfo(&p, FALSE))		return err;	p.fileParam.ioNamePtr = name;	p.fileParam.ioVRefNum = volume;	p.fileParam.ioDirID = directory;	p.fileParam.ioFlFndrInfo.fdCreator = creator;	p.fileParam.ioFlFndrInfo.fdType = type;	p.fileParam.ioFlCrDat = create;	p.fileParam.ioFlMdDat = modif;	return PBHSetFInfo(&p, FALSE);}/* ----- Delete file --------------------------------------------------- */static short DeleteFile(	register short volume,	register long directory,	register Byte *name){	HFileParam p;	memset(&p, 0, sizeof(p));	p.ioNamePtr = (StringPtr)name;	p.ioVRefNum = volume;	p.ioDirID = directory;	return PBHDelete((HParmBlkPtr)&p, FALSE);}/*еееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееее*/static void ShowProgress (void){	Str255		temp;	Str31		numo;			pStrCopy ( (Sending) ? "\pZ-Sending " : "\pZ-Receiving ", temp );	pStrConc ( temp, special, temp );	pStrConc ( temp, "\p ", temp );	NumToString ( Mark, numo );	pStrConc ( temp, numo, temp );	pStrConc ( temp, "\p of ", temp );	NumToString ( Length, numo );	pStrConc ( temp, numo, temp );	putMessage ( 3, temp );}/* ----- Should we escape control characters? -------------------------- */static Boolean Escape(void){	return Settings.ZEscapeCtl || !Serial8Bits(Settings.portSetup);}/* ----- Allocate memory for transmit buffer --------------------------- *//*static short NewTxBuffer (register Boolean block){	if (TxBuffer)		return 1;							//	* Error: already allocated *	TxBuffer = (Byte *)NewPtrClear(block ?		2*(ZMAXSPLEN + 6) :					//	* Worst case for transmitting block *		32);								//	* Worst case for transmitting header *	return TxBuffer ? 0 : memFullErr;}*//* ----- Dispose of transmit buffer ------------------------------------ *//*static void DisposeTxBuffer (void){	while (busy)		;	if (TxBuffer)		DisposPtr((Ptr)TxBuffer);	TxBuffer = 0;}*//* ----- Prepare new transmission -------------------------------------- */static void InitTxBuffer (void){	while (busy || !SerialCTS1())	/* Wait until previous transmission finished */		if (CheckCancel())			longjmp(CancelEnv, CANCEL);	TxPtr = TxBuffer;}/* ----- Start transmission, don't wait -------------------------------- */static void TransmitTxBuffer (void){	SerialSend(TxBuffer, TxPtr - TxBuffer, &busy);}/* ----- Send more bytes ----------------------------------------------- */static void SendString (register Byte *s, register unsigned short n){	InitTxBuffer();	memcpy(TxPtr, s, n);	TxPtr += n;	TransmitTxBuffer();}/* ----- Send cancel string -------------------------------------------- */static void SendCancel(void){	static Byte cs[] = {		CAN, CAN, CAN, CAN, CAN, CAN, CAN, CAN,		BS, BS, BS, BS, BS, BS, BS, BS, BS, BS	};	SerialSend(cs, sizeof(cs), &busy);	while (busy)		;}/* ----- Sleep a while ------------------------------------------------- */static void Sleep (register unsigned long ticks){	register unsigned long start = LMGetTicks ();	while((LMGetTicks () - start) < ticks)		if (CheckCancel())			longjmp(CancelEnv, CANCEL);}/* ----- Send a byte --------------------------------------------------- */static Byte SendByte (register Byte c){	*TxPtr++ = c;	return c;}/* ----- Send attention string ----------------------------------------- */static void SendAttn (register Byte *s){	while (busy)		;	while (*s) {		switch (*s) {			case 0xDD:		/* Send break signal */				/* sendbrk(); */				break;			case 0xDE:		/* Sleep 1 second */				Sleep(60);				break;			default:				SerialSend(s, 1, &busy);				while (busy)					if (CheckCancel())						longjmp(CancelEnv, CANCEL);		}		++s;	}}/* ----- Swap 4 bytes in long ------------------------------------------ *//*static unsigned long Swap4 (register unsigned long n){	register short i;	register unsigned long x = 0;	for (i = 0; i < 4; ++i) {		x <<= 8;		x |= n & 0xFF;		n >>= 8;	}	return x;}*//* ----- Swap 2 bytes in short ----------------------------------------- *//*static unsigned short Swap2 (register unsigned short n){	register short i;	register unsigned short x = 0;	for (i = 0; i < 2; ++i) {		x <<= 8;		x |= n & 0xFF;		n >>= 8;	}	return x;}*//* ----- Adjust header ------------------------------------------------- */static void AdjustHeader (register Byte type, register HEADER *p){	switch (type)	{		case ZACK:		case ZRPOS:		case ZDATA:		case ZEOF:		case ZCRC:		case ZCHALLENGE:		case ZFREECNT:		case ZCOMPL:			p->position = endlong (p->position);			break;		case ZRINIT:			p->zrinit.bufsize = endshort (p->zrinit.bufsize);			break;	}}/* ----- Send a byte as two hex digits --------------------------------- */static Byte PutHex (register Byte c){	static Byte digits[] = {		'0','1','2','3','4','5','6','7','8','9','a','b','c','d','e','f' };	SendByte(digits[(c >> 4) & 0xF]);	SendByte(digits[c & 0xF]);	return c;}/* ----- Send a byte with ZMODEM escape sequence encoding -------------- */static Byte SendLine (register Byte c){	register Byte b = c;	static Byte lastsent = 0;	/* Last byte sent */	if (c & 0x60)		/* Non control character */		SendByte(lastsent = c);	else {		switch (c) {			case ZDLE:				SendByte(ZDLE);				SendByte(lastsent = c ^ 0x40);				break;			case CR:	/* Escape CR followed by @ (Telenet net escape) */			case 0x80 | CR:				if (!Zctlesc && (lastsent & 0x7F) != '@') {					SendByte(lastsent = c);					break;				}				/* Fall thru */			case DLE:			case 0x80 | DLE:			case XON:			case 0x80 | XON:			case XOFF:			case 0x80 | XOFF:				SendByte(ZDLE);				c ^= 0x40;				SendByte(lastsent = c);				break;			default:				if (Zctlesc && !(c & 0x60)) {					SendByte(ZDLE);					c ^= 0x40;				}				SendByte(lastsent = c);		}	}	return b;}/* ----- Send ZMODEM HEX header ---------------------------------------- */static void SendHexHeader (register Byte type, HEADER hdr){	register short i;	register unsigned short crc;	AdjustHeader(type, &hdr);#ifdef MONITOR	{		Byte mon[256];		FormatStr(mon, (Byte *)"\pTransmit HEX header %s",			ZFrameType(type));		MonitorText(mon);		MonitorDump(&hdr.b[0], 4);	}#endif	InitTxBuffer();	SendByte(ZPAD);								/* 1 */	SendByte(ZPAD);								/* 1 */	SendByte(ZDLE);								/* 1 */	SendByte(ZHEX);								/* 1 */	crc = updcrc(PutHex(type), 0);	for (i = 0; i < 4; ++i)		crc = updcrc(PutHex(hdr.b[i]), crc);	/* 8 */	PutHex((crc >> 8) & 0xFF);					/* 2 */	PutHex(crc & 0xFF);							/* 2 */	SendByte(CR);								/* 1 */	SendByte(LF);								/* 1 */	if (type != ZFIN && type != ZACK)		SendByte(XON);							/* 1 */	/*SerialFlush();*/	TransmitTxBuffer();				/* Worst case:	19 bytes */}/* ----- Send ZMODEM binary header ------------------------------------- */static void SendBinaryHeader (register Byte type, HEADER hdr){	register short i;	register unsigned short crc;	AdjustHeader(type, &hdr);#ifdef MONITOR	{		Byte mon[256];		FormatStr(mon, (Byte *)"\pTransmit BIN header %s",			ZFrameType(type));		MonitorText(mon);		MonitorDump(&hdr.b[0], 4);	}#endif	InitTxBuffer();	SendByte(ZPAD);								/* 1 */	SendByte(ZDLE);								/* 1 */	SendByte(ZBIN);								/* 1 */	crc = updcrc(SendLine(type), 0);	for (i = 0; i < 4; ++i)		crc = updcrc(SendLine(hdr.b[i]), crc);	/* 8 */	SendLine((crc >> 8) & 0xFF);					/* 2 */	SendLine(crc & 0xFF);							/* 2 */	if (type != ZDATA)		SerialFlush();											/*****/	TransmitTxBuffer();				/* Worst case:	15 bytes */}/* ----- Send binary array with ending ZDLE sequence ------------------- */static void SendData (	register Byte *buf,	unsigned short length,	Byte frameend){	register unsigned short crc;#ifdef MONITOR	{		Byte mon[256];		FormatStr(mon, (Byte *)"\pTransmit %i bytes %s",			length, ZFrameEnd(frameend));		MonitorText(mon);		MonitorDump(buf, length);	}#endif	InitTxBuffer();	for (crc = 0 ; length; ++buf, --length) {		SendLine(*buf);		crc = updcrc(*buf, crc);	}	SendByte(ZDLE);	SendByte(frameend);	crc = updcrc(frameend, crc);	SendLine((crc >> 8) & 0xFF);	SendLine(crc & 0xFF);	if (frameend == ZCRCW) {		SendByte(XON);		SerialFlush();	}	TransmitTxBuffer();}/* ----- Read character with timeout ----------------------------------- */static short ReadByte (	register Byte *c,				/* Character (result) */	register unsigned long timeout)	/* Timeout in ticks */{	register unsigned long start;	register long count;	static short abort = 0;	/* CAN counter */	/* If a character is available don't check for cancel,	this speeds up reception */	if (!SerialRead(c, 1)) {    	start = LMGetTicks ();		do {			if ((LMGetTicks () - start) > timeout)				return TIMEOUT;			if (!(count = SerialRead(c, 1)) && CheckCancel())				longjmp(CancelEnv, CANCEL);        } while (count == 0);	}	if (*c == CAN) {		if (++abort >= 5)			longjmp(CancelEnv, ABORT);	} else		abort = 0;    return FINE;}/* ----- Wait for ZPAD character --------------------------------------- */static short WaitZPAD (	unsigned long timeout,		/* Timeout in ticks */	register unsigned short n)	/* Max bytes before start of frame */{	Byte c;	for (;;)		switch (ReadByte(&c, timeout)) {			case FINE:				if ((c & 0x7F) == ZPAD)				{					return FINE;				}				if (--n == 0)					return ERROR;				break;			case TIMEOUT:				return TIMEOUT;		}}/* ----- Read character with timemout, eat parity, XON and XOFF -------- */static short ReadByte2 (	register Byte *c,				/* Character (result) */	register unsigned long timeout)	/* Timeout in ticks */{	for (;;) {		if (ReadByte(c, timeout))			return TIMEOUT;		switch (*c &= 0x7F) {			case XON:			case XOFF:				break;			default:				if (Zctlesc && !(*c & 0x60))					break;			case CR:			case LF:			case ZDLE:				return FINE;		}	}}/* ----- Decode two lower case hex digits into an 8 bit byte value ----- */static short GetHex (register Byte *c){	register short i;	Byte n;	*c = 0;	for (i = 0; i < 2; ++i) {		*c <<= 4;		if (ReadByte2(&n, Settings.ZTimeout))			return TIMEOUT;		if (n >= '0' && n <= '9')			n -= '0';		else			if (n >= 'a' && n <= 'f')				n -= 'a' - 10;			else				return ERROR;		*c += n;	}	return FINE;}/* ----- Read a byte, checking for ZMODEM escape encoding -------------- */static short ZdleRead (register Byte *c){	do {		if (ReadByte(c, Settings.ZTimeout))			return TIMEOUT;		if (*c & 0x60)						/* Non-control character */			return FINE;		switch (*c) {						/* Control character */			case ZDLE:			case XON:			case 0x80 | XON:			case XOFF:			case 0x80 | XOFF:				break;						/* Ignore XON/XOFF */			default:				if (!Zctlesc)					return FINE;				break;						/* Ignore ctrl if escaping */		}	} while (*c != ZDLE);	/* Previous character was ZDLE */	for (;;) {		if (ReadByte(c, Settings.ZTimeout))			return TIMEOUT;		switch (*c) {			case ZCRCE:			case ZCRCG:			case ZCRCQ:			case ZCRCW:				return *c | GOTOR;			/* Frame end */			case ZRUB0:				*c = DEL;				return FINE;			case ZRUB1:				*c = 0x80 | DEL;				return FINE;			case XON:			case 0x80 | XON:			case XOFF:			case 0x80 | XOFF:				break;						/* Ignore XON/XOFF */			default:				if (Zctlesc && !(*c & 0x60))					break;					/* Ignore ctrl if escaping */				if ((*c & 0x60) != 0x40)	/* Must be -10- ---- */					return ERROR;				*c ^= 0x40;					/* Invert bit 6 */				return FINE;		}	}}/* ----- Receive a binary style header (type and position) ------------- */static short ReceiveBinaryHeader (	register Byte *type,	register Byte *hdr){	register short n, err;	register unsigned short crc;	Byte c;	/* Header type */	if (err = ZdleRead(type))		return err;		/* TIMEOUT, ERROR, GOTxxxx */	crc = updcrc(*type, 0);	/* Header info (4 bytes) */	for (n = 0; n < 4; ++n, ++hdr) {		if (err = ZdleRead(hdr))			return err;	/* TIMEOUT, ERROR, GOTxxxx */		crc = updcrc(*hdr, crc);	}	/* CRC (2 bytes) */	if (err = ZdleRead(&c))		return err;		/* TIMEOUT, ERROR, GOTxxxx */	crc = updcrc(c, crc);	if (err = ZdleRead(&c))		return err;		/* TIMEOUT, ERROR, GOTxxxx */	if (crc = updcrc(c, crc))		return ERROR;	/* Bad CRC */	return FINE;}/* ----- Receive a hex style header (type and position) ---------------- */static short ReceiveHexHeader (	register Byte *type,	register Byte *hdr){	register short n, err;	register unsigned short crc;	Byte c;	/* Header type */	if (err = GetHex(type))		return err;	crc = updcrc(*type, 0);	/* Header info (4 bytes) */	for (n = 0; n < 4; ++n, ++hdr) {		if (err = GetHex(hdr))			return err;		crc = updcrc(*hdr, crc);	}	/* CRC (2 bytes) */	if (err = GetHex(&c))		return err;	crc = updcrc(c, crc);	if (err = GetHex(&c))		return err;	if (crc = updcrc(c, crc))		return ERROR;	/* Bad CRC */	/* Throw away possible CR/LF */	if (ReadByte(&c, 1) == FINE && (c & 0x7F) == CR)		ReadByte(&c, 1);	return FINE;}/* ----- Read a ZMODEM header (either binary or hex) ------------------- */static short GetHeader (	register Byte *type,	register HEADER *hdr){	register short err;	register short n = GARBAGE;	Byte c;#ifdef MONITOR	short headerNature = 0;#endif	/* Wait for ZPAD character */	if (err = WaitZPAD(Settings.ZTimeout, GARBAGE))		goto done;	/* Just got ZPAD character, wait for ZDLE character */	do {		if (err = ReadByte2(&c, Settings.ZTimeout))			goto done;		switch (c) {			case ZDLE:		/* This is what we want */			case ZPAD:		/* May be more than one ZPAD */			case ZPAD | 0x80:				break;again:			default:		/* Garbage */				if (--n == 0) {					err = ERROR;					goto done;				}				break;		}	} while (c != ZDLE);	/* Just got ZPAD-ZDLE sequence */	if (err = ReadByte2(&c, Settings.ZTimeout))		goto done;	switch (c) {		case ZBIN:		/* It's a binary header */#ifdef MONITOR			headerNature = 1;#endif			err = ReceiveBinaryHeader(type, hdr->b);			break;		case ZHEX:		/* It's a hex header */#ifdef MONITOR			headerNature = 2;#endif			err = ReceiveHexHeader(type, hdr->b);			break;		default:		/* Garbage */			goto again;	}	AdjustHeader(*type, hdr);	/* ZPAD ZDLE ZBIN/ZHEX ... */done:#ifdef MONITOR	{		static char *binhex[] = { "\pBIN", "\pHEX" };		Byte mon[256];		if (headerNature) {			FormatStr(mon, (Byte *)"\pReceived %s header %s error %i",				binhex[headerNature - 1],				ZFrameType(*type),				err);			MonitorText(mon);			MonitorDump(hdr->b, 4);		} else {			FormatStr(mon, (Byte *)"\pReceived error %i", err);			MonitorText(mon);		}	}#endif	return err;}/* ----- Receive array with ending ZDLE sequence and CRC --------------- */static short ReceiveData (	register Byte *buf,		/* Buffer for data */	unsigned short length,	/* Max size of buffer */	unsigned short *count,	/* Number of data bytes received */	Byte *framend)			/* Frame end character received */{	register unsigned short crc = 0;	register Byte *max = buf + length;	register short err;	Byte c;	*framend = 0xFF;	while (buf <= max) {		switch (err = ZdleRead(&c)) {			case FINE:				/* Data byte */				crc = updcrc(c, crc);				*buf++ = (ConvertNL && c == LF) ? CR : c;				break;			case GOTCRCE:			/* Frame end, CRC follows */			case GOTCRCG:			case GOTCRCQ:			case GOTCRCW:				*count = length - (max - buf);				crc = updcrc((*framend = c), crc);				if (err = ZdleRead(&c))					goto done;				crc = updcrc(c, crc);				if (err = ZdleRead(&c))					goto done;				if (crc = updcrc(c, crc))					err = ERROR;	/* Bad CRC */				else					err = FINE;				goto done;			default:				/* TIMEOUT, ERROR, ... */				*count = length - (max - buf);				goto done;		}	}	*count = length - (max - buf);	err = ERROR;					/* Data subpacket too long */putlog (lgATTN, "Data subpacket too long!");done:#ifdef MONITOR	{		Byte mon[256];		FormatStr(mon, (Byte *)"\pReceived %i bytes, end %s (error: %i)",			*count, ZFrameEnd(*framend), err);		MonitorText(mon);		MonitorDump(buf - *count, *count);	}#endif	return err;}/* ----- Update progress indicator ------------------------------------- *///static void Update (register Byte *text, register long error)//{//	register unsigned long n = Mark - StartPos;//	register unsigned long m = (Length > StartPos) ? Length - StartPos : 0;////	UpdateProgress(//		Mark,//		Length,//		(m && n) ? ((Time - StartTime)*(m - n))/n : 0,//		Count,//		error,//		text);//}/* ----- Make info string for progress dialog -------------------------- *///static void MakeInfo(void)//{//	register Byte s[256];//	Byte *c;//	Byte *v;////	c = Zctlesc ? (Byte *)"\pEscape-Ctrl" : "\p";/*	switch (Vers) {		case 0:			v = MyString(STR_P, P_TEXT);			break;		case 1:			v = MyString(STR_P, P_BINARY1);			break;		case 2:			v = MyString(STR_P, P_BINARY2);			break;		default:			v = "\p";	}	FormatStr(s, (Byte *)"\pZModem %s rx=%i %s", c, Rxbuflen, v);	InfoProgress(s);*///}/* ----- Convert between Macintosh time and ZModem time ---------------- */static DateTimeRec ZTimeOrigin = { 1970, 1, 1, 0, 0, 0, 0 };void ConvertTime (Boolean toMac, unsigned long *t){	unsigned long t0;//	putlog ( 'T', "%.8lX", *t );	Date2Secs(&ZTimeOrigin, &t0);	*t = toMac ? (*t + t0) : (*t - t0);//	putlog ( 'T', "%.8lX", *t );}/* ===== TRANSMIT ====================================================== *//* ----- Fill buffer --------------------------------------------------- */static short ReadBuffer (	register long *count,	register Byte *buf){	register long x = *count;	return FSRead(RefNum, count, buf) || *count != x;}/* ----- Set file position --------------------------------------------- */static short Seek (register unsigned long position){	return SetFPos(RefNum, fsFromStart, position);}/* ----- Respond to receiver's complaint, get back in sync ------------- */static short GetInSync (	Boolean flag,	/* TRUE: ZACK always returns */	Byte *type){	register short retry;	register short err;	HEADER hdr;	for (retry = 0; retry < Settings.ZRetries; ++retry)	{		switch (GetHeader(type, &hdr))		{			case FINE:				switch (*type)				{					case ZRPOS:											if (Seek(hdr.position))						{							err = ERROR;							goto done;						}												Lrxpos = Mark = hdr.position;												if (Lastsync == hdr.position &&								++BeenHereB4 > 4 && Count > 32)									Count /= 2;						Lastsync = hdr.position;						err = FINE;						goto done;					case ZACK:						Lrxpos = hdr.position;						if (flag || Mark == hdr.position)						{							err = FINE;							goto done;						}						break;	/* Ignore this ZACK */					case ZCAN:					case ZABORT:					case ZFIN:						goto error;					case ZRINIT:					case ZSKIP:						err = FINE;						goto done;				}				break;			case TIMEOUT:				goto error;		}		hdr.position = 0;		SendHexHeader(ZNAK, hdr);	}error:	err = ERROR;done:	ShowProgress ();	return err;}/* ----- Send the data in the file ------------------------------------- */static short SendFileData (void){	short junkcount;		/* Counts garbage chars received */	unsigned long txwcnt;	/* Counter used to space ACK requests */	short eofseen;			/* End of file seen (file read error) */	Byte type;				/* Header type */	HEADER hdr;				/* Header */	short err;				/* Error code */	short newcnt;			/* Controls receiver's buffer */	long n;					/* Transmit buffer length */	Byte e;					/* Frame end character */	Lastsync = (StartPos = Lrxpos = Mark) - 1;	junkcount = 0;	BeenHereB4 = 0;somemore:	if (FALSE) {waitack:		junkcount = 0;		err = GetInSync(FALSE, &type);gotack:		if (err)		{			putlog (lgATTN, "GetInSync error ret! %d", err);			return ERROR;		}				switch (type) {			case ZSKIP:			case ZRINIT:							return FINE;			case ZACK:			case ZRPOS:				break;			default:				return ERROR;		}		/* Check reverse channel (but don't wait) */		if (CheckCancel())			longjmp(CancelEnv, CANCEL);		while (SerialCheck())		{			Byte c;			SerialFastRead(&c, 1);			switch (c) {				case CAN:				case ZPAD:					err = GetInSync(TRUE, &type);					goto gotack;				case XOFF:		/* Wait a while for an XON */				case XOFF | 0x80:					ReadByte(&c, 100);			}		}	}	/* somemore */	/* Send ZDATA header */		hdr.position = Mark;	SendBinaryHeader(ZDATA, hdr);	/* Send one or more data subpackets */	newcnt = Rxbuflen;	txwcnt = 0;	do {		/* Send data subpacket */			n = Count;		if (eofseen = ReadBuffer(&n, Buffer))			e = ZCRCE;		else if (junkcount > 3)			e = ZCRCW;		else if (Mark == Lastsync)			e = ZCRCW;		else if (Rxbuflen && (newcnt -= n) <= 0)			e = ZCRCW;		else if (Txwindow && (txwcnt += n) >= Txwspac) {			txwcnt = 0;			e = ZCRCQ;		} else			e = ZCRCG;		SendData(Buffer, n, e);		Mark += n;		ShowProgress ();		/* Wait for ZACK if necessary */		if (e == ZCRCW)			goto waitack;		/* Check reverse channel (but don't wait) */		if (CheckCancel())			longjmp(CancelEnv, CANCEL);		while (SerialCheck())		{			Byte c;			SerialFastRead(&c, 1);			switch (c)			{				case CAN:				case ZPAD:					err = GetInSync(TRUE, &type);					if (!err && type == ZACK)						break;					/* zcrce - dinna wanna starta ping-pong game */					SendData(Buffer, 0, ZCRCE);					goto gotack;				case XOFF:		/* Wait a while for an XON */				case XOFF | 0x80:					ReadByte(&c, 100);				default:					++junkcount;					break;			}		}		/* Make sure to stay in transmit window */		if (Txwindow)		{			while ((Mark - Lrxpos) >= Txwindow)			{				if (e != ZCRCQ)					SendData(Buffer, 0, e = ZCRCQ);				err = GetInSync(TRUE, &type);				if (err || type != ZACK)				{					SendData(Buffer, 0, ZCRCE);					goto gotack;				}			}		}	ShowProgress ();	} while (!eofseen);	/* Send ZEOF header, wait for ZRINIT header from receiver */	for (;;)	{		hdr.position = Mark;		SendBinaryHeader(ZEOF, hdr);				if (GetInSync(FALSE, &type))			return ERROR;				switch (type)		{			case ZRINIT:			case ZSKIP:				return FINE;			case ZACK:				break;			case ZRPOS:				goto somemore;			default:				return ERROR;		}	}}/* ----- Invite receiver ----------------------------------------------- */static short Invitation (void){	HEADER hdr;	register short retry;	register short err;/*	if (!(Buffer = (Byte *)NewPtr(ZMAXSPLEN))) {	// е +		err = memFullErr;		return err;	}	if (err = NewTxBuffer(TRUE))		return err;									// е -*/	for (retry = 0; retry < Settings.ZRetries; ++retry)	{		ShowProgress ();		hdr.position = 0;		SendHexHeader(ZRQINIT, hdr);		if ((err = WaitZPAD(Settings.ZTimeout, 1000)) == FINE) {			ShowProgress();			return FINE;		}	}		return TIMEOUT;}/* ----- Send invitation to receiver, get receiver's parameters -------- */static short SessionStartup (void){	register short retry;	register short err;	register Byte *message = "\p";	Byte type;	HEADER hdr;	StartTime = LMGetTime ();	for (retry = 0; retry < Settings.ZRetries; ++retry) {		ShowProgress ();		switch (GetHeader(&type, &hdr))		{			case FINE:				switch (type)				{					case ZRINIT:		/* This is what we want */						message = (Byte *)"\pZRINIT";						/* Set transfer parameters */						Rxbuflen = hdr.zrinit.bufsize;						Txwindow = Settings.ZWindow;						Txwspac = Settings.Zcrcq;				//		Count = Settings.ZPacket;										//		if (remote_capabilities & ZED_ZAPPER)				//			Count += Settings.ZPacket;												Count = (remote_capabilities & ZED_ZAPPER) ? 2048 : 1024;												if (!hdr.zrinit.canfdx)							Txwindow = 0;						if (Rxbuflen && Count > Rxbuflen)							Count = Rxbuflen;						/* No need to send an ZSINIT frame if ... */						Zctlesc = hdr.zrinit.escctl || Escape(); 						if (!Escape() || hdr.zrinit.escctl)						{							err = FINE;							goto done;						}												for (retry = 0; retry < Settings.ZRetries; ++retry)						{							/* ZSINIT header */							hdr.position = 0;							hdr.zsinit.escctl = 1;							SendBinaryHeader(ZSINIT, hdr);							ShowProgress ();							/* Our attention string (empty string) */							type = 0;							SendData(&type, 1, ZCRCW);							/* Wait for ZACK header from receiver */							if (!GetHeader(&type, &hdr) && type == ZACK) {								err = FINE;								goto done;							}						}												err = TIMEOUT;												goto done;					case ZCHALLENGE:	/* Echo challenge number */						SendHexHeader(ZACK, hdr);						message = (Byte *)"\pZCHALLENGE";						break;					case ZCOMMAND:		/* They didn't see out ZRQINIT */						hdr.position = 0;						SendHexHeader(ZRQINIT, hdr);						message = (Byte *)"\pZRQINIT";						break;					case ZRQINIT:						if (!hdr.zrqinit.command)							break;	/* Ignore (our echo) */						/* Fall thru */					default:						hdr.position = 0;						SendHexHeader(ZNAK, hdr);						message = (Byte *)"\p->ZNAK";						break;				}			case TIMEOUT:				err = TIMEOUT;				goto done;			default:				hdr.position = 0;				SendHexHeader(ZNAK, hdr);				message = (Byte *)"\p->ZNAK";				break;			}	}	err = TIMEOUT;	/* Retry count exhausted */done:	ShowProgress();	return err;}/* ----- Send file information ----------------------------------------- */static short SendFileInfo (	Byte *name,					/* File name */	unsigned long size,			/* File size */	Boolean text,				/* Text file? */	unsigned long modif,		/* Modification date */	unsigned long *startpos)	/* Start position */{	register Byte *p;	register Byte s[30];	register short retry;	register short err;	Byte *message;	Byte buffer[128];	Byte type;	HEADER hdr;	/* File name as zero terminated ASCII string */	p = buffer;	memcpy(p, name + 1, *name);	p += *name;	*p++ = 0;	/* File size as decimal ASCII digits */	NumToString(size, s);	memcpy(p, s + 1, *s);	p += *s;	*p++ = ' ';	/* Modification date: octal string = seconds since 1/1/1970 UTC */	ConvertTime(FALSE, &modif);	/* -> ZModem time */	{		register Byte *t = s + sizeof(s);		register unsigned long n = modif;		do {			*(--t) = n % 8 + '0';			n /= 8;		} while (n);		memcpy(p, t, n = sizeof(s) - (t - s));		p += n;	}	*p++ = ' ';	/* File mode (octal string) my == 0! */	*p++ = '0';/*	*p++ = ' ';	/* Serial number (octal string) *	*p++ = '0';	*p++ = ' ';	/* Number of files remaining (decimal number) *	*p++ = '1';	*p++ = ' ';	/* Number of bytes remaining (decimal number) *	NumToString(size, s);	memcpy(p, s + 1, *s);	p += *s;		*/	//	е	excluded by Cyril (optional info!)		*p++ = 0;	/* Final NULL */	/* Send ZFILE header with ZModem conversion, management and transport	options followed by a ZCRCW data subpacket containing the file name,	file length, modification date. */	message = "\p";	for (retry = 0; retry < Settings.ZRetries; ++retry)	{		hdr.position = 0;		hdr.zfile.conv = text ? 0 : ZCBIN;//		hdr.zfile.manage = ZMCLOB;	/* Replace existing file */		hdr.zfile.manage = ZMAPND;	/* Append to existing file */		SendBinaryHeader(ZFILE, hdr);		SendData(buffer, p - buffer, ZCRCW);again:		ShowProgress ();		if (GetHeader(&type, &hdr))		{								/* Error */			message = "\p";			continue;		}				switch (type)		{			case ZRINIT:							message = (Byte *)"\pZRINIT";				if (WaitZPAD(Settings.ZTimeout, 100) == FINE)					goto again;				break;						case ZSKIP:							/* The receiver may respond with a ZSKIP header, which				makes the sender proceed to the next file (if any) in the				batch. */				*startpos = 0x7FFFFFFF;				err = FINE;				goto done;						case ZRPOS:							*startpos = hdr.position;				err = FINE;				goto done;		}	}		err = TIMEOUT;done:	ShowProgress ();	return err;}/* ----- Session cleanup ----------------------------------------------- */static SessionCleanup (void){	register short retry;	HEADER hdr;	Byte type;	static Byte oo[] = "\pOO";	/* Over and out */	for (retry = 0; retry < Settings.ZRetries; ++retry)	{		hdr.position = 0;		SendHexHeader(ZFIN, hdr);		if (GetHeader(&type, &hdr))			continue;		if (type == ZFIN)		{			SendString(oo + 1, oo[0]);			while (CARRIER && !OUT_EMPTY ())				time_release ();						break;		}	}/*	DisposeTxBuffer();		if (Buffer)		DisposPtr((Ptr)Buffer);*/}/* ----- Send a file --------------------------------------------------- */short ZTransmit (Byte *name, short volume, long directory){	short		err, i, j;	OSType		creator, type;	long		create, modif;	Byte		tempname[20];		CLEAR_INBOUND ();	CLEAR_OUTBOUND ();	big_pause (1);	CLEAR_INBOUND ();	CLEAR_OUTBOUND ();	Sending = TRUE;	special[0] = 0;	for ( i=1, j=1; i<=name[0]; i++ )		if (name[i] != ':')		{			special[j++] = name[i];			special[0]++;		}		else		{			j=1;			special[0] = 0;		}	special[j] = 0;	StartTime = LMGetTime ();	Length = Mark = StartPos = 0;//	if (Transfer)//		return fBsyErr;	/* Only send non-TEXT files as MacBinary if requested. TEXT files are	never sent as MacBinary. For MacBinary we convert the file first,	then use that temporay file to transmit. The temporay file will be	deleted if we are finsihed. */	if (err = InfoFile(volume, directory, name, &creator, &type, &create, &modif))	{		putlog (lgALRT, "> InfoFile %#s fuzz... let it be fine", name);		//		SysBeep (10);		return FINE;	}	if (err = OpenFile(volume, directory, name, &RefNum))	{		putlog (lgALRT, "> OpenFile %#s fuzz... let it be fine", name);//		SysBeep (10);		return FINE;	}//	if (!(Buffer = (Byte *)NewPtr(ZMAXSPLEN))) {//		err = memFullErr;//		goto done1;//	}////	if (err = NewTxBuffer(TRUE))//		goto done1;	Transfer = 1;	GetEOF(RefNum, (long *)&Length);	Zctlesc = Escape();	if (err = setjmp(CancelEnv))	{									/* Cancel or abort */		SerialAbort();		while (busy)			;		if (err == CANCEL)			SendCancel();			/* Send cancel string */		goto done;	}	if ( FILENUMBER == 0 )				// е do it only for first file! + by Cyril	{		SENDBYTE ( 'r' );		SENDBYTE ( 'z' );		SENDBYTE ( '\r' );		if (err = Invitation())			goto done;		if (err = SessionStartup())			goto done;	}	ShowProgress ();	putlog ( lgNOPE, "Z-Sending: #%.3d, %s (%ldb)", FILENUMBER, &special[1], Length );	if (err = SendFileInfo(special, Length, type == 'TEXT', modif, &Mark))		goto done;	if (Mark != 0x7FFFFFFF)	{							/* Not skip */		if (Seek(Mark))			goto done;		/* Send file data */		if (err = SendFileData())		{			goto done;		}	}	else		putlog (lgNOPE, "Receiver requested skip file.");done:	Transfer = 0;done1:	if (RefNum)	{		FSClose(RefNum);		RefNum = 0;	}//	DisposeTxBuffer();	//	if (Buffer)//		DisposPtr((Ptr)Buffer);	return err;}/* ===== RECEIVE ======================================================= *//* ----- Free bytes on the current file system ------------------------- */static unsigned long GetFreeSpace (void){	return 0xFFFFFFFF;	/* many free bytes ... */}/* ----- Ack a ZFIN packet, let byegones be byegones ------------------- */static void AckOverAndOut (void){	register short retry;	register short err;	HEADER hdr;	Byte c;	hdr.position = 0;	for (retry = 0; retry < 3; ++retry)	{		SendHexHeader(ZFIN, hdr);		err = ReadByte(&c, Settings.ZTimeout);		if (err == FINE && c == 'O')		{			err = ReadByte(&c, 60);			return;	/* Over and Out */		}	}}/* ----- Initialize for Zmodem receive attempt ------------------------- */static short TryZReceive (	HEADER *filehdr)		/* Return sender's options */{	register Byte *message;	/* Message to display */	HEADER hdr;				/* Header */	Byte type;				/* Header type received */	short retry;			/* Retry counter */	short err;				/* Error code */	short	myret = 0;		/* my retry */	for (retry = 0, message = "\p"; retry < Settings.ZRetries; )	{		hdr.position = 0;		if (TryZhdrType == ZRINIT) {	/* Capability flags */			hdr.zrinit.bufsize = Settings.ZBuffer;			hdr.zrinit.canfdx = 1;			hdr.zrinit.canovio = 1;			hdr.zrinit.escctl = Escape();		}		SendHexHeader(TryZhdrType, hdr);		if (TryZhdrType == ZSKIP)		/* Don't skip too far */			TryZhdrType = ZRINIT;again:		ShowProgress ();		++retry;		if (GetHeader(&type, &hdr) == FINE) {			switch (type)			{				case ZFILE:					*filehdr = hdr;		/* Return file options */					TryZhdrType = ZRINIT;					if (!ReceiveData(Buffer, ZMAXSPLEN, &Count, &type) &&							type == ZCRCW) {						err = FINE;						goto done;		/* File name received */					}					SendHexHeader(ZNAK, hdr);					message = (Byte *)"\pZFILE error";					goto again;				case ZSINIT:					Zctlesc = hdr.zsinit.escctl;					if (!ReceiveData(Attn, ZATTNLEN, &AttnLen, &type) &&							type == ZCRCW) {						hdr.position = 1;						SendHexHeader(ZACK, hdr);						message = (Byte *)"\pZSINIT ok";						goto again;					}					SendHexHeader(ZNAK, hdr);					message = (Byte *)"\pZSINIT error";					goto again;				case ZFREECNT:					hdr.position = GetFreeSpace();					SendHexHeader(ZACK, hdr);					message = (Byte *)"\pZFREECNT";					goto again;				case ZCOMPL:					message = (Byte *)"\pZCOMPL";					goto again;				case ZFIN:		//			putlog ( '+', "ZFIN" );					if (myret<zrecv_start_retry)					{						myret++;						continue;					}					ShowProgress ();										AckOverAndOut();					Count = 0;			/* Nothing in Buffer */					err = FINE;					goto done;			}		} else			message = "\p";	}	err = TIMEOUT;	Count = 0;							/* Nothing in Buffer */done:	ShowProgress();	return err;}/* ----- Process incoming file information header ---------------------- */static OSErr ProcedeHeader (	HEADER filehdr,			/* Sender's options */	Byte *name,				/* File name extracted (pascal string) */	unsigned long *length,	/* File length extracted */	unsigned long *modif)	/* Modification time extracted */{	register short err, doodoo, deedee;	register Byte *p, *max;	register Byte c;	Boolean exists;			/* File exists */	Boolean append;			/* Append to existing file */	OSType creator, type;	long create, modif2;	*name = 0;	*length = 0;	*modif = 0;	RefNum = 0;	/* Extract fields from file information header */	max = (p = Buffer) + Count;	err = 0;	while (p < max) {		c = *p++;		switch (err) {			case 0:	/* File name (C-string) */				if (c == '\0') {//					memcpy(name + 1, Buffer, *name = p - 1 - Buffer);//	е	+ by Cyril					for (doodoo=0, deedee = 1; Buffer[doodoo]; doodoo++)						if (Buffer[doodoo] == '\\' || Buffer[doodoo] == '/' || Buffer[doodoo] == ':')							deedee = 1;						else							name[deedee++] = Buffer[doodoo];//							name[deedee++] = toupper (Buffer[doodoo]);										name[0] = deedee - 1;					++err;	/* Goto next state */				}				break;			case 1:	/* File length (decimal string, space) */				if (c == ' ' || c == '\0')					++err;	/* Goto next state */				else					*length = *length * 10 + (c & 0x0F);				break;			case 2:	/* File modification time (octal string, space) */				if (c == ' ' || c == '\0') {					ConvertTime(TRUE, modif);	/* -> Macintosh time */					++err;	/* Goto next state */				} else					*modif = *modif * 8 + (c & 0x0F);				break;			default:				break;		}	}	if (err < 3)					/* Got no modification time...	*/		*modif = LMGetTime ();		/* ...so use actual time		*/	/* See if file exists */	exists = (InfoFile(Settings.volume, Settings.directory, name,		&creator, &type, &create, &modif2) == noErr);	append = exists &&		creator == 'RvlM' &&		type == 'ZMPT';	/* Skip file if not present at rx */	if (filehdr.zfile.skip && !exists)		return 100;	/* Delete existing file */	if (exists && filehdr.zfile.manage == ZMCLOB) {		putlog (lgNOPE, "Delete existing file.");		DeleteFile(Settings.volume, Settings.directory, name);		exists = append = FALSE;	}	/* Create new file */	if (!exists) {		if (err = CreateFile(Settings.volume, Settings.directory,				name, 'RvlM', 'ZMPT'))			return err;		exists = TRUE;		append = FALSE;	}	else		putlog (lgNOPE, "Resume this file.");	/* Open file (append if necessary) */	if (err = OpenFile(Settings.volume, Settings.directory, name, &RefNum))		return err;	if (append  && (err = SetFPos(RefNum, fsFromLEOF, 0)))	{		FSClose(RefNum);		RefNum = 0;		return err;	}	return FINE;}/* ----- Write buffer to file ------------------------------------------ */static OSErr WriteFile (void){	long count = Count;	/* Write buffer to file */	return FSWrite(RefNum, &count, Buffer);}/* ----- File was completly received ----------------------------------- */static void CleanupFile (	Byte *name,				/* File name from ZModem header */	unsigned long modif)	/* File modification time */{	short ref;	Byte name2[64];			/* File name from MacBinary header */	Byte name3[64];			/* Temporary file name */	long count, data, resource;	short err, err2, a;	/* Set file creator/type and creation/modification time */	name[name[0]+1] = 0;		for (a=0;a<7;a++) 		if ( !strncasecmp ( (char *) &name[10], ValidExt[a], 2) )			break;	if (a != 7)		SetInfoFile(Settings.volume, Settings.directory, name,			'ZIP ', '.PKT', modif, modif);	else		if ( !strcasecmp ( (char *) &name[name[0]-3], ".PKT" ) )			SetInfoFile(Settings.volume, Settings.directory, name,				'RvlM', '.PKT', modif, modif);		else			SetInfoFile(Settings.volume, Settings.directory, name,				'ALFA', 'TEXT', modif, modif);}/* ----- Receive a file ------------------------------------------------ */static short ReceiveFile (	HEADER filehdr)			/* Sender's options */{	register short err;		/* Error code */	register short retry;	/* Retry counter */	register Byte *message;	/* Message to display */	Byte name[256];			/* File name from Z header (Pascal string) */	Byte name2[64];			/* File name from MacBin hdr (Pascal string) */	unsigned long modif;	/* File modification date (Mac time) */	HEADER hdr;				/* Header */	Byte type;				/* Header type received */	Byte end;				/* Data frame type */	/* Get ready to receive new file */	Vers = -1;	StartPos = Mark = Length = 0;	if (ProcedeHeader(filehdr, name, &Length, &modif))	{		TryZhdrType = ZSKIP;		return FINE;	}		name[name[0]+1] = 0;	putlog ( lgATTN, "Z-Receiving: %s (%ldb)", &name[1], Length );		pStrCopy ( name, special );	ShowProgress ();	GetFPos(RefNum, (long *)&StartPos);	Mark = StartPos;	Rxbuflen = Settings.ZBuffer;	/* Receiving loop */	for (retry = 0, message = "\p"; ; )	{		hdr.position = Mark;		SendHexHeader(ZRPOS, hdr);nxthdr:		ShowProgress ();		switch (GetHeader(&type, &hdr))		{			case FINE:				switch (type)				{					case ZNAK:						++retry;						if (retry > Settings.ZRetries) {							err = ERROR;							putlog ('~', "ReceiveFile ZNAK");							goto done;						}						message = (Byte *)"\phdr-ZNAK";						break;					case ZFILE:						err = ReceiveData(Buffer, ZMAXSPLEN, &Count, &end);						message = (Byte *)"\phdr-ZFILE";						break;					case ZEOF:						/* Ignore eof if it's at wrong place - force a						timeout because the eof might have gone out before						we sent our zrpos. */						message = (Byte *)"\phdr-ZEOF";						if (hdr.position != Mark)							goto nxthdr;			/* Ignore this eof */						FSClose(RefNum);						RefNum = 0;						ShowProgress ();						CleanupFile(name, modif);						err = FINE;					/* Normal eof */						goto done;					case ZSKIP:						message = (Byte *)"\phdr-ZSKIP";						FSClose(RefNum);						RefNum = 0;						putlog (lgNOPE, "Sender requested skip file.");						err = FINE;					/* Sender skipped it */						goto done;					case ZDATA:						message = (Byte *)"\phdr-ZDATA";						if (hdr.position != Mark) {							++retry;							if (retry > Settings.ZRetries) {								err = ERROR;								putlog ('~', "ReceiveFile ZDATA");								goto done;							}							SendAttn(Attn);							break;						}moredata:						ShowProgress ();						switch (ReceiveData(Buffer, ZMAXSPLEN, &Count, &end))						{							case TIMEOUT:								++retry;								if (retry > Settings.ZRetries) {									err = ERROR;									putlog ('~', "ReceiveFile TimeOut");									goto done;								}								message = (Byte *)"\pdata-TIMEOUT";								break;													case ERROR:														++retry;								if (retry > Settings.ZRetries) {									err = ERROR;									putlog ('~', "ReceiveFile Error (CRC)");									goto done;								}								SendAttn(Attn);								message = (Byte *)"\pdata-ERROR";								break;													case FINE:														retry = 0;								WriteFile();								Mark += Count;														switch (end)								{									case ZCRCW:																		message = (Byte *)"\pdata-ZCRCW";										hdr.position = Mark;										SendHexHeader(ZACK, hdr);										goto nxthdr;																	case ZCRCQ:																		message = (Byte *)"\pdata-ZCRCQ";										hdr.position = Mark;										SendHexHeader(ZACK, hdr);										goto moredata;																	case ZCRCG:																		message = (Byte *)"\pdata-ZCRCG";										goto moredata;																	case ZCRCE:										message = (Byte *)"\pdata-ZCRCE";										goto nxthdr;								}								break;						}						break;					default:						err = ERROR;						putlog ('~', "ReceiveFile default Error by type = %d", type);						goto done;				}				break;							case TIMEOUT:				++retry;				if (retry > Settings.ZRetries)				{					err = ERROR;					putlog ('~', "ReceiveFile TimeOut by got header");					goto done;				}								message = (Byte *)"\phdr-TIMEOUT";				break;						case ERROR:								++retry;								if (retry > Settings.ZRetries)				{					err = ERROR;					putlog ('~', "ReceiveFile Error by got header");					goto done;				}								SendAttn(Attn);				message = (Byte *)"\phdr-ERROR";				break;		}		ShowProgress ();		}done:		ShowProgress ();		if (err && RefNum)	{		FSClose(RefNum);		RefNum = 0;				name[name[0]+1] = 0;			if ( !strcasecmp ( (char *) &name[name[0]-3], ".PKT" ) )		{			FSDelete (name, Settings.volume);			putlog (lgATTN, "Discard partialy received %s", &name[1]);		}		else			putlog (lgATTN, "Save partialy received %s", &name[1]);	}	return err;}/* ----- Receive one or more files ------------------------------------- */static short ReceiveFiles (void){	register short err;	HEADER filehdr;			/* Sender's options */	gotta_mail = 0;	Mark = StartPos = 0;	StartTime = LMGetTime ();	Zctlesc = Escape();	TryZhdrType = ZRINIT;	Attn[0] = 0;			/* Clear sender's attention string */	AttnLen = 0;	for (;;)	{		StartTime = LMGetTime ();		err = TryZReceive(&filehdr);		putlog ('~', "TryZReceive got err = %d", err);		if (!Count)		{			return err;		}		ConvertNL = filehdr.zfile.conv == ZCNL;		err = ReceiveFile(filehdr);		putlog ('~', "ReceiveFile err = %d", err);		if (err)			return err;			gotta_mail = 1;	}}/* ----- ZModem receive ------------------------------------------------ */short ZReceive (void){	register short err = 0;	CLEAR_INBOUND ();	CLEAR_OUTBOUND ();	big_pause (1);	CLEAR_INBOUND ();	CLEAR_OUTBOUND ();	Sending = FALSE;	if (Transfer)		return fBsyErr;	if ((Settings.volume = myOpenWD ( inboundPath )) == 0)	{		putlog ( lgALRT, "cant open inbound directory" );		return fBsyErr;	}		StartTime = LMGetTime ();	RefNum = 0;						/* No file open yet */	Mark = Length = StartPos = 0;/*	if (!(Buffer = (Byte *)NewPtr(BUFFERSIZE)))	{		err = memFullErr;		goto done;							//	* Not enough memory *	}		if (err = NewTxBuffer(FALSE))			//	* We only will send headers *		goto done;							//	* Not enough memory **/	Transfer = 1;	if (Settings.handshake == 1)	/* XON/OFF must be off */		SerialHandshake(0);	if (err = setjmp(CancelEnv))	{								/* Prepare cancel or abort */		SerialAbort();		while (busy)			;						if (err == CANCEL)		{			putlog ('~', "Canceled!");			SendCancel();			/* Send cancel string */		}		else			putlog ('~', "Aborted!");	} else		err = ReceiveFiles();		/* Receive file(s) */	putlog ('~', "ZReceive err = %d", err);	SerialHandshake(Settings.handshake);	Transfer = 0;done:	if (RefNum)	{								/* Close any open file */		FSClose(RefNum);		RefNum = 0;	}	//	DisposeTxBuffer();				/* Get rid of transmit buffer */	//	if (Buffer)						/* Get rid of receive buffer *///		DisposPtr((Ptr)Buffer);			myCloseWD ( Settings.volume );	Settings.volume = 0;		return err;}short Send_Zmodem (StringPtr fname, char *alias, short fsent, short wazoo){	short	err;	if (fsent==END_BATCH)	{		SessionCleanup();		return FINE;	}	else		if (fsent==NOTHING_TO_DO)		{			CLEAR_INBOUND ();			CLEAR_OUTBOUND ();			big_pause (1);			CLEAR_INBOUND ();			CLEAR_OUTBOUND ();			SENDBYTE ( 'r' );			SENDBYTE ( 'z' );			SENDBYTE ( '\r' );			Invitation();			SessionStartup();			SessionCleanup();			return FINE;										//??		}	fname[fname[0]+1] = 0;//	putlog ( lgNOPE, "Sending: #%.3d, %s", fsent, &fname[1] );	FILENUMBER = fsent;	err = ZTransmit (fname, 0, 0);	//	if (err)//	{//		DisposeTxBuffer();//		//		if (Buffer)//			DisposPtr((Ptr)Buffer);//	}		return err;}Boolean InitializeBuffer (void){	TxBuffer = (Byte *) NewPtrClear ( 2*(ZMAXSPLEN + 6) );	Buffer = (Byte *) NewPtrClear ( 2*(ZMAXSPLEN + 6) );	return (TxBuffer && Buffer);}