#include <stdio.h>#include <string.h>#include <console.h>#include "Ravel_FTN.h"#include "Ravel_Prefs.h"#include "Pathes.h"#include "ascii.h"#include "compatible.h"#include "PopList.h"//#include "ZMisc.h"//#include "Port.h"#include "Comm.h"#include "PascalStr.h"#include "Modem.h"#include "Timing.h"#include "myEnv.h"#include "Session.h"#include "stringutl.h"#include "log.h"#include "pmain.h"#include "Scheduler.h"#include "Unattended.h"#include "Manual.h"#include "Attacher.h"#include "zfiles.h"#include "nodelist.h"#include "busy.h"#define	FAILURE		0#define	IGNORE		1#define	CONNECTED	2#define	RINGING		3#define INCOMING	4#define	FAULTCOUNT	5#define	FAULTIMMED	6extern	in_outboundPtr	outbound;		// original ptrextern	in_outboundPtr	cur_over;		// current ptrextern	manual_chainPtr	manual_outbound;extern	short			gotta_mail;		// somewhat received with ZedZapextern	short			gotta_xmail;		// somewhat received with ZedZapextern	Boolean			force_answer;	// Answer menu item was selected.extern	Boolean			Aborted;extern	homeHndl		homesystem;			//	¥	Home system structextern	short			NodesNumber;		//	¥	Linked Nodes structs listextern	nodePrefHndl	*nodesHndls;extern	unsigned long	cur_baud;extern	unsigned long	minimal_baud_rate;extern	ADDR			called_addr;		char			session_password_s[16];	/* Master EMSI/YooHoo session password */		char			*session_password;	/* Master EMSI/YooHoo session password */extern	DialogPtr		RavelWindow;extern	ListHandle		RavelList;extern	short			current_link;extern	short			links_count;extern	short			badcount;extern	short			FLAG;extern	long			issuse_calls_mask;extern	long			zmh_calls_mask;extern	long			accept_calls_mask;extern	hiddenlinesPtr	*commonhiddens;extern	StringPtr		*commoninits;extern	short			CONNECTION;		short			current_aka;		tsend			tobesend;#define	f_down		0x0010	//	down node#define	f_hold		0x0020	//	hold node#define	f_pvt		0x0040	//	private nodeBoolean haspassword ( ADDR *addr, char **pass );tsend	*calcoutbound (ADDR *addr);Boolean CheckCancel (void);short	matchaka ( ADDR *addrs );short	getlinkinx ( ADDR *addrs );void	PopListDestruct (ListHandle list);void ClearOutboundStruct ( void ){	in_outboundPtr	over, next = outbound;		while (next)	{		over = next->next;				if (next->requests)			DisposeHandle (next->requests);					if (next->attaches)			DisposeHandle (next->attaches);				DisposePtr ( (Ptr) next );		next = over;	}		outbound = NULL;	cur_over = NULL;	links_count = 0;}static	char	*pollModes[3] = { ".HLO", ".DLO", ".CLO" };static	char	*requestSuffix = ".REQ";void AddOutbound ( short dir, StringPtr filename, unsigned char poll, short zone, short net, short node, short point ){#pragma unused (filename, dir)	in_outboundPtr	over = outbound;	if ( poll != 'H' && poll != 'D' && poll != 'C' && poll != 'R' )		return;		if (!over)		outbound = over = (in_outboundPtr) NewPtrClear (sizeof(in_outboundType));	else	{		do {			if ( over->calladdr.zone == zone &&				 over->calladdr.net == net &&				 over->calladdr.node == node &&				 over->calladdr.point == point )				goto already;						if (over->next)				over = over->next;			else				break;		} while (1);		over->next = (in_outboundPtr) NewPtrClear (sizeof(in_outboundType));		over = over->next;	}//	¥	Simplyfied for first	over->next = NULL;	over->calladdr.zone = zone;	over->calladdr.net = net;	over->calladdr.node = node;	over->calladdr.point = point;		over->evt_mask = 0L;		over->nodelist_time.Start.hour = 0;	over->nodelist_time.Start.minute = 0;	over->nodelist_time.End.hour = 0;	over->nodelist_time.End.minute = 0;		over->useaka = 0;	over->poll = 0;	over->force = 0;	over->requests = NULL;	over->attaches = NULL;	over->tempstop = 0;	over->badcount = 0;	links_count++;already:	switch (poll)	{	case 'H':	over->poll |= HOLD;		break;	case 'C':	over->poll |= CRASH;	break;	case 'D':	over->poll |= DIRECT;	break;	case 'R':	over->poll |= REQUEST;	break;	}}static void _RescanOutbound ( void ){	short			zdir, ndir, pdir;			// working directory reference numberÉ	CInfoPBRec		cipbr;						/* local pb */	HFileInfo		*fpb = (HFileInfo *)&cipbr;	/* to pointers */	short			i, j, k, rc, idx, attFile;	short			idx1, idx2;	Str31			filename;	Str255			subfolder, subfolder1, filez;	char			ttt[128], tt[64], *zzz, *signpos;	ADDR			taddr;		long			currentzone, currentnet, currentnode, currentpoint, dummy, cnt, t;	OSType			creator, type;	long			create, modif, flen;		Boolean			was;	Handle			att;		in_outboundPtr	over;	manual_chainPtr	manual_over;	Cell			theCell;		FSSpec			fspec;	Handle			iHandle;	Rect			iRect;	short			iType;		putMessage ( 2, "\pRescan outbound" );//	SysBeep (10);	//	LDelRow ( 0, 0, RavelList );	PopListDestruct (RavelList);	ClearOutboundStruct ();	outboundPath[outboundPath[0]+1] = 0;	if ( ( zdir = myOpenWD ( outboundPath ) ) == 0 )	{		putlog ( lgALRT, "Unable to open directory %s", &outboundPath[1] );		return;	}	fpb->ioNamePtr = filename;	for ( idx=1; TRUE; idx++)	{											/* indexing loop */		fpb->ioDirID = 0L;						/* must set on each loop */		fpb->ioFDirIndex = idx;		fpb->ioVRefNum = zdir;		filename[0] = 0;				rc = PBGetCatInfoSync (&cipbr);				if (rc) break;							/* exit when no more entries */		if ( (fpb->ioFlAttrib & 16) && filename[0] == 9 )		{										/* zone folder: Zone_XXXX */			filename[filename[0]+1] = 0;						if ( strncmp ( (char *) &filename[1], "Zone_", 5 ) )				continue;							if ( sscanf ( (char *) &filename[6], "%lX", &currentzone ) == EOF )				continue;						pStrConc ( outboundPath, filename, subfolder );						ndir = myOpenWD ( subfolder );						for ( idx1=1; TRUE; idx1++)			{											/* indexing loop */				fpb->ioDirID = 0L;						/* must set on each loop */				fpb->ioFDirIndex = idx1;				fpb->ioVRefNum = ndir;				filename[0] = 0;								rc = PBGetCatInfoSync (&cipbr);								if (rc) break;							/* exit when no more entries */						if ( filename[0] == 12 )				{										/* look up for nodes attaches & pts */					filename[filename[0]+1] = 0;		/* NNNNnnnn.?LO or NNNNnnnn.PTS */										if ( !(fpb->ioFlAttrib & 16) &&			//	¥	NODE attach						 filename[9] == '.' &&						(!strncmp ( (char *) &filename[11], "LO", 2 ) ||						 !strncmp ( (char *) &filename[10], "REQ", 3 )) )					{						if ( sscanf ( (char *) &filename[1], "%lX", &currentnode ) == EOF )							continue;										currentnet = currentnode >> 16;						currentnode &= 0x0000FFFF;//¥		fix it for zc and ncÉ//¥//¥						if (currentnet && currentnode)							AddOutbound ( ndir, filename, filename[10], currentzone, currentnet, currentnode, 0 );					}					else						if ( (fpb->ioFlAttrib & 16) &&		//	¥	Point folder							 !strncmp ( (char *) &filename[9], ".PTS", 4 ) )						{							if ( sscanf ( (char *) &filename[1], "%lX", &currentnode ) == EOF )								continue;														currentnet = currentnode >> 16;							currentnode &= 0x0000FFFF;														pStrConc ( subfolder, "\p:", subfolder1 );							pStrConc ( subfolder1, filename, subfolder1 );														pdir = myOpenWD ( subfolder1 );														for ( idx2=1; TRUE; idx2++)							{											/* indexing loop */								fpb->ioDirID = 0L;						/* must set on each loop */								fpb->ioFDirIndex = idx2;								fpb->ioVRefNum = pdir;								filename[0] = 0;																rc = PBGetCatInfoSync (&cipbr);																if (rc) break;							/* exit when no more entries */														if ( filename[0] == 12 )								{										/* look up for pts attaches */									filename[filename[0]+1] = 0;		/* NNNNNNNN.?LO */												if ( !(fpb->ioFlAttrib & 16) &&			//	¥	point attach										 filename[9] == '.' &&										(!strncmp ( (char *) &filename[11], "LO", 2 ) ||										 !strncmp ( (char *) &filename[10], "REQ", 3 )) )									{										if ( sscanf ( (char *) &filename[1], "%lX", &currentpoint ) == EOF )											continue;																				if (currentpoint != 0 && (currentpoint & 0xFFFF0000) == 0)											AddOutbound ( pdir, filename, filename[10], currentzone, currentnet, currentnode, currentpoint );									}								}														}	/* points cycle */														myCloseWD ( pdir );						}				}							}	/* node cycle */					myCloseWD ( ndir );					}	}			/* zone cycle */		myCloseWD ( zdir );//	¥	append pure manual params		if (manual_over = manual_outbound)			// full manual paramsÉ	{		while (manual_over)		{			if (over = outbound)			{				was = FALSE;							while (1)				{					if ( manual_over->calladdr.zone == over->calladdr.zone &&						 manual_over->calladdr.net == over->calladdr.net &&						 manual_over->calladdr.node == over->calladdr.node &&						 manual_over->calladdr.point == over->calladdr.point )					{						was = TRUE;						break;					}										if (over->next)						over = over->next;					else						break;				}			}			else			{				outbound = (in_outboundPtr) NewPtr (sizeof(in_outboundType));				outbound->next = NULL;				outbound->calladdr.zone = manual_over->calladdr.zone;				outbound->calladdr.net = manual_over->calladdr.net;				outbound->calladdr.node = manual_over->calladdr.node;				outbound->calladdr.point = manual_over->calladdr.point;				outbound->evt_mask = 0L;				outbound->nodelist_time.Start.hour = 0;				outbound->nodelist_time.Start.minute = 0;				outbound->nodelist_time.End.hour = 0;				outbound->nodelist_time.End.minute = 0;				outbound->useaka = 0;				outbound->poll = 0;				outbound->force = 0;				outbound->requests = NULL;				outbound->attaches = NULL;								outbound->tempstop = manual_over->tempstop;				outbound->badcount = manual_over->badcount;				links_count++;								goto around;			}						if (!was && !over->next)	// not present yet... append new!			{				in_outboundPtr	over_1 = over;							over_1->next = (in_outboundPtr) NewPtr (sizeof(in_outboundType));				over_1 = over_1->next;									//	¥	Empty for first							over_1->next = NULL;				over_1->calladdr.zone = manual_over->calladdr.zone;				over_1->calladdr.net = manual_over->calladdr.net;				over_1->calladdr.node = manual_over->calladdr.node;				over_1->calladdr.point = manual_over->calladdr.point;				over_1->evt_mask = 0L;				over_1->nodelist_time.Start.hour = 0;				over_1->nodelist_time.Start.minute = 0;				over_1->nodelist_time.End.hour = 0;				over_1->nodelist_time.End.minute = 0;				over_1->useaka = 0;				over_1->poll = 0;				over_1->force = 0;				over_1->requests = NULL;				over_1->attaches = NULL;				over_1->tempstop = manual_over->tempstop;				over_1->badcount = manual_over->badcount;				links_count++;			}				around:			manual_over = manual_over->next;		}	}//	¥	Full outbound's structures with my own node definitions	cur_over = outbound;	over = outbound;		while (over)	{		over->callphone[0] = 0;		over->password[0] = 0;		over->hiddens = NULL;		over->inits = NULL;				for ( i=0; i<NodesNumber; i++ )			if ( (*(nodesHndls[i]))->Addr.zone == over->calladdr.zone &&				 (*(nodesHndls[i]))->Addr.net == over->calladdr.net &&				 (*(nodesHndls[i]))->Addr.node == over->calladdr.node &&				 (*(nodesHndls[i]))->Addr.point == over->calladdr.point )			{				if ((*(nodesHndls[i]))->nodePhone[0])					pStrCopy ( (*(nodesHndls[i]))->nodePhone, over->callphone );				else					GetPhoneFromAddr ( &over->calladdr, over->callphone );								if (commonhiddens[i])					over->hiddens = &commonhiddens[i];								if (commoninits[i])					over->inits = commoninits[i];								over->callphone[over->callphone[0]+1] = 0;				strncpy ( over->password, (*(nodesHndls[i]))->Session_pwd, 8 );				over->useaka = (*(nodesHndls[i]))->yourAka;								over->evt_mask = (*(nodesHndls[i]))->evt_mask;				GetTimesFromAddr ( &over->calladdr, &over->nodelist_time );								break;			}				if (i == NodesNumber)		{			GetTimesFromAddr ( &over->calladdr, &over->nodelist_time );			GetPhoneFromAddr ( &over->calladdr, over->callphone );			over->callphone[over->callphone[0]+1] = 0;		}				if (manual_over = manual_outbound)			// full manual paramsÉ		{			while (manual_over)			{				if ( manual_over->calladdr.zone == over->calladdr.zone &&					 manual_over->calladdr.net == over->calladdr.net &&					 manual_over->calladdr.node == over->calladdr.node &&					 manual_over->calladdr.point == over->calladdr.point )				{					over->poll |= manual_over->poll;					over->force = manual_over->force;					//					if (over->callphone[0] == 0 && manual_over->callphone[0] != 0)					if (manual_over->callphone[0] != 0)						pStrCopy ( manual_over->callphone, over->callphone );					//					if (over->password[0] == 0 && manual_over->password[0] != 0)					if (manual_over->password[0] != 0)						strncpy ( over->password, manual_over->password, 8 );										if (manual_over->requests)					{						Handle	h;												h = manual_over->requests;						HandToHand (&h);						over->requests = h;					}					else						over->requests = NULL;										if (manual_over->attaches)					{						Handle	h;						h = manual_over->attaches;						HandToHand (&h);						over->attaches = h;					}					else						over->attaches = NULL;					over->tempstop = manual_over->tempstop;					over->badcount = manual_over->badcount;				}								manual_over = manual_over->next;			}		}		over = over->next;	}	if (!(over = outbound))	{		putMessage ( 2, "\p" );		cur_over = NULL;		current_link = 0;		links_count = 0;		return;	}		if (current_link >= links_count)		current_link = 0;	j = 0;	//	LSetDrawingMode (false, RavelList);		while (over)	{		if (j == current_link)			cur_over = over;			//	--------------------------------------------------------	//	make all folders for all attaches (manual is our target)				sprintf ( (char *) &filename[1], "Zone_%.4X:", over->calladdr.zone );		filename[0] = strlen ( (char *) &filename[1] );		pStrConc ( outboundPath, filename, subfolder );				if ( FSMakeFSSpec ( 0, 0, subfolder, &fspec ) == fnfErr )		{			putlog ( '~', "RESCAN: Create zonal folder %s", &filename[1] );						if ( DirCreate ( 0, 0, subfolder, &dummy ) )				putlog ( lgALRT, "RESCAN: Cannot create zonal folder %s", &filename[1] );		}			//	¥	Destination node is point?				if ( over->calladdr.point != 0 )		{			//	¥	Creation or finding point subfolderÉ				sprintf ( (char *) &filename[1], "%.4X%.4X.PTS:", over->calladdr.net, over->calladdr.node );			filename[0] = strlen ( (char *) &filename[1] );						pStrConc ( subfolder, filename, subfolder1 );						if ( FSMakeFSSpec ( 0, 0, subfolder1, &fspec ) == fnfErr )			{				putlog ( '~', "RESCAN: Create points folder %s", &filename[1] );				if ( DirCreate ( 0, 0, subfolder1, &dummy ) )					putlog ( lgALRT, "RESCAN: Cannot create points folder %s", &filename[1] );			}		}		//¥		calculate size to be sendÉ		over->tobesend.pkt = 0;		over->tobesend.other = 0;		//¥		.?lo lists		taddr.Zone = over->calladdr.zone;		taddr.Net = over->calladdr.net;		taddr.Node = over->calladdr.node;		taddr.Point = over->calladdr.point;				if (PathForOutbound (&taddr, subfolder))		{			subfolder[subfolder[0]+1] = 0;						for (i=0; i<3; i++)			{				strcpy ( (char *) &subfolder1[1], (char *) &subfolder[1] );				strcat ( (char *) &subfolder1[1], pollModes[i] );				subfolder1[0] = strlen ((char *) &subfolder1[1]);								if (FSOpen (subfolder1, 0, &attFile))					continue;								GetEOF (attFile, &cnt);				att = NewHandleClear (cnt);				HLock (att);				zzz = *att;								FSRead (attFile, &cnt, zzz);								for (t = 0; t < cnt; t++)					if (zzz[t] == 0x0D)						zzz[t] = 0;				t = 0;								while (t < cnt)				{					strcpy ( (char *) &filez[1], zzz+1 );					filez[0] = strlen ( (char *) &filez[1] );					t += filez[0]+2;					signpos = zzz;					zzz += filez[0]+2;										if (*signpos != '~' && GetInfoFile (0, 0, filez, &creator,	&type, &create, &modif,	&flen) == 0)					{						if (ResolveExtension (filez) == 2)							over->tobesend.pkt += flen;						else							over->tobesend.other += flen;					}				}				DisposeHandle (att);								FSClose (attFile);			}		}		//¥		Manual attaches list		if (over->attaches)		{			HLock (over->attaches);			cnt = GetHandleSize (over->attaches);			zzz = *over->attaches;			t = 0;					while (t < cnt)			{				strcpy ( (char *) &filez[1], zzz+1 );				filez[0] = strlen ( (char *) &filez[1] );				t += filez[0]+2;				zzz += filez[0]+2;								if (GetInfoFile (0, 0, filez, &creator,	&type, &create, &modif,	&flen) == 0)				{					if (ResolveExtension (filez) == 2)						over->tobesend.pkt += flen;					else						over->tobesend.other += flen;				}			}			HUnlock (over->attaches);		}	//	--------------------------------------------------------		sprintf ( ttt, "%s", printaddr ( &over->calladdr, tt ) );				if (GetNodeInfo (&over->calladdr, filez))		{			if ((FLAG & f_down) != 0)				over->poll = 0;			else				if ((FLAG & f_hold) != 0)					over->poll = HOLD;		}				i = strlen (ttt);		for ( k=i; k<20; k++ )			ttt[k] = ' ';				if (over->poll & HOLD)			ttt[k++] = 'H';				if (over->poll & DIRECT)			ttt[k++] = 'D';				if (over->poll & CRASH)			ttt[k++] = 'C';				if (over->poll & REQUEST)			ttt[k++] = 'R';				ttt[k] = 0;		if (over->force || over->requests || over->attaches)		{			i = strlen (ttt);			for ( k=i; k<24; k++ )				ttt[k] = ' ';			if (over->force)				ttt[k++] = 'F';						if (over->requests)				ttt[k++] = 'R';						if (over->attaches)				ttt[k++] = 'A';		}		ttt[k] = 0;				if (over->tobesend.pkt || over->tobesend.other)		{			i = strlen (ttt);			for ( k=i; k<28; k++ )				ttt[k] = ' ';						sprintf ( &ttt[k], "%ld%c",					((over->tobesend.pkt+over->tobesend.other) > 1023) ? (over->tobesend.pkt+over->tobesend.other) / 1024 : (over->tobesend.pkt+over->tobesend.other),					((over->tobesend.pkt+over->tobesend.other) > 1023) ? 'K' : 'b' );		}		//		ttt[k] = 0;		i = strlen (ttt);		for ( k=i; k<35; k++ )			ttt[k] = ' ';		ttt[k] = 0;		if (!over->force)		{			if (over->evt_mask)			{				char	t[64];				sprintf ( &ttt[k], "%s", printEvent (over->evt_mask, t) );			}			else				if (over->nodelist_time.Start.hour || over->nodelist_time.End.hour ||					over->nodelist_time.Start.minute || over->nodelist_time.End.minute)				{					sprintf ( &ttt[k], "%.2d:%.2d - %.2d:%.2d", 											(short) over->nodelist_time.Start.hour,											(short) over->nodelist_time.Start.minute,											(short) over->nodelist_time.End.hour,											(short) over->nodelist_time.End.minute );				}				else					strcat (ttt, "--:-- - --:--");		}		else			strcat (ttt, "00:00 - 23:59");				k = strlen (ttt);		sprintf (&ttt[k], " %-2d %s", (over->badcount >= badcount) ? 0 : over->badcount,									(over->badcount >= badcount) ? "!" :										((over->tempstop) ? "¥" : ""));				i = LAddRow ( 1, 0x7FFF, RavelList );		SetPt ( &theCell, 0, i );//		LSetCell ( ttt, strlen (ttt), theCell, RavelList );			PopListSetCell (ttt, strlen (ttt), theCell, RavelList, true);		over = over->next;		j++;	}	SetPt ( &theCell, 0, current_link );	LSetSelect ( TRUE, theCell, RavelList );//	LSetDrawingMode (true, RavelList);		SetPort (RavelWindow);	GetDialogItem (RavelWindow, 9, &iType, &iHandle, &iRect);	InvalRect (&iRect);	MaxMem (&currentpoint);	putMessage ( 2, "\p" );}void RescanOutbound ( void ){	Cell	theCell;	Rect	iRect;	LSetDrawingMode (false, RavelList);	_RescanOutbound ();	LAutoScroll (RavelList);	LSetDrawingMode (true, RavelList);		SetPt (&theCell, 0, (*RavelList)->dataBounds.bottom);	LRect (&iRect, theCell, RavelList);		if (iRect.top < (*RavelList)->rView.bottom)	{		iRect.bottom = (*RavelList)->rView.bottom;		EraseRect (&iRect);	}	InvalRect (&(*RavelList)->rView);}static Boolean CanCall (in_outboundPtr ovr){	hiddenlinesPtr		thidden;	if (bsy_check (&ovr->calladdr, workPath))					//	link is busy		return false;		if (ovr->badcount >= badcount || ovr->tempstop)				//	too many tries or stopped		return false;	if (!CheckEventNow (issuse_calls_mask) && !ovr->force)		//	not global time and not force call		return false;		if ((ovr->poll & (CRASH | DIRECT)) == 0 && !ovr->force)		//	hold (or none) and not force		return false;	if (ovr->callphone[0] == 0 && !ovr->hiddens)				//	no phone number nor hiddens		return false;	if (ovr->hiddens)											//	hiddens condition	{		if (ovr->force)			return true;			thidden = *ovr->hiddens;				do {					if ((*ovr->hiddens)->phone[0] == 0)					//	means primary settings			{				if (ovr->callphone[0])				{					if (ovr->evt_mask == 0)						//	get time from nodelist					{						if (ovr->nodelist_time.Start.hour ||							ovr->nodelist_time.End.hour ||							ovr->nodelist_time.Start.minute ||							ovr->nodelist_time.End.minute)		//	nodelist time presents						{							if (CheckTimesNow (&ovr->nodelist_time))								return true;						}						else									//	no nodelist time, use zmh						{							if (CheckEventNow (zmh_calls_mask))								return true;						}					}					else										//	time pointed in link setting					{						if (CheckEventNow (ovr->evt_mask))		//	check time from link setting							return true;					}				}			}			else			{				if (CheckEventNow ((*ovr->hiddens)->worktime))	//	check time from link setting					return true;			}						if ((*ovr->hiddens)->next == thidden)				break;						*ovr->hiddens = (*ovr->hiddens)->next;				//	get next					} while (1);				*ovr->hiddens = (*ovr->hiddens)->next;				return false;											//	loop closed, no matches	}	else														//	only nodelist or setting's phone exists	{		if (ovr->force)			return true;		if (ovr->evt_mask == 0)									//	get time from nodelist		{			if (ovr->nodelist_time.Start.hour ||				ovr->nodelist_time.End.hour ||				ovr->nodelist_time.Start.minute ||				ovr->nodelist_time.End.minute)					//	nodelist time presents			{				return (CheckTimesNow (&ovr->nodelist_time));			}			else												//	no nodelist time, use zmh			{				return CheckEventNow (zmh_calls_mask);			}		}		else													//	time pointed in link setting		{			return CheckEventNow (ovr->evt_mask);				//	check time from link setting		}	}//	impossible flow		return false;}void Unattended ( void ){	short			i;	char			ttt[128];	addr			taddr;			if (!outbound)		return;	printaddr ( &cur_over->calladdr, &ttt[1] );	ttt[0] = strlen ( (char *) &ttt[1] );	putMessage ( 1, (StringPtr) ttt );/*	if ( !bsy_check (&cur_over->calladdr, workPath) &&		 cur_over->badcount <= badcount && !cur_over->tempstop && (		 (CheckEventNow (issuse_calls_mask) &&		 (cur_over->poll & (CRASH | DIRECT)) != 0 &&		 (cur_over->callphone[0] != 0 || cur_over->hiddens) &&		 (CheckEventNow ( cur_over->evt_mask ) ||		 (cur_over->evt_mask == 0 && CheckTimesNow ( &cur_over->nodelist_time )))) ||				((cur_over->callphone[0] != 0 || cur_over->hiddens) && cur_over->force != 0)) )*/	if (CanCall (cur_over))	{//¥¥¥		taddr = cur_over->calladdr;		bsy_raise (&taddr, workPath);				putMessage ( 0, "\pDialing to uplinkÉ" );		mdm_hangup ((char *) cur_over->inits);				if ( CheckCancel () )		{			putMessage ( 0, "\p" );						if (cur_over->inits)				mdm_hangup (NULL);						bsy_clear (&taddr, workPath);			return;		}			//	¥	Init called_addr for was_initiator (we must know where are we calling)	//	¥	else we must trashed called_addr like this:			called_addr.Zone = cur_over->calladdr.zone;		called_addr.Net = cur_over->calladdr.net;		called_addr.Node = cur_over->calladdr.node;		called_addr.Point = cur_over->calladdr.point;		called_addr.Domain = NULL;				current_aka = cur_over->useaka;				tobesend = cur_over->tobesend;		//		pStrConc ( "\pDialing: ",//				(cur_over->hiddens) ? (*(cur_over->hiddens))->phone : cur_over->callphone,//				(StringPtr) ttt );		//		putMessage ( 2, (StringPtr) ttt );				CLEAR_INBOUND ();		CLEAR_OUTBOUND ();				if (cur_over->hiddens)		{			if ((*(cur_over->hiddens))->phone[0])			{				pStrConc ( "\pDialing: ", (*(cur_over->hiddens))->phone, (StringPtr) ttt );				putMessage ( 2, (StringPtr) ttt );				putlog ( lgNOPE, "Dialing: %s (%s) [Hidden]", &(*(cur_over->hiddens))->phone[1],							printaddr (&cur_over->calladdr, ttt) );				i = dial_modem ( (char *) &(*(cur_over->hiddens))->phone[1] );			}			else				if (cur_over->callphone[0])		//	foolproof				{					pStrConc ( "\pDialing: ", cur_over->callphone, (StringPtr) ttt );					putMessage ( 2, (StringPtr) ttt );					cur_over->callphone[cur_over->callphone[0]+1] = 0;					putlog ( lgNOPE, "Dialing: %s (%s)", &cur_over->callphone[1],								printaddr (&cur_over->calladdr, ttt) );					i = dial_modem ( (char *) &cur_over->callphone[1] );				}				else					Aborted = true;				//	foolproof resolving (nevermind!)						*(cur_over->hiddens) = (*(cur_over->hiddens))->next;		}		else		{			pStrConc ( "\pDialing: ", cur_over->callphone, (StringPtr) ttt );			putMessage ( 2, (StringPtr) ttt );			cur_over->callphone[cur_over->callphone[0]+1] = 0;			putlog ( lgNOPE, "Dialing: %s (%s)", &cur_over->callphone[1],						printaddr (&cur_over->calladdr, ttt) );			i = dial_modem ( (char *) &cur_over->callphone[1] );		}				if ( CheckCancel () )		{			hang_up ();			CLEAR_INBOUND ();			CLEAR_OUTBOUND ();			mdm_hangup (NULL);			putMessage ( 0, "\p" );			bsy_clear (&taddr, workPath);			return;		}		if ( i == CONNECTED )		{			if ((minimal_baud_rate != 0) && (cur_baud < minimal_baud_rate))			{				putlog ( lgNOPE, "Low baud rate." );				putMessage ( 2, "\pLow baud rate - ABORTED" );				OverrideManual (&cur_over->calladdr, 0, false, true, false, false);				RescanOutbound ();			}			else			{				putMessage ( 2, "\pTry establish connection" );				strcpy ( &ttt[1], cur_over->password );				ttt[0] = strlen (&ttt[1]);								if ((cur_over->password[0]))				{					session_password = session_password_s;					strcpy (session_password_s, cur_over->password);				}				else					session_password = NULL;						AddManual ( &cur_over->calladdr, cur_over->callphone,					(StringPtr) ttt, NULL, false, cur_over->poll, cur_over->force );				RescanOutbound ();								Session ( 1 );				newMessage (lTNAME, "");				newMessage (lTSTAT, "");				newMessage (lRNAME, "");				newMessage (lRSTAT, "");				drawProgressBar (ITBAR, -1, 0);				drawProgressBar (IRBAR, -1, 0);				drawProgressCircle (ITCIRCLE, -1, 0);				drawProgressCircle (IRCIRCLE, -1, 0);				RescanOutbound ();			}			hang_up ();			CLEAR_INBOUND ();			CLEAR_OUTBOUND ();			mdm_hangup (NULL);		}		else		{			if (cur_over->inits)				mdm_hangup (NULL);						if (i == FAULTCOUNT)			{				OverrideManual (&cur_over->calladdr, 0, false, true, false, false);				RescanOutbound ();			}			else				if (i == FAULTIMMED)				{					OverrideManual (&cur_over->calladdr, 0, false, true, true, false);					RescanOutbound ();				}		}		bsy_clear (&taddr, workPath);	}	putMessage ( 2, "\p" );}Boolean CheckService ( void ){		short			resp = 0;static	short			cs_Rings = 0;static	unsigned long	cs_RingTime = 0;	//	¥	modem gotta somewhat... maybe RING?	if (CONNECTION >= 0)	{		if (!force_answer)			resp = modem_response ( 600 );	}	else		resp = (INVOKE ()) ? RINGING : 0;		if (CONNECTION < 0 && resp == RINGING && !CheckEventNow (accept_calls_mask))	{		putlog ('~', "+CheckService: Rejecting");		MakeCMAccept (false);	}	else		if ((CONNECTION >= 0 && force_answer) || (resp == RINGING && CheckEventNow (accept_calls_mask)))		{			putlog ('~', "+CheckService: Accepting");			CLEAR_INBOUND ();			CLEAR_OUTBOUND ();						do {							if (CONNECTION >= 0 && !force_answer)				{					if (cs_RingTime == 0 || cs_RingTime < LMGetTime())					{						cs_Rings = 0;						cs_RingTime = LMGetTime () + 5;					}					cs_Rings++;									if (cs_Rings < GetRingsNumber (accept_calls_mask))						break;										cs_Rings = 0;				}								putMessage ( 2, "\pAnsweringÉ" );				if (CONNECTION < 0)				{					if (CONNECTION == -1)					{						putlog ('&', "RING CTB");					}					else						if (CONNECTION == -2)						{							putlog ('&', "RING TCP");						}					putlog ( lgNOPE, "Try to establish connection" );					if (!MakeCMAccept(true))					{						putlog ('!', "Accepting faultÉ");						resp = FAILURE;					}					else					{						resp = CONNECTED;					}				}				else				{					putlog ( lgNOPE, "Answering..." );					putMessage ( 2, "\pAnsweringÉ" );					mdm_cmd_string ( "ATA", 0);					mdm_cmd_char (CR);					resp = modem_response (1800);				}								if (resp == CONNECTED)				{					if ((minimal_baud_rate != 0) && (cur_baud < minimal_baud_rate))					{						putlog ( lgNOPE, "Low baud rate." );						putMessage ( 2, "\pLow baud rate - ABORTED" );					}					else					{						current_aka = 0;		// let assumed will be my main address until.... Hz.						tobesend.pkt = 0;						tobesend.other = 0;						session_password = NULL;						RescanOutbound ();		//¥	07.05.1998						Session ( 0 );						newMessage (lTNAME, "");						newMessage (lTSTAT, "");						newMessage (lRNAME, "");						newMessage (lRSTAT, "");						drawProgressBar (ITBAR, -1, 0);						drawProgressBar (IRBAR, -1, 0);						drawProgressCircle (ITCIRCLE, -1, 0);						drawProgressCircle (IRCIRCLE, -1, 0);						RescanOutbound ();					}				}				hang_up ();				CLEAR_INBOUND ();				CLEAR_OUTBOUND ();				mdm_hangup (NULL);							} while (0);		}	force_answer = false;	putMessage ( 0, "\p" );	return false;}Boolean haspassword ( ADDR *addrs, char **pass ){	short	i;	for (i=0; i<NodesNumber; i++)		if ((*nodesHndls[i])->Addr.zone == addrs->Zone &&			(*nodesHndls[i])->Addr.net == addrs->Net &&			(*nodesHndls[i])->Addr.node == addrs->Node &&			(*nodesHndls[i])->Addr.point == addrs->Point)		{			*pass = (*nodesHndls[i])->Session_pwd;			return true;		}	return false;}short matchaka ( ADDR *addrs ){	short	i;	for (i=0; i<NodesNumber; i++)		if ((*nodesHndls[i])->Addr.zone == addrs->Zone &&			(*nodesHndls[i])->Addr.net == addrs->Net &&			(*nodesHndls[i])->Addr.node == addrs->Node &&			(*nodesHndls[i])->Addr.point == addrs->Point)		{			return (*nodesHndls[i])->yourAka;		}	return -1;}short getlinkinx ( ADDR *addrs ){	short	i;	for (i=0; i<NodesNumber; i++)		if ((*nodesHndls[i])->Addr.zone == addrs->Zone &&			(*nodesHndls[i])->Addr.net == addrs->Net &&			(*nodesHndls[i])->Addr.node == addrs->Node &&			(*nodesHndls[i])->Addr.point == addrs->Point)		{			return i;		}	return -1;}static	tsend	zer;tsend *calcoutbound (ADDR *addr){	in_outboundPtr	over = outbound;	while (over)	{		if ( over->calladdr.zone == addr->Zone &&			 over->calladdr.net == addr->Net &&			 over->calladdr.node == addr->Node &&			 over->calladdr.point == addr->Point )			return &over->tobesend;				over = over->next;	}		zer.pkt = 0;	zer.other = 0;		return &zer;}