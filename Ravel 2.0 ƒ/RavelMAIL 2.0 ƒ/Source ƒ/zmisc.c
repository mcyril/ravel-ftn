#include <Sound.h>#include <string.h>#include <stdio.h>#include "zmodem.h"#include "Comm.h"#include "Timing.h"#include "aglcrc.h"//#include "externs.h"#include "pmain.h"#include "zm.h"#include "myEnv.h"#include "janus_chat.h"#include "log.h"extern unsigned long cr3tab[];extern unsigned short crctab[];extern char Rxhdr[4];					/* Received header           */extern char Txhdr[4];					/* Transmitted header        */extern long Rxpos;			/* Received file position                       */extern int Txfcs32;			/* TRUE means send binary frames with 32 bit FCS*/extern int Crc32t;			/* Display flag indicating 32 bit CRC being sent*/extern int Crc32;			/* Display flag indicating 32 bit CRC being rcvd*/extern int Znulls;			/* # of nulls to send at beginning of ZDATA hdr */extern int Rxtimeout;		/* Tenths of seconds to wait for something      */extern int Rxframeind;		/* ZBIN ZBIN32,ZHEX type of frame received      */extern	short		tmail_chat;extern	long		joho;extern	Boolean		Aborted;extern	short		delaing;//extern struct baud_str cur_baud;	/* Current baud rate   */extern unsigned long	cur_baud;	/* Current baud rate   */static short Rxtype;				/* Type of header received                 */static char hex[] = "0123456789abcdef";/* Send a byte as two hex digits */#define Z_PUTHEX(i,c) {i=(c);SENDBYTE(hex[((i)&0xF0)>>4], z_slice);SENDBYTE(hex[(i)&0xF], z_slice);}/*--------------------------------------------------------------------------*//* Private routines                                                         *//*--------------------------------------------------------------------------*/static short  _Z_GetBinaryHeader (unsigned char *);static short  _Z_32GetBinaryHeader (unsigned char *);static short  _Z_GetHexHeader (unsigned char *);static short  _Z_GetHex (void);static short  _Z_TimedRead (void);static long  _Z_PullLongFromHeader (unsigned char *);extern	short		tmail_chat;static	unsigned char	chattxstate;	/* chat state										*/#define	CHAT_TIMEOUT	30L#define CHATLEN			256#define	local_win		1#define	remote_win		2void	win_putc (short win, short c);void	dispose_chat_window (short win);void	win_puts (short win, unsigned char *s);static	Boolean			warned;static	Boolean			nobell = false;static	Boolean			InitedChat = false;/*---------------------------------------------------------------------------*/static char		*chatstart = "\x5\x5\x5\r * Chat mode start\r\n";static char		*chatend   = "\007\007\r\n * Chat mode end\r\n";static char		*chattime  = "\007\007\r\n * Chat mode end - timeout\r\n";static long		chattimer, lasttimer;static	unsigned char	chatbuf1[CHATLEN + 5],						chatbuf2[CHATLEN + 5],						*curbuf,						inchatbuf[CHATLEN + 5],						*chattxbuf;static short			inchatfill = 0, chatfill = 0;			//¥ ZERRRRO!static void loc_puts (char *s){	win_puts (local_win, (unsigned char *) s);}/*---------------------------------------------------------------------------*/void z_devinit (Boolean start){	InitedChat = false;	if (start)	{		chatfill  = 0;		inchatfill = 0;		lasttimer = 0L;		chattxstate = CHAT_DONE;		curbuf = chatbuf1;		warned = false;		if ((joho & CANBINKCHAT) && tmail_chat)		{			lasttimer = 0L;			chattimer = -1L;			loc_puts (" *** Press DEL to start/end chat mode\r\n");		}		else		{			lasttimer = -2L;			chattimer = -2L;		}	}	else	{		dispose_chat_window (1);		dispose_chat_window (2);	}}/*void z_chatstart (void){	if (!InitedChat)	{		InitedChat = true;		chattimer = 0L;	}}*/static Boolean z_devfree (void){	if (chattxstate || !tmail_chat)		return (false);						/* busy or not allowed       */	else		return (true);						/* allowed to send a new pkt */}static Boolean z_devsend (char *dev, unsigned char *data, unsigned short len){//	char		*p, c;			if (!dev || !data || !len || !z_devfree ())		return (false);	chattxbuf = (unsigned char *)data;	chattxbuf[(len > CHATLEN) ? CHATLEN : len] = 0;	putlog ('~', "[z_devsend]CHT1>> %s", chattxbuf);		chattxstate = CHAT_DATA;	return (true);}void z_devsend_c (Boolean buffering){	char	c, *p;		if (chattxstate)	{		putlog ('~', "[z_devsend_c]CHT2>> %s", chattxbuf);		p = (char *) chattxbuf;				while (c = *p)		{			switch (*p)			{			case ZPAD: c = 248; break;//			case 0x0A: c = 13; break;			}						if (buffering)				BUFFER_BYTE ((unsigned char) c, z_slice);			else				SENDBYTE ((unsigned char) c, z_slice);						p++;		}		chattxstate = CHAT_DONE;	}//	SENDBYTE ((unsigned char) 0, z_slice);}void z_devrecv_c (char c, Boolean flushed){	char		*p;		if (!InitedChat)	{		if (c == 5)		{			putlog ('~',"Chat Inited via input sequention.");			InitedChat = true;			p = " * Hello there! Bell me if I'm away...\n";			z_devsend ("CON",(unsigned char *) p,(short) strlen(p));		}	}	else	{		inchatbuf[inchatfill++] = c;		putlog ('~', "[z_devrecv_c]CHT << %c", c);		if (c)		{			if (inchatfill > 255 || flushed)			{				inchatbuf[inchatfill] = 0;				goto flush;			}		}		else		{		flush:						if (*inchatbuf)			{				p = (char *) inchatbuf;								while (*p)				{					switch (*p)					{					case 248: *p = ZPAD; break;					case 0x0D: *p = 10; break;					}										p++;				}								chattimer = LMGetTicks() + 60L*CHAT_TIMEOUT;				win_puts (remote_win, (unsigned char *) inchatbuf);			}			inchatfill = 0;		}	}}short z_keyabort (void){	Boolean			esc = false;	char			*p;	unsigned short	c;	EventRecord		event;	short			_delaing;	Boolean			tod;	if (Aborted)		return true;	if (chattimer > 0L)	{//		if (LMGetTicks() > chattimer)//		{//			chattimer = lasttimer = 0L;//			z_devsend("CON",(unsigned char *) chattime,strlen(chattime));//			loc_puts(&chattime[2]);//		}//		else//			if ((LMGetTicks() + 10L*60L) > chattimer && !warned)//			{//				loc_puts ("\007\r\n * Warning: chat mode timeout in 10 seconds\r\n");				warned = true;//			}	}	else		if (chattimer != lasttimer)		{			if (chattimer ==  0L)			{//				if (nobell) p = "\x5\x5\x5 * Remote has chat facility with bell disabled\n";//				else        p = "\x5\x5\x5 * Remote has chat facility with bell enabled\n";//				//				p = "\x5\x5\x5 * Hello there! Chat mode on...\n";//				z_devsend ("CON",(unsigned char *) p,(short) strlen(p));//				loc_puts (" * ZModem session in progress, chat facility now available\r\n");			}			else				if (chattimer == -1L)				{//					loc_puts(" * ZModem session in init state, can't chat yet\r\n");//					loc_puts (" * ZModem session in progress, chat facility now available\r\n");					chattimer = 0;				}				else					if (chattimer == -2L)						loc_puts(" * Remote has no chat facility available (DEL - hide window)\r\n");					else						if (chattimer == -3L)						{							if (lasttimer > 0L)								loc_puts("\r\n");					//							loc_puts(" * ZModem session in exit state, can't chat anymore\r\n");						}									lasttimer = chattimer;		}	tod = WaitNextEvent (everyEvent, &event, gSleepTime, NULL);		if (!tod || (event.what != keyDown && event.what != autoKey))	{		_delaing = delaing;		delaing = 1;		DoEvent (&event);		delaing = _delaing;		tod = false;	}		if (Aborted)			//	made by ESC pressed	{		putMessage ( 0, "\pAbortedÉ" );		Aborted = true;		esc = true;	/* Cancel by button */		tod = false;	}		if (tod && tmail_chat)	{		do		{			if ((event.modifiers & (cmdKey | optionKey | controlKey)) == controlKey)			{				switch (event.message & keyCodeMask)				{				case 0x0800:		//	Ctrl-C									c = 0x7F;		//	Map to DEL					break;								case 0x0500:		//	Ctrl-G									c = 0x05;		//	Map to Help					break;								default:									c = event.message & charCodeMask;					break;				}			}			else				c = event.message & charCodeMask;						switch (c)			{			case 0x1B:				putMessage ( 0, "\pAbortedÉ" );				Aborted = true;				esc = true;				break;			case 0x7F:			//	Alt_C:				if (chattimer == 0L)				{					putlog ('~', "User activated chat local.");					if (InitedChat)						p = " * Hello there! Chat mode on...\n";					else						p = "\x5\x5\x5 * Hello there! Chat mode on...\n";					InitedChat = true;					z_devsend ("CON",(unsigned char *) p,(short) strlen(p));					loc_puts(&p[3]);					chattimer = lasttimer = LMGetTicks() + 60L*CHAT_TIMEOUT;				}				else					if (chattimer > 0L)					{						putlog ('~', "User deactivated chat local.");						chattimer = lasttimer = 0L;						z_devsend("CON",(unsigned char *) chatend,strlen(chatend));						loc_puts(&chatend[2]);												dispose_chat_window (1);						dispose_chat_window (2);					}					else						if (chattimer <= -2)						{							dispose_chat_window (1);							dispose_chat_window (2);						}						else							SysBeep (10);				break;						default:				//			if (c < ' ' || c > 126)								if (c == 5)					c = 7;				else					if (c < ' ')						break;			case 13:			case 7:			case 8:				if (chattimer <= 0L)					break;				chattimer = LMGetTicks() + 60L*CHAT_TIMEOUT;				warned = false;				if (chatfill >= CHATLEN)					SysBeep (10);				else				{					switch (c)					{					case 13:						curbuf[chatfill++] = 10;						win_putc (local_win, 10);						break;					case 8:						if (chatfill > 0 && curbuf[chatfill - 1] != 10)							chatfill--;						else						{							curbuf[chatfill++] = '\x8';							curbuf[chatfill++] = ' ';							curbuf[chatfill++] = '\x8';						}						win_putc (local_win, 8);									break;					default:						curbuf[chatfill++] = (unsigned char) c;						if (c != 7)							win_putc (local_win, c);						else							SysBeep (10);													break;					}				}						break;			}			if (!WaitNextEvent (everyEvent, &event, gSleepTime, NULL))				break;		} while (!esc && (event.what == keyDown || event.what == autoKey));		_delaing = delaing;		delaing = 1;		DoEvent (&event);		delaing = _delaing;	}	if (chatfill > 0 && z_devsend ("CON",curbuf,chatfill))	{		curbuf = (curbuf == chatbuf1) ? chatbuf2 : chatbuf1;		chatfill = 0;//		if (sequence >= 0 && sequence == lastsequence)//			sequence++;	}		return (esc);}/*keyabort()*/void z_slice (void){	z_keyabort ();}/*--------------------------------------------------------------------------*//* Z GET BYTE                                                               *//* Get a byte from the modem;                                               *//* return TIMEOUT if no read within timeout tenths,                         *//* return RCDO if carrier lost                                              *//*--------------------------------------------------------------------------*/short Z_GetByte (short tenths){	long timeout;	if (PEEKBYTE () >= 0)		return (MODEM_IN ());	timeout = timerset (tenths * 10);	do	{		if (PEEKBYTE () >= 0)			return MODEM_IN ();		if (!CARRIER)			return RCDO;		if (z_keyabort ())			return -1;		z_slice ();	}	while (!timeup (timeout));	return TIMEOUT;}/*--------------------------------------------------------------------------*//* Z PUT STRING                                                             *//* Send a string to the modem, processing for \336 (sleep 1 sec)            *//* and \335 (break signal, ignored)                                         *//*--------------------------------------------------------------------------*/void Z_PutString (register unsigned char *s){	register unsigned c;	while (*s)	{		switch (c = *s++)		{		case (unsigned short) '\336':			big_pause (2);			break;		case (unsigned short) '\335':			/* Should send a break on this */			break;		default:			SENDBYTE ((unsigned char) c, z_slice);		}							/* switch */	}								/* while */	Z_UncorkTransmitter ();}									/* Z_PutString *//*--------------------------------------------------------------------------*//* Z SEND HEX HEADER                                                        *//* Send ZMODEM HEX header hdr of type type                                  *//*--------------------------------------------------------------------------*/void Z_SendHexHeader (unsigned short type, register unsigned char *hdr){	register short n;	register short i;	register unsigned short crc;	Z_UncorkTransmitter ();		/* Get our transmitter going */#ifdef DEBUG	show_debug_name ("Z_SendHexHeader");#endif	SENDBYTE (ZPAD, z_slice);	SENDBYTE (ZPAD, z_slice);	SENDBYTE (ZDLE, z_slice);	SENDBYTE (ZHEX, z_slice);	Z_PUTHEX (i, type);	Crc32t = 0;	crc = Z_UpdateCRC (type, 0);	for (n = 4; --n >= 0;)	{		Z_PUTHEX (i, (*hdr));		crc = Z_UpdateCRC (((unsigned short) (*hdr++)), crc);	}	Z_PUTHEX (i, (crc >> 8));	Z_PUTHEX (i, crc);	/* Make it printable on remote machine */	SENDBYTE ('\r', z_slice);	SENDBYTE ('\n', z_slice);	/* Uncork the remote in case a fake XOFF has stopped data flow */	if (type != ZFIN && type != ZACK)		SENDBYTE (021, z_slice);	if (!CARRIER)		CLEAR_OUTBOUND ();}								/* Z_SendHexHeader *//*--------------------------------------------------------------------------*//* Z UNCORK TRANSMITTER                                                     *//* Wait a reasonable amount of time for transmitter buffer to clear.        *//*   When it does, or when time runs out, turn XON/XOFF off then on.        *//*   This should release a transmitter stuck by line errors.                *//*--------------------------------------------------------------------------*/void Z_UncorkTransmitter (){	long t;#ifdef DEBUG	show_debug_name ("Z_UncorkTransmitter");#endif	if (!OUT_EMPTY () && CARRIER)	{		t = timerset (5 * Rxtimeout);	/* Wait for silence */		while (!timeup (t) && !OUT_EMPTY () && CARRIER)			z_slice ();				/* Give up slice while waiting  */	}//	com_kick ();}/*--------------------------------------------------------------------------*//* Z GET HEADER                                                             *//* Read a ZMODEM header to hdr, either binary or hex.                       *//*   On success, set Zmodem to 1 and return type of header.                 *//*   Otherwise return negative on error                                     *//*--------------------------------------------------------------------------*/short Z_GetHeader (unsigned char * hdr){	register short c;	unsigned long n;	short cancount;#ifdef DEBUG	show_debug_name ("Z_GetHeader");#endif//	n = (unsigned long) cur_baud.rate_value;	/* Max characters before start of frame */	n = (unsigned long) cur_baud;				/* Max characters before start of frame */		cancount = 5;Again:	if (z_keyabort ())	{		send_can ();		return ZCAN;	}	Rxframeind = Rxtype = 0;	switch (c = _Z_TimedRead ())	{	case ZPAD:	case ZPAD | 0200:		/*-----------------------------------------------*/		/* This is what we want.                         */		/*-----------------------------------------------*/#ifdef DEBUG	show_debug_name (">ZPAD");#endif		break;	case RCDO:	case TIMEOUT:#ifdef DEBUG	show_debug_name (">TO/DCD");#endif		goto Done;	case CAN:#ifdef DEBUG	show_debug_name (">CAN");#endifGotCan:		if (--cancount <= 0)		{			c = ZCAN;			goto Done;		}		switch (c = Z_GetByte (1))		{		case TIMEOUT:			goto Again;		case ZCRCW:			c = ERROR;			/* fallthrough... */		case RCDO:			goto Done;		case CAN:			if (--cancount <= 0)			{				c = ZCAN;				goto Done;			}			goto Again;		}		/* fallthrough... */	default:Agn2:#ifdef DEBUG	putlog ('~', "> %.2lx (%c)", (long)c, c);#endif		if (--n <= 0)		{//			z_log ("MSG_TXT (M_FUBAR_MSG)");			return ERROR;		}		if (c != CAN)			cancount = 5;		goto Again;	}							/* switch */	cancount = 5;Splat:	switch (c = _Z_TimedRead ())	{	case ZDLE:		/*-----------------------------------------------*/		/* This is what we want.                         */		/*-----------------------------------------------*/#ifdef DEBUG	show_debug_name (">>ZDLE");#endif		break;	case ZPAD:#ifdef DEBUG	show_debug_name (">>ZPAD");#endif		goto Splat;	case RCDO:	case TIMEOUT:#ifdef DEBUG	show_debug_name (">>TO/DCD");#endif		goto Done;	default:#ifdef DEBUG	putlog ('~', ">> %.2lx (%c)", (long)c, c);#endif		goto Agn2;	}							/* switch */	switch (c = _Z_TimedRead ())	{	case ZBIN:#ifdef DEBUG	show_debug_name (">>>ZBIN");#endif		Rxframeind = ZBIN;		Crc32 = 0;		c = _Z_GetBinaryHeader (hdr);		break;	case ZBIN32:#ifdef DEBUG	show_debug_name (">>>ZBIN32");#endif		Crc32 = Rxframeind = ZBIN32;		c = _Z_32GetBinaryHeader (hdr);		break;	case ZHEX:#ifdef DEBUG	show_debug_name (">>>ZHEX");#endif		Rxframeind = ZHEX;		Crc32 = 0;		c = _Z_GetHexHeader (hdr);		break;	case CAN:#ifdef DEBUG	show_debug_name (">>>CAN");#endif		goto GotCan;	case RCDO:	case TIMEOUT:#ifdef DEBUG	show_debug_name (">>>TO/DCD");#endif		goto Done;	default:#ifdef DEBUG	putlog ('~', ">>> %.2lx (%c)", (long)c, c);#endif		goto Agn2;	}							/* switch */	Rxpos = _Z_PullLongFromHeader (hdr);Done:	return c;}								/* Z_GetHeader *//*--------------------------------------------------------------------------*//* Z GET BINARY HEADER                                                      *//* Receive a binary style header (type and position)                        *//*--------------------------------------------------------------------------*/static short _Z_GetBinaryHeader (register unsigned char *hdr){	register short c;	register unsigned short crc;	register short n;#ifdef DEBUG	show_debug_name ("Z_GetBinaryHeader");#endif	if ((c = Z_GetZDL ()) & ~0xFF)		return c;	Rxtype = c;	crc = Z_UpdateCRC (c, 0);	for (n = 4; --n >= 0;)	{		if ((c = Z_GetZDL ()) & ~0xFF)			return c;		crc = Z_UpdateCRC (c, crc);		*hdr++ = (unsigned char) (c & 0xff);	}	if ((c = Z_GetZDL ()) & ~0xFF)		return c;	crc = Z_UpdateCRC (c, crc);	if ((c = Z_GetZDL ()) & ~0xFF)		return c;	crc = Z_UpdateCRC (c, crc);	if (crc & 0xFFFF)	{//		z_message ("MSG_TXT (M_CRC_MSG)");		return ERROR;	}	return Rxtype;}								/* _Z_GetBinaryHeader *//*--------------------------------------------------------------------------*//* Z GET BINARY HEADER with 32 bit CRC                                      *//* Receive a binary style header (type and position)                        *//*--------------------------------------------------------------------------*/static short _Z_32GetBinaryHeader (register unsigned char *hdr){	register short c;	register unsigned long crc;	register short n;#ifdef DEBUG	show_debug_name ("Z_32GetBinaryHeader");#endif	if ((c = Z_GetZDL ()) & ~0xFF)		return c;	Rxtype = c;	crc = 0xFFFFFFFF;	crc = Z_32UpdateCRC (c, crc);	for (n = 4; --n >= 0;)	{		if ((c = Z_GetZDL ()) & ~0xFF)			return c;		crc = Z_32UpdateCRC (c, crc);		*hdr++ = (unsigned char) (c & 0xff);	}	for (n = 4; --n >= 0;)	{		if ((c = Z_GetZDL ()) & ~0xFF)			return c;		crc = Z_32UpdateCRC (c, crc);	}	if (crc != 0xDEBB20E3)	{//		z_message ("MSG_TXT (M_CRC_MSG)");		return ERROR;	}	return Rxtype;}								/* _Z_32GetBinaryHeader *//*--------------------------------------------------------------------------*//* Z GET HEX HEADER                                                         *//* Receive a hex style header (type and position)                           *//*--------------------------------------------------------------------------*/static short _Z_GetHexHeader (register unsigned char *hdr){	register short c;	register unsigned short crc;	register short n;#ifdef DEBUG	show_debug_name ("Z_GetHexHeader");#endif	if ((c = _Z_GetHex ()) < 0)		return c;	Rxtype = c;	crc = Z_UpdateCRC (c, 0);	for (n = 4; --n >= 0;)	{		if ((c = _Z_GetHex ()) < 0)			return c;		crc = Z_UpdateCRC (c, crc);		*hdr++ = (unsigned char) c;	}	if ((c = _Z_GetHex ()) < 0)		return c;	crc = Z_UpdateCRC (c, crc);	if ((c = _Z_GetHex ()) < 0)		return c;	crc = Z_UpdateCRC (c, crc);	if (crc & 0xFFFF)	{//		z_message ("MSG_TXT (M_CRC_MSG)");		return ERROR;	}	if (Z_GetByte (1) == '\r')		(void) Z_GetByte (1);	/* Throw away possible cr/lf */	return Rxtype;}/*--------------------------------------------------------------------------*//* Z GET HEX                                                                *//* Decode two lower case hex digits into an 8 bit byte value                *//*--------------------------------------------------------------------------*/static short _Z_GetHex (){	register short c, n;#ifdef DEBUG	show_debug_name ("Z_GetHex");#endif	if ((n = _Z_TimedRead ()) < 0)		return n;	n -= '0';	if (n > 9)		n -= ('a' - ':');	if (n & ~0xF)		return ERROR;	if ((c = _Z_TimedRead ()) < 0)		return c;	c -= '0';	if (c > 9)		c -= ('a' - ':');	if (c & ~0xF)		return ERROR;	return ((n << 4) | c);}/*--------------------------------------------------------------------------*//* Z GET ZDL                                                                *//* Read a byte, checking for ZMODEM escape encoding                         *//* including CAN*5 which represents a quick abort                           *//*--------------------------------------------------------------------------*/short Z_GetZDL (){	register short c, rr;	if ((c = Z_GetByte (Rxtimeout)) != ZDLE)		return c;	switch (c = Z_GetByte (Rxtimeout))	{	case CAN:		return ((c = Z_GetByte (Rxtimeout)) < 0) ? c :			((c == CAN) && ((c = Z_GetByte (Rxtimeout)) < 0)) ? c :			((c == CAN) && ((c = Z_GetByte (Rxtimeout)) < 0)) ? c : (GOTCAN);	case ZCRCE:	case ZCRCG:	case ZCRCQ:	case ZCRCW:		if (tmail_chat)		{			do {							rr = Z_GetByte (Rxtimeout);				//		¥	Incoming chat's byte in rr. ASCIZ string in GAP.								z_devrecv_c (rr, false);							} while (rr);						z_devsend_c (false);		}		return (c | GOTOR);	case ZRUB0:		return 0x7F;	case ZRUB1:		return 0xFF;	default:		return (c < 0) ? c :			((c & 0x60) == 0x40) ? (c ^ 0x40) : ERROR;	}							/* switch */}								/* Z_GetZDL *//*--------------------------------------------------------------------------*//* Z TIMED READ                                                             *//* Read a character from the modem line with timeout.                       *//*  Eat parity, XON and XOFF characters.                                    *//*--------------------------------------------------------------------------*/static short _Z_TimedRead (){	register short c;#ifdef DEBUG	show_debug_name ("Z_TimedRead");#endif	for (;;)	{		if ((c = Z_GetByte (Rxtimeout)) < 0)			return c;		switch (c &= 0x7F)		{		case XON:		case XOFF:			continue;		default:			if (!(c & 0x60))				continue;			/* Else fall through */		case '\r':		case '\n':		case ZDLE:			return c;		}						/* switch */	}							/* for */}								/* _Z_TimedRead *//*--------------------------------------------------------------------------*//* Z LONG TO HEADER                                                         *//* Store long integer pos in Txhdr                                          *//*--------------------------------------------------------------------------*/void Z_PutLongIntoHeader (long pos){#ifdef FASTER	*((long *)Txhdr) = endlong (pos);#else	Txhdr[ZP0] = pos;			//	0	Txhdr[ZP1] = pos >> 8;		//	1	Txhdr[ZP2] = pos >> 16;		//	2	Txhdr[ZP3] = pos >> 24;		//	3#endif}								/* Z_PutLongIntoHeader *//*--------------------------------------------------------------------------*//* Z PULL LONG FROM HEADER                                                  *//* Recover a long integer from a header                                     *//*--------------------------------------------------------------------------*/static long _Z_PullLongFromHeader (unsigned char *hdr){#ifdef FASTER	return endlong (*((long *)hdr));#else	long l;	l = hdr[ZP3];	l = (l << 8) | hdr[ZP2];	l = (l << 8) | hdr[ZP1];	l = (l << 8) | hdr[ZP0];	return l;#endif}								/* _Z_PullLongFromHeader *//* END OF FILE: zmisc.c */