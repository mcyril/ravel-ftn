#include <stdio.h>#include <string.h>#include "Ravel_FTN.h"#include "Ravel_Prefs.h"#include "Scheduler.h"#include "Unattended.h"#include "Manual.h"//#include "Port.h"#include "log.h"#include "pmain.h"#include "key.h"#include "compatible.h"#include "stringutl.h"#include "PascalStr.h"extern short		eventsNumber;		//	¥	Events listextern eventsHndl	*eventsHndls;extern short		***evtRingsHndls;extern short		NodesNumber;		//	¥	Linked Nodes structs listextern nodePrefHndl	*nodesHndls;extern behaviorHndl	behavior;			//	¥	Unattended behaviors listextern short	gotta_mail;extern short	gotta_xmail;extern short	auto_toss;						/* auto toss sublaunch enable */extern	homeHndl	homesystem;			//	¥	Home system structextern	Str255			ShufflerPathName;//extern	Boolean			SessionActive;static	ProcessSerialNumber	launchedProcessSN;	long			current_events;	long			old_events;	long			happened_events;	#define	kRavelEventClass	'R&vl'#define	kAEEnqueueCmd		'enQu'// Search through the current process list to find the given application. See// Using the Process Manager for a similar way of doing this.static OSErr FindAProcess (OSType typeToFind, OSType creatorToFind,			ProcessSerialNumberPtr processSN){	ProcessInfoRec	tempInfo;	FSSpec	procSpec;	Str31		processName;	OSErr		myErr = noErr;	// start at the beginning of the process list	processSN->lowLongOfPSN = kNoProcess;	processSN->highLongOfPSN = 0;	// initialize the process information record	tempInfo.processInfoLength = sizeof(ProcessInfoRec);	tempInfo.processName = (StringPtr)&processName;	tempInfo.processAppSpec = &procSpec;//	while((tempInfo.processSignature != creatorToFind ||//			tempInfo.processType != typeToFind) ||//			myErr != noErr)		do {		myErr = GetNextProcess (processSN);		if (myErr == noErr)		{			GetProcessInformation(processSN, &tempInfo);			if (tempInfo.processSignature == creatorToFind &&				tempInfo.processType == typeToFind)				break;		}			} while (myErr == noErr);	return(myErr);}void doCommandForSHUFFLER (char *cmd){	FILE	*c_file;	char	fi[256];	short	i;	memcpy (fi, &ShufflerPathName[1], ShufflerPathName[0]);	fi[ShufflerPathName[0]] = 0;		for (i = strlen (fi) - 1; i >= 0; i--)		if (fi[i] == ':')			break;		else			fi[i] = 0;	strcat (fi, "Ravel.What");	if (c_file = fopen (fi, "w"))	{		fprintf (c_file, "%s\n", cmd);		fclose (c_file);	}	else		putlog (lgALRT, "Can't create/open Ravel.What file.");}void InitEvents (void){	old_events = 0L;	happened_events = 0L;	current_events = 0L;}long GotCurrentEvtMask (void){	DateTimeRec	dtr;	_times		NowIs;	short		i;	long		mask = 1L, res = 0L;			GetTime (&dtr);	NowIs.hour = dtr.hour;	NowIs.minute = dtr.minute;	for (i=0; i<eventsNumber; i++)	{		if ( inPeriod (NowIs, eventsHndls[i], dtr.dayOfWeek-1) )			res |= mask;		mask <<= 1;	}		return res;}Boolean inPeriod (_times nowis, eventsHndl events, short day){	long	now = nowis.hour * 60 + nowis.minute;	long	start = (**events)[day].Start.hour * 60 + (**events)[day].Start.minute;	long	end = (**events)[day].End.hour * 60 + (**events)[day].End.minute;		if ( end > start )	{		return ( now <= end && now >= start );	}	else		if ( end < start )		{			return ( now <= end || now >= start );		}		else			return false;}Boolean inPeriod2 (_times nowis, _period *period){	long	now = nowis.hour * 60 + nowis.minute;	long	start = period->Start.hour * 60 + period->Start.minute;	long	end = period->End.hour * 60 + period->End.minute;		if ( end > start )	{		return ( now <= end && now >= start );	}	else		if ( end < start )		{			return ( now <= end || now >= start );		}		else			return false;}//	static unsigned long	TimeDestructSec = ~0xAEEF5980L /*^ 0xFFFFFFFFL*/;Boolean CheckHappened (void){//	unsigned long	t;			old_events = current_events;	current_events = GotCurrentEvtMask ();	happened_events |= (~old_events) & current_events;#ifndef LITE#ifdef PROTECTED	if (keys.crc != keys.oldcrc)		exitAfterAll ();	if ((keys.oldcs+1+keys.cs)&0xFFFF)		exitAfterAll ();	pStrCopy (keys.regName, (*homesystem)->sysop);#endif#endif	return happened_events != 0;}char *printEvent (long mask, char *tmp){	short		i;	DateTimeRec	dtr;			GetTime (&dtr);	tmp[0] = 0;	if (!mask)	{		return tmp;	}	for ( i=0; i<32; i++ )	{		if (mask & (1L<<i))		{			sprintf ( tmp, "%.2d:%.2d - %.2d:%.2d",					(**(eventsHndls[i]))[dtr.dayOfWeek-1].Start.hour,					(**(eventsHndls[i]))[dtr.dayOfWeek-1].Start.minute,					(**(eventsHndls[i]))[dtr.dayOfWeek-1].End.hour,					(**(eventsHndls[i]))[dtr.dayOfWeek-1].End.minute );			break;		}	}	return tmp;}Boolean CheckEventNow ( long evt_mask ){	return (evt_mask & current_events) != 0;}short GetRingsNumber (long evt_mask){	long	mask = evt_mask & current_events;	long	one = 1L;	short	i;			for (i=0; i<eventsNumber; i++)	{		if ((mask & one) != 0 && evtRingsHndls[i] != NULL)			return **(evtRingsHndls[i]);		one <<= 1;	}	return 1;}Boolean CheckTimesNow ( _period *times ){	DateTimeRec		dtr;	_times			NowIs;	unsigned long	res = 0L;		//	GetDateTime (&res);//	res -= 60L * 60L * (long) timezone;//	Secs2Date ( res, &dtr );		GetTime (&dtr);	NowIs.hour = dtr.hour;	NowIs.minute = dtr.minute;	return inPeriod2 (NowIs, times);}Boolean Misbehave (){	ProcessInfoRecPtr	ProcessInfo;	Boolean				res;	register short		iErr;	//	make here background working about sublaunching, bbs, etc.	//	putlog ( lgATTN, "+ MISBEHAVE" );	ProcessInfo = (ProcessInfoRecPtr) NewPtr (sizeof(ProcessInfoRec));	ProcessInfo->processInfoLength = sizeof(ProcessInfoRec);	ProcessInfo->processName = NULL;	ProcessInfo->processAppSpec = NULL;		iErr = GetProcessInformation ( &launchedProcessSN, ProcessInfo );		res = ( iErr != noErr );		DisposePtr ( (Ptr) ProcessInfo );	if (res)	{		putlog (lgNOPE, "Resume RavelMAIL");		RescanOutbound ();	}		return res;		//	TRUE - mean rise EventsPossible when done					//	FALSE - not done yet}Boolean	letsMisbehave (void){	long		i, j;	Boolean		res = TRUE;	char		ttt[128];//	check here about received packages from foreign link	if ( (gotta_mail || gotta_xmail) && auto_toss )	{		doCommandForSHUFFLER ( "TOSS" );			if ( ApplicationLaunch (ShufflerPathName) )			res = false;				gotta_xmail = gotta_mail = 0;				return res;	}	gotta_xmail = gotta_mail = 0;//	check here happened events & clear happened_events mask during processing	if (happened_events)	{//		putlog ( '@', "EVENT %.8lX STARTED", happened_events );				for ( i=0; i<32; i++ )		{			if (happened_events & (1L<<i))			{				putlog ( '@', "Event #%.2ld (%s) started.", i+1, printEvent ((1L<<i), ttt) );								for ( j=0; j<(*behavior)->countOfBehave; j++)					if ( (*behavior)->behavior[j].evtNum == i )					{						switch ( (*behavior)->behavior[j].mode )						{						case 0:					//	¥	Shutdown RavelMAIL													putlog ( '@', " Shutdown RavelMAIL." );							exitAfterAll ();							break;													case 1:					//	¥	Create poll													putlog ( '@', " Create poll @ %s", printaddr (&(*(nodesHndls[(*behavior)->behavior[j].nodeNum]))->Addr, ttt) );							AddManual ( &(*(nodesHndls[(*behavior)->behavior[j].nodeNum]))->Addr,												NULL, NULL, NULL, false,												1<<(*(nodesHndls[(*behavior)->behavior[j].nodeNum]))->Poll, 0 );							RescanOutbound ();							break;												case 2:					//	¥	Sublaunch RavelSHUFFLER													putlog ( '@', " Make %s command for RavelSHUFFLER", (*behavior)->behavior[j].cmd );							doCommandForSHUFFLER ( (*behavior)->behavior[j].cmd );														if ( ApplicationLaunch (ShufflerPathName) )								res = FALSE;							gotta_xmail = gotta_mail = 0;														break;												default:													break;						}					}			}		}				happened_events = 0L;		}		return res;				// FALSE	- means that we must drop EventsPossible							// TRUE		- means nothing happened.}Boolean ApplicationLaunch ( StringPtr ApplPathName ){	short				iErr;	LaunchParamBlockRec	myLaunchParams;	FSSpec				spec;	AppleEvent		event, reply;	AEAddressDesc	address;//	putlog ( lgATTN, "Try sublaunch %#s.", ApplPathName );	if ( iErr = FSMakeFSSpec ( 0, 0, ApplPathName, &spec ) )	{		putlog ( lgALRT, "Application %#s not found (err = %d).", ApplPathName, iErr );			return false;	}//	if ( !FindAProcess ( 'APPL', 'RvlQ', &launchedProcessSN ) )//	{//		putlog ( lgALRT, "RavelQUILL running. Try launch %#s later.", ApplPathName );	//		return false;//	}	if ( !FindAProcess ( 'APPL', 'RvlS', &launchedProcessSN ) )	{		iErr = AECreateDesc (typeProcessSerialNumber, &launchedProcessSN, sizeof(launchedProcessSN), &address);		if (iErr)		{			putlog ( lgALRT, "AECreateDesc (err = %d).", iErr );				return false;		}				iErr = AECreateAppleEvent (kRavelEventClass, kAEEnqueueCmd, &address, kAutoGenerateReturnID, kAnyTransactionID, &event);		if (iErr)		{			putlog ( lgALRT, "AECreateAppleEvent (err = %d).", iErr );				return false;		}		iErr = AESend (&event, &reply, kAENeverInteract + kAENoReply, kAENormalPriority, kAEDefaultTimeout, NULL, NULL);		if (iErr)		{			putlog ( lgALRT, "AESend (err = %d).", iErr );				return false;		}				AEDisposeDesc(&event);		AEDisposeDesc(&address);//		AEDisposeDesc(&reply);		putlog ( lgATTN, "Sending command for %#s.", ApplPathName );//		return false;	}	else	{		myLaunchParams.launchBlockID = extendedBlock;		myLaunchParams.launchEPBLength = extendedBlockLen;		myLaunchParams.launchFileFlags = 0;		myLaunchParams.launchControlFlags = launchContinue + launchNoFileFlags + launchDontSwitch;		myLaunchParams.launchAppSpec = &spec;		myLaunchParams.launchAppParameters = NULL;		iErr = LaunchApplication ( &myLaunchParams );		if (!iErr)		{			putlog ( lgATTN, "Sublaunching %#s.", ApplPathName );			launchedProcessSN = myLaunchParams.launchProcessSN;		}		else		{			putlog ( lgALRT, "Launch failed with errCode=%d.", iErr );				return FALSE;		}	}		return true;}