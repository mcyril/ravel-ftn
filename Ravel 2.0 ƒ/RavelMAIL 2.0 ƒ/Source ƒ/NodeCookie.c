#include <Sound.h>#include <stdio.h>#include <string.h>/*본본본본본본본본본본본본본본본본본본본본본본본본본본본본본본본본본본본본본본*/#include "Ravel_FTN.h"#include "Ravel_Prefs.h"#include "Scheduler.h"#include "nodelist.h"#include "Unattended.h"#include "Manual.h"#include "compatible.h"#include "stringutl.h"#include "NodeCookie.h"/*본본본본본본본본본본본본본본본본본본본본본본본본본본본본본본본본본본본본본본*/#include "Menus.h"/*본본본본본본본본본본본본본본본본본본본본본본본본본본본본본본본본본본본본본본*//*Boolean GetNodeInfo (addr *, StringPtr);Boolean GetNameFromAddr (addr *, StringPtr);Boolean GetInfoFromAddr (addr *address, StringPtr result);*/static	addr		nl_addr;static	short		nl_level;static	ListHandle	nl_list;enum {	uppAEHandlerProcInfo = kPascalStackBased		 | RESULT_SIZE(SIZE_CODE(sizeof(OSErr)))		 | STACK_ROUTINE_PARAMETER(1, SIZE_CODE(sizeof(Ptr)))		 | STACK_ROUTINE_PARAMETER(2, SIZE_CODE(sizeof(Ptr)))		 | STACK_ROUTINE_PARAMETER(3, SIZE_CODE(sizeof(long))),//	pascal Boolean myAlertProc (DialogPtr theDialog, EventRecord *theEvent, short *itemHit)	uppModalProcInfo = kPascalStackBased		 | RESULT_SIZE(SIZE_CODE(sizeof(Boolean)))		 | STACK_ROUTINE_PARAMETER(1, SIZE_CODE(sizeof(Ptr)))		 | STACK_ROUTINE_PARAMETER(2, SIZE_CODE(sizeof(Ptr)))		 | STACK_ROUTINE_PARAMETER(3, SIZE_CODE(sizeof(Ptr))),};pascal void LDEFNodes (short lMessage, Boolean lSelect, Rect *lRect, Cell lCell,				short lDataOffset, short lDataLen, ListHandle lHandle);//	#define cLeftOffset		5pascal void LDEFNodes (short lMessage, Boolean lSelect, Rect *lRect, Cell lCell,				short lDataOffset, short lDataLen, ListHandle lHandle){#pragma unused (lCell)	short 		leftDraw, topDraw;	FontInfo 	fi;	short		i;	Str255		temp;	Point		drawpt;	addr		ads;	short		uuu, zzz;		unsigned char	oldMode;	PenState	penState;			if ((lMessage == lInitMsg) || (lMessage == lCloseMsg))		return;		leftDraw = lRect->left+(*lHandle)->indent.h;	topDraw = lRect->top+(*lHandle)->indent.v;		switch (lMessage)	{	case lDrawMsg:			SetPort ((*lHandle)->port);		EraseRect (lRect);			if (lDataLen == 2)		{			GetFontInfo (&fi);			SetPt ( &drawpt, leftDraw + 5, topDraw+fi.leading+fi.ascent );			memcpy ( (Ptr) &i, *((*lHandle)->cells)+lDataOffset, 2 );						MoveTo ( drawpt.h + 6*0, drawpt.v );			NumToString (i, temp);			DrawString (temp);						ads = nl_addr;						switch (nl_level)			{			case 0:	ads.zone = 0;			case 1:	ads.net = 0;			case 2:	ads.node = 0;			case 3:	ads.point = 0;			}			switch (nl_level)			{			case 0:	ads.zone = i;	break;			case 1:	ads.net = i;	break;			case 2:	ads.node = i;	break;			case 3:	ads.point = i;	break;			}			if (nl_level != 3 &&				hasSequence (nl_level, &ads))			{				MoveTo ( drawpt.h + 6*5, drawpt.v );				DrawChar ( '>' );			}			//			GetNameFromAddr ( &ads, temp );			GetInfoFromAddr ( &ads, temp );			for (uuu = 1; uuu <= temp[0]; uuu++)				if (temp[uuu] == ',')					break;						MoveTo ( drawpt.h + 6*6, drawpt.v );						if (uuu-1 <= 28)				DrawText (&temp[1], 0, uuu-1 );			else			{				DrawText (&temp[1], 0, 25 );				DrawString ( "\p..." );			}			for (zzz = ++uuu; uuu <= temp[0]; uuu++)				if (temp[uuu] == ',')					break;						MoveTo ( drawpt.h + 6*35, drawpt.v );						if (uuu-zzz <= 17)				DrawText (&temp[1], zzz-1, uuu-zzz );			else			{				DrawText (&temp[1], zzz-1, 14 );				DrawString ( "\p..." );			}						for (zzz = ++uuu; uuu <= temp[0]; uuu++)				if (temp[uuu] == ',')					break;						MoveTo ( drawpt.h + 6*53, drawpt.v );			if (uuu-zzz <= 27)				DrawText (&temp[1], zzz-1, uuu-zzz );			else			{				DrawText (&temp[1], zzz-1, 24 );				DrawString ( "\p..." );			}			MoveTo ( drawpt.h + 6*6 + 1, drawpt.v + 1 );			LineTo ( drawpt.h + 6*6 + 1, topDraw );				MoveTo ( drawpt.h + 6*34 + 2, drawpt.v + 1 );			LineTo ( drawpt.h + 6*34 + 2, topDraw );				MoveTo ( drawpt.h + 6*52 + 2, drawpt.v + 1 );			LineTo ( drawpt.h + 6*52 + 2, topDraw );		}				if (!lSelect)			break;		case lHiliteMsg:			oldMode = LMGetHiliteMode();		LMSetHiliteMode(1);		if (((WindowPeek)(*lHandle)->port)->hilited)			InvertRect (lRect);		else		{			GetPenState (&penState);			PenMode (srcXor);			FrameRect (lRect);			SetPenState (&penState);		}		LMSetHiliteMode(oldMode);				break;	}}static pascal Boolean myProc ( DialogPtr theDialog, EventRecord *theEvent, short *itemHit ){#pragma unused (theDialog)	Boolean 	result = false;	switch (theEvent->what)	{	case mouseDown:				result = false;		break;		case keyDown:	case autoKey:			*itemHit = 1;		result = true;		break;	}	return result;}void WhoIs (in_outboundPtr who){	DialogPtr	info;	char		sTemp[512];	short		iHit, iType;	Handle		iHandle;	Rect		iRect;	GrafPtr		oldPort;	#if defined(powerc) || defined(__powerc)	UniversalProcPtr	uupMyFilterProc;	uupMyFilterProc = NewRoutineDescriptor ((ProcPtr) myProc, uppModalProcInfo, GetCurrentISA ());#endif		GetPort (&oldPort);		if (GetNodeInfo (&who->calladdr, (StringPtr) sTemp))	{		info = GetNewDialog (300, NULL, (WindowPtr) -1L);		SetPort (info);				GetDialogItem (info, 1, &iType, &iHandle, &iRect);				sTemp[sTemp[0]+1] = 0x0D;		sTemp[sTemp[0]+2] = 0x00;				iType = strlen (&sTemp[1]) + 1;				if (who->evt_mask)		{			char	t[64];			sprintf ( &sTemp[iType], "* %s *", printEvent (who->evt_mask, t) );		}		else			if (who->nodelist_time.Start.hour || who->nodelist_time.End.hour ||				who->nodelist_time.Start.minute || who->nodelist_time.End.minute)			{				sprintf ( &sTemp[iType], "%.2d:%.2d - %.2d:%.2d", 										(short) who->nodelist_time.Start.hour,										(short) who->nodelist_time.Start.minute,										(short) who->nodelist_time.End.hour,										(short) who->nodelist_time.End.minute );			}				InsetRect (&iRect, 0, 15);		TETextBox (&sTemp[1], strlen (&sTemp[1]), &iRect, teJustCenter);				do {			#if defined(powerc) || defined(__powerc)			ModalDialog (uupMyFilterProc, &iHit);#else			ModalDialog (myProc, &iHit);#endif		} while (iHit != 1);			DisposeDialog (info);	}	else		SysBeep (10);	SetPort (oldPort);#if defined(powerc) || defined(__powerc)	DisposeRoutineDescriptor (uupMyFilterProc);#endif}static void DrawNodeList (void){	short	i, j;//	Str15	temp;	Cell	theCell;		for (i=0; ; i++)	{		switch (nl_level)		{		case 0:			//	zone					j = ZoneByIndex (i);			break;				case 1:			//	net						j = NetByIndex (i, &nl_addr);			break;		case 2:						j = NodeByIndex (i, &nl_addr);			break;				case 3:					j = PointByIndex (i, &nl_addr);			break;		}			if (j == -1)			break;	//		temp[0] = 2;	//		temp[1] = (j >> 8)  & 0xFF;//		temp[2] = (j)       & 0xFF;				LAddRow ( 1, 0x7FFF, nl_list );		SetPt ( &theCell, 0, i );		LSetCell (&j, sizeof (short), theCell, nl_list);	}}static void DrawContents (DialogPtr dialog){	char	ttt[128];	Str255	sTemp;	short	iType;	Handle	iHandle;	Rect	iRect;			GetDialogItem (dialog, 1, &iType, &iHandle, &iRect);		iRect.bottom = iRect.top - 1;	iRect.top = 0;		EraseRect (&iRect);		if ((*nl_list)->dataBounds.bottom == 0)		return;		MoveTo (5, 15);	TextFace (bold);		printaddr (&nl_addr, ttt);	GetInfoFromAddr (&nl_addr, sTemp);	sTemp[sTemp[0]] = 0;	strcat (ttt, (char *) &sTemp[1]);	DrawText (ttt, 0, strlen (ttt));	TextFace (0);}static pascal Boolean myNodeProc ( DialogPtr theDialog, EventRecord *theEvent, short *itemHit ){	Boolean 	result = false;	Cell		theCell;	short		newh, newc, neww, key, dummy;	short		iType;	Handle		iHandle;	Rect		rView;	in_outboundType	iot;		switch (theEvent->what)	{	case mouseDown:				{			Point		localWhere = theEvent->where;			GrafPtr		savePort;			short		pump;						GetPort (&savePort);			SetPort (theDialog);			GlobalToLocal (&localWhere);					pump = FindDialogItem (theDialog, localWhere);						if (pump == 0)	// 1 is list pump!			{				result = LClick (localWhere, theEvent->modifiers, nl_list);				SetPt (&theCell, 0, 0);							if ( LGetSelect (true, &theCell, nl_list) )				{					switch (nl_level)					{					case 0:	nl_addr.zone = 0;					case 1:	nl_addr.net = 0;					case 2:	nl_addr.node = 0;					case 3:	nl_addr.point = 0;					}								switch (nl_level)					{					case 0:	nl_addr.zone = ZoneByIndex (theCell.v);				break;					case 1:	nl_addr.net = NetByIndex (theCell.v, &nl_addr);		break;					case 2:	nl_addr.node = NodeByIndex (theCell.v, &nl_addr);	break;					case 3:	nl_addr.point = PointByIndex (theCell.v, &nl_addr);	break;					}				}				DrawContents (theDialog);				*itemHit = 1;			}			else				result = false;						SetPort (savePort);		}		break;		case keyDown:	case autoKey:			switch (key = ((theEvent->message & keyCodeMask) >> 8))		{		case 0x35:		//	ESC					*itemHit = 3;			result = true;			break;				case 0x72:						iot.evt_mask = 0;			iot.nodelist_time.Start.hour = 0;			iot.nodelist_time.Start.minute = 0;			iot.nodelist_time.End.hour = 0;			iot.nodelist_time.End.minute = 0;			iot.calladdr = nl_addr;			WhoIs (&iot);			LUpdate (theDialog->visRgn, nl_list);			break;				case 0x24:		case 0x4C:		//	Enters					*itemHit = 2;			result = true;			break;					case 0x7B:		//	Left					if (nl_level == 0)			{				SysBeep (10);				break;			}						switch (nl_level)			{			case 0:	nl_addr.zone = 0;			case 1:	nl_addr.net = 0;			case 2:	nl_addr.node = 0;			case 3:	nl_addr.point = 0;			}						nl_level--;						LDelRow (0, 0, nl_list);						LSetDrawingMode ( false, nl_list );						DrawNodeList ();						SetPt (&theCell, 0, gotline (nl_level, &nl_addr));						LSetSelect (true, theCell, nl_list);			LAutoScroll (nl_list);			LSetDrawingMode ( true, nl_list );						LUpdate (theDialog->visRgn, nl_list);						DrawContents (theDialog);			break;					case 0x7C:		//	Right					if (nl_level == 3 || !hasSequence (nl_level, &nl_addr))			{				SysBeep (10);				break;			}						nl_level++;						LDelRow (0, 0, nl_list);						LSetDrawingMode ( false, nl_list );			DrawNodeList ();			LSetDrawingMode ( true, nl_list );					switch (nl_level)			{			case 0:	nl_addr.zone = ZoneByIndex (0);				break;			case 1:	nl_addr.net = NetByIndex (0, &nl_addr);		break;			case 2:	nl_addr.node = NodeByIndex (0, &nl_addr);	break;			case 3:	nl_addr.point = PointByIndex (0, &nl_addr);	break;			}						SetPt (&theCell, 0, 0);			LSetSelect (true, theCell, nl_list);			LUpdate (theDialog->visRgn, nl_list);						DrawContents (theDialog);			break;					case 0x7E:		//	Up		case 0x7D:		//	Down					newh = (*(nl_list))->dataBounds.bottom;					SetPt (&theCell, 0, 0);					if ( LGetSelect (true, &theCell, nl_list) )				newc = theCell.v;			else				newc = (key == 0x7E) ? newh : -1;						neww = (key == 0x7E) ? newc - 1 : newc + 1;						if (neww >= newh)				neww = 0;			else				if (neww < 0)					neww = newh - 1;						SetPt (&theCell, 0, newc);			LSetSelect (false, theCell, nl_list);						SetPt (&theCell, 0, neww);			LSetSelect (true, theCell, nl_list);						LAutoScroll (nl_list);						switch (nl_level)			{			case 0:	nl_addr.zone = 0;			case 1:	nl_addr.net = 0;			case 2:	nl_addr.node = 0;			case 3:	nl_addr.point = 0;			}				switch (nl_level)			{			case 0:	nl_addr.zone =						ZoneByIndex (theCell.v);					break;								case 1:	nl_addr.net =						NetByIndex (theCell.v, &nl_addr);					break;								case 2:	nl_addr.node =						NodeByIndex (theCell.v, &nl_addr);					break;								case 3:	nl_addr.point =						PointByIndex (theCell.v, &nl_addr);					break;			}						DrawContents (theDialog);			break;		case 0x74:		//	PgUp		case 0x79:		//	PgDn					GetDialogItem ( theDialog, 1, &iType, &iHandle, &rView );			dummy = (theDialog->portRect.bottom - rView.top) / (*(nl_list))->cellSize.v;			newh = (*(nl_list))->dataBounds.bottom;			if (dummy < newh)			{				SetPt (&theCell, 0, 0);							if ( LGetSelect (true, &theCell, nl_list) )				{					newc = theCell.v;										neww = (key == 0x74) ? newc - dummy : newc + dummy;										if (neww >= newh)						neww = newh - 1;					else						if (neww < 0)							neww = 0;										SetPt (&theCell, 0, newc);					LSetSelect (false, theCell, nl_list);										SetPt (&theCell, 0, neww);					LSetSelect (true, theCell, nl_list);					LAutoScroll (nl_list);				}			}			else			{				SetPt (&theCell, 0, 0);							if ( LGetSelect (true, &theCell, nl_list) )				{					newc = theCell.v;										neww = (key == 0x74) ? 0 : newh - 1;										SetPt (&theCell, 0, newc);					LSetSelect (false, theCell, nl_list);										SetPt (&theCell, 0, neww);					LSetSelect (true, theCell, nl_list);					LAutoScroll (nl_list);				}			}						switch (nl_level)			{			case 0:	nl_addr.zone = 0;			case 1:	nl_addr.net = 0;			case 2:	nl_addr.node = 0;			case 3:	nl_addr.point = 0;			}				switch (nl_level)			{			case 0:	nl_addr.zone =						ZoneByIndex (theCell.v);					break;								case 1:	nl_addr.net =						NetByIndex (theCell.v, &nl_addr);					break;								case 2:	nl_addr.node =						NodeByIndex (theCell.v, &nl_addr);					break;								case 3:	nl_addr.point =						PointByIndex (theCell.v, &nl_addr);					break;			}						DrawContents (theDialog);			break;		case 0x73:		//	Home					SetPt (&theCell, 0, 0);					if ( LGetSelect (true, &theCell, nl_list) )			{				newc = theCell.v;				SetPt (&theCell, 0, newc);				LSetSelect (false, theCell, nl_list);			}			SetPt (&theCell, 0, 0);			LSetSelect (true, theCell, nl_list);			LAutoScroll (nl_list);			switch (nl_level)			{			case 0:	nl_addr.zone = 0;			case 1:	nl_addr.net = 0;			case 2:	nl_addr.node = 0;			case 3:	nl_addr.point = 0;			}				switch (nl_level)			{			case 0:	nl_addr.zone =						ZoneByIndex (theCell.v);					break;								case 1:	nl_addr.net =						NetByIndex (theCell.v, &nl_addr);					break;								case 2:	nl_addr.node =						NodeByIndex (theCell.v, &nl_addr);					break;								case 3:	nl_addr.point =						PointByIndex (theCell.v, &nl_addr);					break;			}						DrawContents (theDialog);			break;		case 0x77:		//	End					newh = (*(nl_list))->dataBounds.bottom;			SetPt (&theCell, 0, 0);					if ( LGetSelect (true, &theCell, nl_list) )			{				newc = theCell.v;				SetPt (&theCell, 0, newc);				LSetSelect (false, theCell, nl_list);			}			SetPt (&theCell, 0, newh-1);			LSetSelect (true, theCell, nl_list);			LAutoScroll (nl_list);			switch (nl_level)			{			case 0:	nl_addr.zone = 0;			case 1:	nl_addr.net = 0;			case 2:	nl_addr.node = 0;			case 3:	nl_addr.point = 0;			}				switch (nl_level)			{			case 0:	nl_addr.zone =						ZoneByIndex (theCell.v);					break;								case 1:	nl_addr.net =						NetByIndex (theCell.v, &nl_addr);					break;								case 2:	nl_addr.node =						NodeByIndex (theCell.v, &nl_addr);					break;								case 3:	nl_addr.point =						PointByIndex (theCell.v, &nl_addr);					break;			}						DrawContents (theDialog);			break;		default:			result = false;			break;		}				break;	}	return result;}Boolean NodeBrowse (addr *result){	DialogPtr	info;	short		iHit, iType;	Handle		iHandle;	GrafPtr		oldPort;		Rect		rView, rDataBnds;	Cell		cellSize;		long		nm;	short		ii;		#if defined(powerc) || defined(__powerc)	UniversalProcPtr	uupLDEFNodesProc;		UniversalProcPtr	uupMyFilterProc;	uupMyFilterProc = NewRoutineDescriptor ((ProcPtr) myNodeProc, uppModalProcInfo, GetCurrentISA ());#endif			GetPort (&oldPort);		iHandle = Get1Resource ('LDEF', 128);#if defined(powerc) || defined(__powerc)	uupLDEFNodesProc = NewRoutineDescriptor ((ProcPtr) LDEFNodes, uppListDefProcInfo, GetCurrentISA ());	*((long *)((*iHandle)+2)) = (long) uupLDEFNodesProc;#else	*((long *)((*iHandle)+2)) = (long) LDEFNodes;#endif		info = GetNewDialog (400, NULL, (WindowPtr) -1L);	SetPort (info);		TextFont ( 4 );	TextSize ( 9 );	GetDialogItem ( info, 1, &iType, &iHandle, &rView );	SetRect ( &rDataBnds, 0, 0, 1, 0 );	rView.right -= 15;	SetPt ( &cellSize, 0, 0 );	nl_list = LNew (					&rView,					&rDataBnds,					cellSize,					128,					info,					true,					false,					false,					true				);	(*nl_list)->selFlags = 0x82;	(*nl_list)->port->txFont = 4;	(*nl_list)->port->txSize = 9;//	MoveTo (rView.left, rView.top-1);//	LineTo (rView.right, rView.top-1);	InsetRect (&rView, -1, -1);	FrameRect (&rView);	if (result)	{		nl_addr = *result;		if (nl_addr.point)			nl_level = 3;		else			if (nl_addr.node)				nl_level = 2;			else				if (nl_addr.net)					nl_level = 1;				else					nl_level = 0;		for (nm = 0; nm <= nl_level; nm++)		{			ii = gotline (nm, &nl_addr);						if (ii < 0)				break;		}				if (nm > 0)		{			nl_level = nm - 1;			ii = gotline (nl_level, &nl_addr);			switch (nl_level)			{			case 0:	nl_addr.net = 0;			case 1:	nl_addr.node = 0;			case 2:	nl_addr.point = 0;			}		}		else			ii = -1;	}	else		ii = -1;		if (ii < 0)	{		ii = 0;		nl_level = 0;		nl_addr.zone = ZoneByIndex (0);		nl_addr.net = 0;		nl_addr.node = 0;		nl_addr.point = 0;	}	LActivate ( true, nl_list );	LSetDrawingMode ( false, nl_list );	DrawNodeList ();		SetPt (&cellSize, 0, ii);	LSetSelect (true, cellSize, nl_list);	LAutoScroll (nl_list);	LSetDrawingMode ( true, nl_list );	LUpdate (info->visRgn, nl_list);	DrawContents (info);	do {		#if defined(powerc) || defined(__powerc)		ModalDialog (uupMyFilterProc, &iHit);#else		ModalDialog (myNodeProc, &iHit);#endif	} while (iHit != 2 && iHit != 3);	LDispose (nl_list);	DisposeDialog (info);	SetPort (oldPort);	if (result)		*result = nl_addr;	#if defined(powerc) || defined(__powerc)	DisposeRoutineDescriptor (uupLDEFNodesProc);	DisposeRoutineDescriptor (uupMyFilterProc);#endif	return (iHit == 2);}