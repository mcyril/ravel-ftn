#include <string.h>#include "PascalStr.h"#include "Ravel_FTN.h"#include "Ravel_Prefs.h"#include "compatible.h"#include "stringutl.h"#include "Scheduler.h"#include "history.h"#include "nodelist.h"#include "Modem.h"extern	Boolean			multiline_flag;extern	short			multiline_line;extern	DialogPtr		RavelWindow;extern	ListHandle		IHSList, OHSList;extern		Str255		modem_diagnosis;static	p_hist_rec	history, c_history;void	put_nodeinfo (StringPtr info);void history_init (void){	p_hist_rec	curr;	hist_rec	temp;	short		i, hRefNum;	Cell		theCell;	long		counter;	Str255		mailername;		history = NULL;	c_history = NULL;#ifndef LITE	if (multiline_flag)	{		pStrCopy ("\pRavelMAIL.hst/Line #0", mailername);		mailername[mailername[0]] += multiline_line;	}	else#endif		pStrCopy ("\pRavelMAIL.hst", mailername);	if (FSOpen (mailername, 0, &hRefNum) == noErr)	{		curr = NULL;			for (;;)		{			counter = sizeof (hist_rec);			if (FSRead (hRefNum, &counter, &temp) == noErr)			{				if (counter != sizeof (hist_rec))					break;									if (!history)					curr = history = (p_hist_rec) NewPtrClear (sizeof (hist_rec));				else				{					curr->next = (p_hist_rec) NewPtrClear (sizeof (hist_rec));					curr = curr->next;				}								*curr = temp;				curr->next = NULL;			}			else				break;		}			FSClose (hRefNum);	}	//	+DEBUGGING/*	history = (p_hist_rec) NewPtrClear (sizeof (hist_rec));	history->inout = 1;	history->time_start = LMGetTime ();	history->time_sess = 60L*32L;		history->operate.zone = 2;	history->operate.net = 5030;	history->operate.node = 700;	history->operate.point = 1;*///	-DEBUGGING	LSetDrawingMode (false, IHSList);	LSetDrawingMode (false, OHSList);	curr = history;		while (curr)	{		i = LAddRow (1, 0x7FFF, (curr->inout) ? OHSList : IHSList);		SetPt (&theCell, 0, i);		LSetCell (&curr, sizeof (p_hist_rec), theCell, (curr->inout) ? OHSList : IHSList);			curr = curr->next;	}	LSetDrawingMode (true, IHSList);	LSetDrawingMode (true, OHSList);	if ((*IHSList)->dataBounds.bottom)	{		SetPt (&theCell, 0, (*IHSList)->dataBounds.bottom - 1);		LSetSelect (true, theCell, IHSList);		LAutoScroll (IHSList);	}		if ((*OHSList)->dataBounds.bottom)	{		SetPt (&theCell, 0, (*OHSList)->dataBounds.bottom - 1);		LSetSelect (true, theCell, OHSList);		LAutoScroll (OHSList);	}		LUpdate ( RavelWindow->visRgn, IHSList );	LUpdate ( RavelWindow->visRgn, OHSList );}void history_add_und_set (short inout, unsigned long time_start){	c_history = (p_hist_rec) NewPtrClear (sizeof (hist_rec));		c_history->inout = inout;	c_history->time_start = time_start;}void history_add_address (addr *operate){//	short			iType;//	Handle			iHandle;//	Rect			iRect;	Str255			tmp;	if (!GetInfoFromAddr (operate, tmp))		pStrCopy ("\pNo info in used nodelist(s)", tmp);	else		tmp[0]--;		pStrConc (tmp, "\p (", tmp);		tmp[tmp[0]+1] = 0;		printaddr (operate, (char *)&tmp[1+strlen((char *)&tmp[1])]);	tmp[0] = strlen ((char *)&tmp[1]);	pStrConc (tmp, "\p)", tmp);//	GetDialogItem (RavelWindow, 16, &iType, &iHandle, &iRect);//	SetDialogItemText (iHandle, tmp);	put_nodeinfo (tmp);	if (c_history)		c_history->operate = *operate;}void history_add_address1 (ADDR *operate){//	short			iType;//	Handle			iHandle;//	Rect			iRect;//	char			tmp[128];	addr			op;	op.zone = operate->Zone;	op.net = operate->Net;	op.node = operate->Node;	op.point = operate->Point;	history_add_address (&op);//	printaddr1 (operate, &tmp[1]);//	tmp[0] = strlen (&tmp[1]);////	GetDialogItem ( RavelWindow, 16, &iType, &iHandle, &iRect );//	SetDialogItemText ( iHandle, (StringPtr)tmp );//	if (c_history)//	{//		c_history->operate.zone = operate->Zone;//		c_history->operate.net = operate->Net;//		c_history->operate.node = operate->Node;//		c_history->operate.point = operate->Point;//	}}void history_add_traff (Boolean sending, long vol){	if (c_history)		if (sending)			c_history->was_sent += vol;		else			c_history->was_received += vol;}void history_add_freq (long vol){	if (c_history)		c_history->was_requested += vol;}void history_reset (unsigned long time_sess){	p_hist_rec	curr;	short		i;	Cell		theCell;//	short		iType;//	Handle		iHandle;//	Rect		iRect;//	GetDialogItem ( RavelWindow, 16, &iType, &iHandle, &iRect );//	SetDialogItemText ( iHandle, "\p" );	put_nodeinfo ("\p");		if (c_history)		if (c_history->operate.zone)		{	//	¥	VALID			c_history->time_sess = time_sess;			if (!history)			{				history = c_history;			}			else			{				curr = history;							while (curr->next)					curr = curr->next;									curr->next = c_history;			}			for (i=0; i<(*((c_history->inout) ? OHSList : IHSList))->dataBounds.bottom; i++)			{				SetPt (&theCell, 0, i);				LSetSelect (false, theCell, (c_history->inout) ? OHSList : IHSList);			}			i = LAddRow (1, 0x7FFF, (c_history->inout) ? OHSList : IHSList);			SetPt (&theCell, 0, i);			LSetCell (&c_history, sizeof (p_hist_rec), theCell, (c_history->inout) ? OHSList : IHSList);				LSetSelect (true, theCell, (c_history->inout) ? OHSList : IHSList);			LAutoScroll ((c_history->inout) ? OHSList : IHSList);					if (modem_diagnosis[0])			{				mdm_flush_diagnosis ((char *) &modem_diagnosis[1]);			}		}		else			DisposePtr ((Ptr) c_history);				c_history = NULL;}void history_deinit (void){	p_hist_rec	curr;	short		hRefNum;	long		counter;	Str255		mailername;	#ifndef LITE	if (multiline_flag)	{		pStrCopy ("\pRavelMAIL.hst/Line #0", mailername);		mailername[mailername[0]] += multiline_line;	}	else#endif		pStrCopy ("\pRavelMAIL.hst", mailername);	FSDelete (mailername, 0);		if (Create (mailername, 0, 'RvlM', 'HiST') == noErr)	{		if (FSOpen (mailername, 0, &hRefNum) == noErr)		{			curr = history;						while (curr)			{				counter = sizeof (hist_rec);				FSWrite (hRefNum, &counter, curr);				curr = curr->next;			}						FSClose (hRefNum);		}	}}