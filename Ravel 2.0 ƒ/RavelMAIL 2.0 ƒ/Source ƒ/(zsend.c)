/*--------------------------------------------------------------------------*//*                                                                          *//*                                                                          *//*      ------------         Bit-Bucket Software, Co.                       *//*      \ 10001101 /         Writers and Distributors of                    *//*       \ 011110 /          Freely Available<tm> Software.                 *//*        \ 1011 /                                                          *//*         ------                                                           *//*                                                                          *//*              (C) Copyright 1987-96, Bit Bucket Software Co.              *//*                                                                          *//*                                                                          *//*                                                                          *//*                    Zmodem file transmission module                       *//*                                                                          *//*                                                                          *//*    For complete  details  of the licensing restrictions, please refer    *//*    to the License  agreement,  which  is published in its entirety in    *//*    the MAKEFILE and BT.C, and also contained in the file LICENSE.260.    *//*                                                                          *//*    USE  OF THIS FILE IS SUBJECT TO THE  RESTRICTIONS CONTAINED IN THE    *//*    BINKLEYTERM  LICENSING  AGREEMENT.  IF YOU DO NOT FIND THE TEXT OF    *//*    THIS  AGREEMENT IN ANY OF THE  AFOREMENTIONED FILES,  OR IF YOU DO    *//*    NOT HAVE THESE FILES,  YOU  SHOULD  IMMEDIATELY CONTACT BIT BUCKET    *//*    SOFTWARE CO.  AT ONE OF THE  ADDRESSES  LISTED BELOW.  IN NO EVENT    *//*    SHOULD YOU  PROCEED TO USE THIS FILE  WITHOUT HAVING  ACCEPTED THE    *//*    TERMS  OF  THE  BINKLEYTERM  LICENSING  AGREEMENT,  OR  SUCH OTHER    *//*    AGREEMENT AS YOU ARE ABLE TO REACH WITH BIT BUCKET SOFTWARE, CO.      *//*                                                                          *//*                                                                          *//* You can contact Bit Bucket Software Co. at any one of the following      *//* addresses:                                                               *//*                                                                          *//* Bit Bucket Software Co.        FidoNet  1:104/501, 1:343/491             *//* P.O. Box 460398                AlterNet 7:42/1491                        *//* Aurora, CO 80046               BBS-Net  86:2030/1                        *//*                                Internet f491.n343.z1.fidonet.org         *//*                                                                          *//* Please feel free to contact us at any time to share your comments about  *//* our software and/or licensing policies.                                  *//*                                                                          *//*                                                                          *//*  This module is based largely on a similar module in OPUS-CBCS V1.03b.   *//*  The original work is (C) Copyright 1986, Wynn Wagner III. The original  *//*  authors have graciously allowed us to use their code in this work.      *//*                                                                          *//*--------------------------------------------------------------------------*//* Include this file before any other includes or defines! *///	#include "includes.h"#include <ctype.h>#include <stdio.h>#include <string.h>#include "Comm.h"#include "zmodem.h"#include "zfiles.h"#include "definitions.h"#include "zm.h"//#include "PascalStr.h"#include "Timing.h"#include "pmain.h"#include "log.h"#include "PKT.h"#include "Prefs.h"#include "compatible.h"#include "history.h"//#include "debugging.h"/*--------------------------------------------------------------------------*//* Private routines                                                         *//*--------------------------------------------------------------------------*/static void ZS_SendBinaryHeader (unsigned short, unsigned char *);static void  ZS_32SendBinaryHeader (unsigned short, unsigned char *);static void  ZS_SendData (unsigned char *, short, unsigned short);static void  ZS_32SendData (unsigned char *, short, unsigned short);static void  ZS_SendByte (unsigned char);static short  ZS_GetReceiverInfo (void);static short  ZS_SendFile (short, short);static short  ZS_SendFileData (short);static short  ZS_SyncWithReceiver (short);static void  ZS_EndSend (void);/*--------------------------------------------------------------------------*//* Private data                                                             *//*--------------------------------------------------------------------------*///	static FILE *Infile;			/* Handle of file being sent */static short Infile;static long Strtpos;			/* Starting unsigned char position of */								/* download                  */extern unsigned char	Txbuf[WAZOOMAX + 16];extern	short			remote_capabilities;extern short			fstblklen;extern long				zoho;extern	short			tmail_chat;static long LastZRpos;			/* Last error location       */static long ZRPosCount;			/* ZRPOS repeat count        */static long Txpos;				/* Transmitted file position */static short Rxbuflen;			/* Receiver's max buffer     */								/* length                    */static unsigned long	TxStart;static short Rxflags;				/* Receiver's flags          */extern char				*Filename;extern long				file_length;extern unsigned long	cur_baud;	/* Current baud rate   */extern unsigned short	z_size;extern unsigned long cr3tab[];extern unsigned short crctab[];extern char Rxhdr[4];					/* Received header           */extern char Txhdr[4];					/* Transmitted header        */extern long Rxpos;			/* Received file position                       */extern int Txfcs32;			/* TRUE means send binary frames with 32 bit FCS*/extern int Crc32t;			/* Display flag indicating 32 bit CRC being sent*/extern int Crc32;			/* Display flag indicating 32 bit CRC being rcvd*/extern int Znulls;			/* # of nulls to send at beginning of ZDATA hdr */extern int Rxtimeout;		/* Tenths of seconds to wait for something      */extern int Rxframeind;		/* ZBIN ZBIN32,ZHEX type of frame received      *//*--------------------------------------------------------------------------*//* SEND ZMODEM (send a file)                                                *//*   returns TRUE (1) for good xfer, FALSE (0) for bad                      *//*   sends one file per call; 'fsent' flags start and end of batch          *//*--------------------------------------------------------------------------*/short Send_Zmodem (StringPtr fname, char *alias, short fsent, short wazoo){	register unsigned char *p;	register unsigned char *q;//	struct stat f;	long ltemp;	short rc = 1;	char j[100];//	time_t filetime;	long			fst_size;	long			fst_mtime;	OSType			creator, type;	long			create;#ifdef DEBUG	show_debug_name ("send_Zmodem");#endif	z_size = 0;	Infile = 0;			//	zap operating file's reference number	switch (fsent)	{	case 0:		Z_PutString ((unsigned char *) "rz\r");		Z_PutLongIntoHeader (0L);		Z_SendHexHeader (ZRQINIT, (unsigned char *) Txhdr);		/* Fall through */	case NOTHING_TO_DO:		Rxtimeout = 200;		if (ZS_GetReceiverInfo () == ERROR)		{			CLEAR_OUTBOUND ();			CLEAR_INBOUND ();			return OK;		}	}	Rxtimeout = (short) (614400L / (long) cur_baud);	if (Rxtimeout < 400)		Rxtimeout = 400;	if (fname == NULL)		goto Done;	/*--------------------------------------------------------------------*/	/* Prepare the file for transmission.  Just ignore file open errors   */	/* because there may be other files that can be sent.                 */	/*--------------------------------------------------------------------*/	fname[fname[0]+1] = 0;	Filename = (char *) &fname[1];	/*--------------------------------------------------------------------*/	/* Send the file                                                      */	/* Display outbound filename, size, and ETA for sysop                 */	/*--------------------------------------------------------------------*///•••	if (GetInfoFile (0, 0, fname, &creator, &type, &create, &fst_mtime, &fst_size))	{		rc = OK;		goto Done;	}		if (FSOpen (fname, 0, &Infile))	{		rc = OK;		goto Done;	}		ltemp = ((fst_size * 10L) / cur_baud + 53L) / 54L;//••	putlog (lgNOPE, "Z-Sending: %s (%ldb %ld min)", trunc_path (Filename), fst_size, ltemp);//••	file_length = fst_size;	/*--------------------------------------------------------------------*/	/* Get outgoing file name; no directory path, lower case              */	/*--------------------------------------------------------------------*/	for (p = (unsigned char *) Filename, q = Txbuf; *p;)	{		if ((*p == '/') || (*p == '\\') || (*p == ':'))			q = Txbuf;		else			*q++ = (char) tolower (*p);		p++;	}	*q++ = '\0';	p = q;	newMessage (lTNAME, "Z-Sending: %s", Txbuf);	newMessage (lTSTAT, "0:%ld (0) [%ld min, 0 cps]", file_length, ltemp);	/*--------------------------------------------------------------------*/	/* Zero out remainder of file header packet                           */	/*--------------------------------------------------------------------*/	while (q < (Txbuf + KSIZE))		*q++ = '\0';	/*--------------------------------------------------------------------*/	/* Store filesize, time last modified, and file mode in header packet */	/*--------------------------------------------------------------------*/	UxConvertTime (false, (unsigned long *) &fst_mtime);	/* -> ZModem time */	(void) sprintf ((char *) p, "%lu %lo 0", fst_size, fst_mtime);	/*--------------------------------------------------------------------*/	/* Transmit the filename block and   the download					  */	/*--------------------------------------------------------------------*/	/*--------------------------------------------------------------------*/	/* Check the results                                                  */	/*--------------------------------------------------------------------*/	switch (ZS_SendFile (1 + strlen ((char *) p) + (short) (p - Txbuf), wazoo))	{	case ERROR:		/*--------------------------------------------------*/		/* Something tragic happened                        */		/*--------------------------------------------------*/		goto Err_Out;	case OK:		/*--------------------------------------------------*/		/* File was sent                                    */		/*--------------------------------------------------*/		FSClose (Infile);		Infile = 0;		rc = OK;		goto Done;	case ZSKIP:		/* Backwards compatibility for a while */		putMessage (0, "\pRemote skipped this file");		putlog (lgNOPE, "Remote skipped %s", trunc_path (Filename));				rc = OK;				goto Done;	case ZFERR:		putMessage (0, "\pRemote refused this file");		putlog (lgNOPE, "Remote refused %s", trunc_path (Filename));		rc = SPEC_COND;			/* Success but don't truncate! */		goto Done;	default:		/*--------------------------------------------------*/		/* Ignore the problem, get next file, trust other   */		/* error handling mechanisms to deal with problems  */		/*--------------------------------------------------*/		rc = OK;		goto Done;	}							/* switch */Err_Out:	rc = 1;Done:	if (Infile)		FSClose (Infile);	if (fsent < 0)		ZS_EndSend ();	newMessage (lTNAME, "");	newMessage (lTSTAT, "");	return rc;}								/* send_Zmodem *//*--------------------------------------------------------------------------*//* ZS SEND BINARY HEADER                                                    *//* Send ZMODEM binary header hdr of type type                               *//*--------------------------------------------------------------------------*/static void  ZS_SendBinaryHeader (unsigned short type, register unsigned char * hdr){	register unsigned short crc;	short n;#ifdef DEBUG	show_debug_name ("+ZS_SendBinaryHeader");#endif	BUFFER_BYTE (ZPAD, NULL);	BUFFER_BYTE (ZDLE, NULL);	if ((Crc32t = Txfcs32) != 0)		ZS_32SendBinaryHeader (type, hdr);	else	{		BUFFER_BYTE (ZBIN, NULL);		ZS_SendByte ((unsigned char) type);		crc = Z_UpdateCRC (type, 0);		for (n = 4; --n >= 0;)		{			ZS_SendByte (*hdr);			crc = Z_UpdateCRC (((unsigned short) (*hdr++)), crc);		}		ZS_SendByte ((unsigned char) (crc >> 8));		ZS_SendByte ((unsigned char) crc);		UNBUFFER_BYTES (NULL);	}	if (type != ZDATA)	{		while (CARRIER && !OUT_EMPTY ())			time_release ();		if (!CARRIER)			CLEAR_OUTBOUND ();	}#ifdef DEBUG	show_debug_name ("-ZS_SendBinaryHeader");#endif}								/* ZS_SendBinaryHeader *//*--------------------------------------------------------------------------*//* ZS SEND BINARY HEADER                                                    *//* Send ZMODEM binary header hdr of type type                               *//*--------------------------------------------------------------------------*/static void  ZS_32SendBinaryHeader (unsigned short type, register unsigned char * hdr){	unsigned long crc;	short n;#ifdef DEBUG	show_debug_name ("ZS_32SendBinaryHeader");#endif	BUFFER_BYTE (ZBIN32, NULL);	ZS_SendByte ((unsigned char) type);	crc = 0xFFFFFFFF;	crc = Z_32UpdateCRC (type, crc);	for (n = 4; --n >= 0;)	{		ZS_SendByte (*hdr);		crc = Z_32UpdateCRC (((unsigned short) (*hdr++)), crc);	}	crc = ~crc;	for (n = 4; --n >= 0;)	{		ZS_SendByte ((unsigned char) crc);		crc >>= 8;	}	UNBUFFER_BYTES (NULL);}								/* ZS_SendBinaryHeader *//*--------------------------------------------------------------------------*//* ZS SEND DATA                                                             *//* Send binary array buf with ending ZDLE sequence frameend                 *//*--------------------------------------------------------------------------*/static void ZS_SendData (register unsigned char * buf, short length, unsigned short frameend){	register unsigned short crc;#ifdef DEBUG	show_debug_name ("ZS_SendData");#endif	if (Crc32t)		ZS_32SendData (buf, length, frameend);	else	{		crc = 0;		for (; --length >= 0;)		{			ZS_SendByte (*buf);			crc = Z_UpdateCRC (((unsigned short) (*buf++)), crc);		}		BUFFER_BYTE (ZDLE, NULL);		BUFFER_BYTE ((unsigned char) frameend, NULL);		if (tmail_chat)		{//		•	Make empty ASCIZ string in GAP (for first).						if (frameend == ZCRCG || frameend == ZCRCW)			{//		•	Insert flush of chat buffer here (later :)			}						BUFFER_BYTE (0, NULL);		}		crc = Z_UpdateCRC (frameend, crc);		ZS_SendByte ((unsigned char) (crc >> 8));		ZS_SendByte ((unsigned char) crc);		UNBUFFER_BYTES (NULL);	}	if (frameend == ZCRCW)	{		SENDBYTE (XON, NULL);		while (CARRIER && !OUT_EMPTY ())			time_release ();		if (!CARRIER)			CLEAR_OUTBOUND ();	}}								/* ZS_SendData *//*--------------------------------------------------------------------------*//* ZS SEND DATA with 32 bit CRC                                             *//* Send binary array buf with ending ZDLE sequence frameend                 *//*--------------------------------------------------------------------------*/static void ZS_32SendData (register unsigned char * buf, short length, unsigned short frameend){	unsigned long crc;#ifdef DEBUG	show_debug_name ("ZS_32SendData");#endif	crc = 0xFFFFFFFF;	for (; --length >= 0; ++buf)	{		ZS_SendByte (*buf);		crc = Z_32UpdateCRC (((unsigned short) (*buf)), crc);	}	BUFFER_BYTE (ZDLE, NULL);	BUFFER_BYTE ((unsigned char) frameend, NULL);	if (tmail_chat)	{//	•	Make empty ASCIZ string in GAP (for first).				if (frameend == ZCRCG || frameend == ZCRCW)		{//	•	Insert flush of chat buffer here (later :)		}				BUFFER_BYTE (0, NULL);	}	crc = Z_32UpdateCRC (frameend, crc);	crc = ~crc;	for (length = 4; --length >= 0;)	{		ZS_SendByte ((unsigned char) crc);		crc >>= 8;	}	UNBUFFER_BYTES (NULL);}								/* ZS_SendData *//*--------------------------------------------------------------------------*//* ZS SEND BYTE                                                             *//* Send character c with ZMODEM escape sequence encoding.                   *//* Escape XON, XOFF. Escape CR following @ (Telenet net escape)             *//*--------------------------------------------------------------------------*//*static void  ZS_SendByte (register unsigned char c){	static unsigned char lastsent = 0;	switch (c)	{	case 015:	case 0215:		if ((lastsent & 0x7F) != '@')			goto SendIt;//		* else fall through *	case 020:	case 021:	case 023:	case 0220:	case 0221:	case 0223:	case ZDLE://		*--------------------------------------------------*//		* Quoted characters                                *//		*--------------------------------------------------*		BUFFER_BYTE (ZDLE);		c ^= 0x40;//		* Then fall through *	default://		*--------------------------------------------------*//		* Normal character output                          *//		*--------------------------------------------------*SendIt:		BUFFER_BYTE (lastsent = c);	}	//						* switch *}		//						* ZS_SendByte **/static void ZS_SendByte (register unsigned char c){	static unsigned char lastsent = 0;	switch( c )	{	case 015:	case 0215:		if( (lastsent & 0x7F) != '@' )			break;//	case 021://	case 023://	case 0221://	case 0223://	case 020://	case 0220://	case ZDLE|0x80:	case 020:	case 021:	case 023:	case 0220:	case 0221:	case 0223:		if ((remote_capabilities & DIR_ZAPPER) != 0)			break;	case ZDLE:		BUFFER_BYTE (ZDLE, NULL);		c ^= 0x40;		break;			default:			break;	}	BUFFER_BYTE (lastsent = c, NULL);}/*--------------------------------------------------------------------------*//* ZS GET RECEIVER INFO                                                     *//* Get the receiver's init parameters                                       *//*--------------------------------------------------------------------------*/static short ZS_GetReceiverInfo (void){	short n;#ifdef DEBUG	show_debug_name ("ZS_GetReceiverInfo");#endif	for (n = 10; --n >= 0;)	{		switch (Z_GetHeader ((unsigned char *) Rxhdr))		{		case ZCHALLENGE:			/*--------------------------------------*/			/* Echo receiver's challenge number     */			/*--------------------------------------*/			Z_PutLongIntoHeader (Rxpos);			Z_SendHexHeader (ZACK, (unsigned char *) Txhdr);			continue;		case ZCOMMAND:			/*--------------------------------------*/			/* They didn't see our ZRQINIT          */			/*--------------------------------------*/			Z_PutLongIntoHeader (0L);			Z_SendHexHeader (ZRQINIT, (unsigned char *) Txhdr);			continue;		case ZRINIT:			/*--------------------------------------*/			/*                                      */			/*--------------------------------------*/			Rxflags = 0377 & Rxhdr[ZF0];			Rxbuflen = ((unsigned short) Rxhdr[ZP1] << 8) | Rxhdr[ZP0];//			Txfcs32 = Rxflags & CANFC32;			Txfcs32 = Rxflags & zoho;			return OK;		case ZCAN:		case RCDO:		case TIMEOUT:			return ERROR;		case ZRQINIT:			if (Rxhdr[ZF0] == ZCOMMAND)				continue;			/* else fall through */		default:			Z_SendHexHeader (ZNAK, (unsigned char *) Txhdr);			continue;		}						/* switch */	}							/* for */	return ERROR;}								/* ZS_GetReceiverInfo *//*--------------------------------------------------------------------------*//* ZS SEND FILE                                                             *//* Send ZFILE frame and begin sending ZDATA frame                           *//*--------------------------------------------------------------------------*/static short ZS_SendFile (short blen, short wazoo){	register short c;	long t;#ifdef DEBUG	show_debug_name ("+ZS_SendFile");#endif	TxStart = LMGetTicks ();	for (;;)	{		if (CheckCancel ())		{			CLEAR_OUTBOUND ();//			XON_DISABLE ();			/* Make sure xmitter is unstuck */			send_can ();			/* transmit at least 10 cans    */			t = timerset (200);		/* wait no more than 2 seconds  */			while (!timeup (t) && !OUT_EMPTY () && CARRIER)				time_release ();	/* Give up slice while waiting  *///			XON_ENABLE ();			/* Turn XON/XOFF back on...     *///			z_log ("MSG_TXT (M_KBD_MSG)");			return ERROR;		}		else if (!CARRIER)			return ERROR;		Txhdr[ZF0] = LZCONV;		/* Default file conversion mode */		Txhdr[ZF1] = LZMANAG;		/* Default file management mode */		Txhdr[ZF2] = LZTRANS;		/* Default file transport mode  */		Txhdr[ZF3] = 0;		ZS_SendBinaryHeader (ZFILE, (unsigned char *) Txhdr);		ZS_SendData (Txbuf, blen, ZCRCW);Again:		switch (c = Z_GetHeader ((unsigned char *) Rxhdr))		{		case ZRINIT:			while ((c = Z_GetByte (50)) > 0)				if (c == ZPAD)					goto Again;			/* if we run out, Fall thru to */		default:			continue;		case ZFERR:			return ZFERR;		case ZCAN:		case RCDO:		case TIMEOUT:		case ZFIN:		case ZABORT:			return ERROR;		case ZSKIP:			/*-----------------------------------------*/			/* Other system wants to skip this file    */			/*-----------------------------------------*/			return c;		case ZRPOS:			/*-----------------------------------------*/			/* Resend from this position...            */			/*-----------------------------------------*///			(void) fseek (Infile, Rxpos, SEEK_SET);						SetFPos ( Infile, fsFromStart, Rxpos );						if (Rxpos != 0L)			{				putlog (lgNOPE, "Synchronizing from %ld", Rxpos);//				status_line (MSG_TXT (M_SYNCHRONIZING_OFFSET), Rxpos);				CLEAR_OUTBOUND ();		/* Get rid of queued data *///				XON_DISABLE ();			/* End XON/XOFF restraint */				SENDBYTE (XON, NULL);			/* Send XON to remote     *///				XON_ENABLE ();			/* Start XON/XOFF again   */			}			LastZRpos = Strtpos = Txpos = Rxpos;			ZRPosCount = 10;			CLEAR_INBOUND ();			return ZS_SendFileData (wazoo);		}						/* switch */	}							/* while */}								/* ZS_SendFile *//*--------------------------------------------------------------------------*//* ZS SEND FILE DATA                                                        *//* Send the data in the file                                                *//*--------------------------------------------------------------------------*/static short ZS_SendFileData (short wazoo){	register short	c, e;	unsigned long	ulrate;	char			j[100];	unsigned short	newcnt;	unsigned short	blklen;	unsigned short	maxblklen;	unsigned short	goodblks = 0;	unsigned short	goodneeded = 1;	long			lSize, lTime;	long			tsize;	long			t, cps;#ifdef DEBUG	show_debug_name ("+ZS_SendFileData");#endif	ulrate = cur_baud;	maxblklen = (ulrate >= 9600) ? WAZOOMAX :		((ulrate < 300) ? 128 : (short)ulrate / 300 * 256);	if (maxblklen > WAZOOMAX)		maxblklen = WAZOOMAX;	if (!wazoo && maxblklen > KSIZE)		maxblklen = KSIZE;	if (Rxbuflen && maxblklen > (unsigned) Rxbuflen)		maxblklen = Rxbuflen;	if (wazoo && (remote_capabilities & (ZED_ZIPPER /*| DIR_ZAPPER*/)))		maxblklen = KSIZE;	blklen = (fstblklen != 0) ? fstblklen : maxblklen;	goodneeded = (fstblklen != 0) ? 8 : 1;SomeMore:	if (CHAR_AVAIL ())	{WaitAck:		switch (c = ZS_SyncWithReceiver (1))		{		case ZSKIP:			/*-----------------------------------------*/			/* Skip this file                          */			/*-----------------------------------------*/			return c;		case ZACK:			break;		case ZRPOS:			/*-----------------------------------------*/			/* Resume at this position                 */			/*-----------------------------------------*/			blklen = ((blklen >> 2) > 64) ? blklen >> 2 : 64;			goodblks = 0;			goodneeded = ((goodneeded << 1) > 16) ? 16 : goodneeded << 1;			break;		case ZRINIT:			/*-----------------------------------------*/			/* Receive init                            */			/*-----------------------------------------*/			goto file_sent;		case TIMEOUT:			/*-----------------------------------------*/			/* Timed out on message from other side    */			/*-----------------------------------------*/			break;		default:			putMessage (0, "\pCanceled");//			z_log ("MSG_TXT (M_CAN_MSG)");//			(void) fclose (Infile);						FSClose (Infile);						return ERROR;		}						/* switch */		/*       * Noise probably got us here. Odds of surviving are not good. But we       * have to get unstuck in any event.       *       */		Z_UncorkTransmitter ();	/* Get our side free if need be      */		SENDBYTE (XON, NULL);			/* Send an XON to release other side */		while (CHAR_AVAIL ())		{			switch (MODEM_IN ())			{			case CAN:			case RCDO:			case ZPAD:				goto WaitAck;			}					/* switch */		}						/* while */	}							/* while */	newcnt = Rxbuflen;	Z_PutLongIntoHeader (Txpos);	ZS_SendBinaryHeader (ZDATA, (unsigned char *) Txhdr);	do	{#ifdef DEBUG	show_debug_name ("+ZS_SendFileData: do block…");#endif		if (CheckCancel ())		{			CLEAR_OUTBOUND ();//			XON_DISABLE ();			/* Make sure xmitter is unstuck */			send_can ();			/* transmit at least 10 cans    */			t = timerset (200);		/* wait no more than 2 seconds  */			while (!timeup (t) && !OUT_EMPTY () && CARRIER)				time_release ();	/* Give up slice while waiting  *///			XON_ENABLE ();			/* Turn XON/XOFF back on...     *///			z_log ("MSG_TXT (M_KBD_MSG)");			goto oops;		}		if (!CARRIER)			goto oops;/*		if ((unsigned) (c = fread (Txbuf, 1, blklen, Infile)) != z_size)		{			if (fullscreen && un_attended)			{				sb_move (filewin, 2, 12);				sb_puts (filewin, ultoa (((unsigned long) (z_size = c)), e_input, 10));				sb_puts (filewin, "    ");				elapse_time ();				sb_show ();			}			else			{				gotoxy (locate_x + 10, locate_y);				(void) cputs (ultoa (((unsigned long) (z_size = c)), e_input, 10));				(void) putch (' ');			}		}*/		tsize = blklen;		FSRead (Infile, &tsize, Txbuf);		c = tsize;		if (c!=z_size)			z_size = c;				if ((unsigned) c < blklen)			e = ZCRCE;		else if (Rxbuflen && (newcnt -= c) <= 0)			e = ZCRCW;		else			e = ZCRCG;		ZS_SendData (Txbuf, c, (unsigned short) e);		(void) sprintf (j, "%ld min",			(((file_length - Txpos) * 10L) / ulrate + 53L) / 54L);		lSize = Txpos - Strtpos;		if ((LMGetTicks () - TxStart) != 0)//			cps = (((lSize * 60L) / (LMGetTicks () - TxStart)) * 1000L) / cur_baud;			cps = ((lSize * 60L) / (LMGetTicks () - TxStart));		else			cps = 0;		newMessage (lTSTAT, "%ld:%ld (%d) [%s, %ld cps]", Txpos, file_length, z_size, j, cps);		putMessage (0, "\p");/*		if (fullscreen && un_attended)		{			sb_move (filewin, 2, 2);			sb_puts (filewin, ultoa (((unsigned long) Txpos), e_input, 10));			sb_puts (filewin, "  ");			sb_move (filewin, 2, 69);			sb_puts (filewin, j);			elapse_time ();			sb_show ();		}		else		{			gotoxy (locate_x, locate_y);			(void) cputs (ultoa (((unsigned long) Txpos), e_input, 10));			(void) putch (' ');			(void) putch (' ');			gotoxy (locate_x + 20, locate_y);			(void) printf ("%s", j);			(void) putch (' ');#if defined __IBMC__		fflush(stdout) ;#endif		}*/		Txpos += c;		if (blklen < maxblklen && ++goodblks > goodneeded)		{			blklen = ((unsigned short) (blklen << 1) < maxblklen) ? blklen << 1 : maxblklen;			goodblks = 0;		}		if (e == ZCRCW)			goto WaitAck;		while (CHAR_AVAIL ())		{			switch (c = MODEM_IN ())			{			case CAN:			case RCDO:			case ZPAD:				/*--------------------------------------*/				/* Interruption detected;               */				/* stop sending and process complaint   */				/*--------------------------------------*/				putMessage (0, "\pInterruption detected");//				z_message ("MSG_TXT (M_TROUBLE)");				CLEAR_OUTBOUND ();				ZS_SendData (Txbuf, 0, ZCRCE);				goto WaitAck;							default:							if (!CARRIER)					goto oops;								if (tmail_chat)				{//	process 'c' char as input chat								}								break;			}					/* switch */		}						/* while */	}							/* do */	while (e == ZCRCG);	for (;;)	{		Z_PutLongIntoHeader (Txpos);		ZS_SendBinaryHeader (ZEOF, (unsigned char *) Txhdr);		switch (ZS_SyncWithReceiver (7))		{		case ZACK:			continue;		case ZRPOS:			/*-----------------------------------------*/			/* Resume at this position...              */			/*-----------------------------------------*/			goto SomeMore;		case ZRINIT:			/*-----------------------------------------*/			/* Receive init                            */			/*-----------------------------------------*/file_sent://			if (locate_y && !(fullscreen && un_attended))//				gotoxy (2, (unsigned char) locate_y - 1);			lSize = Txpos - Strtpos;//			lTime = throughput (1, Txpos - Strtpos);//			status_line ("%s-Z%s %s", MSG_TXT (M_FILE_SENT), Crc32t ? "/32" : "", Filename);//			update_files (1, Filename, lSize, lTime, 0);			if ((LMGetTicks () - TxStart) != 0)//				cps = (((lSize * 60L) / (LMGetTicks () - TxStart)) * 1000L) / cur_baud;				cps = ((lSize * 60L) / (LMGetTicks () - TxStart));			else				cps = 0;			history_add_traff (true, lSize);			putlog (lgNOPE, "Sent-Z%s %s [%ld cps]", Crc32t ? "/32" : "", trunc_path (Filename), cps);			return OK;		case ZSKIP:			/*-----------------------------------------*/			/* Request to skip the current file        */			/*-----------------------------------------*/			putlog (lgNOPE, "Skip %s", trunc_path (Filename));			putMessage (0, "\pSkip file");//			z_log ("MSG_TXT (M_SKIP_MSG)");//			CLEAR_IOERR ();//			(void) fclose (Infile);			FSClose (Infile);			return c;		default:oops:			putMessage (0, "\pCanceled");//			z_log ("MSG_TXT (M_CAN_MSG)");//			(void) fclose (Infile);			FSClose (Infile);			return ERROR;		}						/* switch */	}							/* while */}								/* ZS_SendFileData *//*--------------------------------------------------------------------------*//* ZS SYNC WITH RECEIVER                                                    *//* Respond to receiver's complaint, get back in sync with receiver          *//*--------------------------------------------------------------------------*/static short ZS_SyncWithReceiver (short num_errs){	register short c;	char j[50];#ifdef DEBUG	show_debug_name ("ZS_SyncWithReceiver");#endif	for (;;)	{		c = Z_GetHeader ((unsigned char *) Rxhdr);		CLEAR_INBOUND ();		switch (c)		{		case TIMEOUT:			putMessage (0, "\pTimeout");//			z_message ("MSG_TXT (M_TIMEOUT)");			if ((num_errs--) >= 0)				break;			/* else fall through */		case ZCAN:		case ZABORT:		case ZFIN:		case RCDO:			putMessage (0, "\pError");//			z_log ("MSG_TXT (M_ERROR)");			return ERROR;		case ZRPOS:			if (Rxpos == LastZRpos)		/* Same as last time?    */			{				if (!(--ZRPosCount))	/* Yup, 10 times yet?    */					return ERROR;		/* Too many, get out     */			}			else				ZRPosCount = 10;		/* Reset repeat count    */			LastZRpos = Rxpos;			/* Keep track of this    *///			rewind (Infile);			/* In case file EOF seen *///			(void) fseek (Infile, Rxpos, SEEK_SET);			SetFPos (Infile, fsFromStart, Rxpos);			Txpos = Rxpos;			putMessage (0, "\pResending…");//			(void) sprintf (j, MSG_TXT (M_RESENDING_FROM),//				ultoa (((unsigned long) (Txpos)), e_input, 10));//			z_message (j);			return c;		case ZSKIP:			putMessage (0, "\pSkip this file");//			z_log ("MSG_TXT (M_SKIP_MSG)");			/* fall through */		case ZRINIT://			CLEAR_IOERR ();//			(void) fclose (Infile);			FSClose (Infile);			return c;		case ZACK://			z_message (NULL);			return c;		default://			z_message (IDUNNO_msg);			ZS_SendBinaryHeader (ZNAK, (unsigned char *) Txhdr);			continue;		}						/* switch */	}							/* while */}								/* ZS_SyncWithReceiver *//*--------------------------------------------------------------------------*//* ZS END SEND                                                              *//* Say BIBI to the receiver, try to do it cleanly                           *//*--------------------------------------------------------------------------*/static void  ZS_EndSend (){#ifdef DEBUG	show_debug_name ("ZS_EndSend");#endif	CLEAR_OUTBOUND ();	CLEAR_INBOUND ();	for (;;)	{		Z_PutLongIntoHeader (0L);		ZS_SendBinaryHeader (ZFIN, (unsigned char *) Txhdr);		switch (Z_GetHeader ((unsigned char *) Rxhdr))		{		case ZFIN:			SENDBYTE ('O', NULL);			SENDBYTE ('O', NULL);			while (CARRIER && !OUT_EMPTY ())				time_release ();			if (!CARRIER)				CLEAR_OUTBOUND ();			/* fallthrough... */		case ZCAN:		case RCDO:		case TIMEOUT:			return;		}						/* switch */	}							/* while */}								/* ZS_EndSend */