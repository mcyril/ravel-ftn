#include <stdio.h>#include <string.h>#include "PKT.h"#include "Prefs.h"#include "stringutl.h"#include "Scheduler.h"#include "PascalStr.h"#include "nodelist.h"typedef struct _nodelistheader {	char			sign[16];	long			ofs_zones;	long			ofs_nets;	long			ofs_nodes;	long			ofs_points;	} nodelistheader;typedef struct _filerec {		Str15			fname;	unsigned long	modifdate;	long			flength;	short			points;} filerec, *p_files;typedef struct _zonerec  {		unsigned short	zone;	short			fnum;	long			foffset;	long			netoffset;	} zonerec, *p_zones;typedef struct _netrec  {		unsigned short	net;	short			fnum;	long			foffset;	long			nodeoffset;	} netrec, *p_nets;typedef struct _noderec  {		unsigned short	node;	short			flags;	long			foffset;	long			pointoffset;	} noderec, *p_nodes;typedef struct _pointrec  {		unsigned short	point;	short			fnum;	long			foffset;	} pointrec, *p_points;extern	Handle			phoneTrans;extern	Str255			nodePath;extern	short			timezone;static	long			ofs_zones;static	long			ofs_nets;static	long			ofs_nodes;static	long			ofs_points;	static	Str255			ravelnodesindex;static	short			indexref;static	p_files			pfiles;static	p_zones			pzones;static	p_nets			pnets;static	p_nodes			pnodes;static	p_points		ppoints;static	short			FLAG;void ReadNodeList (void);void CloseNodeList (void);Boolean GetNodeInfo (addr *, StringPtr);Boolean GetNameFromAddr (addr *, StringPtr);static void TranslatePhone (StringPtr ph_num){	Str255		back, rrr;	StringPtr	tmp;	short		i, j;		if (!phoneTrans)		return;		pStrCopy (ph_num, back);		for ( i = 1; ; i+= 2 )	{		tmp = GetStr (phoneTrans, i);		if (!tmp)			break;		back[0] = tmp[0];				if (!pStrComp (back, tmp))		{			pStrCopy ( GetStr (phoneTrans, i+1), rrr );						for ( j=back[0]+1; j <= ph_num[0]; j++ )			{				rrr[rrr[0]+1] = ph_num[j];				rrr[0]++;			}						pStrCopy ( rrr, ph_num );						break;		}	}}void ReadNodeList (void){	nodelistheader	header;	long			ioCount;	Handle			h;			pStrConc ( nodePath, "\pRavel.NODELIST.INDEX", ravelnodesindex );		if ( FSOpen ( ravelnodesindex, 0, &indexref ) )	{		indexref = 0;		return;	}		ioCount = sizeof (nodelistheader);	FSRead ( indexref, &ioCount, &header );	ofs_zones = header.ofs_zones;	ofs_nets = header.ofs_nets;	ofs_nodes = header.ofs_nodes;	ofs_points = header.ofs_points;//е	h = NewHandle ( ofs_zones - sizeof (nodelistheader) );	MoveHHi (h);	HLock (h);		pfiles = (p_files) *h;	ioCount = ofs_zones - sizeof (nodelistheader);	FSRead ( indexref, &ioCount, pfiles );//е	h = NewHandle ( ofs_nets - ofs_zones );	MoveHHi (h);	HLock (h);	pzones = (p_zones) *h;	ioCount = ofs_nets - ofs_zones;	FSRead ( indexref, &ioCount, pzones );//е	h = NewHandle ( ofs_nodes - ofs_nets );	MoveHHi (h);	HLock (h);	pnets = (p_nets) *h;	ioCount = ofs_nodes - ofs_nets;	FSRead ( indexref, &ioCount, pnets );//е	h = NewHandle ( ofs_points - ofs_nodes );	MoveHHi (h);	HLock (h);	pnodes = (p_nodes) *h;	ioCount = ofs_points - ofs_nodes;	FSRead ( indexref, &ioCount, pnodes );//е	h = NewHandle ( 2048 );	MoveHHi (h);	HLock (h);	ppoints = (p_points) *h;//ее	FSClose (indexref);}void CloseNodeList (){//	if (indexref)//		FSClose (indexref);}static long lookupZoneIndex (short zone){	register long	i = 0;			while (pzones[i].zone != -1)		if (pzones[i].zone == zone)			return i;		else			i++;	return -1;}static long lookupNetIndex (long netoffset, short net){	register long	i = netoffset / sizeof (netrec);	while (pnets[i].net != -1)		if (pnets[i].net == net)			return i;		else			i++;		return -1;}static long lookupNodeIndex (long nodeoffset, short node){	register long	i = nodeoffset / sizeof (noderec);	while (pnodes[i].node != -1)		if (pnodes[i].node == node)			return i;		else			i++;		return -1;}static long lookupPoint (pointrec *pt, long pointoffset, short point){	short		i, j;	long		ioCount;		if (pointoffset >= 0)	{		SetFPos ( indexref, fsFromStart, ofs_points + pointoffset );				ioCount = sizeof (pointrec) * 128;		FSRead ( indexref, &ioCount, ppoints );				i = 0;				do {					if (ppoints[i].point == point)			{				*pt = ppoints[i];				return 0;			}						i++;			if (i > 127)			{				ioCount = sizeof (pointrec) * 128;				FSRead ( indexref, &ioCount, ppoints );								i = 0;			}				} while (ppoints[i].point != -1);	}	return -1;}/*Hold,352,GR_44_Station,St.Petersburg,Alexander_Mironov,7-812-314-0518,9600,XA,MO,H16,V32T,U,TVF*/static void FilterNodeString (addr *address, StringPtr str){	short	i, j, k;	Str255	temp;		i = 1;		while (str[i] != ',' && i <= str[0])		i++;		i++;		while (str[i] != ',' && i <= str[0])		i++;		if (i < str[0])	{		i++;		k = 0;		j = 1;				while (str[i] != 0x0D && i <= str[0])		{			switch (str[i])			{			case ',':								if (k > 4)					temp[j++] = str[i];				else				{					k++;					temp[j++] = 0x0D;				}								break;							case '_':							temp[j++] = ' ';				break;						default:				temp[j++] = str[i];				break;			}						i++;		}				temp[j] = 0;		temp[0] = strlen ( (char *) &temp[1] );			printaddr ( address, (char *) &str[1] );		str[0] = strlen ( (char *) &str[1] );				pStrConc ( str, "\p, ", str );		pStrConc ( str, temp, str );	}}Boolean GetNodeInfo (addr *address, StringPtr result){	long		inx_z, inx_nt, inx_nd, ioCount;	short		a;	pointrec	pt;	Boolean		res = false;	Str255		ttt;				if (!indexref)		return false;		if ( FSOpen ( ravelnodesindex, 0, &indexref ) )	{		return false;	}	FLAG = 0;	inx_z = lookupZoneIndex ( address->zone );	if (inx_z >= 0)	{		if (address->net)		{			inx_nt = lookupNetIndex ( pzones[inx_z].netoffset, address->net );			if (inx_nt >= 0)			{				if (address->node)				{					inx_nd = lookupNodeIndex ( pnets[inx_nt].nodeoffset, address->node );									if (inx_nd >= 0)					{						if (address->point)						{	//	full 4D - zone:net/node.point																		if ( lookupPoint ( &pt, pnodes[inx_nd].pointoffset, address->point ) == 0 )							{								pStrConc ( nodePath, pfiles[pt.fnum].fname, ttt );								FSOpen ( ttt, 0, &a );								SetFPos ( a, fsFromStart, pt.foffset );								ioCount = 255;								FSRead ( a, &ioCount, &result[1] );								result[0] = 255;								FilterNodeString (address, result);								FSClose ( a );								res = true;							}						}						else						{	//	node only - zone:net/node								pStrConc ( nodePath, pfiles[pnets[inx_nt].fnum].fname, ttt );							FSOpen ( ttt, 0, &a );							SetFPos ( a, fsFromStart, pnodes[inx_nd].foffset );							ioCount = 255;							FSRead ( a, &ioCount, &result[1] );							result[0] = 255;							FilterNodeString (address, result);							FSClose ( a );							FLAG = pnodes[inx_nd].flags;							res = true;						}					}				}				else				{	//	net only - zone:net/0									pStrConc ( nodePath, pfiles[pnets[inx_nt].fnum].fname, ttt );					FSOpen ( ttt, 0, &a );					SetFPos ( a, fsFromStart, pnets[inx_nt].foffset );					ioCount = 255;					FSRead ( a, &ioCount, &result[1] );					result[0] = 255;					FilterNodeString (address, result);					FSClose ( a );					FLAG = f_host;					res = true;				}			}		}		else		{	//	zone only - zone:0/0					pStrConc ( nodePath, pfiles[pzones[inx_z].fnum].fname, ttt );			FSOpen ( ttt, 0, &a );			SetFPos ( a, fsFromStart, pzones[inx_z].foffset );			ioCount = 255;			FSRead ( a, &ioCount, &result[1] );			result[0] = 255;			FilterNodeString (address, result);			FSClose ( a );			FLAG = f_zone;			res = true;		}	}		FSClose (indexref);	if (res && FLAG)	{		pStrConc ( result, "\p\xD", result );		if (FLAG & f_zone)			pStrConc ( result, "\pZone", result );		else			if (FLAG & f_host)			{				if (address->net < 100)					pStrConc ( result, "\pRegion", result );				else					pStrConc ( result, "\pHost", result );			}			else				if (FLAG & f_hub)					pStrConc ( result, "\pHub", result );				else					if (FLAG & f_down)						pStrConc ( result, "\pDown", result );					else						if (FLAG & f_hold)							pStrConc ( result, "\pHold", result );						else							if (FLAG & f_pvt)								pStrConc ( result, "\pPrivate", result );	}	return res;}Boolean GetNameFromAddr (addr *address, StringPtr result){	Str255		sTemp;	short		i, j;		if (GetNodeInfo (address, sTemp))	{		i = 1;		for (j = 0; j < 2 && i <= sTemp[0]; j++)		{			while (sTemp[i] != 0x0D && i <= sTemp[0])				i++;			i++;		}		j = 1;		while (sTemp[i] != 0x0D && i <= sTemp[0])			result[j++] = sTemp[i++];				result[0] = j-1;	}	else		return false;}Boolean GetPhoneFromAddr (addr *address, StringPtr result){	Str255		sTemp;	short		i, j;		if (GetNodeInfo (address, sTemp))	{		i = 1;		for (j = 0; j < 3 && i <= sTemp[0]; j++)		{			while (sTemp[i] != 0x0D && i <= sTemp[0])				i++;			i++;		}				if (i > sTemp[0])			return false;		j = 1;		while (sTemp[i] != 0x0D && i <= sTemp[0])			result[j++] = sTemp[i++];				result[0] = j-1;				if (result[1] == '-')		{			result[0] = 0;			return false;		}				TranslatePhone (result);		return true;	}	else	{		result[0] = 0;		return false;	}}Boolean GetTimesFromAddr (addr *address, _period *result){	Str255		sTemp, res;	short		i, j;	Boolean		addenum;	long		tt1, tt2;	DateTimeRec	dtr;		if (GetNodeInfo (address, sTemp))	{		i = 1;		for (j = 0; j < 5 && i <= sTemp[0]; j++)		{			while (sTemp[i] != 0x0D && i <= sTemp[0])				i++;			i++;		}		if (i > sTemp[0])			return false;		j = 1;		while (sTemp[i] != 0x0D && i <= sTemp[0])			res[j++] = sTemp[i++];				res[0] = j-1;		//		DebugStr ( res );		addenum = false;				for (i = 1; i <= j-1; i++)		{			sTemp[0] = 0;						while (res[i] != ',' && i <= j-1)			{				sTemp[0]++;				sTemp[sTemp[0]] = res[i];				i++;			}			//			DebugStr (sTemp);						if (addenum)			{				if ( sTemp[1] == 'T' )				{					tt1 = (sTemp[2] >= 'a') ? sTemp[2] - 'a' : sTemp[2] - 'A';					tt1 *= 60L;					tt1 += (sTemp[2] >= 'a') ? 30L : 0;					tt1 *= 60L;					tt1 += 60L * 60L * (long) timezone;					Secs2Date ( tt1, &dtr );										result->Start.hour = dtr.hour;					result->Start.minute = dtr.minute;										tt1 = (sTemp[3] >= 'a') ? sTemp[3] - 'a' : sTemp[3] - 'A';					tt1 *= 60L;					tt1 += (sTemp[3] >= 'a') ? 30L : 0;					tt1 *= 60L;					tt1 += 60L * 60L * (long) timezone;					Secs2Date ( tt1, &dtr );										result->End.hour = dtr.hour;					result->End.minute = dtr.minute;										return true;				}			}			else				if (!pStrComp (sTemp, "\pCM"))				{					result->Start.hour = 0;					result->Start.minute = 0;					result->End.hour = 23;					result->End.minute = 59;					return true;				}				else					if (!pStrComp (sTemp, "\pU"))						addenum = true;						}				result->Start.hour = 0;		result->Start.minute = 0;		result->End.hour = 0;		result->End.minute = 0;		return false;	}	else	{		result->Start.hour = 0;		result->Start.minute = 0;		result->End.hour = 0;		result->End.minute = 0;		return false;	}}