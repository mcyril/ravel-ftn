#include <stdio.h>#include "zmodem.h"#include "Comm.h"#include "Timing.h"#include "aglcrc.h"//#include "externs.h"#include "pmain.h"#include "zm.h"#include "myEnv.h"//#include "debugging.h"extern unsigned long cr3tab[];extern unsigned short crctab[];extern char Rxhdr[4];					/* Received header           */extern char Txhdr[4];					/* Transmitted header        */extern long Rxpos;			/* Received file position                       */extern int Txfcs32;			/* TRUE means send binary frames with 32 bit FCS*/extern int Crc32t;			/* Display flag indicating 32 bit CRC being sent*/extern int Crc32;			/* Display flag indicating 32 bit CRC being rcvd*/extern int Znulls;			/* # of nulls to send at beginning of ZDATA hdr */extern int Rxtimeout;		/* Tenths of seconds to wait for something      */extern int Rxframeind;		/* ZBIN ZBIN32,ZHEX type of frame received      */extern	short		tmail_chat;//extern struct baud_str cur_baud;	/* Current baud rate   */extern unsigned long	cur_baud;	/* Current baud rate   */static short Rxtype;				/* Type of header received                 */static char hex[] = "0123456789abcdef";/* Send a byte as two hex digits */#define Z_PUTHEX(i,c) {i=(c);SENDBYTE(hex[((i)&0xF0)>>4], NULL);SENDBYTE(hex[(i)&0xF], NULL);}/*--------------------------------------------------------------------------*//* Private routines                                                         *//*--------------------------------------------------------------------------*/static short  _Z_GetBinaryHeader (unsigned char *);static short  _Z_32GetBinaryHeader (unsigned char *);static short  _Z_GetHexHeader (unsigned char *);static short  _Z_GetHex (void);static short  _Z_TimedRead (void);static long  _Z_PullLongFromHeader (unsigned char *);/*void z_message (char *s){	if (fullscreen && un_attended)	{		if (s)		{			sb_move (filewin, 2, 27);			sb_puts (filewin, s);		}		sb_puts (filewin, "              ");		sb_show ();	}	else	{		gotoxy (locate_x + 20, locate_y);		if (s)		{			(void) cputs (s);		}		(void) cputs ("               ");	}}void z_log (char *s){	unsigned short x, y;	z_message (s);	x = locate_x;	y = locate_y;	status_line (s);			/* also does disk file logging *	locate_x = x;	locate_y = y;}void show_loc (unsigned long l, unsigned short w){	char j[100];	if (fullscreen && un_attended)	{		(void) sprintf (j, "Ofs=%ld Retries=%d        ", l, w);		sb_move (filewin, 2, 37);		sb_puts (filewin, j);		sb_show ();	}	else	{		gotoxy (locate_x + 35, locate_y);		(void) printf ("Ofs=%ld Retries=%d        ", l, w);	}}*//*void z_message (char *s){	printf ( "M:, %s\n", s );}void z_log (char *s){	printf ( "L: %s\n", s );}void show_loc (unsigned long l, unsigned short w){	printf ( "l=%ld, w=%d\n", l, w );}*//*--------------------------------------------------------------------------*//* Z GET BYTE                                                               *//* Get a byte from the modem;                                               *//* return TIMEOUT if no read within timeout tenths,                         *//* return RCDO if carrier lost                                              *//*--------------------------------------------------------------------------*/short Z_GetByte (short tenths){	long timeout;	if (PEEKBYTE () >= 0)		return (MODEM_IN ());	timeout = timerset (tenths * 10);	do	{		if (PEEKBYTE () >= 0)			return MODEM_IN ();		if (!CARRIER)			return RCDO;		if (CheckCancel ())			return -1;		time_release ();	}	while (!timeup (timeout));	return TIMEOUT;}/*--------------------------------------------------------------------------*//* Z PUT STRING                                                             *//* Send a string to the modem, processing for \336 (sleep 1 sec)            *//* and \335 (break signal, ignored)                                         *//*--------------------------------------------------------------------------*/void Z_PutString (register unsigned char *s){	register unsigned c;	while (*s)	{		switch (c = *s++)		{		case (unsigned short) '\336':			big_pause (2);			break;		case (unsigned short) '\335':			/* Should send a break on this */			break;		default:			SENDBYTE ((unsigned char) c, NULL);		}							/* switch */	}								/* while */	Z_UncorkTransmitter ();}									/* Z_PutString *//*--------------------------------------------------------------------------*//* Z SEND HEX HEADER                                                        *//* Send ZMODEM HEX header hdr of type type                                  *//*--------------------------------------------------------------------------*/void Z_SendHexHeader (unsigned short type, register unsigned char *hdr){	register short n;	register short i;	register unsigned short crc;	Z_UncorkTransmitter ();		/* Get our transmitter going */#ifdef DEBUG	show_debug_name ("Z_SendHexHeader");#endif	SENDBYTE (ZPAD, NULL);	SENDBYTE (ZPAD, NULL);	SENDBYTE (ZDLE, NULL);	SENDBYTE (ZHEX, NULL);	Z_PUTHEX (i, type);	Crc32t = 0;	crc = Z_UpdateCRC (type, 0);	for (n = 4; --n >= 0;)	{		Z_PUTHEX (i, (*hdr));		crc = Z_UpdateCRC (((unsigned short) (*hdr++)), crc);	}	Z_PUTHEX (i, (crc >> 8));	Z_PUTHEX (i, crc);	/* Make it printable on remote machine */	SENDBYTE ('\r', NULL);	SENDBYTE ('\n', NULL);	/* Uncork the remote in case a fake XOFF has stopped data flow */	if (type != ZFIN && type != ZACK)		SENDBYTE (021, NULL);	if (!CARRIER)		CLEAR_OUTBOUND ();}								/* Z_SendHexHeader *//*--------------------------------------------------------------------------*//* Z UNCORK TRANSMITTER                                                     *//* Wait a reasonable amount of time for transmitter buffer to clear.        *//*   When it does, or when time runs out, turn XON/XOFF off then on.        *//*   This should release a transmitter stuck by line errors.                *//*--------------------------------------------------------------------------*/void Z_UncorkTransmitter (){	long t;#ifdef DEBUG	show_debug_name ("Z_UncorkTransmitter");#endif	if (!OUT_EMPTY () && CARRIER)	{		t = timerset (5 * Rxtimeout);	/* Wait for silence */		while (!timeup (t) && !OUT_EMPTY () && CARRIER)			time_release ();				/* Give up slice while waiting  */	}//	com_kick ();}/*--------------------------------------------------------------------------*//* Z GET HEADER                                                             *//* Read a ZMODEM header to hdr, either binary or hex.                       *//*   On success, set Zmodem to 1 and return type of header.                 *//*   Otherwise return negative on error                                     *//*--------------------------------------------------------------------------*/short Z_GetHeader (unsigned char * hdr){	register short c;	unsigned long n;	short cancount;#ifdef DEBUG	show_debug_name ("Z_GetHeader");#endif//	n = (unsigned long) cur_baud.rate_value;	/* Max characters before start of frame */	n = (unsigned long) cur_baud;				/* Max characters before start of frame */		cancount = 5;Again:	if (CheckCancel ())	{		send_can ();//		z_log ("MSG_TXT (M_KBD_MSG)");		return ZCAN;	}	Rxframeind = Rxtype = 0;	switch (c = _Z_TimedRead ())	{	case ZPAD:	case ZPAD | 0200:		/*-----------------------------------------------*/		/* This is what we want.                         */		/*-----------------------------------------------*/		break;	case RCDO:	case TIMEOUT:		goto Done;	case CAN:GotCan:		if (--cancount <= 0)		{			c = ZCAN;			goto Done;		}		switch (c = Z_GetByte (1))		{		case TIMEOUT:			goto Again;		case ZCRCW:			c = ERROR;			/* fallthrough... */		case RCDO:			goto Done;		case CAN:			if (--cancount <= 0)			{				c = ZCAN;				goto Done;			}			goto Again;		}		/* fallthrough... */	default:Agn2:		if (--n <= 0)		{//			z_log ("MSG_TXT (M_FUBAR_MSG)");			return ERROR;		}		if (c != CAN)			cancount = 5;		goto Again;	}							/* switch */	cancount = 5;Splat:	switch (c = _Z_TimedRead ())	{	case ZDLE:		/*-----------------------------------------------*/		/* This is what we want.                         */		/*-----------------------------------------------*/		break;	case ZPAD:		goto Splat;	case RCDO:	case TIMEOUT:		goto Done;	default:		goto Agn2;	}							/* switch */	switch (c = _Z_TimedRead ())	{	case ZBIN:		Rxframeind = ZBIN;		Crc32 = 0;		c = _Z_GetBinaryHeader (hdr);		break;	case ZBIN32:		Crc32 = Rxframeind = ZBIN32;		c = _Z_32GetBinaryHeader (hdr);		break;	case ZHEX:		Rxframeind = ZHEX;		Crc32 = 0;		c = _Z_GetHexHeader (hdr);		break;	case CAN:		goto GotCan;	case RCDO:	case TIMEOUT:		goto Done;	default:		goto Agn2;	}							/* switch */	Rxpos = _Z_PullLongFromHeader (hdr);Done:	return c;}								/* Z_GetHeader *//*--------------------------------------------------------------------------*//* Z GET BINARY HEADER                                                      *//* Receive a binary style header (type and position)                        *//*--------------------------------------------------------------------------*/static short _Z_GetBinaryHeader (register unsigned char *hdr){	register short c;	register unsigned short crc;	register short n;#ifdef DEBUG	show_debug_name ("Z_GetBinaryHeader");#endif	if ((c = Z_GetZDL ()) & ~0xFF)		return c;	Rxtype = c;	crc = Z_UpdateCRC (c, 0);	for (n = 4; --n >= 0;)	{		if ((c = Z_GetZDL ()) & ~0xFF)			return c;		crc = Z_UpdateCRC (c, crc);		*hdr++ = (unsigned char) (c & 0xff);	}	if ((c = Z_GetZDL ()) & ~0xFF)		return c;	crc = Z_UpdateCRC (c, crc);	if ((c = Z_GetZDL ()) & ~0xFF)		return c;	crc = Z_UpdateCRC (c, crc);	if (crc & 0xFFFF)	{//		z_message ("MSG_TXT (M_CRC_MSG)");		return ERROR;	}	return Rxtype;}								/* _Z_GetBinaryHeader *//*--------------------------------------------------------------------------*//* Z GET BINARY HEADER with 32 bit CRC                                      *//* Receive a binary style header (type and position)                        *//*--------------------------------------------------------------------------*/static short _Z_32GetBinaryHeader (register unsigned char *hdr){	register short c;	register unsigned long crc;	register short n;#ifdef DEBUG	show_debug_name ("Z_32GetBinaryHeader");#endif	if ((c = Z_GetZDL ()) & ~0xFF)		return c;	Rxtype = c;	crc = 0xFFFFFFFF;	crc = Z_32UpdateCRC (c, crc);	for (n = 4; --n >= 0;)	{		if ((c = Z_GetZDL ()) & ~0xFF)			return c;		crc = Z_32UpdateCRC (c, crc);		*hdr++ = (unsigned char) (c & 0xff);	}	for (n = 4; --n >= 0;)	{		if ((c = Z_GetZDL ()) & ~0xFF)			return c;		crc = Z_32UpdateCRC (c, crc);	}	if (crc != 0xDEBB20E3)	{//		z_message ("MSG_TXT (M_CRC_MSG)");		return ERROR;	}	return Rxtype;}								/* _Z_32GetBinaryHeader *//*--------------------------------------------------------------------------*//* Z GET HEX HEADER                                                         *//* Receive a hex style header (type and position)                           *//*--------------------------------------------------------------------------*/static short _Z_GetHexHeader (register unsigned char *hdr){	register short c;	register unsigned short crc;	register short n;#ifdef DEBUG	show_debug_name ("Z_GetHexHeader");#endif	if ((c = _Z_GetHex ()) < 0)		return c;	Rxtype = c;	crc = Z_UpdateCRC (c, 0);	for (n = 4; --n >= 0;)	{		if ((c = _Z_GetHex ()) < 0)			return c;		crc = Z_UpdateCRC (c, crc);		*hdr++ = (unsigned char) c;	}	if ((c = _Z_GetHex ()) < 0)		return c;	crc = Z_UpdateCRC (c, crc);	if ((c = _Z_GetHex ()) < 0)		return c;	crc = Z_UpdateCRC (c, crc);	if (crc & 0xFFFF)	{//		z_message ("MSG_TXT (M_CRC_MSG)");		return ERROR;	}	if (Z_GetByte (1) == '\r')		(void) Z_GetByte (1);	/* Throw away possible cr/lf */	return Rxtype;}/*--------------------------------------------------------------------------*//* Z GET HEX                                                                *//* Decode two lower case hex digits into an 8 bit byte value                *//*--------------------------------------------------------------------------*/static short _Z_GetHex (){	register short c, n;#ifdef DEBUG	show_debug_name ("Z_GetHex");#endif	if ((n = _Z_TimedRead ()) < 0)		return n;	n -= '0';	if (n > 9)		n -= ('a' - ':');	if (n & ~0xF)		return ERROR;	if ((c = _Z_TimedRead ()) < 0)		return c;	c -= '0';	if (c > 9)		c -= ('a' - ':');	if (c & ~0xF)		return ERROR;	return ((n << 4) | c);}/*--------------------------------------------------------------------------*//* Z GET ZDL                                                                *//* Read a byte, checking for ZMODEM escape encoding                         *//* including CAN*5 which represents a quick abort                           *//*--------------------------------------------------------------------------*/short Z_GetZDL (){	register short c, rr;	if ((c = Z_GetByte (Rxtimeout)) != ZDLE)		return c;	switch (c = Z_GetByte (Rxtimeout))	{	case CAN:		return ((c = Z_GetByte (Rxtimeout)) < 0) ? c :			((c == CAN) && ((c = Z_GetByte (Rxtimeout)) < 0)) ? c :			((c == CAN) && ((c = Z_GetByte (Rxtimeout)) < 0)) ? c : (GOTCAN);	case ZCRCE:	case ZCRCG:	case ZCRCQ:	case ZCRCW:		if (tmail_chat)		{			do {							rr = Z_GetByte (Rxtimeout);				//		¥	Incoming chat's byte in rr. ASCIZ string in GAP.							} while (rr);		}		return (c | GOTOR);	case ZRUB0:		return 0x7F;	case ZRUB1:		return 0xFF;	default:		return (c < 0) ? c :			((c & 0x60) == 0x40) ? (c ^ 0x40) : ERROR;	}							/* switch */}								/* Z_GetZDL *//*--------------------------------------------------------------------------*//* Z TIMED READ                                                             *//* Read a character from the modem line with timeout.                       *//*  Eat parity, XON and XOFF characters.                                    *//*--------------------------------------------------------------------------*/static short _Z_TimedRead (){	register short c;#ifdef DEBUG	show_debug_name ("Z_TimedRead");#endif	for (;;)	{		if ((c = Z_GetByte (Rxtimeout)) < 0)			return c;		switch (c &= 0x7F)		{		case XON:		case XOFF:			continue;		default:			if (!(c & 0x60))				continue;			/* Else fall through */		case '\r':		case '\n':		case ZDLE:			return c;		}						/* switch */	}							/* for */}								/* _Z_TimedRead *//*--------------------------------------------------------------------------*//* Z LONG TO HEADER                                                         *//* Store long integer pos in Txhdr                                          *//*--------------------------------------------------------------------------*/void Z_PutLongIntoHeader (long pos){#ifdef FASTER	*((long *)Txhdr) = endlong (pos);#else	Txhdr[ZP0] = pos;			//	0	Txhdr[ZP1] = pos >> 8;		//	1	Txhdr[ZP2] = pos >> 16;		//	2	Txhdr[ZP3] = pos >> 24;		//	3#endif}								/* Z_PutLongIntoHeader *//*--------------------------------------------------------------------------*//* Z PULL LONG FROM HEADER                                                  *//* Recover a long integer from a header                                     *//*--------------------------------------------------------------------------*/static long _Z_PullLongFromHeader (unsigned char *hdr){#ifdef FASTER	return endlong (*((long *)hdr));#else	long l;	l = hdr[ZP3];	l = (l << 8) | hdr[ZP2];	l = (l << 8) | hdr[ZP1];	l = (l << 8) | hdr[ZP0];	return l;#endif}								/* _Z_PullLongFromHeader *//* END OF FILE: zmisc.c */