#include <stdio.h>#include <string.h>#include <stdlib.h>#include <Serial.h>#include <CommResources.h>#include <CRMSerialDevices.h>#include <Connections.h>#include <CTBUtilities.h>#include <MacTCP.h>#include "AddressXlation.h"#include "myTCP.h"#include "Main.h"#include "PascalStr.h"#include "zmodem.h"#include "Comm.h"#include "Timing.h"#include "log.h"#include "Scheduler.h"#include "pmain.h"//#define	FASTER//	#include "debugging.h"#define	CREFNUM(x)	(x).ioCRefNumextern	long	defaultPort, listenPort;extern	short	isdcd;extern	Boolean	BUSY;			/* Processing send operation */extern	short	VMPresent;extern	Ptr		configStr;extern	long	accept_calls_mask;extern	unsigned long	cur_baud;extern	Options		Settings;				/* Current options */extern	char		SerialDMA;extern	Boolean		Aborted;extern	char		ctb_mon;static	short		INPUT = 0;		/* Current input reference number */static	short		OUTPUT = 0;		/* Current output reference number */static	ConnHandle	conn = NULL;	/* Current connection if CTB using */static	StreamPtr	stream_out;typedef struct {	TCPiopb	pb;	long	a5;	} iTCPiopb;static	iTCPiopb	gpb_out;static	iTCPiopb	opb_out;static	wdsEntry	wds[2];static	ip_addr		localIP			= 0;static	ip_port		localPort		= 0;static	long		localMask		= 0;static	ip_addr		remoteIP		= 0;static	ip_port		remotePort		= 0;static	Ptr		inputBuffer = 0;	/* Current input buffer *///static	Ptr		outputBuffer = 0;	/* Current output buffer */static	short	hhhack;extern	Str255	lstnr1, lstnr2;		short	CONNECTION;			//	connection mode == port number or -1 for CTBenum {	uppCompleterProcInfo = kPascalStackBased,	uppCMCompleterProcInfo = kPascalStackBased		 | STACK_ROUTINE_PARAMETER(1, SIZE_CODE(sizeof(Handle)))};static	UniversalProcPtr		uupCompleter;static	ConnectionCompletionUPP	uupListner, uupListnerOpen, uupCMComplete;static	IPIOCompletionUPP		uupTCPListner, uupTCPComplete;/*ееееееееееееееееееееееееееееееееееееееееееееееееееееееееееее*///	#define	TSIZE	8192//	#define	TSIZE	0x2000L	#define	TSIZE	0x4000Ltypedef struct {	unsigned char	buf[TSIZE];	short			rpos;	short			wpos;	short			inbuf;} BufferType;static BufferType		*txBuf;static BufferType		*rxBuf;static unsigned char	*tmpbuf;static unsigned long B[] = {			/* Baud rates we support */	300,		/* 0 */	600,		/* 1 */	1200,		/* 2 */	2400,		/* 3 */	4800,		/* 4 */	9600,		/* 5 */	19200,		/* 6 */	38400,		/* 7 */	57600,		/* 8 */	0};static short Baud[] = {			/* Baud rates we support */	baud300,					/* 0 */	baud600,					/* 1 */	baud1200,					/* 2 */	baud2400,					/* 3 */	baud4800,					/* 4 */	baud9600,					/* 5 */	baud19200,					/* 6 */	baud38400,					/* 7 */	baud57600					/* 8 */};static short Data[] = {			/* Data bits we support */	data7,						/* 0 */	data8						/* 1 */};static short Parity[] = {		/* Parity options we support */	noParity,					/* 0 */	evenParity,					/* 1 */	oddParity					/* 2 */};static short StopBits[] = {		/* Stop bits we support */	stop10,						/* 0 */	stop20						/* 1 */};static pascal void	StrToAddrResultProc (struct hostInfo *aHostInfo, Ptr userdata)	/* utility routine for StrToAddr */{#pragma unused (aHostInfo, userdata)	/* why bother when we can simply watch the aHostInfo.rtnCode? */}static OSErr TCPDotAddress (char *dotAddress, ip_addr *ipAddress){	OSErr				err;	struct hostInfo		aHostInfo;			/* a data structure for the DNR function */#if defined(powerc) || defined(__powerc)		ResultUPP			uupStrToAddrResultProc;	uupStrToAddrResultProc = NewResultProc (StrToAddrResultProc);#endif	err = OpenResolver((char *) 0);	if (err)	{		putlog ('~', "OpenResolver %d", err);		return err;	}		/* ask the DNR function to get the IP address */#if defined(powerc) || defined(__powerc)	StrToAddr (dotAddress, &aHostInfo, uupStrToAddrResultProc, NULL);#else	StrToAddr (dotAddress, &aHostInfo, StrToAddrResultProc, NULL);#endif	/* wait for the address information or some error other than cacheFault to occur */	while (cacheFault == aHostInfo.rtnCode)		;	err = CloseResolver();	if (err)	{		putlog ('~', "CloseResolver %d", err);#if defined(powerc) || defined(__powerc)		DisposeRoutineDescriptor (uupStrToAddrResultProc);#endif		return err;	}	/* if it was an error there isn't much more we can do here but let the caller know */	if (noErr != aHostInfo.rtnCode)	{		putlog ('~', "rtnCode %d", aHostInfo.rtnCode);		err = aHostInfo.rtnCode;#if defined(powerc) || defined(__powerc)		DisposeRoutineDescriptor (uupStrToAddrResultProc);#endif		return err;	}		/* use the first IP address for this host */	*ipAddress = aHostInfo.addr[0];#if defined(powerc) || defined(__powerc)		DisposeRoutineDescriptor (uupStrToAddrResultProc);#endif					return err;}static OSErr TCPIPAddress (ip_addr ipAddress, char *dotAddress){	OSErr				err;//	struct hostInfo		aHostInfo;			/* a data structure for the DNR function */	err = OpenResolver((char *) 0);	if (err)	{		return err;	}		/* ask the DNR function to get the address by IP */	AddrToStr (ipAddress, dotAddress);	err = CloseResolver();					return err;}static void SubstedCfgSet (char *subs1, char *subs2){	OSErr	err;		long	len;	char	*p, *q, *newcfg;		len = strlen (configStr);	len += strlen (subs1);	len += strlen (subs2);	newcfg = NewPtrClear (len+1);		p = configStr;	q = newcfg;		while (*p)	{		if (*p == 'б')		{			p++;						if (*p == '1')			{				strcpy (q, subs1);				q += strlen (subs1);			}			else				if (*p == '2')				{					strcpy (q, subs2);					q += strlen (subs2);				}			p++;		}		else			*q++ = *p++;	}		*q = 0;	putlog ('~', "%s", newcfg);	err = CMSetConfig (conn, newcfg);	DisposePtr (newcfg);}/*ееееееееееееееееееееееееееееееееееееееееееееееееееееееееееее*/////	Allocate internal i/o buffer//static Boolean buffer_new (void){	if (!(txBuf = (BufferType *) NewPtr (sizeof(BufferType))))		return false;	if (!(rxBuf = (BufferType *) NewPtr (sizeof(BufferType))))		return false;	if (!(tmpbuf = (unsigned char *) NewPtr (TSIZE)))		return false;		return true;}/*ееееееееееееееееееееееееееееееееееееееееееееееееееееееееееее*/////	Init internal i/o buffer//static void buffer_init (BufferType *buf){	buf->rpos = 0;	buf->wpos = 0;	buf->inbuf = 0;}/*ееееееееееееееееееееееееееееееееееееееееееееееееееееееееееее*/////	Get buffer filled size//#ifndef FASTERstatic short buffer_vol (BufferType *buf){	return buf->inbuf;}#else#define buffer_vol(b)	(b)->inbuf#endif/*ееееееееееееееееееееееееееееееееееееееееееееееееееееееееееее*/////	Get buffer free space size//#ifndef FASTERstatic short buffer_left (BufferType *buf){	return TSIZE - buf->inbuf;}#else#define buffer_left(b)	(TSIZE - (b)->inbuf)#endif/*ееееееееееееееееееееееееееееееееееееееееееееееееееееееееееее*/////	Get one char from buffer//static unsigned char buffer_get (BufferType *buf){	unsigned char	result;		if(buf->inbuf)	{		result = buf->buf[buf->rpos];		buf->rpos = (buf->rpos+1) & (TSIZE - 1);		buf->inbuf--;		return result;	}	else	{		DebugStr ("\pbuffer_get - empty");		return 0;	}}/*ееееееееееееееееееееееееееееееееееееееееееееееееееееееееееее*/////	Get one char from buffer (w/o fetching)//#ifndef FASTERstatic unsigned char buffer_peek (BufferType *buf){	if (buf->inbuf)		return buf->buf[buf->rpos];	else	{		DebugStr ("\pbuffer_peek - empty");		return 0;	}}#else#define buffer_peek(b)	((b)->buf[(b)->rpos])#endif/*ееееееееееееееееееееееееееееееееееееееееееееееееееееееееееее*/////	Put one char to buffer//static void buffer_put (BufferType *buf, unsigned char ch){	if(buf->inbuf < TSIZE)	{		buf->buf[buf->wpos] = ch;		buf->wpos = (buf->wpos+1) & (TSIZE - 1);		buf->inbuf++;	}	else	{		DebugStr ("\pbuffer_put - full");	}}/*ееееееееееееееееееееееееееееееееееееееееееееееееееееееееееее*//*ееееееееееееееееееееееееееееееееееееееееееееееееееееееееееее*/static Boolean fill_rxbuff (void){	short			i;	long			numchar = 0, count;	unsigned short	count2;	CntrlParam		c;	IOParam			b;	CMBufferSizes	sizes;	CMStatFlags		status;		OSErr			err;	CMFlags			flags;	//TCPiopb			pb;	TCPStatusPB		tcp_status;		if (buffer_vol (rxBuf))		return true;	if (CONNECTION == -1)	{		err = CMStatus (conn, (long *) &sizes, &status);		if (err == noErr)		{			if (status & cmStatusOpen)			{				if (status & cmStatusDataAvail)				{					count = (buffer_left (rxBuf) > sizes[cmDataIn]) ? sizes[cmDataIn] : buffer_left (rxBuf);										err = CMRead (conn, tmpbuf, &count, cmData, false, NULL, 0, &flags);					if (err != noErr)						return false;										for (i = 0; i < count; i++)						buffer_put (rxBuf, tmpbuf[i]);				}			}		}	}	else		if (CONNECTION == -2)		{			err = _TCPStatus ((TCPiopb *) &gpb_out, stream_out, &tcp_status, NULL, NULL, false);			if (err == noErr)			{//				putlog ('~', "_TCPStatus = %d", gpb_out.pb.csParam.status.connectionState);				if (gpb_out.pb.csParam.status.amtUnreadData != 0)				{					count2 = (buffer_left (rxBuf) > gpb_out.pb.csParam.status.amtUnreadData) ? gpb_out.pb.csParam.status.amtUnreadData : buffer_left (rxBuf);										err = _TCPRcv ((TCPiopb *) &gpb_out, stream_out, (Ptr) tmpbuf, &count2, NULL, NULL, false);					if (err != noErr)						return false;										for (i = 0; i < count2; i++)						buffer_put (rxBuf, tmpbuf[i]);				}			}		}		else		{			CREFNUM(c) = INPUT;			c.csCode = 2;			if (PBStatusSync ((ParmBlkPtr)&c))				return false;						if (numchar = *(long *)&c.csParam[0])			{				b.ioRefNum = INPUT;				b.ioBuffer = (Ptr)tmpbuf;				b.ioReqCount = (buffer_left (rxBuf) > numchar) ? numchar : buffer_left (rxBuf);								if (PBReadSync ((ParmBlkPtr)&b))					return false;									if (b.ioActCount != b.ioReqCount)					DebugStr ("\pfill_rxbuff - read&avail mismatch!");								for (i = 0; i < b.ioActCount; i++)					buffer_put (rxBuf, tmpbuf[i]);			}		}		return buffer_vol (rxBuf);}/*ееееееееееееееееееееееееееееееееееееееееееееееееееееееееееее*/Boolean CHAR_AVAIL (void){	return fill_rxbuff ();}/*ееееееееееееееееееееееееееееееееееееееееееееееееееееееееееее*/short MODEM_IN (void){	unsigned char c;	long		bigtimer;		bigtimer = timerset (3600);	while (!fill_rxbuff() && !timeup (bigtimer));		if (fill_rxbuff())		c = buffer_get (rxBuf);	else		c = 0;	return c;}/*ееееееееееееееееееееееееееееееееееееееееееееееееееееееееееее*/short PEEKBYTE (void){	if (fill_rxbuff())		return buffer_peek (rxBuf);	else		return -1;}/*ееееееееееееееееееееееееееееееееееееееееееееееееееееееееееее*/short TIMED_READ (short t, void (*idle)(void)){	long t1;	if (!CHAR_AVAIL ())	{		t1 = timerset ((long)t * 100L);		while (!CHAR_AVAIL ())		{			if (timeup (t1))			{				return (EOF);			}		 /*          * This should work because we only do TIMED_READ when we have          * carrier          */			if (!CARRIER)			{				return (EOF);			}						if (idle == NULL)				time_release ();			else				idle ();		}	}	return ((unsigned short) (MODEM_IN ()) & 0x00ff);}/*ееееееееееееееееееееееееееееееееееееееееееееееееееееееееееее*//*ееееееееееееееееееееееееееееееееееееееееееееееееееееееееееее*/#if defined(powerc) || defined(__powerc)#elseasm static pascal void SendComplete (void){		MOVE.L	-4(A0),A0	/* Get busy flag address */		CLR.B	(A0)		/* Clear the busy flag (FALSE) */		RTS}#endifstatic	Boolean	*BSY;static pascal void CMSendComplete (ConnHandle conn){#if defined(powerc) || defined(__powerc)//#pragma unused a5#else	long             a5;	a5 = SetA5(CMGetRefCon (conn));#endif	switch ((**conn).errCode)	{	case noErr :		{			*BSY = false;		}		break;	}#if defined(powerc) || defined(__powerc)#else	(void) SetA5(a5);#endif}static void TCPSendComplete (TCPiopb *iopb){#if defined(powerc) || defined(__powerc)#else	long             a5;	a5 = SetA5(((iTCPiopb *)iopb)->a5);#endif	switch (iopb->ioResult)	{	case noErr:			*BSY = false;		break;		case inProgress:			break;			default:		//	Something awfull happen			break;	}#if defined(powerc) || defined(__powerc)#else	(void) SetA5(a5);#endif}/*ееееееееееееееееееееееееееееееееееееееееееееееееееееееееееее*/static void SerialSend (register unsigned char *buffer, register long count, register Boolean *busy){	static struct {				/* Must be static! */		Boolean		*busy;		/* TRUE while sending */		IOParam		b;	} param;	CMBufferSizes	sizes;	CMStatFlags		status;		OSErr			err;//	CMFlags			flags;	long			icount;//	TCPiopb			pb;//	TCPStatusPB		tcp_status;			*busy = true;	if (CONNECTION == -1)	{		BSY = busy;				err = CMStatus (conn, (long *) &sizes, &status);		if (err == noErr)		{			if (status & cmStatusOpen)			{				if (!(status & cmStatusDWPend))				{					icount = count;#if defined(powerc) || defined(__powerc)					err = CMWrite (conn, buffer, &icount, cmData, true, uupCMComplete, -1, 0);#else					err = CMWrite (conn, buffer, &icount, cmData, true, CMSendComplete, -1, 0);#endif				}			}		}	}	else		if (CONNECTION == -2)		{			BSY = busy;			/* send data to the remote host */			wds[0].ptr = (Ptr) buffer;			wds[0].length = count;			wds[1].ptr = NULL;			wds[1].length = 0;#if defined(powerc) || defined(__powerc)			err = _TCPSend((TCPiopb *) &gpb_out, stream_out, (wdsEntry *) &wds, NULL, uupTCPComplete, true);#else			err = _TCPSend((TCPiopb *) &gpb_out, stream_out, (wdsEntry *) &wds, NULL, TCPSendComplete, true);#endif		}		else		{			param.busy = busy;#if defined(powerc) || defined(__powerc)			param.b.ioCompletion = uupCompleter;#else			param.b.ioCompletion = SendComplete;#endif			param.b.ioRefNum = OUTPUT;			param.b.ioBuffer = (Ptr)buffer;			param.b.ioReqCount = count;			PBWriteAsync ((ParmBlkPtr)&param.b);		/* Asynchrone */		}}/*ееееееееееееееееееееееееееееееееееееееееееееееееееееееееееее*/void SENDBYTE (unsigned char c, void (*idle)(void)){	long		bigtimer;		SerialSend ( &c, 1L, &BUSY );	bigtimer = timerset (3600);	while (BUSY && !timeup (bigtimer))		if (idle == NULL)			timer (1);		else			idle ();		if (BUSY)	{		CLEAR_OUTBOUND ();		BUSY = false;		Aborted = true;	}}/*ееееееееееееееееееееееееееееееееееееееееееееееееееееееееееее*/void SENDCHARS (unsigned char *c, long len, short fuflo, void (*idle)(void)){#pragma unused (fuflo)	long		bigtimer;		SerialSend ( c, len, &BUSY );	bigtimer = timerset (3600);	while (BUSY && !timeup (bigtimer))		if (idle == NULL)			timer (1);		else			idle ();		if (BUSY)	{		CLEAR_OUTBOUND ();		BUSY = false;		Aborted = true;	}}/*ееееееееееееееееееееееееееееееееееееееееееееееееееееееееееее*/Boolean OUT_EMPTY (void){	return !BUSY;}/*ееееееееееееееееееееееееееееееееееееееееееееееееееееееееееее*//* ----- Check CTS/DCD ------------------------------------------------- *//*	Pin number	Signal name		Signal description		1			HSKo		Output Handshake (SCC DTR output)		2			HSKi		Input Handshake (SCC CTS input)		7			GPi			General-purpose input (SCC DCD input)*//*#ifdef QUICK_AND_DIRTYBoolean SerialCTS(void){	register Byte r;	if (!INPUT || PORTNO < 1 || PORTNO > 2)		return FALSE;	r = *(SCCRd + ((PORTNO == 2) ? 0 : 2));		// SCC channel A/B control	return !(r & 0x20);							// CTS is bit 5}#elseBoolean SerialCTS(void){	CntrlParam c;	if (!INPUT)		return 0;	CREFNUM(c) = INPUT;	c.csCode = 8;	if (!PBStatus((ParmBlkPtr)&c, FALSE))		return !((SerStaRec *)&c.csParam[0])->ctsHold;	return 0;}#endif*/Boolean SerialDCD (void){	OSErr			err;	register Byte	r;	TCPStatusPB		tcp_status;	if (CONNECTION > 0 && CONNECTION < 3)	{		if (!(isdcd & 0x00FF))			return true;														// 2 is Printer !		r = *(LMGetSCCRd () + (2-CONNECTION)*2);		// SCC channel A/B control		return (r & 0x08) != 0;							// DCD is bit 3	}	else		if (CONNECTION == -2)		{			err = _TCPStatus ((TCPiopb *) &gpb_out, stream_out, &tcp_status, NULL, NULL, false);			if (err == noErr)			{//				putlog ('~', "_TCPStatus = %d", gpb_out.pb.csParam.status.connectionState);				return (gpb_out.pb.csParam.status.connectionState == 8);			}//			return true;	//е??			return false;		}		else			return true;}//ееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееBoolean SerialCTS (void){	SerStaRec		serSta;	CMBufferSizes	sizes;	CMStatFlags		status;		OSErr			err;	register Byte	r;	if (CONNECTION == -1)	{		err = CMStatus (conn, (long *) &sizes, &status);		if (err == noErr)		{			if (status & cmStatusOpen)			{				return !(status & cmStatusDWPend);			}		}	}	else		if (CONNECTION == -2)		{			return true; //е???		}		else		{			if (!hhhack)				return true;			else				if (hhhack == 1)				{					if (SerStatus(OUTPUT,&serSta) == noErr)						return (serSta.xOffHold == 0);					else						return true;				}				else				{					if (CONNECTION > 0 && CONNECTION < 3)					{						r = *(LMGetSCCRd () + (2-CONNECTION)*2);	// SCC channel A/B control						return (r & 0x20) == 0;						// CTS is bit 5					}					else						if (SerStatus(OUTPUT,&serSta) == noErr)							return	(serSta.ctsHold == 0);						else							return true;				}		}	return true;			//	? why not...?}void UNBUFFER_BYTES (void (*idle)(void)){	short			numch, i;	long			bigtimer;	numch = buffer_vol (txBuf);	if(numch && CARRIER)	{		bigtimer = timerset (3600);		while ((!SerialCTS () || BUSY) && !timeup (bigtimer))			if (idle == NULL)				timer (1);			else				idle ();				if (BUSY || !SerialCTS ())		{			CLEAR_OUTBOUND ();			BUSY = false;			Aborted = true;		}		else		{			if(numch == 1)				SENDBYTE (buffer_get (txBuf), idle);			else			{				for(i=0; i < numch; i++)					tmpbuf[i] = buffer_get(txBuf);								SENDCHARS (tmpbuf, numch, 1, idle);			}		}	}}/*ееееееееееееееееееееееееееееееееееееееееееееееееееееееееееее*/void BUFFER_BYTE (unsigned char ch, void (*idle)(void)){	if (!buffer_left (txBuf))		/* If buffer full, then empty it */		UNBUFFER_BYTES(idle);		buffer_put (txBuf, ch);		/* Add character to buffer */}/*ееееееееееееееееееееееееееееееееееееееееееееееееееееееееееее*//*ееееееееееееееееееееееееееееееееееееееееееееееееееееееееееее*/void CLEAR_OUTBOUND (void){	CntrlParam b;	if (CONNECTION == -1)	{	    CMIOKill (conn, cmDataOut);	}	else		if (CONNECTION == -2)		{				}		else		{			CREFNUM(b) = OUTPUT;			b.ioCompletion = 0;			if (PBKillIOSync ((ParmBlkPtr)&b))				DebugStr ("\pCLEAR_OUTBOUND");		}		buffer_init (txBuf);}/*ееееееееееееееееееееееееееееееееееееееееееееееееееееееееееее*/void CLEAR_INBOUND (void){	CntrlParam b;	if (CONNECTION == -1)	{	    CMIOKill (conn, cmDataIn);	}	else		if (CONNECTION == -2)		{		}		else		{			CREFNUM(b) = INPUT;						b.ioCompletion = 0;			if (PBKillIOSync ((ParmBlkPtr)&b))				DebugStr ( "\pCLEAR_INBOUND" );		}		buffer_init (rxBuf);}/*ееееееееееееееееееееееееееееееееееееееееееееееееееееееееееее*/static	Boolean		ringring;static	short		ringres;static pascal void CMListner (ConnHandle conn){	long			a5;//	CMFlags			flags;	OSErr			err;	CMBufferSizes	sizes;	CMStatFlags		status;		a5 = SetA5(CMGetRefCon(conn));	switch ((**conn).errCode)	{	case noErr :		{			err = CMStatus (conn, (long *) &sizes, &status);						if (status & cmStatusIncomingCallPresent)				ringring = true;			else				ringring = false;		}		break;	}	(void) SetA5(a5);}static pascal void CMListnerOpen (ConnHandle conn){	long			a5;//	CMFlags			flags;	OSErr			err;	CMBufferSizes	sizes;	CMStatFlags		status;		a5 = SetA5(CMGetRefCon(conn));	switch ((**conn).errCode)	{	case noErr :		{			err = CMStatus (conn, (long *) &sizes, &status);						if (status & cmStatusOpen)				ringring = true;			else				ringring = false;		}		break;		default:			ringring = true;		break;	}	ringres = (**conn).errCode;	(void) SetA5(a5);}static void TCPListner (TCPiopb *iopb){//	OSErr			err;//	TCPiopb			pb;//	TCPStatusPB		tcp_status;#if defined(powerc) || defined(__powerc)#else	long             a5;	a5 = SetA5(((iTCPiopb *)iopb)->a5);#endif	ringres = iopb->ioResult;	switch (iopb->ioResult)	{	case noErr:		remoteIP = iopb->csParam.open.remoteHost;			remotePort = iopb->csParam.open.remotePort;	//		localIP = iopb->csParam.open.localHost;			localPort = iopb->csParam.open.localPort;		ringring = true;		break;		case inProgress:			ringring = false;		ringres = noErr;		break;			default:		//	Something awfull happen		ringring = false;	//е	?		break;	}#if defined(powerc) || defined(__powerc)#else	(void) SetA5(a5);#endif}/*ееееееееееееееееееееееееееееееееееееееееееееееееееееееееееее*/static void SerialDTR (register Boolean how)	/* FALSE: negate, TRUE:assert */{	CntrlParam		c;	OSErr			err;	CMBufferSizes	sizes;	CMStatFlags		status;		TCPStatusPB		tcp_status;	if (CONNECTION == -1)		//	dtr usualy using for dropping connection... check it later.	{		err = CMStatus (conn, (long *) &sizes, &status);		if (err == noErr)		{			if (status & (cmStatusOpen | cmStatusOpening | cmStatusClosing))			{				err = CMAbort (conn);				err = CMClose (conn, false, NULL, 0, true);			}			else				if ((status & cmStatusListenPend) && !(accept_calls_mask & GotCurrentEvtMask ()))				{					err = CMClose (conn, false, NULL, 0, true);					return;				}							if (!(status & cmStatusListenPend) && (accept_calls_mask & GotCurrentEvtMask ()))			{				SubstedCfgSet ((char *) &lstnr1[1], (char *) &lstnr2[1]);			#if defined(powerc) || defined(__powerc)				err = CMListen (conn, true, uupListner, -1);#else				err = CMListen (conn, true, CMListner, -1);#endif			}		}	}	else		if (CONNECTION == -2)		{			err = _TCPStatus ((TCPiopb *) &gpb_out, stream_out, &tcp_status, NULL, NULL, false);//			if (err == noErr)//			{				putlog ('~', "DTR>> err = %d, _TCPStatus = %d", err, gpb_out.pb.csParam.status.connectionState);//				switch (gpb_out.pb.csParam.status.connectionState)//				{//				case 0:		//	no connection exists on this stream//				case 20:	//	connection is being broken//				//					if (accept_calls_mask & GotCurrentEvtMask ())//					{//						localIP = 0;//						localPort = listenPort;//						remoteIP = 0;//						remotePort = 0;//#if defined(powerc) || defined(__powerc)//						err = _TCPPassiveOpen ((TCPiopb *) &opb_out, stream_out, &remoteIP, &remotePort, &localIP, &localPort, NULL, uupTCPListner, true);//#else//						err = _TCPPassiveOpen ((TCPiopb *) &opb_out, stream_out, &remoteIP, &remotePort, &localIP, &localPort, NULL, TCPListner, true);//#endif////						putlog ('~', "DTR>> _TCPPassiveOpen = %d", err);//					}//					break;//				//				case 2:		//	listening for incoming connection//				//					if (!(accept_calls_mask & GotCurrentEvtMask ()))//					{//						err = _TCPClose ((TCPiopb *) &gpb_out, stream_out, NULL, NULL, false);//						putlog ('~', "DTR>> _TCPClose = %d", err);//						err = _TCPAbort ((TCPiopb *) &gpb_out, stream_out, NULL, NULL, false);//						putlog ('~', "DTR>> _TCPAbort = %d", err);//					}//				//					break;//				//				case 4:		//	incoming connection is being established//				case 6:		//	outgoing connection is being established//				case 8:		//	connection is up//				case 10:	//	connection is up; close has been issued//				case 12:	//	connection is up; close has been completed//				case 14:	//	connection is up; close has been received//				case 16:	//	connection is up; close has been issued and received//				case 18:	//	connection is up; close has been issued and received					err = _TCPAbort ((TCPiopb *) &opb_out, stream_out, NULL, NULL, false);					putlog ('~', "DTR>> _TCPAbort = %d", err);//					err = _TCPClose ((TCPiopb *) &gpb_out, stream_out, NULL, NULL, false);//					putlog ('~', "DTR>> _TCPClose = %d", err);					if (accept_calls_mask & GotCurrentEvtMask ())					{//						localIP = 0;						localPort = listenPort;						remoteIP = 0;						remotePort = 0;#if defined(powerc) || defined(__powerc)						err = _TCPPassiveOpen ((TCPiopb *) &opb_out, stream_out, &remoteIP, &remotePort, &localIP, &localPort, NULL, uupTCPListner, true);//						err = _TCPPassiveOpen ((TCPiopb *) &gpb_out, stream_out, &remoteIP, &remotePort, &localIP, &localPort, NULL, uupTCPListner, true);#else						err = _TCPPassiveOpen ((TCPiopb *) &opb_out, stream_out, &remoteIP, &remotePort, &localIP, &localPort, NULL, TCPListner, true);//						err = _TCPPassiveOpen ((TCPiopb *) &gpb_out, stream_out, &remoteIP, &remotePort, &localIP, &localPort, NULL, TCPListner, true);#endif						putlog ('~', "DTR>> _TCPPassiveOpen = %d", err);					}					err = _TCPStatus ((TCPiopb *) &gpb_out, stream_out, &tcp_status, NULL, NULL, false);					putlog ('~', "DTR>> err = %d, _TCPStatus = %d", err, gpb_out.pb.csParam.status.connectionState);//					break;//				}//			}		}		else		{			CREFNUM(c) = OUTPUT;			c.csCode = how ? 17 : 18;			PBControlSync ((ParmBlkPtr)&c);		}}void RAISE_DTR(void){	SerialDTR (true);}void LOWER_DTR(void){	SerialDTR (false);}/*ееееееееееееееееееееееееееееееееееееееееееееееееееееееееееее*/Boolean OpenSerial (StringPtr portname, short setup, short hsk){	CntrlParam		c;	register SerShk	*handshake;	short			err;//	long			streamBufLen;	Str255			input, output;	char			s[256];		CRMRec			cc;	CRMRecPtr		cPtr = &cc;	CRMSerialPtr	serialPtr;	GetAddrParamBlock	gapb;	ringring = false;	if (portname[0] == 0xFF)	{//	ееееееееееееееееееееееееее//	е	It is unusual I/O ports//	е	TCP/IP here			CONNECTION = -2;			if (!buffer_new ())			return false;				while (VMPresent)		{			if (err = HoldMemory (txBuf, sizeof (BufferType)))			{				putlog (lgALRT, "Can't hold VM for txBuf (err = %d)", err);				VMPresent = false;				break;			}						if (err = HoldMemory (rxBuf, sizeof (BufferType)))			{				putlog (lgALRT, "Can't hold VM for rxBuf (err = %d)", err);				VMPresent = false;				break;			}					if (err = HoldMemory (tmpbuf, TSIZE))			{				putlog (lgALRT, "Can't hold VM for tmpbuf (err = %d)", err);				VMPresent = false;				break;			}			break;		}				buffer_init (txBuf);		buffer_init (rxBuf);		if (!(inputBuffer = NewPtr (0x8000L)))		{			return false;		}		if (VMPresent)			if (err = HoldMemory (inputBuffer, 0x8000L))			{				putlog (lgALRT, "Can't hold VM for inputBuffer (err = %d)", err);				VMPresent = false;			}		err = _TCPInit ();		if (err != noErr)		{			putlog ('~', "_TCPInit = %d", err);			return false;		}			err = _TCPGetIP (&gapb, &localIP, &localMask, NULL, false);		if (err != noErr)		{			putlog ('~', "_TCPGetIP in = %d", err);			return false;		}		TCPIPAddress (localIP, s);		putlog ('~', "local %s:%ld", s, (long)listenPort);		opb_out.a5 = SetCurrentA5 ();		gpb_out.a5 = SetCurrentA5 ();			err = _TCPCreate ((TCPiopb *) &gpb_out, &stream_out, inputBuffer, 0x8000L, NULL, NULL, NULL, false);		if (err != noErr)		{			putlog ('~', "_TCPCreate in = %d", err);			return false;		}		#if defined(powerc) || defined(__powerc)		uupTCPListner = NewIPIOCompletionProc ((ProcPtr) TCPListner);		uupTCPComplete = NewIPIOCompletionProc ((ProcPtr) TCPSendComplete);#endif		if (accept_calls_mask & GotCurrentEvtMask ())		{//			localIP = 0;			localPort = listenPort;			remoteIP = 0;			remotePort = 0;#if defined(powerc) || defined(__powerc)			err = _TCPPassiveOpen ((TCPiopb *) &opb_out, stream_out, &remoteIP, &remotePort, &localIP, &localPort, NULL, uupTCPListner, true);//			err = _TCPPassiveOpen ((TCPiopb *) &gpb_out, stream_out, &remoteIP, &remotePort, &localIP, &localPort, NULL, uupTCPListner, true);#else			err = _TCPPassiveOpen ((TCPiopb *) &opb_out, stream_out, &remoteIP, &remotePort, &localIP, &localPort, NULL, TCPListner, true);//			err = _TCPPassiveOpen ((TCPiopb *) &gpb_out, stream_out, &remoteIP, &remotePort, &localIP, &localPort, NULL, TCPListner, true);#endif			putlog ('~', "_TCPPassiveOpen in = %d", err);		}	}	else	{		CONNECTION = 0;		cc.crmDeviceType = crmSerialDevice;		cc.crmDeviceID   = 0;				while (cPtr)		{			cPtr = (CRMRecPtr)CRMSearch((CRMRecPtr)cPtr);						if (cPtr)			{				CONNECTION++;				serialPtr = (CRMSerialPtr)cPtr->crmAttributes;								if (!pStrComp (*(serialPtr->name), portname))				{					pStrCopy (*(serialPtr->inputDriverName), input);					pStrCopy (*(serialPtr->outputDriverName), output);					break;				}				cc.crmDeviceID = cPtr->crmDeviceID;			}		}				if (cPtr)		{	//	ееееееееееееееееееееееееее	//	е	It is usual I/O ports			#if defined(powerc) || defined(__powerc)			Handle			hndl;			hndl = Get1Resource ('proc', 128);			if (!hndl)			{				putlog (lgALRT, "RavelMAIL corrupted");				return false;			}						uupCompleter = NewRoutineDescriptor ((ProcPtr) *hndl, uppCompleterProcInfo, kM68kISA);			#endif			hhhack = hsk;		//	е	Create tile buffers			if (!buffer_new ())			{				putlog (lgALRT, "Can't create buffers");				return false;			}						while (VMPresent)			{				if (err = HoldMemory (txBuf, sizeof (BufferType)))				{					putlog (lgALRT, "Can't hold VM for txBuf (err = %d)", err);					VMPresent = false;					break;				}								if (err = HoldMemory (rxBuf, sizeof (BufferType)))				{					putlog (lgALRT, "Can't hold VM for rxBuf (err = %d)", err);					VMPresent = false;					break;				}							if (err = HoldMemory (tmpbuf, TSIZE))				{					putlog (lgALRT, "Can't hold VM for tmpbuf (err = %d)", err);					VMPresent = false;					break;				}				break;			}						buffer_init (txBuf);			buffer_init (rxBuf);		//	е	Open drivers			if (err = OpenDriver(output, &OUTPUT))			{				putlog (lgALRT, "Can't open output driver err = %d.", err);				return false;			}			if (err = OpenDriver(input, &INPUT))			{				putlog (lgALRT, "Can't open input driver err = %d.", err);				CloseDriver(OUTPUT);	/* Output open error */				return false;			}		//	е	Set input driver's buffer			if (!(inputBuffer = NewPtr (0x7FF0)))			{				putlog (lgALRT, "Not enough memory.");				CloseSerial ();				return false;			}			if (VMPresent)				if (err = HoldMemory (inputBuffer, 0x7FF0L))				{					putlog (lgALRT, "Can't hold VM for inputBuffer (err = %d)", err);					VMPresent = false;				}			if (SerSetBuf(INPUT, inputBuffer, 0x7FF0))			{				putlog (lgALRT, "Can't set input buffer.");				CloseSerial ();				return false;			}					//	е	Setup handshaking			CREFNUM(c) = OUTPUT;			c.csCode = 14;				/* SerHShake */			handshake = (SerShk *)&c.csParam[0];			handshake->fXOn = 0;		/* no XON/XOFF output flow control */			handshake->fCTS = 0;		/* CTS (input) hardware handshake */			handshake->xOn  = 0x00;		/* XON character */			handshake->xOff = 0x00;		/* XOFF character */			handshake->errs = 0;		/* Ignore input errors */			handshake->evts = 0;		/* No device driver events */			handshake->fInX = 0;		/* no XON/XOFF input flow control */			handshake->fDTR = 0;		/* DTR (output) hardware handshake */			switch (hsk)			{				case 1:		/* XON/XOFF */					handshake->fXOn = 1;	/* XON/XOFF output flow control */					handshake->xOn  = 0x11;	/* XON character (ctrl-Q) */					handshake->xOff = 0x13;	/* XOFF character (ctrl-S) */					break;				case 2:		/* CTS */					handshake->fCTS = 1;	/* CTS (input) hardware handshake */					break;				case 3:		/* DTR */					handshake->fDTR = 1;	/* DTR (output) hardware handshake */					break;				case 4:		/* CTS/DTR */					handshake->fCTS = handshake->fDTR = 1;					break;			}						PBControlSync ((ParmBlkPtr)&c);		//	е	Setup drivers options			SerReset (OUTPUT, setup);			SerReset (INPUT, setup);						if (SerialDMA)			{				CREFNUM(c) = OUTPUT;				c.csCode = (SerialDMA == 1) ? kSERD115KBaud : kSERD230KBaud;				if (PBControlSync ((ParmBlkPtr)&c) != noErr)				{					putlog (lgALRT, "High-speed SerialDMA driver is not supported with this Mac.");					CloseSerial ();					return false;				}				CREFNUM(c) = INPUT;				c.csCode = (SerialDMA == 1) ? kSERD115KBaud : kSERD230KBaud;				if (PBControlSync ((ParmBlkPtr)&c) != noErr)				{					putlog (lgALRT, "High-speed SerialDMA driver is not supported with this Mac.");					CloseSerial ();					return false;				}			}					return true;		}#ifndef LITE		else		{	//	ееееееееееееееееееееееееее	//	е	It is unusual I/O ports	//	е	try find CommTools					CMBufferSizes	bSizes;			short			procID;			OSErr			err;//			char			flags;			#if defined(powerc) || defined(__powerc)			uupListner = NewRoutineDescriptor ((ProcPtr) CMListner, uppCMCompleterProcInfo, GetCurrentISA ());			uupListnerOpen = NewRoutineDescriptor ((ProcPtr) CMListnerOpen, uppCMCompleterProcInfo, GetCurrentISA ());			uupCMComplete = NewRoutineDescriptor ((ProcPtr) CMSendComplete, uppCMCompleterProcInfo, GetCurrentISA ());#endif			procID = CMGetProcID (portname);							if (procID == -1)				return false;		//	no such CTB						memset (&bSizes, 0, sizeof (bSizes));			conn = CMNew (procID, cmData | ((ctb_mon) ? 0 : (cmNoMenus | cmQuiet)), (long *) &bSizes, SetCurrentA5 (), 0L);			if (!conn)				return false;						if (configStr)				err = CMSetConfig (conn, configStr);			CONNECTION = -1;			if (!buffer_new ())				return false;						while (VMPresent)			{				if (err = HoldMemory (txBuf, sizeof (BufferType)))				{					putlog (lgALRT, "Can't hold VM for txBuf (err = %d)", err);					VMPresent = false;					break;				}								if (err = HoldMemory (rxBuf, sizeof (BufferType)))				{					putlog (lgALRT, "Can't hold VM for rxBuf (err = %d)", err);					VMPresent = false;					break;				}							if (err = HoldMemory (tmpbuf, TSIZE))				{					putlog (lgALRT, "Can't hold VM for tmpbuf (err = %d)", err);					VMPresent = false;					break;				}				break;			}						buffer_init (txBuf);			buffer_init (rxBuf);			if (accept_calls_mask & GotCurrentEvtMask ())			{				SubstedCfgSet ((char *) &lstnr1[1], (char *) &lstnr2[1]);#if defined(powerc) || defined(__powerc)				err = CMListen (conn, true, uupListner, -1);#else				err = CMListen (conn, true, CMListner, -1);#endif				if (err != noErr)					return false;			}		}#else		else			return false;#endif	}	return true;}void CloseSerial (void){	OSErr          err;	CMBufferSizes  sizes;	CMStatFlags    status;	//	TCPStatusPB		tcp_status;		long			streamBufLen;	if (VMPresent)	{		UnholdMemory (txBuf, sizeof (BufferType));		UnholdMemory (rxBuf, sizeof (BufferType));		UnholdMemory (tmpbuf, TSIZE);				if (CONNECTION >= 0)			UnholdMemory (inputBuffer, 0x7FF0L);	}		if (CONNECTION == -1)	{		err = CMStatus (conn, (long *) &sizes, &status);		if (err == noErr)		{			if (status & (cmStatusOpen | cmStatusListenPend))			{				err = CMClose (conn, false, NULL, 0, true);			}		}				CMDispose (conn);#if defined(powerc) || defined(__powerc)		DisposeRoutineDescriptor (uupListner);		DisposeRoutineDescriptor (uupListnerOpen);		DisposeRoutineDescriptor (uupCMComplete);#endif	}	else		if (CONNECTION == -2)		{			if (VMPresent)				UnholdMemory (inputBuffer, 0x8000L);			err = _TCPAbort ((TCPiopb *) &opb_out, stream_out, NULL, NULL, false);//			err = _TCPClose ((TCPiopb *) &gpb_out, stream_out, NULL, NULL, false);			streamBufLen = 0x8000L;			err = _TCPRelease ((TCPiopb *) &gpb_out, stream_out, &inputBuffer, &streamBufLen, NULL, false);#if defined(powerc) || defined(__powerc)			DisposeRoutineDescriptor (uupTCPListner);			DisposeRoutineDescriptor (uupTCPComplete);#endif		}		else		{			SerSetBuf(INPUT, inputBuffer, 0);			CloseDriver(INPUT);			CloseDriver(OUTPUT);#if defined(powerc) || defined(__powerc)			DisposeRoutineDescriptor (uupCompleter);#endif		}}/* ----- Get serial port setup ----------------------------------------- */short SerialGetSetup(	register short setup,	//* Serial chip setup word *	short *baud,			//* 0=300 Baud ... *	short *data,			//* 0=7 bits ... *	short *parity,			//* 0=none ... *	short *stop)			//* 0=1 stop bits ... *{	register short i;	register short v;	*baud = *data = *parity = *stop = 0;	v = setup & 0x03FF;					//* Baud rate: bits 9 - 0 *	for (i = 0; i < sizeof(Baud)/sizeof(short); i++)		if (v == Baud[i]) {			*baud = i;			break;		}	if (i >= sizeof(Baud)/sizeof(short))		return 1;	v = setup & 0x0C00;					//* Data bits: bits 11 - 10 *	for (i = 0; i < sizeof(Data)/sizeof(short); i++)		if (v == Data[i]) {			*data = i;			break;		}	if (i >= sizeof(Data)/sizeof(short))		return 2;	v = setup & 0x3000;					//* Parity: bits 13 - 12 *	for (i = 0; i < sizeof(Parity)/sizeof(short); i++)		if (v == Parity[i]) {			*parity = i;			break;		}	if (i >= sizeof(Parity)/sizeof(short))		return 3;	v = setup & 0xC000;					//* Stop bits: bits 15 - 14 *	for (i = 0; i < sizeof(StopBits)/sizeof(short); i++)		if (v == StopBits[i]) {			*stop = i;			break;		}	if (i >= sizeof(StopBits)/sizeof(short))		return 4;	return 0;}/* ----- Set serial port setup ----------------------------------------- */short SerialSetSetup(	register short baud,	//* 0=300 Baud ... *	register short data,	//* 0=7 bits ... *	register short parity,	//* 0=none ... *	register short stop,	//* 0=1 stop bits ... *	register short *setup)	//* Serial chip setup word *{	*setup = Baud[0] | Data[0] | Parity[0] | StopBits[0];	if (baud < 0 || baud >= sizeof(Baud)/sizeof(short))		return 1;	if (data < 0 || data >= sizeof(Data)/sizeof(short))		return 2;	if (parity < 0 || parity >= sizeof(Parity)/sizeof(short))		return 3;	if (stop < 0 || stop >= sizeof(StopBits)/sizeof(short))		return 4;	*setup = Baud[baud] | Data[data] | Parity[parity] | StopBits[stop];	return 0;}void SerialReset (register short setup)	/* Serial chip setup word */{	CntrlParam		c;	if (CONNECTION >= 0)	{		SerReset(OUTPUT, setup);		SerReset(INPUT, setup);			if (SerialDMA)		{			CREFNUM(c) = INPUT;			c.csCode = (SerialDMA == 1) ? kSERD115KBaud : kSERD230KBaud;			PBControlSync ((ParmBlkPtr)&c);			CREFNUM(c) = OUTPUT;			c.csCode = (SerialDMA == 1) ? kSERD115KBaud : kSERD230KBaud;			PBControlSync ((ParmBlkPtr)&c);		}	}}#define	FAILURE		0#define	IGNORE		1#define	CONNECTED	2#define	RINGING		3#define INCOMING	4#define	FAULTCOUNT	5#define	FAULTIMMED	6short MakeTCPOpen (char *number){	char	s1[256], s2[256], *p, *q;	short	i, j;	TCPStatusPB		tcp_status;	OSErr			err;	//	long			streamBufLen;	long			end_time;	putlog ('~', "+MakeTCPOpen: entry");	q = s1;	s2[0] = 0;	p = number;	while (*p)	{		if (*p == ':')			break;		else			*q++ = *p++;	}		*q = 0;		if (*p)	{		strcpy (s2, p+1);	}	if ((err = TCPDotAddress (s1, &remoteIP)) != noErr)	{		putlog ('~', "TCPDotAddress fault %d", err);		return FAILURE;	}		if (s2[0])		remotePort = atol (s2);	else		remotePort = defaultPort;		//	was 0?	err = _TCPStatus ((TCPiopb *) &gpb_out, stream_out, &tcp_status, NULL, NULL, false);	if (err == noErr)	{		putlog ('~', "_TCPStatus = %d", gpb_out.pb.csParam.status.connectionState);		switch (gpb_out.pb.csParam.status.connectionState)		{		case 0:		//	no connection exists on this stream		case 20:	//	connection is being broken						break;					case 2:		//	listening for incoming connection					err = _TCPAbort ((TCPiopb *) &opb_out, stream_out, NULL, NULL, false);			putlog ('~', "_TCPAbort (after listen) = %d", err);//			err = _TCPClose ((TCPiopb *) &gpb_out, stream_out, NULL, NULL, false);//			putlog ('~', "_TCPClose (after listen) = %d", err);			break;				case 4:		//	incoming connection is being established		case 6:		//	outgoing connection is being established		case 8:		//	connection is up		case 10:	//	connection is up; close has been issued		case 12:	//	connection is up; close has been completed		case 14:	//	connection is up; close has been received		case 16:	//	connection is up; close has been issued and received		case 18:	//	connection is up; close has been issued and received			err = _TCPAbort ((TCPiopb *) &opb_out, stream_out, NULL, NULL, false);			putlog ('~', "_TCPAbort (after :) = %d", err);//			err = _TCPClose ((TCPiopb *) &gpb_out, stream_out, NULL, NULL, false);//			putlog ('~', "_TCPClose (after :) = %d", err);			break;		}	}//	localIP = 0;	localPort = 0;#if defined(powerc) || defined(__powerc)	err = _TCPActiveOpen ((TCPiopb *) &gpb_out, stream_out, remoteIP, remotePort, &localIP, &localPort, NULL, uupTCPListner, true);#else	err = _TCPActiveOpen ((TCPiopb *) &gpb_out, stream_out, remoteIP, remotePort, &localIP, &localPort, NULL, TCPListner, true);#endif	if (err == noErr)	{		end_time = timerset (9000);		ringring = false;		ringres = noErr;		while (!ringring && !ringres && !CheckCancel () && !timeup (end_time));	}	if (Aborted)		err = cmUserCancel;	else		if (timeup (end_time))			err = cmTimeOut;		else			err = ringres;		ringring = false;	if (err == noErr)	{		j = Settings.portSetup & 0x03FF;				for ( i=0; B[i]; i++ )			if (j == Baud[i])				break;						cur_baud = (B[i]) ? B[i] : 12345L;		putlog ('&', "CONNECT %ld/TCP (%s)", cur_baud, number);		return CONNECTED;	}	else	{		putlog ('~', "_TCPActiveOpen = %d", err);		putlog ('&', "FAILED (%d)", err);		if (accept_calls_mask & GotCurrentEvtMask ())		{//			localIP = 0;			localPort = listenPort;			remoteIP = 0;			remotePort = 0;#if defined(powerc) || defined(__powerc)			err = _TCPPassiveOpen ((TCPiopb *) &opb_out, stream_out, &remoteIP, &remotePort, &localIP, &localPort, NULL, uupTCPListner, true);//			err = _TCPPassiveOpen ((TCPiopb *) &gpb_out, stream_out, &remoteIP, &remotePort, &localIP, &localPort, NULL, uupTCPListner, true);#else			err = _TCPPassiveOpen ((TCPiopb *) &opb_out, stream_out, &remoteIP, &remotePort, &localIP, &localPort, NULL, TCPListner, true);//			err = _TCPPassiveOpen ((TCPiopb *) &gpb_out, stream_out, &remoteIP, &remotePort, &localIP, &localPort, NULL, TCPListner, true);#endif			putlog ('~', "_TCPPassiveOpen = %d", err);		}		return FAILURE;	}}short MakeCMOpen (char *number){	OSErr	err;	CMBufferSizes  sizes;	CMStatFlags    status;		ConnEnvironRec	CER;	char	s1[256], s2[256], *p, *q;	short	i, j;	long	end_time;	err = CMStatus (conn, (long *) &sizes, &status);	if (err == noErr)	{		if (status & (cmStatusOpen | cmStatusListenPend))		{			err = CMClose (conn, false, NULL, 0, true);		}	}	q = s1;	s2[0] = 0;	p = number;	while (*p)	{		if (*p == ':')			break;		else			*q++ = *p++;	}		*q = 0;		if (*p)	{		strcpy (s2, p+1);	}	SubstedCfgSet (s1, s2);#if defined(powerc) || defined(__powerc)	err = CMOpen (conn, true, uupListnerOpen, -1);#else	err = CMOpen (conn, true, CMListnerOpen, -1);#endif		if (err == noErr)	{		end_time = timerset (7000);		ringring = false;		while (!ringring && !CheckCancel () && !timeup (end_time));	}		putlog ('~', "CMOpen = %d", err);		if (Aborted)		err = cmUserCancel;	else		if (timeup (end_time))			err = cmTimeOut;		else			err = ringres;		ringring = false;	switch (err)	{	case cmNoErr:			break;	case cmRejected:		putlog ('&', "BUSY");		return FAILURE;		break;	case cmTimeOut:	case cmFailed:			putlog ('&', "FAILED (%d)", err);		return FAULTCOUNT;		break;	case cmUnknownError:	case cmGenericError:	case cmNotSupported:	case cmNoTools:			putlog ('&', "ERROR (%d)", err);		return FAULTIMMED;		break;			case cmUserCancel:				putlog ('&', "Escaped");		return FAILURE;		break;	}		err = CMStatus (conn, (long *) &sizes, &status);	if (err == noErr)	{		if (status & cmStatusOpen)		{			err = CMGetConnEnvirons (conn, &CER);			putlog ('~', "CMGetConnEnvirons = %d", err);			if (err == noErr)			{				cur_baud = (CER.baudRate) ? CER.baudRate : 12345L;			}			else			{				j = Settings.portSetup & 0x03FF;								for ( i=0; B[i]; i++ )					if (j == Baud[i])						break;										cur_baud = (B[i]) ? B[i] : 12345L;			}						putlog ('&', "CONNECT %ld/CTB", cur_baud);			return CONNECTED;		}		else		{			putlog ('&', "ERROR (%d)", err);			return FAULTIMMED;		}	}	else	{		putlog ('&', "ERROR (%d)", err);		return FAULTIMMED;	}}Boolean MakeCMAccept (Boolean accpt){	OSErr	err = noErr;//	TCPStatusPB		tcp_status;	char			s[256];	short			i, j;	ConnEnvironRec	CER;			if (CONNECTION == -1)	{		err = CMAccept (conn, accpt);		if (err != noErr)		{			putlog ('~', "CMAccept in = %d", err);			return false;		}				err = CMGetConnEnvirons (conn, &CER);		putlog ('~', "CMGetConnEnvirons = %d", err);		if (err == noErr)		{			cur_baud = (CER.baudRate) ? CER.baudRate : 12345L;		}		else		{			j = Settings.portSetup & 0x03FF;						for ( i=0; B[i]; i++ )				if (j == Baud[i])					break;								cur_baud = (B[i]) ? B[i] : 12345L;		}				putlog ('&', "CONNECT %ld/CTB", cur_baud);		err = noErr;	}	else		if (CONNECTION == -2)		{			TCPIPAddress (remoteIP, s);			if (!accpt)			{				putlog (lgATTN, "Rejecting (%s:%ld)", s, (long) remotePort);							err = _TCPAbort ((TCPiopb *) &opb_out, stream_out, NULL, NULL, false);//				err = _TCPClose ((TCPiopb *) &gpb_out, stream_out, NULL, NULL, false);				if (accept_calls_mask & GotCurrentEvtMask ())				{//					localIP = 0;					localPort = listenPort;					remoteIP = 0;					remotePort = 0;#if defined(powerc) || defined(__powerc)					err = _TCPPassiveOpen ((TCPiopb *) &opb_out, stream_out, &remoteIP, &remotePort, &localIP, &localPort, NULL, uupTCPListner, true);//					err = _TCPPassiveOpen ((TCPiopb *) &gpb_out, stream_out, &remoteIP, &remotePort, &localIP, &localPort, NULL, uupTCPListner, true);#else					err = _TCPPassiveOpen ((TCPiopb *) &opb_out, stream_out, &remoteIP, &remotePort, &localIP, &localPort, NULL, TCPListner, true);//					err = _TCPPassiveOpen ((TCPiopb *) &gpb_out, stream_out, &remoteIP, &remotePort, &localIP, &localPort, NULL, TCPListner, true);#endif					putlog ('~', "_TCPPassiveOpen in = %d", err);				}			}			else			{				j = Settings.portSetup & 0x03FF;								for ( i=0; B[i]; i++ )					if (j == Baud[i])						break;										cur_baud = (B[i]) ? B[i] : 12345L;				putlog ('&', "CONNECT %ld/TCP (%s:%ld)", cur_baud, s, (long) remotePort);			}		}		ringring = false;	return err == noErr;}Boolean INVOKE (void){	if (CONNECTION < 0)	{		return ringring;	}	else		return CHAR_AVAIL ();}void send_can (void){	short	i;	CLEAR_OUTBOUND ();	CLEAR_INBOUND ();	for (i = 0; i < 10; i++)		SENDBYTE (CAN, NULL);	for (i = 0; i < 10; i++)		SENDBYTE (BS, NULL);}void do_break (Boolean doit){	if (CONNECTION >= 0)	{		if (doit)			SerSetBrk (OUTPUT);		else			SerClrBrk (OUTPUT);	}}void mioCMResume (Boolean flag){	if (CONNECTION == -1)	{		CMResume (conn, flag);	}}void mioCMIdle (void){	if (CONNECTION == -1)	{		CMIdle (conn);	}}void mioCMEvent (long refCon, EventRecord *event){	if (CONNECTION == -1 && ((long)conn) == refCon)	{		CMEvent (conn, event);	}}