/*--------------------------------------------------------------------------*//*                                                                          *//*                                                                          *//*      ------------         Bit-Bucket Software, Co.                       *//*      \ 10001101 /         Writers and Distributors of                    *//*       \ 011110 /          Freely Available<tm> Software.                 *//*        \ 1011 /                                                          *//*         ------                                                           *//*                                                                          *//*              (C) Copyright 1987-96, Bit Bucket Software Co.              *//*                                                                          *//*                 This module was written by Rick Huebner                  *//*                 BinkleyTerm Janus revision 0.31, 11-2-89                 *//*                 Full-duplex WaZOO file transfer protocol                 *//*                                                                          *//*                                                                          *//*    For complete  details  of the licensing restrictions, please refer    *//*    to the License  agreement,  which  is published in its entirety in    *//*    the MAKEFILE and BT.C, and also contained in the file LICENSE.260.    *//*                                                                          *//*    USE  OF THIS FILE IS SUBJECT TO THE  RESTRICTIONS CONTAINED IN THE    *//*    BINKLEYTERM  LICENSING  AGREEMENT.  IF YOU DO NOT FIND THE TEXT OF    *//*    THIS  AGREEMENT IN ANY OF THE  AFOREMENTIONED FILES,  OR IF YOU DO    *//*    NOT HAVE THESE FILES,  YOU  SHOULD  IMMEDIATELY CONTACT BIT BUCKET    *//*    SOFTWARE CO.  AT ONE OF THE  ADDRESSES  LISTED BELOW.  IN NO EVENT    *//*    SHOULD YOU  PROCEED TO USE THIS FILE  WITHOUT HAVING  ACCEPTED THE    *//*    TERMS  OF  THE  BINKLEYTERM  LICENSING  AGREEMENT,  OR  SUCH OTHER    *//*    AGREEMENT AS YOU ARE ABLE TO REACH WITH BIT BUCKET SOFTWARE, CO.      *//*                                                                          *//*                                                                          *//* You can contact Bit Bucket Software Co. at any one of the following      *//* addresses:                                                               *//*                                                                          *//* Bit Bucket Software Co.        FidoNet  1:104/501, 1:343/491             *//* P.O. Box 460398                AlterNet 7:42/1491                        *//* Aurora, CO 80046               BBS-Net  86:2030/1                        *//*                                Internet f491.n343.z1.fidonet.org         *//*                                                                          *//* Please feel free to contact us at any time to share your comments about  *//* our software and/or licensing policies.                                  *//*                                                                          *//*--------------------------------------------------------------------------*//* Include this file before any other includes or defines! *///#include "includes.h"#include <stdio.h>#include <string.h>#include <time.h>#include "Comm.h"#include "janus.h"#include "zfiles.h"#include "zmodem.h"#include "Modem.h"#include "Timing.h"#include "compatible.h"#include "aglcrc.h"#include "PascalStr.h"#include "PKT.h"#include "Prefs.h"#include "Scheduler.h"#include "Unattended.h"#include "Attacher.h"#include "Pathes.h"#include "emsi.h"#include "wazoo.h"#include "log.h"#include "pmain.h"#include "freq.h"#include "myEnv.h"#include "history.h"extern unsigned char	Txbuf[WAZOOMAX + 16];extern unsigned long	cur_baud;	/* Current baud rate   */extern long				Rxpos;						/* Received file position    */extern short			isOriginator;extern short			gotta_mail;				// somewhat received with ZedZapextern short			gotta_xmail;				// somewhat received with ZedZapextern Boolean			Aborted;extern	in_outboundPtr	cur_over;		// current ptr for flostatic	in_outboundPtr	frq_over;		// current ptr for frqextern	in_outboundPtr	outbound;		// original ptrextern short		remote_capabilities;extern Boolean		emsi_session;extern ADDR			remote_addr;extern ADDR_LIST	remote_ads;extern EMSI_CALL_OPTIONS emsi_options;extern long			joho;extern h_pc_exch	pc_exch_pref;static long			rxstpos1;				/* Initial data position of file we're receiving   */static ADDR			*operate_addr;static ADDR_LIST	*next_oper;static Str255		flo_attacher;		//	full path to .?lo file w/o suffixstatic short		flo_method;			//	0	-	manual										//	3	-	hold										//	2	-	direct										//	1	-	crashstatic char			outboundname[PATHLEN];static ADDR			*operate_addr_frq;static ADDR_LIST	*next_oper_frq;static Str255		frq_attacher;		//	full path to .req file w/o suffixstatic short		frq_method;			//	0	-	manual										//	3	-	hold										//	2	-	direct										//	1	-	crashstatic	StringPtr	pollModes[4] = { "\p", "\p.CLO", "\p.DLO", "\p.HLO" };static short	errno;static long		ioCounter;static Ptr				attachlist;static Ptr				requestlist;static pfreq	nextfreq;static char		*request_template = "%s%s.R%02x";/* Private routines */static Boolean PathForOutbound (ADDR *oper, StringPtr flo);static void  getfname (unsigned short);static void  sendpkt (unsigned char *, short, short);static void  sendpkt32 (unsigned char *, short, short);static void  txbyte (unsigned char);static long  procfname (void);static unsigned char  rcvpkt (void);static void  rxclose (unsigned short);static void  endbatch (void);static void  update_y (void);static void  long_set_timer (unsigned long *, unsigned short);static short  long_time_gone (unsigned long *);static short  rcvrawbyte (void);static short  rxbyte (void);static short  get_filereq (unsigned char);static short record_reqfile (char *);	/* ** NOT ** !!! */static short timeof_reqfile (long);	/* ** NOT ** !!! */static unsigned char  get_reqname (unsigned char);static void  mark_done (char *);/* Common with HYDRA.C */void j_message (unsigned short, char *,...);void j_status (char *,...);void j_msgend (short);short j_error (char *, char *);void xfer_summary (char *, char *, long *, short);void update_status (long *, long *, long, short *, short);long through (long *, long *);/* Private data. I know, proper software design says you shouldn't make data *//* global unless you really need to.  In this case speed and code size make  *//* it more important to avoid constantly pushing & popping arguments.        */static char *GenericError = "!%s";static char *ReqTmpTempl = "JANUSREQ.%02x";static char ReqTmp[16];static char *Rxbuf;				/* Address of packet reception buffer              */static char *Txfname;			/* Full path of file we're sending                 */static char *Rxfname;			/* Full path of file we're receiving               */static unsigned char *Rxbufptr;			/* Current position within packet reception buffer */static unsigned char *Rxbufmax;			/* Upper bound of packet reception buffer          */static unsigned char Do_after;			/* What to do with file being sent when we're done */static unsigned char WaitFlag;			/* Tells rcvrawbyte() whether or not to wait       */static unsigned char SharedCap;			/* Capability bits both sides have in common       */static short Txfile;				/* File handle of file we're sending               */static short Rxfile;				/* File handle of file we're receiving             */static short ReqRecorded;			/* Number of files obtained by this request        */static unsigned short TimeoutSecs;		/* How long to wait for various things             */static short Rxblklen;			/* Length of data in last data block packet recvd  */static short Next_y;				/* Number of next available line on screen         */static short Tx_y;				/* Line number of file transmission status display */static short Rx_y;				/* Line number of file reception status display    */static long Txlen;				/* Total length of file we're sending              */static long Rxlen;				/* Total length of file we're receiving            */static long Rxfiletime;			/* Timestamp of file we're receiving               */static long Diskavail;			/* Bytes available in upload directory             *///static long Txsttime;			/* Time at which we started sending current file   *///static long Rxsttime;			/* Time at which we started receiving current file */static short EMSI_flag;			/* Currently in EMSI-Session ?                     */static short EMSI_aka;			/* Current aka to send mail to                     */static short EMSI_raka;			/* Current aka to request files from               */static unsigned long	TxStart, RxStart;/*****************************************************************************//* Super-duper neato-whizbang full-duplex streaming ACKless batch file       *//* transfer protocol for use in WaZOO mail sessions                          *//*****************************************************************************/void Janus (void){	unsigned char xstate;				/* Current file transmission state                 */	unsigned char rstate;				/* Current file reception state                    */	unsigned char pkttype;				/* Type of packet last received                    */	unsigned char tx_inhibit;			/* Flag to wait and send after done receiving      */	char *holdname;				/* Name of hold area                               */	unsigned char fsent;					/* Did we manage to send anything this session?    */	unsigned char sending_req;			/* Are we currently sending requested files?       */	unsigned char attempting_req;		/* Are we waiting for the sender to start our req? */	unsigned char req_started;			/* Has the sender started servicing our request?   */	short txoldeta;				/* Last transmission ETA displayed                 */	short rxoldeta;				/* Last reception ETA displayed                    */	unsigned short blklen;				/* Length of last data block sent                  */	unsigned short txblklen;				/* Size of data block to try to send this time     */	unsigned short txblkmax;				/* Max size of data block to send at this speed    */	unsigned short goodneeded;			/* # good bytes to send before upping txblklen     */	unsigned short goodbytes;				/* Number of good bytes sent at this block size    */	unsigned short rpos_count;			/* Number of RPOS packets sent at this position    */	unsigned long xmit_retry;			/* Time to retransmit lost FNAMEPKT or EOF packet  */	long txpos;					/* Current position within file we're sending      */	long lasttx;				/* Position within file of last data block we sent */	long txstpos;				/* Initial data position of file we're sending     */	long rxstpos;				/* Initial data position of file we're receiving   */	long txoldpos;				/* Last transmission file position displayed       */	long rxoldpos;				/* Last reception file position displayed          */	unsigned long rpos_retry;			/* Time at which to retry RPOS packet              */	unsigned long brain_dead;			/* Time at which to give up on other computer      */	unsigned long rpos_sttime = 0;		/* Time at which we started current RPOS sequence  */	unsigned long last_rpostime;		/* Timetag of last RPOS which we performed         */	long last_blkpos;			/* File position of last out-of-sequence BLKPKT    *///	FILE *reqfile;				/* File handle for .REQ file                       */	short		eta;	long		cps;		Str255		pathname;		//	¥¥	Special for CHAT perversions	joho &= OURCAP;	Aborted = false;	nextfreq = NULL;//	sprintf (ReqTmp, ReqTmpTempl, 0 /*TaskNumber*/);//	set_prior (3);				/* Time Critical             *///	XON_DISABLE ();/*	if (un_attended && fullscreen)	{		clear_filetransfer ();		sb_show ();	}	else	{		set_xy (NULL);		Next_y = locate_y;	}*/	Tx_y = Rx_y = 0;	SharedCap = 0;	attachlist = NULL;	requestlist = NULL;	frq_method = 0;		/*------------------------------------------------------------------------*/	/* Allocate memory                                                        */	/*------------------------------------------------------------------------*/	Rxbuf = (char *) Txbuf + 4096 + 8;	Txfname = Rxfname = NULL;	if (((Txfname = NewPtr (PATHLEN)) == NULL)		|| ((Rxfname = NewPtr (PATHLEN)) == NULL))	{//		status_line (MSG_TXT (M_MEM_ERROR));		Aborted = true;		mdm_hangup (NULL);		goto freemem;	}	Rxbufmax = (unsigned char *) (Rxbuf + BUFMAX + 8);	/*------------------------------------------------------------------------*/	/* Initialize file transmission variables                                 */	/*------------------------------------------------------------------------*///¥¥	EMSI_flag = emsi_session;	if (EMSI_flag)	{		next_oper_frq = remote_ads.next;  /* This should be empty, but we'll go to the end anyway! */		operate_addr_frq = &(next_oper_frq->ad);	}	else		operate_addr_frq = &remote_addr;		EMSI_raka = 0;	/*	if (!no_EMSI_Session)	{		EMSI_flag = TRUE;		EMSI_aka = EMSI_raka = 0;		called_addr = remote_akas[EMSI_aka];	}	else		EMSI_flag = FALSE;*/	tx_inhibit = FALSE;	last_rpostime = last_blkpos = lasttx = txstpos = rxstpos = rxstpos1 = xmit_retry = 0L;	long_set_timer (&brain_dead, 120);	if (cur_baud > 9600L)	{		TimeoutSecs = 30;		txblkmax = BUFMAX;	}	else	{		TimeoutSecs = (unsigned short) (40960L / cur_baud);		if (TimeoutSecs < 30)			TimeoutSecs = 30;		txblkmax = (short)cur_baud / 300 * 128;		if (txblkmax > BUFMAX)			txblkmax = BUFMAX;	}	txblklen = txblkmax;	goodbytes = goodneeded = 0;	Txfile = -1;	sending_req = fsent = FALSE;	xstate = XSENDFNAME;	getfname (INITIAL_XFER);	/*------------------------------------------------------------------------*/	/* Initialize file reception variables                                    */	/*------------------------------------------------------------------------*///	holdname = HoldAreaNameMunge (&called_addr);//	(void) sprintf (Abortlog_name, "%s%s.Z\0", holdname, Hex_Addr_Str (&called_addr));//	if ((Diskavail = zfree (CURRENT.sc_Inbound)) <= 0L)		Diskavail = 0x7FFFFFF;	Rxbufptr = NULL;	rpos_retry = rpos_count = 0;	attempting_req = req_started = FALSE;	rstate = RRCVFNAME;	/*------------------------------------------------------------------------*/	/* Send and/or receive stuff until we're done with both                   */	/*------------------------------------------------------------------------*/	do	{							/* while (xstate || rstate)  *///		if (CheckCancel)		putMessage (0, "\p");		/*---------------------------------------------------------------------*/		/* If nothing useful (i.e. sending or receiving good data block) has   */		/* happened within the last 2 minutes, give up in disgust              */		/*---------------------------------------------------------------------*/		if (long_time_gone (&brain_dead))		{//			j_status (MSG_TXT (M_OTHER_DIED));	/* "He's dead, Jim." */			putlog (lgALRT, "He's dead, Jim.");			goto giveup;		}		/*---------------------------------------------------------------------*/		/* If we're tired of waiting for an ACK, try again                     */		/*---------------------------------------------------------------------*/		if (xmit_retry)		{			if (long_time_gone (&xmit_retry))			{//				j_message (Tx_y, MSG_TXT (M_TIMEOUT));				putMessage (0, "\pTimeout");								xmit_retry = 0L;				switch (xstate)				{				case XRCVFNACK:					xstate = XSENDFNAME;					break;				case XRCVFRNAKACK:					xstate = XSENDFREQNAK;					break;				case XRCVEOFACK:					errno = 0;//					if (lseek (Txfile, txpos = lasttx, SEEK_SET) == -1L)					if (SetFPos (Txfile, fsFromStart, txpos = lasttx))					{//						(void) j_error (MSG_TXT (M_SEEK_MSG), Txfname);						goto giveup;					}					xstate = XSENDBLK;					break;				}			}		}		/*---------------------------------------------------------------------*/		/* Transmit next part of file, if any                                  */		/*---------------------------------------------------------------------*/		switch (xstate)		{		case XSENDBLK:			if (tx_inhibit)				break;			lasttx = txpos;#ifdef FASTER			*((long *)Txbuf) = endlong (txpos);#else			Txbuf[0] = txpos & 0xff;			Txbuf[1] = (txpos >> 8) & 0xff;			Txbuf[2] = (txpos >> 16) & 0xff;			Txbuf[3] = (txpos >> 24) & 0xff;#endif			errno = 0;//			blklen = read (Txfile, Txbuf + sizeof (txpos), txblklen);//¥¥			ioCounter = txblklen;			FSRead (Txfile, &ioCounter, Txbuf + sizeof (txpos));			blklen = ioCounter;			//			if (j_error ("MSG_TXT (M_READ_MSG) %s", Txfname))//				goto giveup;			txpos += blklen;			sendpkt (Txbuf, sizeof (txpos) + blklen, BLKPKT);//			update_status (&txpos, &txoldpos, Txlen - txpos, &txoldeta, Tx_y);						eta = (short) ((((Txlen - txpos) * 10L) / cur_baud * 100L / JANUS_EFFICIENCY + 59L) / 60L);						if ((LMGetTicks () - TxStart) != 0)//				cps = ((((Txlen - txpos) * 60L) / (LMGetTicks () - TxStart)) * 1000L) / cur_baud;				cps = (((txpos - txstpos) * 60L) / (LMGetTicks () - TxStart));			else				cps = 0;						newMessage (lTSTAT, "%ld:%ld (%d) [%d min, %ld cps]", txpos, Txlen, blklen, eta, cps);			putMessage (0, "\p");						fsent = TRUE;			if (txpos >= Txlen || blklen < txblklen)			{				long_set_timer (&xmit_retry, TimeoutSecs);				xstate = XRCVEOFACK;			}			else				long_set_timer (&brain_dead, 120);			if (txblklen < txblkmax && (goodbytes += txblklen) >= goodneeded)			{				txblklen <<= 1;				goodbytes = 0;			}						break;		case XSENDFNAME:			blklen = (short) (strchr (strchr ((char *) Txbuf, '\0') + 1, '\0') - (char *) Txbuf) + 1;//			Txbuf[blklen++] = OURCAP;			Txbuf[blklen++] = joho;			sendpkt (Txbuf, blklen, FNAMEPKT);			txoldpos = txoldeta = -1;			long_set_timer (&xmit_retry, TimeoutSecs);			xstate = XRCVFNACK;			break;		case XSENDFREQNAK://			putlog (lgNOPE, "Remote has no requested file.");			sendpkt (NULL, 0, FREQNAKPKT);			long_set_timer (&xmit_retry, TimeoutSecs);			xstate = XRCVFRNAKACK;			break;		}		/*---------------------------------------------------------------------*/		/* Catch up on our reading; receive and handle all outstanding packets */		/*---------------------------------------------------------------------*/		while ((pkttype = rcvpkt ()) != 0)		{			if (pkttype != BADPKT)				long_set_timer (&brain_dead, 120);			switch (pkttype)			{				/*---------------------------------------------------------------*/				/* File data block or munged block                               */				/*---------------------------------------------------------------*/			case BADPKT:			case BLKPKT:				if (rstate == RRCVBLK)				{					unsigned long t;#ifdef FASTER					t = endlong (*((long *)Rxbuf));#else					t = (unsigned char) Rxbuf[3];					t = (t << 8) | (unsigned char) Rxbuf[2];					t = (t << 8) | (unsigned char) Rxbuf[1];					t = (t << 8) | (unsigned char) Rxbuf[0];//					t = (long) Rxbuf[0] +//						((long) Rxbuf[1] << 8) +//						((long) Rxbuf[2] << 16) +//						((long) Rxbuf[3] << 24);#endif					if (pkttype == BADPKT || (t != Rxpos))					{						if (pkttype == BLKPKT)						{							if (t < last_blkpos)								rpos_retry = rpos_count = 0;							last_blkpos = t;						}						if (long_time_gone (&rpos_retry))						{							/*---------------------------------------------------*/							/* If we're the called machine, and we're trying to  */							/* send stuff, and it seems to be screwing up our    */							/* ability to receive stuff, maybe this connection   */							/* just can't hack full-duplex.  Try waiting till    */							/* the sending system finishes before sending our    */							/* stuff to it                                       */							/*---------------------------------------------------*/							if (rpos_count > 4)							{								if (xstate && !isOriginator && !tx_inhibit)								{									tx_inhibit = TRUE;									putMessage (0, "\pSwitch to half-duplex");//									j_status (MSG_TXT (M_GOING_ONE_WAY));								}								rpos_count = 0;							}							if (++rpos_count == 1)								(void) time ((time_t *) & rpos_sttime);//							j_message (Rx_y, MSG_TXT (M_J_BAD_PACKET), Rxpos);							putMessage (0, "\pBad packet");#ifdef FASTER							*((long *)Rxbuf) = endlong (Rxpos);							*((long *)&Rxbuf[4]) = endlong (rpos_sttime);#else							Rxbuf[0] = Rxpos & 0xff;							Rxbuf[1] = (Rxpos >> 8) & 0xff;							Rxbuf[2] = (Rxpos >> 16) & 0xff;							Rxbuf[3] = (Rxpos >> 24) & 0xff;							Rxbuf[4] = rpos_sttime & 0xff;							Rxbuf[5] = (rpos_sttime >> 8) & 0xff;							Rxbuf[6] = (rpos_sttime >> 16) & 0xff;							Rxbuf[7] = (rpos_sttime >> 24) & 0xff;#endif							sendpkt ((unsigned char *) Rxbuf, sizeof (Rxpos) + sizeof (rpos_sttime), RPOSPKT);							long_set_timer (&rpos_retry, TimeoutSecs / 2);						}					}					else					{						last_blkpos = Rxpos;						rpos_retry = rpos_count = 0;						errno = 0;						//						(void) write (Rxfile, Rxbuf + sizeof (Rxpos), Rxblklen -= sizeof (Rxpos));						ioCounter = (Rxblklen -= sizeof (Rxpos));						FSWrite (Rxfile, &ioCounter, Rxbuf + sizeof (Rxpos) );//						if (j_error ("MSG_TXT (M_WRITE_MSG) %s", Rxfname))//							goto giveup;												Diskavail -= Rxblklen;						Rxpos += Rxblklen;//						update_status (&Rxpos, &rxoldpos, Rxlen - Rxpos, &rxoldeta, Rx_y);						eta = (short) ((((Rxlen - Rxpos) * 10L) / cur_baud * 100L / JANUS_EFFICIENCY + 59L) / 60L);						if ((LMGetTicks () - RxStart) != 0)//							cps = ((((Rxlen - Rxpos) * 60L) / (LMGetTicks () - RxStart)) * 1000L) / cur_baud;							cps = (((Rxpos - rxstpos) * 60L) / (LMGetTicks () - RxStart));						else							cps = 0;						newMessage (lRSTAT, "%ld:%ld (%d) [%d min, %ld cps]", Rxpos, Rxlen, Rxblklen, eta, cps);						if (Rxpos >= Rxlen)						{//							unsigned long Rxtime;							rxclose (GOOD_XFER);							Rxlen -= rxstpos;//							Rxtime = through (&Rxlen, &Rxsttime);//							j_status ("%s-J%s %s", "MSG_TXT (M_FILE_RECEIVED)", (SharedCap & CANCRC32) ? "/32" : " ", Rxfname);							history_add_traff (false, Rxlen);							putlog (lgNOPE, "Received-J%s %s [%ld cps]", (SharedCap & CANCRC32) ? "/32" : "", trunc_path (Rxfname), cps);							newMessage (lRNAME, "");							newMessage (lRSTAT, "");//							j_msgend (Rx_y);//							update_files (0, Rxfname, Rxlen, Rxtime, 0);							rstate = RRCVFNAME;						}					}				}				if (rstate == RRCVFNAME)					sendpkt (NULL, 0, EOFACKPKT);				break;				/*---------------------------------------------------------------*/				/* Name and other data for next file to receive                  */				/*---------------------------------------------------------------*/			case FNAMEPKT:								if (rstate == RRCVFNAME)					Rxpos = rxstpos = rxstpos1 = procfname ();								if (!Rxfname[0] && get_filereq (req_started))				{//			putlog (lgATTN, "Sending request PKT");					sendpkt ((unsigned char *) Rxbuf, strlen (Rxbuf) + 2, FREQPKT);					attempting_req = TRUE;					req_started = FALSE;				}				else				{					if (attempting_req)					{						attempting_req = FALSE;						req_started = TRUE;					}#ifdef FASTER					*((long *)Rxbuf) = endlong (Rxpos);#else					Rxbuf[0] = Rxpos & 0xff;					Rxbuf[1] = (Rxpos >> 8) & 0xff;					Rxbuf[2] = (Rxpos >> 16) & 0xff;					Rxbuf[3] = (Rxpos >> 24) & 0xff;#endif					Rxbuf[4] = SharedCap;					sendpkt ((unsigned char *) Rxbuf, sizeof (Rxpos) + 1, FNACKPKT);					rxoldpos = rxoldeta = -1;					if (Rxpos > -1)						rstate = (unsigned char) ((Rxfname[0]) ? RRCVBLK : RDONE);					else						putlog (lgNOPE, "Refusing %s", trunc_path (Rxfname));//						j_status ("MSG_TXT (M_REFUSING) %s", Rxfname);					if (!rstate)						tx_inhibit = FALSE;					if (!(xstate || rstate))						goto breakout;				}				break;				/*---------------------------------------------------------------*/				/* ACK to filename packet we just sent                           */				/*---------------------------------------------------------------*/			case FNACKPKT:							if (xstate == XRCVFNACK)				{					xmit_retry = 0L;					if (Txfname[0])					{						SharedCap = (Rxblklen > sizeof (long)) ? Rxbuf[4] : 0;#ifdef FASTER						txpos = endlong (*((long *)Rxbuf));#else						txpos = (unsigned char) Rxbuf[3];						txpos = (txpos << 8) | (unsigned char) Rxbuf[2];						txpos = (txpos << 8) | (unsigned char) Rxbuf[1];						txpos = (txpos << 8) | (unsigned char) Rxbuf[0];//						txpos = (long) Rxbuf[0] +//							((long) Rxbuf[1] << 8) +//							((long) Rxbuf[2] << 16) +//							((long) Rxbuf[3] << 24);#endif						if (txpos > -1L)						{							if (txpos)								putlog (lgNOPE, "Resume file from %ld", txpos);//								status_line (MSG_TXT (M_SYNCHRONIZING), txpos);							errno = 0;//							if (lseek (Txfile, txstpos = txpos, SEEK_SET) == -1L)							if (SetFPos (Txfile, fsFromStart, txstpos = txpos))							{//								(void) j_error ("MSG_TXT (M_SEEK_MSG) %s", Txfname);								goto giveup;							}							xstate = XSENDBLK;						}						else						{//							j_status ("MSG_TXT (M_REMOTE_REFUSED) %s", Txfname);							putlog (lgNOPE, "Remote refused %s", trunc_path (Txfname));							newMessage (lTNAME, "");							newMessage (lTSTAT, "");							if (sending_req)							{								if (!(sending_req = get_reqname (FALSE)))									getfname (GOOD_XFER);							}							else							{								Do_after = NOTHING_AFTER;								getfname (GOOD_XFER);							}							xstate = XSENDFNAME;						}					}					else					{//						sent_mail = 1;						xstate = XDONE;					}				}				if (!(xstate || rstate))					goto breakout;				break;				/*---------------------------------------------------------------*/				/* Request to send more stuff rather than end batch just yet     */				/*---------------------------------------------------------------*/			case FREQPKT:							if (xstate == XRCVFNACK)				{					xmit_retry = 0L;					SharedCap = *(strchr (Rxbuf, '\0') + 1);//					(void) sprintf ((char *) Txbuf, request_template, CURRENT.sc_Inbound,//						Hex_Addr_Str (&(alias[0])), TaskNumber);					errno = 0;//					reqfile = fopen ((char *) Txbuf, write_ascii);//					if (reqfile != (FILE *) NULL)//						errno = 0;//					(void) j_error (MSG_TXT (M_OPEN_MSG), (char *) Txbuf);//					(void) fputs (Rxbuf, reqfile);//					(void) fputs ("\n", reqfile);//					(void) fclose (reqfile);//					(void) unlink (ReqTmp);//					ReqRecorded = 0;	/* counted by record_reqfile *///					(void) respond_to_file_requests (0, record_reqfile, timeof_reqfile);//					CURRENT.rq_Limit -= ReqRecorded;										appendrequests (Rxbuf);										if (!nextfreq)					{						nextfreq = freqchain;												while (nextfreq->next && nextfreq->wassent)							nextfreq = nextfreq->next;													if (nextfreq->wassent)							nextfreq = NULL;					}										if ((sending_req = get_reqname (TRUE)) != 0)						xstate = XSENDFNAME;					else						xstate = XSENDFREQNAK;				}				break;				/*---------------------------------------------------------------*/				/* Our last file request didn't match anything; move on to next  */				/*---------------------------------------------------------------*/			case FREQNAKPKT:				attempting_req = FALSE;				req_started = TRUE;				sendpkt (NULL, 0, FRNAKACKPKT);				break;				/*---------------------------------------------------------------*/				/* ACK to no matching files for request error; try to end again  */				/*---------------------------------------------------------------*/			case FRNAKACKPKT:				if (xstate == XRCVFRNAKACK)				{					xmit_retry = 0L;					getfname (GOOD_XFER);					xstate = XSENDFNAME;				}				break;				/*---------------------------------------------------------------*/				/* ACK to last data block in file                                */				/*---------------------------------------------------------------*/			case EOFACKPKT:				if (xstate == XRCVEOFACK || xstate == XRCVFNACK)				{					xmit_retry = 0L;					if (xstate == XRCVEOFACK)					{						long	Txtime;						Txlen -= txstpos;//						Txtime = through (&Txlen, &Txsttime);//						if ((LMGetTicks () - TxStart) != 0)			//				cps = (((Txlen * 60L) / (LMGetTicks () - TxStart)) * 1000L) / cur_baud;							cps = ((Txlen * 60L) / (LMGetTicks () - TxStart));						else							cps = 0;												history_add_traff (true, Txlen);						putlog (lgNOPE, "Sent-J%s %s [%ld cps]", (SharedCap & CANCRC32) ? "/32" : "", trunc_path (Txfname), cps);						newMessage (lTNAME, "");						newMessage (lTSTAT, "");//						j_status ("%s-J%s %s", MSG_TXT (M_FILE_SENT), (SharedCap & CANCRC32) ? "/32" : " ", Txfname);//						j_msgend (Tx_y);//						update_files (1, Txfname, Txlen, Txtime, 0);						if (sending_req)						{							if (!(sending_req = get_reqname (FALSE)))								getfname (GOOD_XFER);						}						else							getfname (GOOD_XFER);					}					xstate = XSENDFNAME;				}				break;				/*---------------------------------------------------------------*/				/* Receiver says "let's try that again."                         */				/*---------------------------------------------------------------*/			case RPOSPKT:				if (xstate == XSENDBLK || xstate == XRCVEOFACK)				{					unsigned long t;#ifdef FASTER					t = endlong (*((long *)&Rxbuf[4]));#else					t = (unsigned char) Rxbuf[7];					t = (t << 8) | (unsigned char) Rxbuf[6];					t = (t << 8) | (unsigned char) Rxbuf[5];					t = (t << 8) | (unsigned char) Rxbuf[4];//					t = (long) Rxbuf[4] +//						((long) Rxbuf[5] << 8) +//						((long) Rxbuf[6] << 16) +//						((long) Rxbuf[7] << 24);#endif					if (t != last_rpostime)					{						last_rpostime = t;						xmit_retry = 0L;						CLEAR_OUTBOUND ();						errno = 0;#ifdef FASTER						lasttx = endlong (*((long *)Rxbuf));#else						lasttx = (unsigned char) Rxbuf[3];						lasttx = (lasttx << 8) | (unsigned char) Rxbuf[2];						lasttx = (lasttx << 8) | (unsigned char) Rxbuf[1];						lasttx = (lasttx << 8) | (unsigned char) Rxbuf[0];//						lasttx = (long) Rxbuf[0] +//							((long) Rxbuf[1] << 8) +//							((long) Rxbuf[2] << 16) +//							((long) Rxbuf[3] << 24);#endif//						if (lseek (Txfile, txpos = lasttx, SEEK_SET) == -1L)						if (SetFPos (Txfile, fsFromStart, txpos = lasttx))						{//							(void) j_error (MSG_TXT (M_SEEK_MSG), Txfname);							goto giveup;						}//						j_status (MSG_TXT (M_SYNCHRONIZING), txpos);						putMessage (0, "\pResync with receiver");						txblklen >>= 2;						if (txblklen < 64)							txblklen = 64;						goodbytes = 0;						goodneeded += 1024;						if (goodneeded > 8192)							goodneeded = 8192;						xstate = XSENDBLK;					}				}				break;				/*---------------------------------------------------------------*/				/* Debris from end of previous Janus session; ignore it          */				/*---------------------------------------------------------------*/			case HALTACKPKT:				break;				/*---------------------------------------------------------------*/				/* Abort the transfer and quit                                   */				/*---------------------------------------------------------------*/			default://				j_status (MSG_TXT (M_UNKNOWN_PACKET), pkttype);				putMessage (0, "\pUnknown packet");				/* fallthrough */			case HALTPKT:giveup://				j_status (MSG_TXT (M_SESSION_ABORT));				if (Txfname[0])					getfname (ABORT_XFER);				if (rstate == RRCVBLK)				{					rxclose (FAILED_XFER);				}				//				putlog (lgATTN, "state is HALTPKT");								Aborted = true;								goto abortxfer;			}					/* switch (pkttype)  */		}						/* while (pkttype)   *///		putMessage (0, "\p");	}	while (xstate || rstate);	/*------------------------------------------------------------------------*/	/* All done; make sure other end is also finished (one way or another)    */	/*------------------------------------------------------------------------*/breakout://	if (!fsent)//		putlog (lgNOPE, "Nothing to send.");//		j_status (MSG_TXT (M_NOTHING_TO_SEND), Full_Addr_Str (&called_addr));abortxfer:	endbatch ();	/*------------------------------------------------------------------------*/	/* Release allocated memory                                               */	/*------------------------------------------------------------------------*/freemem:	if (!Aborted)		if (EMSI_flag)		{			next_oper_frq = remote_ads.next;			while (next_oper_frq)			{				if (PathForOutbound (&next_oper_frq->ad, frq_attacher))	// ¥ path is absent				{					pStrConc (frq_attacher, "\p.REQ", pathname);//					putlog (lgATTN, "clean-up %#s", pathname);					FSDelete (pathname, 0);				}								next_oper_frq = next_oper_frq->next;			}		}		else		{			if (PathForOutbound (&remote_addr, frq_attacher))	// ¥ path is absent			{				pStrConc (frq_attacher, "\p.REQ", pathname);//				putlog (lgATTN, "clean-up %#s", pathname);				FSDelete (pathname, 0);			}		}		if (attachlist)		DisposePtr (attachlist);	if (requestlist)		DisposePtr (requestlist);	if (Txfname)		DisposePtr (Txfname);	if (Rxfname)		DisposePtr (Rxfname);//	set_prior (4);				/* Always High                                     */	newMessage (lTNAME, "");	newMessage (lTSTAT, "");	newMessage (lRNAME, "");	newMessage (lRSTAT, "");}/*****************************************************************************//* Get name and info for next file to be transmitted, if any, and build      *//* FNAMEPKT.  Packet contents as per ZModem filename info packet, to allow   *//* use of same method of aborted-transfer recovery.  If there are no more    *//* files to be sent, build FNAMEPKT with null filename.  Also open file and  *//* set up for transmission.  Set Txfname, Txfile, Txlen.  Txbuf must not be  *//* modified until FNACKPKT is received.                                      *//*****************************************************************************/static void getfname (unsigned short xfer_flag){	static unsigned char	floflag, bad_xfers;	static long				in_pos, in_len;	static Str255			flopathname;	short					florefnum;	char					*p;	long			fst_size;	long			fst_mtime;	OSType			creator, type;	long			create;		short			eta;		/*------------------------------------------------------------------------*/	/* Initialize static variables on first call of the batch                 */	/*------------------------------------------------------------------------*/	if (xfer_flag == INITIAL_XFER)	{		EMSI_aka = 0;		flo_attacher[0] = 0;		flopathname[0] = 0;		flo_method = -1;		attachlist = NULL;		in_pos = 0;		in_len = 0;		if (EMSI_flag)		{			next_oper = remote_ads.next;  /* This should be empty, but we'll go to the end anyway! */			operate_addr = &(next_oper->ad);		}		else			operate_addr = &remote_addr;	}	else		/*------------------------------------------------------------------------*/		/* If we were already sending a file, close it and clean up               */		/*------------------------------------------------------------------------*/	if (Txfile != -1)	{		FSClose (Txfile);		Txfile = -1;				/*---------------------------------------------------------------------*/		/* If xfer completed, do post-xfer cleanup                             */		/*---------------------------------------------------------------------*/		if (xfer_flag == GOOD_XFER && outboundname[0])		{			/*------------------------------------------------------------------*/			/* Perform post-xfer file massaging if neccessary                   */			/*------------------------------------------------------------------*/			switch (Do_after)			{			case '-':				//				putlog (lgATTN, "Killing: %#s", outboundname);				FSDelete ((StringPtr)outboundname, 0);				break;			default:			//				putlog (lgATTN, "Preserving: %#s", outboundname);				break;			}		}	}		/*------------------------------------------------------------------------*/	/* Find all files to be sent and build FNAMEPKT.  If reading .FLO-type    */	/* file get next entry from it; otherwise check for next .OUT/.FLO file   */	/*------------------------------------------------------------------------*/	outboundname[0] = Txfname[0] = Txbuf[0] = Txbuf[1] = 0;	if (xfer_flag != ABORT_XFER)	{		next_file:			while ((EMSI_flag && next_oper) || (!EMSI_flag && !EMSI_aka))		{			if (in_pos >= in_len)			{				if (flopathname[0])				// ¥ kill old .?lo file				{//					putlog (lgATTN, "try kill flo: %#s", flopathname);					FSDelete (flopathname, 0);					flopathname[0] = 0;				}								if (attachlist)				{					DisposePtr (attachlist);					attachlist = NULL;				}								flo_method++;								if (flo_method > 3)				{	next_aka:					if (EMSI_flag)					{						next_oper = next_oper->next;						if (next_oper)							operate_addr = &(next_oper->ad);					}					else						EMSI_aka = 1;										flo_method = -1;					continue;				}								if (!flo_method)				{	putlog ( '~', "Operate attaches to %d:%d/%d.%d",										operate_addr->Zone, operate_addr->Net, operate_addr->Node, operate_addr->Point );										cur_over = LookForOutbound (operate_addr);										if (!cur_over)						goto next_aka;										flopathname[0] = 0;											if (cur_over->attaches)			// ¥ virtual attaches					{						attachlist = NewPtr (in_len = GetHandleSize ( cur_over->attaches ));						memcpy (attachlist, *(cur_over->attaches), in_len);						in_pos = 0;						continue;					}										flo_method++;					// ¥ go to .HLO				}								if (flo_method == 1)				{					if (!PathForOutbound (operate_addr, flo_attacher))	// ¥ path is absent						goto next_aka;				}								pStrConc (flo_attacher, pollModes[flo_method], flopathname);								if (FSOpen (flopathname, 0, &florefnum))					continue;						// ¥ go to next .?lo								GetEOF (florefnum, &in_len);								attachlist = NewPtr (in_len);								FSRead (florefnum, &in_len, attachlist);				FSClose (florefnum);								for (in_pos = 0; in_pos < in_len; in_pos++)					if (attachlist[in_pos] == 0x0D)						attachlist[in_pos] = 0;				in_pos = 0;			}			else			{				strcpy (outboundname, attachlist + in_pos);				Do_after = outboundname[0];				outboundname[0] = strlen (&outboundname[1]);								strcpy (Txfname, attachlist + in_pos + 1);								in_pos += strlen (attachlist + in_pos) + 1;								break;			}		}			if (Txfname[0])		{			touch_arcmail_suffix (operate_addr, (StringPtr)outboundname);						if (GetInfoFile (0, 0, (StringPtr)outboundname, &creator, &type, &create, &fst_mtime, &fst_size))				goto next_file;						if (FSOpen ((StringPtr)outboundname, 0, &Txfile))				goto next_file;			p = strchr (Txfname, '\0');			while (p >= Txfname && *p != ':')				--p;						p++;						UxConvertTime (false, (unsigned long *) &fst_mtime);			strcpy ((char *)Txbuf, p);			sprintf (strchr ((char *) Txbuf, '\0') + 1, "%lu %lo 0", Txlen = fst_size, fst_mtime);			eta = (short) (((Txlen * 10L) / cur_baud * 100L / JANUS_EFFICIENCY + 59L) / 60L);putlog (lgNOPE, "J-Sending: %s (%ldb %d min)", Txbuf, Txlen, eta);			TxStart = LMGetTicks ();						newMessage (lTNAME, "J-Sending: %s", Txbuf);			newMessage (lTSTAT, "0:%ld (0) [%d min, 0 cps]", Txlen, eta);		}	}}/*****************************************************************************//* Build and send a packet of any type.                                      *//* Packet structure is: PKTSTRT,contents,packet_type,PKTEND,crc              *//* CRC is computed from contents and packet_type only; if PKTSTRT or PKTEND  *//* get munged we'll never even find the CRC.                                 *//*****************************************************************************/static void sendpkt (register unsigned char * buf, short len, short type){	register unsigned short crc;	if ((SharedCap & CANCRC32) && type != FNAMEPKT)		sendpkt32 (buf, len, type);	else	{		BUFFER_BYTE (DLE);		BUFFER_BYTE (PKTSTRTCHR ^ 0x40);		crc = 0;		while (--len >= 0)		{			txbyte (*buf);			crc = xcrc (crc, ((unsigned short) (*buf++)));		}		BUFFER_BYTE ((unsigned char) type);		crc = xcrc (crc, type);		BUFFER_BYTE (DLE);		BUFFER_BYTE (PKTENDCHR ^ 0x40);		txbyte ((unsigned char) (crc >> 8));		txbyte ((unsigned char) (crc & 0xFF));		UNBUFFER_BYTES ();	}}/*****************************************************************************//* Build and send a packet using 32-bit CRC; same as sendpkt in other ways   *//*****************************************************************************/static void sendpkt32 (register unsigned char * buf, register short len, short type){	unsigned long crc32;	BUFFER_BYTE (DLE);	BUFFER_BYTE (PKTSTRTCHR32 ^ 0x40);	crc32 = 0xFFFFFFFF;	while (--len >= 0)	{		txbyte (*buf);		crc32 = Z_32UpdateCRC (((unsigned short) * buf), crc32);		++buf;	}	BUFFER_BYTE ((unsigned char) type);	crc32 = Z_32UpdateCRC (type, crc32);	BUFFER_BYTE (DLE);	BUFFER_BYTE (PKTENDCHR ^ 0x40);	txbyte ((unsigned char) (crc32 >> 24));	txbyte ((unsigned char) ((crc32 >> 16) & 0xFF));	txbyte ((unsigned char) ((crc32 >> 8) & 0xFF));	txbyte ((unsigned char) (crc32 & 0xFF));	UNBUFFER_BYTES ();}/*****************************************************************************//* Transmit cooked escaped unsigned char(s) corresponding to raw input unsigned char.  Escape  *//* DLE, XON, and XOFF using DLE prefix unsigned char and ^ 0x40. Also escape          *//* CR-after-'@' to avoid Telenet/PC-Pursuit problems.                        *//*****************************************************************************/static void txbyte (register unsigned char c){	static unsigned char lastsent;	switch (c)	{	case CR:		if (lastsent != '@')			goto sendit;		/* fallthrough */	case DLE:	case XON:	case XOFF:		BUFFER_BYTE (DLE);		c ^= 0x40;		/* fallthrough */	default:sendit:		BUFFER_BYTE (lastsent = c);	}}/*****************************************************************************//* Process FNAMEPKT of file to be received.  Check for aborted-transfer      *//* recovery and solve filename collisions.    Check for enough disk space.   *//* Return initial file data position to start receiving at, or -1 if error   *//* detected to abort file reception.  Set Rxfname, Rxlen, Rxfile.            *//*****************************************************************************/static long procfname (void){	register char *p;	char linebuf[128], *fileinfo, *badfname;	long filestart, bytes;	Str255		sptemp;	short i;	long			fst_size;	long			fst_mtime;	OSType			creator, type;	long			create;		short			eta;		/*------------------------------------------------------------------------*/	/* Initialize for file reception                                          */	/*------------------------------------------------------------------------*/	badfname = NULL;	Rxfname[0] = 0;//	Resume_WaZOO = 0;	/*------------------------------------------------------------------------*/	/* Save info on WaZOO transfer in case of abort                           */	/*------------------------------------------------------------------------*///	(void) strcpy (Resume_name, fancy_str (Rxbuf));//	strcpy (Resume_name, Rxbuf);	fileinfo = strchr (Rxbuf, '\0') + 1;	p = strchr (fileinfo, '\0') + 1;//	SharedCap = (unsigned char) ((Rxblklen > p - Rxbuf) ? *p & OURCAP : 0);	SharedCap = (unsigned char) ((Rxblklen > p - Rxbuf) ? *p & joho : 0);	/*------------------------------------------------------------------------*/	/* If this is a null FNAMEPKT, return OK immediately                      */	/*------------------------------------------------------------------------*/	if (!Rxbuf[0])		return 0L;	p = Rxbuf + strlen ((char *) Rxbuf) - 1;	/* Find transmitted simple filename */	while (p >= Rxbuf && *p != '\\' && *p != '/' && *p != ':')		p--;	inboundPath[inboundPath[0]+1] = 0;	strcpy (Rxfname, (char *) &inboundPath[1]);	(void) strcat (Rxfname, ++p);//	(void) strlwr (linebuf);//	p = check_netfile (linebuf);//	j_status ("#%s %s %s", MSG_TXT (M_RECEIVING), (p) ? p : " ", Rxbuf);	/*------------------------------------------------------------------------*/	/* Extract and validate filesize                                          */	/*------------------------------------------------------------------------*/	Rxlen = -1;	Rxfiletime = 0;	if (sscanf (fileinfo, "%ld %lo", &Rxlen, &Rxfiletime) < 1 || Rxlen < 0)	{//		j_status (MSG_TXT (M_NO_LENGTH));		return -1L;	}	UxConvertTime (true, (unsigned long *) &Rxfiletime);	strcpy ((char *) &sptemp[1], Rxfname);	sptemp[0] = strlen (Rxfname);	filestart = 0L;		if (GetInfoFile (0, 0, sptemp, &creator, &type, &create, &fst_mtime, &fst_size) == 0)	{//	¥¥	If file already exists...		if (Rxlen == fst_size && Rxfiletime == fst_mtime)		{			putMessage (0, "\pSkip file");			putlog (lgNOPE, "Skip %s", trunc_path (Rxfname));			newMessage (lRNAME, "");			newMessage (lRSTAT, "");			return -1;		}				if (creator == 'RvlM' && type == 'ZMPT')		{//	¥¥	exist uncompletedÉ//	¥¥	do concatenation?					if (Rxfiletime != fst_mtime)			{//	¥¥	other file - kill it (maybe was addenum pack to it?)				FSDelete (sptemp, 0);				filestart = 0L;				Create (sptemp, 0, 'RvlM', 'ZMPT');			}			else			{			//	¥¥	that file				filestart = fst_size;			}		}		else		{			Str255		newname;			short		iErr;			//	¥¥	other file already present with this name			pStrCopy (sptemp, newname);			do {							newname[newname[0]]++;				if (newname[newname[0]] == ':')					newname[newname[0]]++;								iErr = HRename ( 0, 0, sptemp, newname );			} while (iErr == dupFNErr);						if (iErr)			{				putlog (lgATTN, "Kill dup file %s", trunc_path ((char *) &sptemp[1]));				FSDelete (sptemp, 0);			}			else			{				newname[newname[0]+1] = 0;				putlog (lgATTN, "Rename dup file %s to %s",											trunc_path ((char *) &sptemp[1]),											trunc_path ((char *) &newname[1]));							}						filestart = 0L;			Create (sptemp, 0, 'RvlM', 'ZMPT');		}	}						/* if exist */	else		Create (sptemp, 0, 'RvlM', 'ZMPT');	if (filestart)	{		putMessage (0, "\pResume");		putlog (lgNOPE, "Resume file from %ld", filestart);	}	FSOpen ( sptemp, 0, &Rxfile );	SetFPos ( Rxfile, fsFromStart, filestart );	eta = (short) ((((Rxlen - filestart) * 10L) / cur_baud * 100L / JANUS_EFFICIENCY + 59L) / 60L);putlog (lgNOPE, "J-Receiving: %s (%ldb %d min)", trunc_path (Rxfname), Rxlen, eta);	newMessage (lRNAME, "J-Receiving: %s", trunc_path (Rxfname));		RxStart = LMGetTicks ();		newMessage (lRSTAT, "%ld:%ld (0) [%d min, 0 cps]", filestart, Rxlen, eta);//	(void) time ((time_t *) & Rxsttime);	return filestart;}/*****************************************************************************//* Receive, validate, and extract a packet if available.  If a complete      *//* packet hasn't been received yet, receive and store as much of the next    *//* packet as possible.    Each call to rcvpkt() will continue accumulating a *//* packet until a complete packet has been received or an error is detected. *//* Rxbuf must not be modified between calls to rcvpkt() if NOPKT is returned.*//* Returns type of packet received, NOPKT, or BADPKT.  Sets Rxblklen.        *//*****************************************************************************/static unsigned char rcvpkt (){	static unsigned char rxcrc32;	static unsigned short crc;	static unsigned long crc32;	register unsigned char *p;	register short c;	short i;	unsigned long pktcrc;	/*------------------------------------------------------------------------*/	/* Abort transfer if operator pressed ESC                                 */	/*------------------------------------------------------------------------*/	if (CheckCancel ())		//	give task chance by Cyril	{//		j_status (GenericError, MSG_TXT (M_KBD_MSG));		putlog (lgALRT, "Aborted...");		return HALTPKT;	}	/*------------------------------------------------------------------------*/	/* If not accumulating packet yet, find start of next packet              */	/*------------------------------------------------------------------------*/	WaitFlag = FALSE;	p = Rxbufptr;	if (!p)	{		do			c = rxbyte ();		while (c >= 0 || c == PKTEND);		switch (c)		{		case PKTSTRT:			rxcrc32 = FALSE;			p = (unsigned char *) Rxbuf;			crc = 0;			break;		case PKTSTRT32:			rxcrc32 = TRUE;			p = (unsigned char *) Rxbuf;			crc32 = 0xFFFFFFFF;			break;		case NOCARRIER://			j_status (GenericError, &(MSG_TXT (M_NO_CARRIER)[1]));			return HALTPKT;		default:			return NOPKT;		}	}	/*------------------------------------------------------------------------*/	/* Accumulate packet data until we empty buffer or find packet delimiter  */	/*------------------------------------------------------------------------*/	if (rxcrc32)	{		while ((c = rxbyte ()) >= 0 && p < Rxbufmax)		{			*p++ = (unsigned char) c;			crc32 = Z_32UpdateCRC (c, crc32);		}	}	else	{		while ((c = rxbyte ()) >= 0 && p < Rxbufmax)		{			*p++ = (unsigned char) c;			crc = xcrc (crc, c);		}	}	/*------------------------------------------------------------------------*/	/* Handle whichever end-of-packet condition occurred                      */	/*------------------------------------------------------------------------*/	switch (c)	{		/*---------------------------------------------------------------------*/		/* PKTEND found; verify valid CRC                                      */		/*---------------------------------------------------------------------*/	case PKTEND:		WaitFlag = TRUE;		pktcrc = 0;		for (i = (rxcrc32) ? 4 : 2; i; --i)		{			if ((c = rxbyte ()) < 0)				break;			pktcrc = (pktcrc << 8) | c;		}		if (!i)		{			if ((rxcrc32 && pktcrc == crc32) || pktcrc == crc)			{				/*------------------------------------------------------------*/				/* Good packet verified; compute packet data length and       */				/* return packet type                                         */				/*------------------------------------------------------------*/				Rxbufptr = NULL;				Rxblklen = (short) (--p - (unsigned char *) Rxbuf);				return *p;			}		}		/* fallthrough */		/*---------------------------------------------------------------------*/		/* Bad CRC, carrier lost, or buffer overflow from munged PKTEND        */		/*---------------------------------------------------------------------*/	default:		if (c == NOCARRIER)		{//			j_status (GenericError, &(MSG_TXT (M_NO_CARRIER)[1]));			return HALTPKT;		}		else		{			Rxbufptr = NULL;			return BADPKT;		}		/*---------------------------------------------------------------------*/		/* Emptied buffer; save partial packet and let sender do something     */		/*---------------------------------------------------------------------*/	case BUFEMPTY://		time_release ();		/* Also give other tasks a chance */		Rxbufptr = p;		return NOPKT;		/*---------------------------------------------------------------------*/		/* PKTEND was trashed; discard partial packet and prep for next one    */		/*---------------------------------------------------------------------*/	case PKTSTRT:		rxcrc32 = FALSE;		Rxbufptr = (unsigned char *) Rxbuf;		crc = 0;		return BADPKT;	case PKTSTRT32:		rxcrc32 = TRUE;		Rxbufptr = (unsigned char *) Rxbuf;		crc32 = 0xFFFFFFFF;		return BADPKT;	}}/*****************************************************************************//* Close file being received and perform post-reception aborted-transfer     *//* recovery cleanup if neccessary.                                           *//*****************************************************************************/static void rxclose (unsigned short xfer_flag){	register char *p;	char namebuf[PATHLEN], linebuf[128];	unsigned char c;//	FILE *abortlog, *newlog;//	struct utimbuf utimes;	short			rz123;	Str255		sptemp;	/*------------------------------------------------------------------------*/	/* Close file we've been receiving                                        */	/*------------------------------------------------------------------------*/	errno = 0;	FSClose (Rxfile);//	if (Rxfiletime > 0) /* utime doesn't like negative numbers *///	{//		utimes.UT_ACTIME = Rxfiletime;//		utimes.modtime = Rxfiletime;//		(void) utime (Rxfname, (UTIMBUF *) & utimes);//	}	strcpy ((char *) &sptemp[1], Rxfname);	sptemp[0] = strlen (Rxfname);	/*------------------------------------------------------------------------*/	/* If we completed a previously-aborted transfer, kill log entry & rename */	/*------------------------------------------------------------------------*/	if (xfer_flag == GOOD_XFER)	{//	1	-	arcmail//	2	-	pkt//	0	-	other files			switch (rz123 = ResolveExtension (sptemp))			{			case 0:							SetInfoFile (0, 0, sptemp, 'ALFA', 'TEXT', Rxfiletime, Rxfiletime);				break;						case 1:								SetInfoFile (0, 0, sptemp, 'ZIP ', '.PKT', Rxfiletime, Rxfiletime);				gotta_xmail = 1;				break;						case 2:							SetInfoFile (0, 0, sptemp, 'RvlM', '.PKT', Rxfiletime, Rxfiletime);				gotta_mail = 1;				break;			default:								if (rz123 < 0)				{					SetInfoFile (0, 0, sptemp, (*pc_exch_pref)[-rz123-1].creator, (*pc_exch_pref)[-rz123-1].type, Rxfiletime, Rxfiletime);				}								break;			}	}	else		if (xfer_flag == FAILED_XFER)		{		//	1	-	arcmail		//	2	-	pkt		//	0	-	other files			if (ResolveExtension (sptemp) == 2)			{				putlog (lgATTN, "Kill aborted %s", trunc_path (Rxfname));				FSDelete (sptemp, 0);			}			else			{				SetInfoFile ( 0, 0, sptemp, 'RvlM', 'ZMPT', Rxfiletime, Rxfiletime );				history_add_traff (false, Rxpos - rxstpos1);				putlog (lgATTN, "Save partialy received %s (%ldb)", trunc_path (Rxfname), Rxpos);			}		}}/*****************************************************************************//* Try REAL HARD to disengage batch session cleanly                          *//*****************************************************************************/static void endbatch (void){	register short done, timeouts;	unsigned long timeval, brain_dead;	/*------------------------------------------------------------------------*/	/* Tell the other end to halt if it hasn't already                        */	/*------------------------------------------------------------------------*/	done = timeouts = 0;	long_set_timer (&brain_dead, 120);	sendpkt (NULL, 0, HALTPKT);	long_set_timer (&timeval, TimeoutSecs);	/*------------------------------------------------------------------------*/	/* Wait for the other end to acknowledge that it's halting                */	/*------------------------------------------------------------------------*/	while (!done)	{		if (long_time_gone (&brain_dead) || !CARRIER)			break;		switch (rcvpkt ())		{		case NOPKT:		case BADPKT:			if (long_time_gone (&timeval))			{				if (++timeouts > 2)					++done;				else					goto reject;			}			break;		case HALTPKT:		case HALTACKPKT:			++done;			break;		default:			timeouts = 0;reject:			sendpkt (NULL, 0, HALTPKT);			long_set_timer (&timeval, TimeoutSecs);			break;		}	}	/*------------------------------------------------------------------------*/	/* Announce quite insistently that we're done now                         */	/*------------------------------------------------------------------------*/	for (done = 0; done < 10; ++done)		sendpkt (NULL, 0, HALTACKPKT);	while (!OUT_EMPTY() && !long_time_gone (&brain_dead) && CARRIER)		time_release ();}#if 0/*****************************************************************************//* Print a message in the message field of a transfer status line            *//*****************************************************************************/void j_message (unsigned short pos, char *va_alist,...){	va_list arg_ptr;	short y, l;	char buf[128];	y = pos;	va_start (arg_ptr, va_alist);	if (!un_attended || !fullscreen)		gotoxy (MSG_X, y);	else		sb_move (filewin, y, MSG_X);	(void) vsprintf (buf, va_alist, arg_ptr);	for (l = 25 - strlen (buf); l > 0; --l)		(void) strcat (buf, " ");	if (!un_attended || !fullscreen)	{		(void) cputs (buf);	}	else	{		sb_puts (filewin, buf);		sb_show ();	}	va_end (arg_ptr);}/*****************************************************************************//* Clear out a line in the log status display                                *//*****************************************************************************/void j_msgend (short pos){	if (un_attended && fullscreen)	{		sb_move (filewin, pos, 2);		/* 72 blanks */		sb_puts (filewin, "                                                                        ");		sb_show ();	}}/*****************************************************************************//* Print & log status message without messing up display                     *//*****************************************************************************/void j_status (char *va_alist,...){	va_list arg_ptr;	char buf[128];	va_start (arg_ptr, va_alist);	if (!un_attended || !fullscreen)		gotoxy (1, Next_y - 1);	(void) vsprintf (buf, va_alist, arg_ptr);	status_line (buf);	if (!un_attended || !fullscreen)		update_y ();	va_end (arg_ptr);}/*****************************************************************************//* Print & log error message without messing up display                      *//*****************************************************************************/short j_error (char *msg, char *fname){	register short e;	if ((e = (short) errno) != 0)	{		if (!un_attended || !fullscreen)			gotoxy (1, Next_y - 1);		(void) got_error (msg, fname);		if (!un_attended || !fullscreen)			update_y ();	}	return e;}/*****************************************************************************//* Update screen position variables after printing a message                 *//*****************************************************************************/static void  update_y (){	set_xy (NULL);				/* Bump cursor to next line after printing   */	if (locate_y == Next_y)	{							/* If we didn't go anywhere, screen scrolled;*/		if (Tx_y > 1)			/* so decrement status line numbers          */			--Tx_y;		if (Rx_y > 1)			--Rx_y;	}	else		Next_y = locate_y;}#endif/*****************************************************************************//* Compute future timehack for later reference                               *//*****************************************************************************/static void long_set_timer (unsigned long *Buffer, unsigned short Duration){//	(void) time ((time_t *) Buffer);//	*Buffer += (long) Duration;	*Buffer = LMGetTime () + Duration;}/*****************************************************************************//* Return TRUE if timehack has been passed, FALSE if not                     *//*****************************************************************************/static short long_time_gone (unsigned long *TimePtr){	return (((unsigned long) LMGetTime ()) > *TimePtr);//	return (time (NULL) > (time_t) * TimePtr);}/*****************************************************************************//* Receive cooked escaped unsigned char translated to avoid various problems.         *//* Returns raw unsigned char, BUFEMPTY, PKTSTRT, PKTEND, or NOCARRIER.                *//*****************************************************************************/static short  rxbyte (void){	register short c, w;	if ((c = rcvrawbyte ()) == DLE)	{		w = WaitFlag++;		if ((c = rcvrawbyte ()) >= 0)		{			switch (c ^= 0x40)			{			case PKTSTRTCHR:				c = PKTSTRT;				break;			case PKTSTRTCHR32:				c = PKTSTRT32;				break;			case PKTENDCHR:				c = PKTEND;				break;			}		}		WaitFlag = (unsigned char) w;	}	return c;}/*****************************************************************************//* Receive raw non-escaped byte.  Returns byte, BUFEMPTY, or NOCARRIER.      *//* If waitflag is true, will wait for a byte for Timeoutsecs; otherwise      *//* will return BUFEMPTY if a byte isn't ready and waiting in inbound buffer. *//*****************************************************************************/static short  rcvrawbyte (void){	long timeval;	if ((short) PEEKBYTE () >= 0)		return MODEM_IN ();	if (!CARRIER)		return NOCARRIER;	if (!WaitFlag)		return BUFEMPTY;	timeval = time (NULL) + TimeoutSecs;	while ((short) PEEKBYTE () < 0)	{		if (!CARRIER)			return NOCARRIER;		if (time (NULL) > (time_t) timeval)			return BUFEMPTY;		time_release ();	}	return MODEM_IN ();}/*****************************************************************************//* Get next file to request, if any                                          *//*****************************************************************************/static short get_filereq (unsigned char req_started){	static long				in_pos_r, in_len_r;	Str255					frqpathname;	long					i;	short					gotone = false, frqrefnum;//	putlog (lgALRT, "+get_filereq");	if (!(remote_capabilities & WZ_FREQ))	{		putMessage (0, "\pRemote cannot accept freqs");		return false;	}	else		if (!(SharedCap & CANFREQ))		{			putMessage (0, "\pRemote cannot accept freqs");			return false;		}			if (!requestlist)	{		in_pos_r = 0;		in_len_r = 0;	}	while ((EMSI_flag && next_oper_frq) || (!EMSI_flag && !EMSI_raka))	{		if (in_pos_r >= in_len_r)		{//	putlog ( lgATTN, "Operate requests to %d:%d/%d.%d",//										operate_addr_frq->Zone, operate_addr_frq->Net,//										operate_addr_frq->Node, operate_addr_frq->Point );			if (requestlist)			{				DisposePtr (requestlist);				requestlist = NULL;			}						frq_method++;						if (frq_method > 2)			{next_aka:				if (EMSI_flag)				{					next_oper_frq = next_oper_frq->next;					if (next_oper_frq)						operate_addr_frq = &(next_oper_frq->ad);				}				else					EMSI_raka = 1;								frq_method = 0;				continue;			}			if (frq_method == 1)			{//			putlog (lgATTN, "Check manual requests");				frq_over = LookForOutbound (operate_addr_frq);								if (!frq_over)					goto next_aka;									if (frq_over->requests)			// ¥ virtual requests				{					requestlist = NewPtr (in_len_r = GetHandleSize ( frq_over->requests ));					memcpy (requestlist, *(frq_over->requests), in_len_r);					goto filter;				}				frq_method++;					// ¥ go to .REQ			}			//			putlog (lgATTN, "Check requests");			if (!PathForOutbound (operate_addr_frq, frq_attacher))	// ¥ path is absent				goto next_aka;						pStrConc (frq_attacher, "\p.REQ", frqpathname);						if (FSOpen (frqpathname, 0, &frqrefnum))				goto next_aka;						// ¥ go to next aka						GetEOF (frqrefnum, &in_len_r);						requestlist = NewPtr (in_len_r);						FSRead (frqrefnum, &in_len_r, requestlist);			FSClose (frqrefnum);	filter:			for (in_pos_r = 0, i = 0; i < in_len_r; in_pos_r++)				if (requestlist[in_pos_r] != 0x0A)				{					if (requestlist[in_pos_r] == 0x0D)						requestlist[i++] = 0;					else						requestlist[i++] = requestlist[in_pos_r];				}				else					in_len_r--;			in_pos_r = 0;		}		else		{			(void) strcpy (Rxbuf, requestlist + in_pos_r);			*(strchr (Rxbuf, '\0') + 1) = SharedCap;			gotone = true;			in_pos_r += strlen (requestlist + in_pos_r) + 1;			putMessage ( 0,"\pSending requests" );						break;		}	}//	putlog (lgALRT, "-get_filereq");	return gotone;}static char	*trailer = "\r=======================================================================\r\r\rSee ya!\r--- " MAILERNAME " " RAVELVERS " " RAVELISA "\r";static void append_trailer (StringPtr pktname){	short		refnum;	long		ioCount, zero = 0L;			if (FSOpen (pktname, 0, &refnum) == noErr)	{		SetFPos (refnum, fsFromLEOF, 0L);				ioCount = strlen (trailer);		FSWrite (refnum, &ioCount, trailer);		ioCount = 3L;		FSWrite (refnum, &ioCount, &zero);		FSClose (refnum);	}}static unsigned char get_reqname (unsigned char first_req){	long			fst_size;	long			fst_mtime;	OSType			creator, type;	long			create;		short			eta, boo;	Str255			stemp;//	putlog (lgATTN, "+get_reqname");	if (!first_req && Txfile != -1)	{		FSClose (Txfile);		Txfile = -1;	}	outboundname[0] = Txfname[0] = Txbuf[0] = Txbuf[1] = 0;	if (!freqchain)		return false;	if (!nextfreq)		return false;//	putlog (lgATTN, "freq is %#s", nextfreq->freqname);	if (nextfreq->sumsent)	{		pStrCopy (nextfreq->freqname, stemp);		append_trailer (stemp);	}	else		if (!parseFreqAliasFolder (nextfreq->freqname, stemp))		{			nextfreq = nextfreq->next;			return false;		}		else			putlog (lgNOPE, "Processing freq: %#s", nextfreq->freqname);			nextfreq->wassent = true;	nextfreq = nextfreq->next;	if (GetInfoFile (0, 0, stemp, &creator, &type, &create, &fst_mtime, &fst_size))		return false;		if (FSOpen (stemp, 0, &Txfile))		return false;		pStrCopy (stemp, (StringPtr)outboundname);	outboundname[outboundname[0]+1] = 0;	Do_after = NOTHING_AFTER;								//	??? no in Janus	strcpy (Txfname, &outboundname[1]);	strcpy ((char *)Txbuf, trunc_path (Txfname));		sprintf (strchr ((char *) Txbuf, '\0') + 1, "%lu %lo 0", Txlen = fst_size, fst_mtime);	eta = (short) (((Txlen * 10L) / cur_baud * 100L / JANUS_EFFICIENCY + 59L) / 60L);	putlog (lgNOPE, "J-Sending: %s (%ldb %d min)", Txbuf, Txlen, eta);	TxStart = LMGetTicks ();	newMessage (lTNAME, "J-Sending: %s", Txbuf);	newMessage (lTSTAT, "0:%ld (0) [%d min, 0 cps]", Txlen, eta);	return true;}