#include <stdio.h>//#include "Port.h"#include "Comm.h"#include "Modem.h"#include "ascii.h"#include "wazoo.h"#include "Ravel_FTN.h"#include "Ravel_Prefs.h"#include "Session.h"#include "EMSI.h"#include "YooHoo.h"#include "ftsc.h"#include "Timing.h"#include "Scheduler.h"#include "Unattended.h"#include "Manual.h"#include "freq.h"#include "compatible.h"#include "log.h"#include "pmain.h"#include "Pathes.h"#include "busy.h"#include "zfiles.h"#include "history.h"short		Netmail_Session;short		isOriginator = 0;				/* Global logical "I'm the caller"  */short		got_arcmail;short		got_packet;short		got_mail;short		mail_finished;short		sent_mail;short		net_problems;					/* This should be external */short		thy_request = 0;					//	reote made file requestshort		we_request = 0;					//	we made file requestshort		tmail_chat;ADDR		remote_addr;ADDR		called_addr;ADDR_LIST	remote_ads;short		remote_capabilities;long		total_bytes = 0L;				/* Total bytes transferred          */char		*request_template = "%s%s.req";extern		char		*session_password;				/* Master EMSI/YooHoo session password */Boolean		doing_janus = FALSE;extern short	mail_only;extern short	gotta_mail;extern short	gotta_xmail;extern Boolean	Aborted;Boolean		g_wasrefused;Boolean		dos_names;short		xHydraPhase;	//¥¥	Boolean		emsi_session;//	Boolean		ftsc_session;/*---------------------------------------------------- * Do a session */void Session ( Boolean was_initiator ){	short		i;	ADDR_LIST	*ads, *ads1;	addr		tad;#ifndef LITE	pfreq		xfreqchain;#endif	Str255		stemp;	long		hmr_total, hmr_start = LMGetTicks (), type, fst_size;		gSleepTime = 0;//	CLEAR_OUTBOUND ();//	CLEAR_INBOUND ();//	putlog ( '~', " + Session" );		remote_capabilities = 0;	gotta_xmail = gotta_mail = 0;	remote_ads.next = NULL;#ifndef LITE	freqchain = NULL;#endif		g_wasrefused = false;	dos_names = true;	xHydraPhase = 0;	//¥¥	tmail_chat = false;	//¥¥		isOriginator = was_initiator;	history_add_und_set ((was_initiator) ? 1 : 0, LMGetTime ());		if (was_initiator)	{		/*		 *    OUTBOUND -- meaning call was made by us.		 */		switch(TxEmsiInit())		{		case SESSION_FTSC:			putlog ( lgNOPE, "Session:     FTS-0001" );			putMessage ( 3, "\pSession FTS-0001" );			emsi_session = false;			FTSC_sender (0);			tad.zone = called_addr.Zone;			tad.net = called_addr.Net;			tad.node = called_addr.Node;			tad.point = called_addr.Point;			if (!Aborted)			{				KillManual ( &tad );			}			bsy_clear (&tad, workPath);			break;				case SESSION_WAZOO:			putlog ( lgNOPE, "Session:     WaZOO" );			putMessage ( 2, "\pSession WaZOO" );			if ( YooHoo_Sender () )			{				emsi_session = false;				WaZOO (1);			}					tad.zone = remote_addr.Zone;			tad.net = remote_addr.Net;			tad.node = remote_addr.Node;			tad.point = remote_addr.Point;						if (!Aborted && !g_wasrefused)			{				KillManual ( &tad );			}			bsy_clear (&tad, workPath);			tad.zone = called_addr.Zone;			tad.net = called_addr.Net;			tad.node = called_addr.Node;			tad.point = called_addr.Point;						if (!Aborted && !g_wasrefused)			{				KillManual ( &tad );			}			bsy_clear (&tad, workPath);						break;				case SESSION_EMSI:			putlog ( lgNOPE, "Session:     EMSI" );			putelog ( lgNOPE, " " );			putMessage ( 2, "\pSession EMSI" );			dos_names = false;			emsi_session = true;			if ( EMSI_sender () != EMSI_SUCCESS )				Aborted = true;			ads = remote_ads.next;  /* This should be empty, but we'll go to the end anyway! */					while(ads)			{				tad.zone = ads->ad.Zone;				tad.net = ads->ad.Net;				tad.node = ads->ad.Node;				tad.point = ads->ad.Point;								if (!Aborted && !g_wasrefused)				{					KillManual ( &tad );				}				bsy_clear (&tad, workPath);								ads1 = ads->next;				DisposePtr ((Ptr)ads);				ads = ads1;			}						tad.zone = called_addr.Zone;			tad.net = called_addr.Net;			tad.node = called_addr.Node;			tad.point = called_addr.Point;							if (!Aborted && !g_wasrefused)			{				KillManual ( &tad );			}			bsy_clear (&tad, workPath);						break;				default:			putMessage ( 3, "\pHandshaking failed." );			putlog ( lgALRT, "Handshaking failed." );			Aborted = true;			break;		}									/* end switch */	}	else	{		/*		 *    INBOUND -- meaning we were connected to by another system.		 */		//		putlog ( lgATTN, "Meaning we were connected to by another system." );				switch ( i = RxEmsiInit () )		{		case SESSION_BBS:                       /* ESCape or Timeout    */				//		putlog ( lgNOPE, "Calling for BBS" );			if (CARRIER && !mail_only)			{				putlog (lgNOPE, "Processing BBS call.");	//			BBSexit ();			}				//		Aborted = true;			break;				case SESSION_FTSC:                      /* FTSC Netmail Session */						putMessage ( 3, "\pSession FTS-0001" );			putlog ( lgNOPE, "Session:     FTS-0001" );						if (CARRIER)			{				emsi_session = false;				FTSC_receiver (0);				tad.zone = remote_addr.Zone;				tad.net = remote_addr.Net;				tad.node = remote_addr.Node;				tad.point = remote_addr.Point;								if (!Aborted)				{					KillManual ( &tad );				}				bsy_clear (&tad, workPath);			}					    break;				case SESSION_WAZOO:                     /* WaZOO Netmail Session*/						putlog ( lgNOPE, "Session:     WaZOO" );			putMessage ( 2, "\pSession WaZOO" );			if (YooHoo_Receiver ())			{				emsi_session = false;				WaZOO (0);                      /* do WaZOO!!!          */			}			tad.zone = remote_addr.Zone;			tad.net = remote_addr.Net;			tad.node = remote_addr.Node;			tad.point = remote_addr.Point;						if (!Aborted && !g_wasrefused)			{				KillManual ( &tad );			}			bsy_clear (&tad, workPath);					    break;				case SESSION_EMSI:		    			putlog ( lgNOPE, "Session:     EMSI" );			putelog ( lgNOPE, " " );			putMessage ( 2, "\pSession EMSI" );			dos_names = false;			emsi_session = true;						if (EMSI_receiver() != EMSI_SUCCESS)				Aborted = true;			ads = remote_ads.next;  /* This should be empty, but we'll go to the end anyway! */					while(ads)			{				tad.zone = ads->ad.Zone;				tad.net = ads->ad.Net;				tad.node = ads->ad.Node;				tad.point = ads->ad.Point;				if (!Aborted && !g_wasrefused)				{					KillManual ( &tad );				}				bsy_clear (&tad, workPath);								ads1 = ads->next;				DisposePtr ((Ptr)ads);				ads = ads1;			}								break;				case SESSION_FAIL:		default:			putMessage ( 3, "\pHandshaking failed." );			putlog ( lgALRT, "Handshaking failed." );			Aborted = true;			break;					}                /* end switch */	}            /* end if (was_initiator) *///	putlog ( lgNOPE, " - Session" );#ifndef LITE	if (freqchain)	{		xfreqchain = freqchain;				while (xfreqchain)		{			freqchain = xfreqchain->next;//¥	remove for debuggingÉ			if (xfreqchain->sumsent)				FSDelete (xfreqchain->freqname, 0);			else			{				if (parseFreqAliasFolder (xfreqchain->freqname, stemp) && xfreqchain->wassent)				{					if (GetInfoFile (0, 0, stemp, (unsigned long *) &type, (unsigned long *) &type, &type, &type, &fst_size) == noErr)						history_add_freq (fst_size);				}			}			DisposePtr ((Ptr)xfreqchain);			xfreqchain = freqchain;		}	}#endif	hmr_total = (LMGetTicks () - hmr_start) / 60;		if (!Aborted)		putlog (lgNOPE, "Session done (%.2ld:%.2ld).", (long) (hmr_total / 60L), (long) (hmr_total % 60L));	else		putlog (lgATTN, "Session aborted (%.2ld:%.2ld).", (long) (hmr_total / 60L), (long) (hmr_total % 60L));	history_reset (hmr_total);	gSleepTime = 20;	return;}/* * Send banner-type lines to remote. Since strange modems like Courier HST * have a propensity for thinking they are connected when talking to a dial * tone (but do leave CTS down just to screw us up) we have to use a timeout * to figure out if we are in trouble, and if so, we drop DTR to make the * bogus carrier go away. * * This routine is used in modules B_BBS.C and RECVSYNC.C, both of which * are called from this module only. * */short SendBanner (char *string){	long			t1;	register char	c;	//	putlog ( lgATTN, "Sent banner..." );		t1 = timerset (60*60);						/* 60 seconds max to put out banner */		while (!timeup (t1) && CARRIER)	{		if (CheckCancel())							/* Manual abort?     */			break;								/* Use failure logic */				if (OUT_EMPTY ())		{			c = *string++;			if (!c)								/* Test for end      */				return (1);						/* Yes, success      */						SENDBYTE ((unsigned char) c, NULL);		}	}		/*	* If we get here we had trouble. Drop DTR now to hopefully get out of	* this trouble. Flush outbound. Pause for 1 second.	*/	hang_up ();	CLEAR_OUTBOUND ();	CLEAR_INBOUND ();		putlog ( lgALRT, "banner fault!" );		return (0);}