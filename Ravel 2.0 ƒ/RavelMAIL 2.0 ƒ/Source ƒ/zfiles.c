#include <string.h>#include "ICAPI.h"#include "Ravel_FTN.h"#include "Ravel_Prefs.h"#include "compatible.h"#include "stringutl.h"//#include "strnutl.h"#include "zfiles.h"h_pc_exch	pc_exch_pref = NULL;short		pc_exch_num = 0;/* ----- Get file info ------------------------------------------------- */short GetInfoFile (	register short volume,		/* <- Volume reference number */	register long directory,	/* <- Directory id */	register StringPtr name,	/* <- File name */	OSType *creator,			/* -> File creator */	OSType *type,				/* -> File type */	long *create,				/* -> File creation date */	long *modif,				/* -> File modification date */	long *flen)					/* -> File length */{	register short err;	HParamBlockRec p;	memset (&p, 0, sizeof(p));	p.fileParam.ioNamePtr = (StringPtr)name;	p.fileParam.ioVRefNum = volume;	p.fileParam.ioDirID = directory;	if (err = PBHGetFInfoSync (&p))		return err;	*creator = p.fileParam.ioFlFndrInfo.fdCreator;	*type = p.fileParam.ioFlFndrInfo.fdType;	*create = p.fileParam.ioFlCrDat;	*modif = p.fileParam.ioFlMdDat;	*flen = p.fileParam.ioFlLgLen;	return err;}/* ----- Set file info ------------------------------------------------- */short SetInfoFile (	register short volume,		/* <- Volume reference number */	register long directory,	/* <- Directory id */	register StringPtr name,	/* <- File name */	OSType creator,				/* <- File creator */	OSType type,				/* <- File type */	long create,				/* <- File creation date */	long modif)					/* <- File modification date */{	register short err;	HParamBlockRec p;	memset(&p, 0, sizeof(p));	p.fileParam.ioNamePtr = (StringPtr)name;	p.fileParam.ioVRefNum = volume;	p.fileParam.ioDirID = directory;	if (err = PBHGetFInfoSync (&p))		return err;	p.fileParam.ioNamePtr = name;	p.fileParam.ioVRefNum = volume;	p.fileParam.ioDirID = directory;	p.fileParam.ioFlFndrInfo.fdCreator = creator;	p.fileParam.ioFlFndrInfo.fdType = type;	p.fileParam.ioFlCrDat = create;	p.fileParam.ioFlMdDat = modif;	return PBHSetFInfoSync (&p);}/* ----- Convert between Macintosh time and ZModem time ---------------- */static DateTimeRec ZTimeOrigin = { 1970, 1, 1, 0, 0, 0, 0 };void UxConvertTime (Boolean toMac, unsigned long *t){	unsigned long t0;	DateToSeconds (&ZTimeOrigin, &t0);	*t = toMac ? (*t + t0) : (*t - t0);}/* ----- Convert between Macintosh time and MSDOS time ---------------- */void MSConvertTime (Boolean toMac, unsigned long *t){//	unsigned long t0;	DateTimeRec	dtr;	if (toMac)	{		dtr.hour = (*t >> 27) & 0x1F;		dtr.minute = (*t >> 21) & 0x3F;		dtr.second = 2 * ((*t >> 16) & 0x1F);		dtr.year = 1980 + ((*t >> 9) & 0x7F);		dtr.month = (*t >> 5) & 0x0F;		dtr.day = *t & 0x1F;			DateToSeconds (&dtr, t);	}	else	{		SecondsToDate (*t, &dtr);		*t =	((long) dtr.hour << 27) |				((long) dtr.minute << 21) |				((long) (dtr.second/2) << 16) |				((long) (dtr.year - 1980) << 9) |				((long) dtr.month << 5) | dtr.day;	}	}/* ---------------------------------------------------------------------- *///	1	-	arcmail//	2	-	pkt//	3	-	req//	0	-	other filesstatic	char	*ValidExt[7] = { "mo", "tu", "we", "th", "fr", "sa", "su" };static	Boolean	useIC = false;short ResolveExtensionInit (void){	short	wdRefNum, RefNum, oldRes = CurResFile (), res = 0;	long	dirID;		ICInstance	inst;	OSErr	err;		err = ICStart(&inst, 'RvlM');			// Use your creator code if you have one!	if (err == noErr)	{		useIC = true;		res = 2;		(void) ICStop(inst);	}	if (!useIC)	{		pc_exch_pref = NULL;		pc_exch_num = 0;		if (FindFolder ( kOnSystemDisk, kPreferencesFolderType, kDontCreateFolder, &wdRefNum, &dirID ) != noErr)			return res;				RefNum = HOpenResFile (wdRefNum, dirID, "\pPC Exchange Preferences", fsRdPerm);		if (RefNum == -1)			return res;		UseResFile (RefNum);				pc_exch_pref = (h_pc_exch) Get1Resource ('dMap', -4040);				if (pc_exch_pref)		{			DetachResource ((Handle) pc_exch_pref);			MoveHHi ((Handle) pc_exch_pref);			HLock ((Handle) pc_exch_pref);					pc_exch_num = GetHandleSize ((Handle) pc_exch_pref) / 16;			res = 1;		}				UseResFile (oldRes);		CloseResFile (RefNum);	}	return res;}static	ICMapEntry	gICMapEntry;short ResolveExtension (StringPtr fname){	short	a;	char	tmp[16];		ICInstance	inst;	OSErr	err;		for (a=0;a<7;a++) 		if ( !strncasecmp ( (char *) &fname[fname[0]-2], ValidExt[a], 2) )			break;	if (a != 7)		return 1;	else		if ( !strcasecmp ( (char *) &fname[fname[0]-3], ".pkt" ) )			return 2;		else			if ( !strcasecmp ( (char *) &fname[fname[0]-3], ".req" ) )				return 3;			else			{				if (useIC)				{					gICMapEntry.file_type = 'TEXT';					gICMapEntry.file_creator = 'ALFA';					err = ICStart(&inst, 'RvlM');			// Use your creator code if you have one!					if (err == noErr)					{						err = ICFindConfigFile(inst, 0, NULL);						if (err == noErr)						{							err = ICMapFilename (inst, fname, &gICMapEntry);							if (err)							{								gICMapEntry.file_type = 'TEXT';								gICMapEntry.file_creator = 'ALFA';							}						}						(void) ICStop(inst);					}										return -1;				}				else					if (pc_exch_pref && pc_exch_num)					{						for (a=0; a<pc_exch_num; a++)						{							strncpy (tmp, (*pc_exch_pref)[a].pc_ext, 4);							if (!strcasecmp ((char *) &fname[fname[0]-3], tmp))								return -(a+1);						}					}								return 0;			}}void SetInfoAndICTypeCreator (	register short volume,		/* <- Volume reference number */	register long directory,	/* <- Directory id */	register StringPtr name,	/* <- File name */	long create,				/* <- File creation date */	long modif,	short indexer	){	if (useIC)		SetInfoFile (volume, directory, name, gICMapEntry.file_creator,								gICMapEntry.file_type, create, modif);	else		SetInfoFile (volume, directory, name, (*pc_exch_pref)[-indexer-1].creator,								(*pc_exch_pref)[-indexer-1].type, create, modif);}char *trunc_path (char *filepath){	char *q, *p;		for (q = p = filepath; *p;)	{		if (*p == ':')			q = p + 1;		p++;	}	return q;}short get_info (char *name,	OSType *creator, OSType *type, long *create, long *flen){	long	modif;	Str255	fname;	strcpy ((char *) &fname[1], name);	fname[0] = strlen (name);	return GetInfoFile (0, 0, fname, creator, type, create, &modif, flen);}short set_info (char *name, OSType creator, OSType type, long create){//	long	modif;	Str255	fname;	strcpy ((char *) &fname[1], name);	fname[0] = strlen (name);	return SetInfoFile (0, 0, fname, creator, type, create, create);}short set_ic_info (char *name, long create, short indexer){//	long	modif;	Str255	fname;	strcpy ((char *) &fname[1], name);	fname[0] = strlen (name);	SetInfoAndICTypeCreator (0,	0, fname, create, create, indexer);		return 1;}short xfsopen (char *name, short vref, short *fref){	Str255	fname;	strcpy ((char *) &fname[1], name);	fname[0] = strlen (name);	return FSOpen (fname, vref, fref);}short xfscreate (char *name, short vref, long creator, long type){	Str255	fname;	strcpy ((char *) &fname[1], name);	fname[0] = strlen (name);	return Create (fname, vref, creator, type);}short xfsdelete (char *name, short vref){	Str255	fname;	strcpy ((char *) &fname[1], name);	fname[0] = strlen (name);	return FSDelete (fname, vref);}