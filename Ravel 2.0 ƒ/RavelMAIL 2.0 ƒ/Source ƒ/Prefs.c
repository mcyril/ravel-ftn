#include <stdio.h>#include <string.h>#include "Ravel_FTN.h"//#include "hydra.h"#include "hydra_chat.h"#include "Ravel_Prefs.h"#include "log.h"#include "PascalStr.h"#include "Pathes.h"#include "Scheduler.h"#include "Main.h"#include "key.h"#define workPath		Pathes[_homePath-1]		//	working folder for bundling outbound#define outboundPath	Pathes[_outbPath-1]		//	outbound folder#define inboundPath		Pathes[_inbdPath-1]		//	inbound folder#define basePath		Pathes[_basePath-1]		//	base storage folder#define tempPath		Pathes[_tempPath-1]		//	temp folder (fe. for unpacking)#define logPath			Pathes[_logPath-1]		//	log-file pathStr255			nodePath;Str255			freqPath;Str255			ShufflerPathName;homeHndl		homesystem;			//	•	Home system structshort			NodesNumber;		//	•	Linked Nodes structs listnodePrefHndl	*nodesHndls;short			eventsNumber;		//	•	Events listeventsHndl		*eventsHndls;short			***evtRingsHndls;behaviorHndl	behavior;			//	•	Unattended behaviors list		Handle	phoneTrans;hiddenlinesPtr	*commonhiddens;StringPtr		*commoninits;		short	isdcd;extern	short	no_EMSI;			/* Global EMSI disable */extern	short	no_WaZOO;			/* Global WaZOO/YooHoo disable */		//		short	ZMAXSPLEN;		char	YesZedZip;		char	YesZedZap;		char	YesDirZap;		char	YesJanus;		char	YesHydra;		char	YesxHydra;		//••		char	YesClasp = false;		char	YesHydra8K;		char	YesHydra16K;				char	ctb_mon;unsigned char	timesyncbounds;short			timesynclink;extern	short	no_overdrive;	//••extern	short	no_resync;extern	short	no_sealink;extern	short	small_window;		short	badcount;		char	SerialDMA;extern	Boolean			multiline_flag;extern	short			multiline_line;unsigned long	minimal_baud_rate;				long	issuse_calls_mask;		long	zmh_calls_mask;		long	accept_calls_mask;		long	freq_event_mask;				short	timezone;//		short	daylight;extern	short	auto_scan;			/* auto toss sublaunch enable */extern	short	auto_toss;			/* auto toss sublaunch enable */extern	Str255		init_string;		Ptr			configStr;		Str255		lstnr1, lstnr2;		Str255		modem_diagnosis;//		short		zrecv_start_retry;//		short		zretries;		Boolean		paranoidal_log;		long	UNATTENDEDSLICE;		long	fUNATTENDEDSLICE;		long	hiho_can;		long	hiho_want;		long	joho;		long	zoho;typedef struct _tcp_rec {	long	defaultPort;	long	listenPort;	long	reserved[8];} tcp_rec, *p_tcp_rec, **h_tcp_rec;long			defaultPort, listenPort;typedef struct _wzoo {	char		zedzap;	char		paranoidal_log;	char		janus;	char		hydra;	long		freq_event_mask;	long		issuse_calls_mask;	long		accept_calls_mask;		char		dirzap;	char		zedzip;	short		badcount;	short		slice;	short		force_slice;	} wzoo, *p_wzoo, **h_wzoo;typedef struct _ftsc {	char	no_sealink;		//••		lika no_wazoo, etc.?	char	no_resync;		//••	char	no_overdrive;	//••	char	small_window;	//••	long	min_baud;	char	xhydra;	char	ctb_mon;	char	hydra8;	char	hydra16;	char	reserved[4];} ftsc, *p_ftsc, **h_ftsc;Boolean ReadPreference (void){	prefHndl	h1;	Handle		h, hhh;	short		prefResNum, prefResNum_l;	short		oldResNum = CurResFile ();	Boolean		res = FALSE;	short		i, ii;	Str255		temp;	FSSpec		spec;	long		dummy;	StringPtr	ph_num;		hiddenlinesPtr	lasthidden;		prefResNum = OpenRFPerm ( prefFile, 0, fsRdWrPerm );		if (multiline_flag)	{		pStrConc (prefFile, "\p #0", temp);		temp[temp[0]] += multiline_line;		prefResNum_l = OpenRFPerm ( temp, 0, fsRdWrPerm );			if ( prefResNum_l == -1 )		{			if ( prefResNum != -1 )				CloseResFile (prefResNum);						return res;		}	}		if ( prefResNum == -1 )		return res;	do {				if (!multiline_flag)			UseResFile ( prefResNum );		else			UseResFile ( prefResNum_l );	//•	Get tcp prefs…		h = Get1Resource ('TCP_', 0);				if (h)		{			defaultPort = (*(h_tcp_rec)h)->defaultPort;			listenPort = (*(h_tcp_rec)h)->listenPort;			ReleaseResource (h);		}		else		{			defaultPort = 60179;			listenPort = 60179;		}	//•	Get SerialDMA prefs…		h = Get1Resource ('SDMA', 0);				if (h)		{			SerialDMA = **h;			ReleaseResource (h);		}		else		{			SerialDMA = 0;		}		UseResFile ( prefResNum );		h = Get1Resource ( 'Shfl', 0 );		if (h)		{			MachineLocation	loc;			long			lll;			timezone = *((short *) (*h+2));						if (timezone == 'TZ')			{				ReadLocation (&loc);							lll = loc.u.gmtDelta & 0x00FFFFFFL;								if (loc.u.gmtDelta & 0x00010000L)					lll |= 0xFF000000L;				lll = lll / 3600L;				if (loc.u.dlsDelta < 0)					lll--;								timezone = lll;			}			ReleaseResource (h);		}		else			timezone = 0;	//•	Get comm. prefs…			if (!multiline_flag)			UseResFile ( prefResNum );		else			UseResFile ( prefResNum_l );		h = Get1Resource ( 'TptL', 0 );		if (h)		{			hiho_can = (xHCAN_OPTIONS & ~(HOPT_CRC32 | HOPT_DEVICE)) |					(((*(h_tpt_opt)h)->hydra32) ? HOPT_CRC32 : 0) |					(((*(h_tpt_opt)h)->chat) ? HOPT_DEVICE : 0);						hiho_want = xHWNT_OPTIONS |					(((*(h_tpt_opt)h)->hydra_esc) ? HOPT_XONXOFF|HOPT_TELENET : 0) |					(((*(h_tpt_opt)h)->hydra_uue) ? HOPT_CANUUE : 0) |					(((*(h_tpt_opt)h)->hydra_hi8) ? HOPT_HIGHBIT : 0);						joho = (xOURCAP & ~(xCANCRC32 | xCANBINKCHAT)) |					(((*(h_tpt_opt)h)->janus32) ? xCANCRC32 : 0) |					(((*(h_tpt_opt)h)->chat) ? xCANBINKCHAT : 0);			zoho = ((*(h_tpt_opt)h)->zmodem32) ? xCANFC32 : 0;						timesyncbounds = (*(h_tpt_opt)h)->timesyncbounds;			timesynclink = (!timesyncbounds) ? -1 : (*(h_tpt_opt)h)->timesynclink;			ReleaseResource ( h );		}		else		{			hiho_can = xHCAN_OPTIONS;			hiho_want = xHWNT_OPTIONS;			joho = xOURCAP;			zoho = xCANFC32;			timesyncbounds = 0;			timesynclink = -1;		}		h = Get1Resource ( 'WZoo', 0 );		if (h)		{			YesZedZip = (*(h_wzoo)h)->zedzip;			YesZedZap = (*(h_wzoo)h)->zedzap;			YesJanus = (*(h_wzoo)h)->janus;			YesHydra = (*(h_wzoo)h)->hydra;			YesDirZap = (*(h_wzoo)h)->dirzap;						badcount = ((*(h_wzoo)h)->badcount) ? (*(h_wzoo)h)->badcount : 0x7FF0;						paranoidal_log = (*(h_wzoo)h)->paranoidal_log;			freq_event_mask = (*(h_wzoo)h)->freq_event_mask;			issuse_calls_mask = (*(h_wzoo)h)->issuse_calls_mask;			accept_calls_mask = (*(h_wzoo)h)->accept_calls_mask;						UNATTENDEDSLICE = 60L * (*(h_wzoo)h)->slice;			fUNATTENDEDSLICE = 60L * (*(h_wzoo)h)->force_slice;			if (!UNATTENDEDSLICE)				UNATTENDEDSLICE = 1800L;						if (!fUNATTENDEDSLICE)				fUNATTENDEDSLICE = 1800L / 3;			//			ZMAXSPLEN = (YesZedZap) ? 8192 : 1024;			ReleaseResource ( h );		}		else		{			YesZedZip = 1;			YesZedZap = 0;			YesJanus = 0;			YesHydra = 0;			paranoidal_log = false;						freq_event_mask = 0;			issuse_calls_mask = 0;			accept_calls_mask = 0;			UNATTENDEDSLICE = 1800L;			fUNATTENDEDSLICE = 1800L / 3;//			ZMAXSPLEN = 1024;		}				h = Get1Resource ( 'FTSC', 0 );		if (h)		{			no_sealink = (*(h_ftsc)h)->no_sealink;		//••		lika no_wazoo, etc.?			no_resync = (*(h_ftsc)h)->no_resync;		//••			no_overdrive = (*(h_ftsc)h)->no_overdrive;	//••			small_window = (*(h_ftsc)h)->small_window;	//••			minimal_baud_rate = (*(h_ftsc)h)->min_baud;						YesxHydra = (YesHydra) ? (*(h_ftsc)h)->xhydra : 0;			YesHydra8K = (YesHydra) ? (*(h_ftsc)h)->hydra8 : 0;			YesHydra16K = (YesHydra && YesHydra8K) ? (*(h_ftsc)h)->hydra16 : 0;			ctb_mon = (*(h_ftsc)h)->ctb_mon;						ReleaseResource ( h );		}		else		{			no_sealink = 0;		//••		lika no_wazoo, etc.?			no_resync = 0;		//••			no_overdrive = 0;	//••			small_window = 0;	//••			YesxHydra = 0;			YesHydra8K = 0;			YesHydra16K = 0;						ctb_mon = false;						minimal_baud_rate = 0;		}		phoneTrans = Get1Resource ( 'STR#', 2 );		if (phoneTrans)		{			DetachResource (phoneTrans);			MoveHHi (phoneTrans);			HLock (phoneTrans);		}				h1 = (prefHndl) Get1Resource ( 'Pref', 0 );			if (h1)		{			no_EMSI = (*h1)->disableEMSI;		/* Global EMSI disable */			no_WaZOO = (*h1)->disableWaZOO;		/* Global WaZOO/YooHoo disable */				auto_scan = (*h1)->auto_scan;		/* Auto scan enabler */			auto_toss = (*h1)->auto_toss;		/* Auto toss enabler */						Settings.portSetup = (*h1)->baud+(*h1)->stop+(*h1)->parity+(*h1)->data;			Settings.handshake = (*h1)->hanshake & 0xFF;		//	Settings.handshake = 4;			Settings.lockPort = (*h1)->hanshake >> 8;						isdcd = (*h1)->isdcd;						pStrCopy ( (*h1)->port_name, Settings.portName );						ReleaseResource ((Handle)h1);		}		else			break;	//• Get init string			h = Get1Resource ( 'STR ', 1 );		pStrCopy ( (h) ? (unsigned char *) *h : "\pATZ", init_string );				if (h)			ReleaseResource (h);		h = Get1Resource ('CSTR', 128);		if (h)		{			HLock (h);			configStr = NewPtrClear (GetResourceSizeOnDisk (h));			strcpy (configStr, *h);			ReleaseResource (h);		}		else			configStr = NULL;		h = Get1Resource ( 'STR ', 129 );		pStrCopy ( (h) ? (unsigned char *) *h : "\p", lstnr1 );		if (h)			ReleaseResource (h);		lstnr1[lstnr1[0]+1] = 0;		h = Get1Resource ( 'STR ', 130 );		pStrCopy ( (h) ? (unsigned char *) *h : "\p", lstnr2 );		if (h)			ReleaseResource (h);		lstnr2[lstnr2[0]+1] = 0;		h = Get1Resource ( 'STR ', 131 );		//	gotcha modem tester		pStrCopy ( (h) ? (unsigned char *) *h : "\p", modem_diagnosis );		modem_diagnosis[modem_diagnosis[0]+1] = 0;				if (h)			ReleaseResource (h);		lstnr2[lstnr2[0]+1] = 0;		UseResFile ( prefResNum );	//•	Get pathes…			if ( Get1Resource ( 'STR#', PathID ) && !LMGetResErr () )		{					for ( i = 0; i < _logPath; i++ )			{				GetIndString ( Pathes[i], PathID, i+1 );				Pathes[i][Pathes[i][0]+1] = 0;			}				//•	Check all folders…				for ( i = 0; i < _basePath; i++ )			{				pStrCopy ( Pathes[i], temp );	//			temp[0]--;								if ( FSMakeFSSpec ( 0, 0, temp, &spec ) == fnfErr )				{					if ( DirCreate ( 0, 0, temp, &dummy ) )						return false;				}			}		}		else			break;		//•	NodeList path			GetIndString ( nodePath, PathID, 7 );	//•	Freq path			GetIndString ( freqPath, PathID, 8 );	//•	Get Shuffler PathName			h = Get1Resource ( 'STR ', 100 );		pStrCopy ( (h) ? (unsigned char *) *h : "\p:RavelSHUFFLER", ShufflerPathName );		ReleaseResource (h);				if (!ShufflerPathName[0])			pStrCopy ( "\p:RavelSHUFFLER", ShufflerPathName );			//•	Get home system info…			if ( (h = Get1Resource ( homeRes, 0 )) != NULL )		{			DetachResource ( h );			MoveHHi ( h );			HLock ( h );		}		else			break;				homesystem = (homeHndl) h;	//•	Get nodes desc…		if (!multiline_flag)			UseResFile ( prefResNum );		else			UseResFile ( prefResNum_l );		NodesNumber = Count1Resources ( nodesRes );		nodesHndls = (nodePrefHndl *) NewPtr ( NodesNumber * sizeof (Handle) );		for ( i = 0; ; i++ )			if ( (h = Get1Resource ( nodesRes, i )) != NULL )			{				DetachResource ( h );				MoveHHi ( h );				HLock ( h );				nodesHndls[i] = (nodePrefHndl) h;			}			else				break;		if (timesyncbounds)		{			if (timesynclink < 0 || timesynclink >= NodesNumber)			{				timesyncbounds = 0;				timesynclink = -1;			}		}		else			timesynclink = -2;		if ( i != NodesNumber )			break;	//•	ZMH		hhh = Get1Resource ('WKtm', 0);		if (hhh)		{			zmh_calls_mask = *((long *) *hhh);			ReleaseResource (hhh);		}		else			zmh_calls_mask = 0;				//•	Nodes' hidden lines phones and alternative init strings			commonhiddens = (hiddenlinesPtr *) NewPtrClear (sizeof (hiddenlinesPtr) * NodesNumber);		commoninits = (StringPtr *) NewPtrClear (sizeof (Ptr) * NodesNumber);				for (i = 0; i < NodesNumber; i++)		{			h = Get1Resource ( 'STR#', i+1000 );						if (h)			{				HLock (h);					for (ii = 1; ; ii++)				{					ph_num = GetStr (h, ii);										if (!ph_num)					{						if (ii != 1)						{							lasthidden->next = (hiddenlinesPtr) NewPtr (sizeof (hiddenlines));							lasthidden = lasthidden->next;							lasthidden->worktime = 0;							lasthidden->phone[0] = 0;							lasthidden->next = commonhiddens[i];						}												break;					}					else					{						if (ii == 1)						{							commonhiddens[i] = (hiddenlinesPtr) NewPtr (sizeof (hiddenlines));							lasthidden = commonhiddens[i];						}						else						{							lasthidden->next = (hiddenlinesPtr) NewPtr (sizeof (hiddenlines));							lasthidden = lasthidden->next;						}												pStrCopy (ph_num, lasthidden->phone);						lasthidden->phone[lasthidden->phone[0]+1] = 0;												hhh = Get1Resource ('WKtm', ii+i*100+999);						if (hhh)						{							lasthidden->worktime = *((long *) *hhh);							ReleaseResource (hhh);						}						else							lasthidden->worktime = 0;					}				}								ReleaseResource (h);			}				//•	Get Addenum init strings						h = Get1Resource ( 'STR ', i+1000 );						if (h)			{				HLock (h);				commoninits[i] = (StringPtr) NewPtrClear (*((unsigned char *)*h) + 2);				pStrCopy ((StringPtr) *h, commoninits[i]);				ReleaseResource (h);			}		}			//•	Get events desc…		eventsNumber = Count1Resources ( 'Evt ' );		eventsHndls = (eventsHndl *) NewPtr ( eventsNumber * sizeof (Handle) );		evtRingsHndls = (short ***) NewPtrClear ( eventsNumber * sizeof (short **) );		if (eventsNumber>32)			break;				for ( i = 0; ; i++ )			if ( (h = Get1Resource ( 'Evt ', i )) != NULL )			{				DetachResource ( h );				MoveHHi ( h );				HLock ( h );				eventsHndls[i] = (eventsHndl) h;								if ( (h = Get1Resource ( 'Ring', i )) != NULL )				{					DetachResource ( h );					MoveHHi ( h );					HLock ( h );				}				else				{					h = NULL;				}								evtRingsHndls[i] = (short **) h;			}			else				break;		if ( i != eventsNumber )			break;	//• Get behaviors		if ( (h = Get1Resource ( 'Evts', 0 )) != NULL )		{			DetachResource ( h );			MoveHHi ( h );			HLock ( h );			behavior = (behaviorHndl) h;		}				else			break;		//•	Get key			UseResFile ( prefResNum );#ifndef LITE#ifdef PROTECTED		h = Get1Resource ( 'TEXT', 0 );		if (h)			DetachResource (h);				keyHandle = h;#endif#endif		res = true;	} while (0);	UseResFile ( oldResNum );	CloseResFile ( prefResNum );	if (multiline_flag)		CloseResFile ( prefResNum_l );	return res;}