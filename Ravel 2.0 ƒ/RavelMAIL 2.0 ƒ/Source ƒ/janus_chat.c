#include <stdio.h>#include <string.h>#include <time.h>#include <Sound.h>#include "Comm.h"#include "janus_chat.h"#include "zfiles.h"#include "zmodem.h"#include "Modem.h"#include "Timing.h"#include "compatible.h"#include "aglcrc.h"#include "PascalStr.h"#include "Ravel_FTN.h"#include "Ravel_Prefs.h"#include "Scheduler.h"#include "Unattended.h"#ifndef LITE#include "Attacher.h"#include "Pathes.h"#include "emsi.h"#include "wazoo.h"#include "log.h"#include "pmain.h"#include "freq.h"#include "myEnv.h"#include "history.h"extern unsigned char	Txbuf[WAZOOMAX + 16];extern unsigned long	cur_baud;	/* Current baud rate   */extern long				Rxpos;						/* Received file position    */extern short			isOriginator;extern short			gotta_mail;				// somewhat received with ZedZapextern short			gotta_xmail;				// somewhat received with ZedZapextern Boolean			Aborted;extern	in_outboundPtr	cur_over;		// current ptr for flostatic	in_outboundPtr	frq_over;		// current ptr for frqextern	in_outboundPtr	outbound;		// original ptrextern short		remote_capabilities;extern Boolean		emsi_session;extern ADDR			remote_addr;extern ADDR_LIST	remote_ads;extern EMSI_CALL_OPTIONS emsi_options;extern	short		tmail_chat;extern long			joho;extern h_pc_exch	pc_exch_pref;static long			rxstpos1;				/* Initial data position of file we're receiving   */static ADDR			*operate_addr;static ADDR_LIST	*next_oper;static Str255		flo_attacher;		//	full path to .?lo file w/o suffixstatic short		flo_method;			//	0	-	manual										//	3	-	hold										//	2	-	direct										//	1	-	crashstatic char			outboundname[PATHLEN];static ADDR			*operate_addr_frq;static ADDR_LIST	*next_oper_frq;static Str255		frq_attacher;		//	full path to .req file w/o suffixstatic short		frq_method;			//	0	-	manual										//	3	-	hold										//	2	-	direct										//	1	-	crashstatic	StringPtr	pollModes[4] = { "\p", "\p.CLO", "\p.DLO", "\p.HLO" };static short	errno;static long		ioCounter;static Ptr				attachlist;static Ptr				requestlist;static pfreq	nextfreq;static char		*request_template = "%s%s.R%02x";/* Private routines */Boolean PathForOutbound (ADDR *oper, StringPtr flo);static void  getfname (unsigned short);static void  sendpkt (unsigned char *, short, short);static void  sendpkt32 (unsigned char *, short, short);static void  txbyte (unsigned char);static long  procfname (void);static unsigned char  rcvpkt (void);static void  rxclose (unsigned short);static void  endbatch (void);static void  update_y (void);static void  long_set_timer (unsigned long *, unsigned short);static short  long_time_gone (unsigned long *);static short  rcvrawbyte (void);static short  rxbyte (void);static short  get_filereq (unsigned char);static short record_reqfile (char *);	/* ** NOT ** !!! */static short timeof_reqfile (long);	/* ** NOT ** !!! */static unsigned char  get_reqname (unsigned char);static void  mark_done (char *);/* Private data. I know, proper software design says you shouldn't make data *//* global unless you really need to.  In this case speed and code size make  *//* it more important to avoid constantly pushing & popping arguments.        */static char *GenericError = "!%s";static char *ReqTmpTempl = "JANUSREQ.%02x";static char ReqTmp[16];static char *Rxbuf;				/* Address of packet reception buffer              */static char *Txfname;			/* Full path of file we're sending                 */static char *Rxfname;			/* Full path of file we're receiving               */static unsigned char *Rxbufptr;			/* Current position within packet reception buffer */static unsigned char *Rxbufmax;			/* Upper bound of packet reception buffer          */static unsigned char Do_after;			/* What to do with file being sent when we're done */static unsigned char WaitFlag;			/* Tells rcvrawbyte() whether or not to wait       */static unsigned char SharedCap;			/* Capability bits both sides have in common       */static short Txfile;				/* File handle of file we're sending               */static short Rxfile;				/* File handle of file we're receiving             */static short ReqRecorded;			/* Number of files obtained by this request        */static unsigned short TimeoutSecs;		/* How long to wait for various things             */static short Rxblklen;			/* Length of data in last data block packet recvd  */static short Next_y;				/* Number of next available line on screen         */static short Tx_y;				/* Line number of file transmission status display */static short Rx_y;				/* Line number of file reception status display    */static long Txlen;				/* Total length of file we're sending              */static long Rxlen;				/* Total length of file we're receiving            */static long Rxfiletime;			/* Timestamp of file we're receiving               */static long Diskavail;			/* Bytes available in upload directory             */static short EMSI_flag;			/* Currently in EMSI-Session ?                     */static short EMSI_aka;			/* Current aka to send mail to                     */static short EMSI_raka;			/* Current aka to request files from               */static long	TxChatOffset;		/* Chat related stuffs */static long	RxChatOffset;static unsigned long	TxStart, RxStart;static char		*chatstart = "\x5\r * Chat mode start\r\n";static char		*chatend   = "\007\007\r\n * Chat mode end\r\n";static char		*chattime  = "\007\007\r\n * Chat mode end - timeout\r\n";//static char		*cooka  = "\005?";static long		chattimer, lasttimer;static short	chatfill = 0;			//• ZERRRRO!static Boolean	nobell = false;extern	short		delaing;										/* Moved from locals */static	unsigned long	brain_dead;		/* Time at which to give up on other computer      */static	unsigned char	xstate;			/* Current file transmission state                 */static	unsigned char	rstate;			/* Current file reception state                    */static	unsigned char	pkttype;		/* Type of packet last received                    */static	unsigned char	chattxstate;	/* chat state										*/static	unsigned char	*chattxbuf;static	unsigned short	chattxlen;static	Boolean			InitedChat = false;//static	short			sequence, lastsequence;#define	CHAT_TIMEOUT	30L#define	local_win		1#define	remote_win		2void	win_putc (short win, short c);void	dispose_chat_window (short win);void	win_puts (short win, unsigned char *s);static	Boolean			warned;/*---------------------------------------------------------------------------*/static Boolean janus_devfree (void){	if (chattxstate || !((SharedCap & CANBINKCHAT) || tmail_chat))		return (false);						/* busy or not allowed       */	else		return (true);						/* allowed to send a new pkt */}/*---------------------------------------------------------------------------*/static Boolean janus_devsend (char *dev, unsigned char *data, unsigned short len){	if (!dev || !data || !len || !janus_devfree ())		return (false);	chattxbuf = data;	chattxlen = (len > BUFMAX) ? BUFMAX : len;	chattxstate = CHAT_DATA;	/* special for chat, only prolong life if our side keeps typing! */	if (chattimer > 0L && xstate == XDONE)		long_set_timer (&brain_dead, 120);	return (true);}static void janus_devrecv (long offsettotext){	register char *p = ((char *) Rxbuf) + offsettotext;//	register short i;	unsigned short len = Rxblklen - offsettotext;	if (chattimer > 0)	{		chattimer = LMGetTicks() + 60L*CHAT_TIMEOUT;		warned = false;	}		p[len] = 0;	win_puts (remote_win, (unsigned char *) p);}static void loc_puts (char *s){	win_puts (local_win, (unsigned char *) s);}#define CHATLEN 256static	unsigned char	chatbuf1[CHATLEN + 5],						chatbuf2[CHATLEN + 5],						*curbuf;static short keyabort (void){		Boolean			esc = false;		char			*p;		unsigned short	c;		EventRecord		event;		short			_delaing;		Boolean			tod;	if (Aborted)		return true;	if (chattimer > 0L)	{		if (LMGetTicks() > chattimer)		{			chattimer = lasttimer = 0L;			janus_devsend("CON",(unsigned char *) chattime,strlen(chattime));			loc_puts(&chattime[2]);		}		else			if ((LMGetTicks() + 10L*60L) > chattimer && !warned)			{				loc_puts ("\007\r\n * Warning: chat mode timeout in 10 seconds\r\n");				warned = true;			}	}	else		if (chattimer != lasttimer)		{			if (chattimer ==  0L)			{				if (nobell) p = " * Remote has chat facility with bell disabled\n";				else        p = " * Remote has chat facility with bell enabled\n";				janus_devsend ("CON",(unsigned char *) p,(short) strlen(p));//				loc_puts(" * Janus session in progress, chat facility now available\r\n");			}			else				if (chattimer == -1L)				{//					loc_puts(" * Janus session in init state, can't chat yet\r\n");				}				else					if (chattimer == -2L)						loc_puts(" * Remote has no chat facility available (DEL - hide window)\r\n");					else						if (chattimer == -3L)						{							if (lasttimer > 0L)								loc_puts("\r\n");					//							loc_puts(" * Janus session in exit state, can't chat anymore\r\n");						}									lasttimer = chattimer;		}	tod = WaitNextEvent (everyEvent, &event, gSleepTime, NULL);		if (!tod || (event.what != keyDown && event.what != autoKey))	{		_delaing = delaing;		delaing = 1;		DoEvent (&event);		delaing = _delaing;		tod = false;	}		if (Aborted)			//	made by ESC pressed	{		putMessage ( 0, "\pAborted…" );		Aborted = true;		esc = true;	/* Cancel by button */		tod = false;	}		if (tod && ((joho & CANBINKCHAT) || tmail_chat))	{		do		{			if ((event.modifiers & (cmdKey | optionKey | controlKey)) == controlKey)			{				switch (event.message & keyCodeMask)				{				case 0x0800:		//	Ctrl-C									c = 0x7F;		//	Map to DEL					break;								case 0x0500:		//	Ctrl-G									c = 0x05;		//	Map to Help					break;								default:									c = event.message & charCodeMask;					break;				}			}			else				c = event.message & charCodeMask;						switch (c)			{			case 0x1B:				putMessage ( 0, "\pAborted…" );				Aborted = true;				esc = true;				break;			case 0x7F:			//	Alt_C:				if (chattimer == 0L)				{					janus_devsend ("CON",(unsigned char *) chatstart,strlen(chatstart));					loc_puts(&chatstart[2]);					chattimer = lasttimer = LMGetTicks() + 60L*CHAT_TIMEOUT;//					putlog ('~', "Starting sent");//					sequence = lastsequence = 0;				}				else					if (chattimer > 0L)					{						chattimer = lasttimer = 0L;						janus_devsend("CON",(unsigned char *) chatend,strlen(chatend));						loc_puts(&chatend[2]);												dispose_chat_window (1);						dispose_chat_window (2);					}					else						if (chattimer <= -2)						{							dispose_chat_window (1);							dispose_chat_window (2);						}						else							SysBeep (10);				break;						default:				//			if (c < ' ' || c > 126)								if (c == 5)					c = 7;				else					if (c < ' ')						break;			case 13:			case 7:			case 8:				if (chattimer <= 0L)					break;				chattimer = LMGetTicks() + 60L*CHAT_TIMEOUT;				warned = false;				if (chatfill >= CHATLEN)					SysBeep (10);				else				{					switch (c)					{					case 13:						curbuf[chatfill++] = 10;						win_putc (local_win, 10);						break;					case 8:						if (chatfill > 0 && curbuf[chatfill - 1] != 10)							chatfill--;						else						{							curbuf[chatfill++] = '\x8';							curbuf[chatfill++] = ' ';							curbuf[chatfill++] = '\x8';						}						win_putc (local_win, 8);									break;					default:						curbuf[chatfill++] = (unsigned char) c;						if (c != 7)							win_putc (local_win, c);						else							SysBeep (10);													break;					}				}						break;			}			if (!WaitNextEvent (everyEvent, &event, gSleepTime, NULL))				break;		} while (!esc && (event.what == keyDown || event.what == autoKey));		_delaing = delaing;		delaing = 1;		DoEvent (&event);		delaing = _delaing;	}	if (chatfill > 0 && janus_devsend ("CON",curbuf,chatfill))	{		curbuf = (curbuf == chatbuf1) ? chatbuf2 : chatbuf1;		chatfill = 0;//		if (sequence >= 0 && sequence == lastsequence)//			sequence++;	}		return (esc);}/*keyabort()*/static void slice (void){	keyabort ();}/*****************************************************************************//* Super-duper neato-whizbang full-duplex streaming ACKless batch file       *//* transfer protocol for use in WaZOO mail sessions                          *//*****************************************************************************/void Janus (void){//	unsigned char pkttype;				/* Type of packet last received                    */	unsigned char tx_inhibit;			/* Flag to wait and send after done receiving      *///	char *holdname;				/* Name of hold area                               */	unsigned char fsent;					/* Did we manage to send anything this session?    */	unsigned char sending_req;			/* Are we currently sending requested files?       */	unsigned char attempting_req;		/* Are we waiting for the sender to start our req? */	unsigned char req_started;			/* Has the sender started servicing our request?   */	short txoldeta;				/* Last transmission ETA displayed                 */	short rxoldeta;				/* Last reception ETA displayed                    */	unsigned short blklen;				/* Length of last data block sent                  */	unsigned short txblklen;				/* Size of data block to try to send this time     */	unsigned short txblkmax;				/* Max size of data block to send at this speed    */	unsigned short goodneeded;			/* # good bytes to send before upping txblklen     */	unsigned short goodbytes;				/* Number of good bytes sent at this block size    */	unsigned short rpos_count;			/* Number of RPOS packets sent at this position    */	unsigned long xmit_retry;			/* Time to retransmit lost FNAMEPKT or EOF packet  */	long txpos;					/* Current position within file we're sending      */	long lasttx;				/* Position within file of last data block we sent */	long txstpos;				/* Initial data position of file we're sending     */	long rxstpos;				/* Initial data position of file we're receiving   */	long txoldpos;				/* Last transmission file position displayed       */	long rxoldpos;				/* Last reception file position displayed          */	unsigned long rpos_retry;			/* Time at which to retry RPOS packet              */	unsigned long rpos_sttime = 0;		/* Time at which we started current RPOS sequence  */	unsigned long last_rpostime;		/* Timetag of last RPOS which we performed         */	long last_blkpos;			/* File position of last out-of-sequence BLKPKT    */	short		eta;	long		cps;		Str255		pathname;	//	••	Special for CHAT perversions	joho &= OURCAP;	if (!(joho & CANBINKCHAT))		tmail_chat = false;		putlog ('~', "We can %.2lX", (unsigned long)joho);		InitedChat = false;	Aborted = false;	nextfreq = NULL;//	Tx_y = Rx_y = 0;	SharedCap = 0;	TxChatOffset = 0;	RxChatOffset = 0;	attachlist = NULL;	requestlist = NULL;	frq_method = 0;		/*------------------------------------------------------------------------*/	/* Allocate memory                                                        */	/*------------------------------------------------------------------------*/	Rxbuf = (char *) Txbuf + 4096 + 8;	Txfname = Rxfname = NULL;	if (((Txfname = NewPtr (PATHLEN)) == NULL)		|| ((Rxfname = NewPtr (PATHLEN)) == NULL))	{		Aborted = true;		mdm_hangup (NULL);		goto freemem;	}	Rxbufmax = (unsigned char *) (Rxbuf + BUFMAX + 8);	/*------------------------------------------------------------------------*/	/* Initialize file transmission variables                                 */	/*------------------------------------------------------------------------*///••	EMSI_flag = emsi_session;	if (EMSI_flag)	{		next_oper_frq = remote_ads.next;  /* This should be empty, but we'll go to the end anyway! */		operate_addr_frq = &(next_oper_frq->ad);	}	else		operate_addr_frq = &remote_addr;		EMSI_raka = 0;		tx_inhibit = FALSE;	last_rpostime = last_blkpos = lasttx = txstpos = rxstpos = rxstpos1 = xmit_retry = 0L;	long_set_timer (&brain_dead, 120);	if (cur_baud > 9600L)	{		TimeoutSecs = 30;		txblkmax = BUFMAX;	}	else	{		TimeoutSecs = (unsigned short) (40960L / cur_baud);		if (TimeoutSecs < 30)			TimeoutSecs = 30;		txblkmax = (short)cur_baud / 300 * 128;		if (txblkmax > BUFMAX)			txblkmax = BUFMAX;	}	/*------------------------------------------------------------------------*/	chatfill  = 0;	lasttimer = 0L;	chattxstate = CHAT_DONE;	curbuf = chatbuf1;	warned = false;//	sequence = lastsequence = -1;//	if ((joho & CANBINKCHAT) || tmail_chat)		//•••???????	if (joho & CANBINKCHAT)						//•••???????	{		lasttimer = 0L;		chattimer = -1L;		loc_puts (" *** Press DEL to start/end chat mode\r\n");	}	else	{		lasttimer = -2L;		chattimer = -2L;	}	/*------------------------------------------------------------------------*/	txblklen = txblkmax;	goodbytes = goodneeded = 0;	Txfile = -1;	sending_req = fsent = FALSE;	xstate = XSENDFNAME;	getfname (INITIAL_XFER);	/*------------------------------------------------------------------------*/	/* Initialize file reception variables                                    */	/*------------------------------------------------------------------------*/	Diskavail = 0x7FFFFFF;	Rxbufptr = NULL;	rpos_retry = rpos_count = 0;	attempting_req = req_started = FALSE;	rstate = RRCVFNAME;	/*------------------------------------------------------------------------*/	/* Send and/or receive stuff until we're done with both                   */	/*------------------------------------------------------------------------*/	do	{							/* while (xstate || rstate)  */		putMessage (0, "\pTransferring file(s)…");		/*---------------------------------------------------------------------*/		/* If nothing useful (i.e. sending or receiving good data block) has   */		/* happened within the last 2 minutes, give up in disgust              */		/*---------------------------------------------------------------------*/		if (long_time_gone (&brain_dead))		{			putlog (lgALRT, "He's dead, Jim.");			goto giveup;		}		/*---------------------------------------------------------------------*/		/* If we're tired of waiting for an ACK, try again                     */		/*---------------------------------------------------------------------*/		if (xmit_retry)		{			if (long_time_gone (&xmit_retry))			{				putMessage (0, "\pTimeout");								xmit_retry = 0L;				switch (xstate)				{				case XRCVFNACK:					xstate = XSENDFNAME;					break;				case XRCVFRNAKACK:					xstate = XSENDFREQNAK;					break;				case XRCVEOFACK:					errno = 0;					if (SetFPos (Txfile, fsFromStart, txpos = lasttx))					{						goto giveup;					}					xstate = XSENDBLK;					break;				}			}		}				/*---------------------------------------------------------------------*/		/* Chat's fucking about                                                */		/*---------------------------------------------------------------------*/				if (xstate != XSENDFNAME)		switch (chattxstate)		{		case CHAT_DATA:				putlog ('~', "in CHAT>> %s (%ldb)", Txbuf, Txlen);			if (tmail_chat)			{				memcpy (Txbuf, chattxbuf, chattxlen);				Txbuf[chattxlen] = 0;				sendpkt (Txbuf, chattxlen, TCHATPKT);			}			else			{#ifdef FASTER				*((long *)Txbuf) = endlong (RxChatOffset);				*((long *)&Txbuf[4]) = endlong (TxChatOffset);#else				Txbuf[0] = RxChatOffset & 0xff;				Txbuf[1] = (RxChatOffset >> 8) & 0xff;				Txbuf[2] = (RxChatOffset >> 16) & 0xff;				Txbuf[3] = (RxChatOffset >> 24) & 0xff;				Txbuf[4] = TxChatOffset & 0xff;				Txbuf[5] = (TxChatOffset >> 8) & 0xff;				Txbuf[6] = (TxChatOffset >> 16) & 0xff;				Txbuf[7] = (TxChatOffset >> 24) & 0xff;#endif				memcpy (Txbuf+8, chattxbuf, chattxlen);				Txbuf[chattxlen+8] = 0;				sendpkt (Txbuf, chattxlen+8, CHATPKT);				TxChatOffset += chattxlen;			}						chattxstate = CHAT_DONE;	putlog ('~', "out CHAT>> %s (%ldb)", Txbuf, Txlen);			break;					default:					break;		}				/*---------------------------------------------------------------------*/		/* Transmit next part of file, if any                                  */		/*---------------------------------------------------------------------*/		switch (xstate)		{		case XSENDBLK:			if (tx_inhibit)				break;			lasttx = txpos;#ifdef FASTER			*((long *)Txbuf) = endlong (txpos);#else			Txbuf[0] = txpos & 0xff;			Txbuf[1] = (txpos >> 8) & 0xff;			Txbuf[2] = (txpos >> 16) & 0xff;			Txbuf[3] = (txpos >> 24) & 0xff;#endif			errno = 0;//••			ioCounter = txblklen;			FSRead (Txfile, &ioCounter, Txbuf + sizeof (txpos));			blklen = ioCounter;						txpos += blklen;			sendpkt (Txbuf, sizeof (txpos) + blklen, BLKPKT);						eta = (short) ((((Txlen - txpos) * 10L) / cur_baud * 100L / JANUS_EFFICIENCY + 59L) / 60L);						if ((LMGetTicks () - TxStart) != 0)				cps = (((txpos - txstpos) * 60L) / (LMGetTicks () - TxStart));			else				cps = 0;						newMessage (lTSTAT, "%ld:%ld (%d) [%d min, %ld cps]", txpos, Txlen, blklen, eta, cps);			drawProgressBar (ITBAR, txpos, Txlen);			drawProgressCircle (ITCIRCLE, blklen, 0);			putMessage (0, "\pTransferring file(s)…");						fsent = TRUE;			if (txpos >= Txlen || blklen < txblklen)			{				long_set_timer (&xmit_retry, TimeoutSecs);				xstate = XRCVEOFACK;			}			else				long_set_timer (&brain_dead, 120);			if (txblklen < txblkmax && (goodbytes += txblklen) >= goodneeded)			{				txblklen <<= 1;				goodbytes = 0;			}						break;		case XSENDFNAME:			blklen = (short) (strchr (strchr ((char *) Txbuf, '\0') + 1, '\0') - (char *) Txbuf) + 1;			//			Txbuf[blklen++] = (tmail_chat) ? (joho & ~CANBINKCHAT) : joho;			Txbuf[blklen++] = joho;			putlog ('~', "[XSENDFNAME] blklen = %ld '%s', %.2lX", (long) blklen, Txbuf, (unsigned long)(Txbuf[blklen-1]));			sendpkt (Txbuf, blklen, FNAMEPKT);			txoldpos = txoldeta = -1;			long_set_timer (&xmit_retry, TimeoutSecs);			xstate = XRCVFNACK;			break;		case XSENDFREQNAK:			sendpkt (NULL, 0, FREQNAKPKT);			long_set_timer (&xmit_retry, TimeoutSecs);			xstate = XRCVFRNAKACK;			break;		}		/*---------------------------------------------------------------------*/		/* Catch up on our reading; receive and handle all outstanding packets */		/*---------------------------------------------------------------------*/		while ((pkttype = rcvpkt ()) != 0)		{			if (pkttype != BADPKT)				long_set_timer (&brain_dead, 120);			switch (pkttype)			{				/*---------------------------------------------------------------*/				/* File data block or munged block                               */				/*---------------------------------------------------------------*/			case BADPKT:			case BLKPKT:				if (rstate == RRCVBLK)				{					unsigned long t;#ifdef FASTER					t = endlong (*((long *)Rxbuf));#else					t = (unsigned char) Rxbuf[3];					t = (t << 8) | (unsigned char) Rxbuf[2];					t = (t << 8) | (unsigned char) Rxbuf[1];					t = (t << 8) | (unsigned char) Rxbuf[0];#endif					if (pkttype == BADPKT || (t != Rxpos))					{						if (pkttype == BLKPKT)						{							if (t < last_blkpos)								rpos_retry = rpos_count = 0;							last_blkpos = t;						}						if (long_time_gone (&rpos_retry))						{							/*---------------------------------------------------*/							/* If we're the called machine, and we're trying to  */							/* send stuff, and it seems to be screwing up our    */							/* ability to receive stuff, maybe this connection   */							/* just can't hack full-duplex.  Try waiting till    */							/* the sending system finishes before sending our    */							/* stuff to it                                       */							/*---------------------------------------------------*/							if (rpos_count > 4)							{								if (xstate && !isOriginator && !tx_inhibit)								{									tx_inhibit = TRUE;									putMessage (0, "\pSwitch to half-duplex");								}								rpos_count = 0;							}							if (++rpos_count == 1)								(void) time ((time_t *) & rpos_sttime);							putMessage (0, "\pBad packet");#ifdef FASTER							*((long *)Rxbuf) = endlong (Rxpos);							*((long *)&Rxbuf[4]) = endlong (rpos_sttime);#else							Rxbuf[0] = Rxpos & 0xff;							Rxbuf[1] = (Rxpos >> 8) & 0xff;							Rxbuf[2] = (Rxpos >> 16) & 0xff;							Rxbuf[3] = (Rxpos >> 24) & 0xff;							Rxbuf[4] = rpos_sttime & 0xff;							Rxbuf[5] = (rpos_sttime >> 8) & 0xff;							Rxbuf[6] = (rpos_sttime >> 16) & 0xff;							Rxbuf[7] = (rpos_sttime >> 24) & 0xff;#endif							sendpkt ((unsigned char *) Rxbuf, sizeof (Rxpos) + sizeof (rpos_sttime), RPOSPKT);							long_set_timer (&rpos_retry, TimeoutSecs / 2);						}					}					else					{						last_blkpos = Rxpos;						rpos_retry = rpos_count = 0;						errno = 0;												ioCounter = (Rxblklen -= sizeof (Rxpos));						FSWrite (Rxfile, &ioCounter, Rxbuf + sizeof (Rxpos) );						Diskavail -= Rxblklen;						Rxpos += Rxblklen;						eta = (short) ((((Rxlen - Rxpos) * 10L) / cur_baud * 100L / JANUS_EFFICIENCY + 59L) / 60L);						if ((LMGetTicks () - RxStart) != 0)							cps = (((Rxpos - rxstpos) * 60L) / (LMGetTicks () - RxStart));						else							cps = 0;						newMessage (lRSTAT, "%ld:%ld (%d) [%d min, %ld cps]", Rxpos, Rxlen, Rxblklen, eta, cps);						drawProgressBar (IRBAR, Rxpos, Rxlen);						drawProgressCircle (IRCIRCLE, Rxblklen, 0);						if (Rxpos >= Rxlen)						{							rxclose (GOOD_XFER);							Rxlen -= rxstpos;							history_add_traff (false, Rxlen);							putlog (lgNOPE, "Received-J%s %s [%ld cps]", (SharedCap & CANCRC32) ? "/32" : "", trunc_path (Rxfname), cps);							newMessage (lRNAME, "");							newMessage (lRSTAT, "");							drawProgressBar (IRBAR, -1, 0);							rstate = RRCVFNAME;						}					}				}				if (rstate == RRCVFNAME)					sendpkt (NULL, 0, EOFACKPKT);				break;				/*---------------------------------------------------------------*/				/* Name and other data for next file to receive                  */				/*---------------------------------------------------------------*/			case FNAMEPKT:								if (rstate == RRCVFNAME)					Rxpos = rxstpos = rxstpos1 = procfname ();								if (!Rxfname[0] && get_filereq (req_started))				{					sendpkt ((unsigned char *) Rxbuf, strlen (Rxbuf) + 2, FREQPKT);					attempting_req = TRUE;					req_started = FALSE;				}				else				{					if (attempting_req)					{						attempting_req = FALSE;						req_started = TRUE;					}#ifdef FASTER					*((long *)Rxbuf) = endlong (Rxpos);#else					Rxbuf[0] = Rxpos & 0xff;					Rxbuf[1] = (Rxpos >> 8) & 0xff;					Rxbuf[2] = (Rxpos >> 16) & 0xff;					Rxbuf[3] = (Rxpos >> 24) & 0xff;#endif					Rxbuf[4] = SharedCap;					putlog ('~', "[FNAMEPKT] SharedCap %.2lX", (unsigned long)SharedCap);					sendpkt ((unsigned char *) Rxbuf, sizeof (Rxpos) + 1, FNACKPKT);					rxoldpos = rxoldeta = -1;					if (Rxpos > -1)						rstate = (unsigned char) ((Rxfname[0]) ? RRCVBLK : RDONE);					else						putlog (lgNOPE, "Refusing %s", trunc_path (Rxfname));					if (!rstate)						tx_inhibit = FALSE;					if (!(xstate || rstate))						goto breakout;				}				break;				/*---------------------------------------------------------------*/				/* ACK to filename packet we just sent                           */				/*---------------------------------------------------------------*/			case FNACKPKT:							if (xstate == XRCVFNACK)				{					xmit_retry = 0L;					if (Txfname[0])					{						SharedCap = (Rxblklen > sizeof (long)) ? Rxbuf[4] : 0;						putlog ('~', "[FNACKPKT] Shared %.2lX", (unsigned long)SharedCap);//•••	chat workaround						if (!InitedChat)						{							chattimer = (SharedCap & CANBINKCHAT) ? 0L : -2L;							if (chattimer == -2 && tmail_chat)								chattimer = 0L;														if ((SharedCap & CANBINKCHAT) && tmail_chat)								tmail_chat = false;														putlog ('~', "[FNACKPKT] Chat initiated %ld", chattimer);							InitedChat = true;						}//•••	chat workaround#ifdef FASTER						txpos = endlong (*((long *)Rxbuf));#else						txpos = (unsigned char) Rxbuf[3];						txpos = (txpos << 8) | (unsigned char) Rxbuf[2];						txpos = (txpos << 8) | (unsigned char) Rxbuf[1];						txpos = (txpos << 8) | (unsigned char) Rxbuf[0];#endif						if (txpos > -1L)						{							if (txpos)								putlog (lgNOPE, "Resume file from %ld", txpos);							errno = 0;							if (SetFPos (Txfile, fsFromStart, txstpos = txpos))							{								goto giveup;							}							xstate = XSENDBLK;						}						else						{							putlog (lgNOPE, "Remote refused %s", trunc_path (Txfname));							newMessage (lTNAME, "");							newMessage (lTSTAT, "");							drawProgressBar (ITBAR, -1, 0);							drawProgressCircle (ITCIRCLE, Txlen, 0);							if (sending_req)							{								if (!(sending_req = get_reqname (FALSE)))									getfname (GOOD_XFER);							}							else							{								Do_after = NOTHING_AFTER;								getfname (GOOD_XFER);							}							//	putlog ('~', "1>> %s (%ldb)", Txbuf, Txlen);							xstate = XSENDFNAME;						}					}					else					{						xstate = XDONE;					}				}				if (!(xstate || rstate))					goto breakout;				break;				/*---------------------------------------------------------------*/				/* Request to send more stuff rather than end batch just yet     */				/*---------------------------------------------------------------*/			case FREQPKT:							if (xstate == XRCVFNACK)				{					xmit_retry = 0L;					SharedCap = *(strchr (Rxbuf, '\0') + 1);					putlog ('~', "[FREQPKT] Shared %.2lX", (unsigned long)SharedCap);//•••	chat workaround					if (!InitedChat)					{						chattimer = (SharedCap & CANBINKCHAT) ? 0L : -2L;						if (chattimer == -2 && tmail_chat)							chattimer = 0L;						if ((SharedCap & CANBINKCHAT) && tmail_chat)							tmail_chat = false;													putlog ('~', "[FREQPKT] Chat initiated %ld", chattimer);						InitedChat = true;					}//•••	chat workaround					errno = 0;										appendrequests (Rxbuf);										if (!nextfreq)					{						nextfreq = freqchain;												while (nextfreq->next && nextfreq->wassent)							nextfreq = nextfreq->next;													if (nextfreq->wassent)							nextfreq = NULL;					}										if ((sending_req = get_reqname (TRUE)) != 0)						xstate = XSENDFNAME;					else						xstate = XSENDFREQNAK;//	putlog ('~', "2>> %s (%ldb)", Txbuf, Txlen);				}				break;				/*---------------------------------------------------------------*/				/* Our last file request didn't match anything; move on to next  */				/*---------------------------------------------------------------*/			case FREQNAKPKT:				attempting_req = FALSE;				req_started = TRUE;				sendpkt (NULL, 0, FRNAKACKPKT);				break;				/*---------------------------------------------------------------*/				/* ACK to no matching files for request error; try to end again  */				/*---------------------------------------------------------------*/			case FRNAKACKPKT:				if (xstate == XRCVFRNAKACK)				{					xmit_retry = 0L;					getfname (GOOD_XFER);					xstate = XSENDFNAME;				}				break;				/*---------------------------------------------------------------*/				/* ACK to last data block in file                                */				/*---------------------------------------------------------------*/			case EOFACKPKT:				if (xstate == XRCVEOFACK || xstate == XRCVFNACK)				{					xmit_retry = 0L;					if (xstate == XRCVEOFACK)					{//						long	Txtime;						Txlen -= txstpos;						if ((LMGetTicks () - TxStart) != 0)							cps = ((Txlen * 60L) / (LMGetTicks () - TxStart));						else							cps = 0;												history_add_traff (true, Txlen);						putlog (lgNOPE, "Sent-J%s %s [%ld cps]", (SharedCap & CANCRC32) ? "/32" : "", trunc_path (Txfname), cps);						newMessage (lTNAME, "");						newMessage (lTSTAT, "");						drawProgressBar (ITBAR, -1, 0);						if (sending_req)						{							if (!(sending_req = get_reqname (FALSE)))								getfname (GOOD_XFER);						}						else							getfname (GOOD_XFER);//	putlog ('~', "3>> %s (%ldb)", Txbuf, Txlen);					}					xstate = XSENDFNAME;				}				break;				/*---------------------------------------------------------------*/				/* Receiver says "let's try that again."                         */				/*---------------------------------------------------------------*/			case RPOSPKT:				if (xstate == XSENDBLK || xstate == XRCVEOFACK)				{					unsigned long t;#ifdef FASTER					t = endlong (*((long *)&Rxbuf[4]));#else					t = (unsigned char) Rxbuf[7];					t = (t << 8) | (unsigned char) Rxbuf[6];					t = (t << 8) | (unsigned char) Rxbuf[5];					t = (t << 8) | (unsigned char) Rxbuf[4];#endif					if (t != last_rpostime)					{						last_rpostime = t;						xmit_retry = 0L;						CLEAR_OUTBOUND ();						errno = 0;#ifdef FASTER						lasttx = endlong (*((long *)Rxbuf));#else						lasttx = (unsigned char) Rxbuf[3];						lasttx = (lasttx << 8) | (unsigned char) Rxbuf[2];						lasttx = (lasttx << 8) | (unsigned char) Rxbuf[1];						lasttx = (lasttx << 8) | (unsigned char) Rxbuf[0];#endif						if (SetFPos (Txfile, fsFromStart, txpos = lasttx))						{							goto giveup;						}						putMessage (0, "\pResync with receiver");						txblklen >>= 2;						if (txblklen < 64)							txblklen = 64;						goodbytes = 0;						goodneeded += 1024;						if (goodneeded > 8192)							goodneeded = 8192;						xstate = XSENDBLK;					}				}				break;				/*---------------------------------------------------------------*/				/* Debris from end of previous Janus session; ignore it          */				/*---------------------------------------------------------------*/			case HALTACKPKT:				break;			case TCHATPKT:							janus_devrecv (0L);				break;							case CHATPKT:			#ifdef FASTER				TxChatOffset = endlong (*((long *)Rxbuf));				RxChatOffset = endlong (*((long *)&Rxbuf[4]));#else				TxChatOffset = (unsigned char) Rxbuf[3];				TxChatOffset = (TxChatOffset << 8) | (unsigned char) Rxbuf[2];				TxChatOffset = (TxChatOffset << 8) | (unsigned char) Rxbuf[1];				TxChatOffset = (TxChatOffset << 8) | (unsigned char) Rxbuf[0];				RxChatOffset = (unsigned char) Rxbuf[7];				RxChatOffset = (RxChatOffset << 8) | (unsigned char) Rxbuf[6];				RxChatOffset = (RxChatOffset << 8) | (unsigned char) Rxbuf[5];				RxChatOffset = (RxChatOffset << 8) | (unsigned char) Rxbuf[4];#endif				RxChatOffset += Rxblklen - 8;								if (Rxblklen > 8)				{					janus_devrecv (8L);#ifdef FASTER					*((long *)Rxbuf) = endlong (RxChatOffset);					*((long *)&Rxbuf[4]) = endlong (TxChatOffset);#else					Rxbuf[0] = RxChatOffset & 0xff;					Rxbuf[1] = (RxChatOffset >> 8) & 0xff;					Rxbuf[2] = (RxChatOffset >> 16) & 0xff;					Rxbuf[3] = (RxChatOffset >> 24) & 0xff;					Rxbuf[4] = TxChatOffset & 0xff;					Rxbuf[5] = (TxChatOffset >> 8) & 0xff;					Rxbuf[6] = (TxChatOffset >> 16) & 0xff;					Rxbuf[7] = (TxChatOffset >> 24) & 0xff;#endif					sendpkt ((unsigned char *) Rxbuf, 8, CHATPKT);				}								break;								/*---------------------------------------------------------------*/				/* Abort the transfer and quit                                   */				/*---------------------------------------------------------------*/						default:				putlog ('!', "Unknown packet type '%c', blklen=%d", (char)pkttype, Rxblklen);				Rxbuf[Rxblklen] = 0;				putlog ('~', "<<%s>>", Rxbuf);				putMessage (0, "\pUnknown packet");				/* fallthrough */			case HALTPKT:giveup:				//•••				/* special for chat, other side wants to quit *///				if (chattimer > 0L && xstate == XDONE)//				{//					chattimer = -3L;//					break;//				}				if (Txfname[0])					getfname (ABORT_XFER);				if (rstate == RRCVBLK)				{					rxclose (FAILED_XFER);				}								Aborted = true;								goto abortxfer;			}					/* switch (pkttype)  */		}						/* while (pkttype)   */	}	while (xstate || rstate);	/*------------------------------------------------------------------------*/	/* All done; make sure other end is also finished (one way or another)    */	/*------------------------------------------------------------------------*/breakout://	if (!fsent)//		putlog (lgNOPE, "Nothing to send.");abortxfer:	endbatch ();	/*------------------------------------------------------------------------*/	/* Release allocated memory                                               */	/*------------------------------------------------------------------------*/freemem:	if (!Aborted)		if (EMSI_flag)		{			next_oper_frq = remote_ads.next;			while (next_oper_frq)			{				if (PathForOutbound (&next_oper_frq->ad, frq_attacher))	// • path is absent				{					pStrConc (frq_attacher, "\p.REQ", pathname);					FSDelete (pathname, 0);				}								next_oper_frq = next_oper_frq->next;			}		}		else		{			if (PathForOutbound (&remote_addr, frq_attacher))	// • path is absent			{				pStrConc (frq_attacher, "\p.REQ", pathname);				FSDelete (pathname, 0);			}		}		if (attachlist)		DisposePtr (attachlist);	if (requestlist)		DisposePtr (requestlist);	if (Txfname)		DisposePtr (Txfname);	if (Rxfname)		DisposePtr (Rxfname);	newMessage (lTNAME, "");	newMessage (lTSTAT, "");	newMessage (lRNAME, "");	newMessage (lRSTAT, "");	drawProgressBar (ITBAR, -1, 0);	drawProgressBar (IRBAR, -1, 0);	dispose_chat_window (1);	dispose_chat_window (2);}/*****************************************************************************//* Get name and info for next file to be transmitted, if any, and build      *//* FNAMEPKT.  Packet contents as per ZModem filename info packet, to allow   *//* use of same method of aborted-transfer recovery.  If there are no more    *//* files to be sent, build FNAMEPKT with null filename.  Also open file and  *//* set up for transmission.  Set Txfname, Txfile, Txlen.  Txbuf must not be  *//* modified until FNACKPKT is received.                                      *//*****************************************************************************/static void getfname (unsigned short xfer_flag){	static unsigned char	floflag, bad_xfers;	static long				in_pos, in_len;	static Str255			flopathname;	static char				*signpos;	short					florefnum;	char					*p;	long			fst_size;	long			fst_mtime;	OSType			creator, type;	long			create;		short			eta;		/*------------------------------------------------------------------------*/	/* Initialize static variables on first call of the batch                 */	/*------------------------------------------------------------------------*/	if (xfer_flag == INITIAL_XFER)	{		EMSI_aka = 0;		flo_attacher[0] = 0;		flopathname[0] = 0;		flo_method = -1;		attachlist = NULL;		in_pos = 0;		in_len = 0;		if (EMSI_flag)		{			next_oper = remote_ads.next;  /* This should be empty, but we'll go to the end anyway! */			operate_addr = &(next_oper->ad);		}		else			operate_addr = &remote_addr;	}	else		/*------------------------------------------------------------------------*/		/* If we were already sending a file, close it and clean up               */		/*------------------------------------------------------------------------*/	if (Txfile != -1)	{		FSClose (Txfile);		Txfile = -1;				/*---------------------------------------------------------------------*/		/* If xfer completed, do post-xfer cleanup                             */		/*---------------------------------------------------------------------*/		if (xfer_flag == GOOD_XFER && outboundname[0])		{			*signpos = '~';					/*------------------------------------------------------------------*/			/* Perform post-xfer file massaging if neccessary                   */			/*------------------------------------------------------------------*/			switch (Do_after)			{			case '-':				//				putlog (lgATTN, "Killing: %#s", outboundname);				FSDelete ((StringPtr)outboundname, 0);				break;			default:			//				putlog (lgATTN, "Preserving: %#s", outboundname);				break;			}		}	}		/*------------------------------------------------------------------------*/	/* Find all files to be sent and build FNAMEPKT.  If reading .FLO-type    */	/* file get next entry from it; otherwise check for next .OUT/.FLO file   */	/*------------------------------------------------------------------------*/	outboundname[0] = Txfname[0] = Txbuf[0] = Txbuf[1] = 0;	if (xfer_flag != ABORT_XFER)	{		next_file:			while ((EMSI_flag && next_oper) || (!EMSI_flag && !EMSI_aka))		{			if (in_pos >= in_len)			{				if (flopathname[0])				// • kill old .?lo file				{//					putlog (lgATTN, "try kill flo: %#s", flopathname);					FSDelete (flopathname, 0);					flopathname[0] = 0;				}								if (attachlist)				{					DisposePtr (attachlist);					attachlist = NULL;				}								flo_method++;								if (flo_method > 3)				{	next_aka:					if (EMSI_flag)					{						next_oper = next_oper->next;						if (next_oper)							operate_addr = &(next_oper->ad);					}					else						EMSI_aka = 1;										flo_method = -1;					continue;				}								if (!flo_method)				{					putlog ( '~', "Operate attaches to %d:%d/%d.%d",										operate_addr->Zone, operate_addr->Net, operate_addr->Node, operate_addr->Point );										cur_over = LookForOutbound (operate_addr);										if (!cur_over)						goto next_aka;										flopathname[0] = 0;											if (cur_over->attaches)			// • virtual attaches					{						attachlist = NewPtr (in_len = GetHandleSize ( cur_over->attaches ));						memcpy (attachlist, *(cur_over->attaches), in_len);						in_pos = 0;						continue;					}										flo_method++;					// • go to .HLO				}								if (flo_method == 1)				{					if (!PathForOutbound (operate_addr, flo_attacher))	// • path is absent						goto next_aka;				}								pStrConc (flo_attacher, pollModes[flo_method], flopathname);								if (FSOpen (flopathname, 0, &florefnum))					continue;						// • go to next .?lo								GetEOF (florefnum, &in_len);								attachlist = NewPtr (in_len);								FSRead (florefnum, &in_len, attachlist);				FSClose (florefnum);								for (in_pos = 0; in_pos < in_len; in_pos++)					if (attachlist[in_pos] == 0x0D)						attachlist[in_pos] = 0;				in_pos = 0;			}			else			{				signpos = attachlist + in_pos;				strcpy (outboundname, attachlist + in_pos);				Do_after = outboundname[0];								if (Do_after != '~')				{					outboundname[0] = strlen (&outboundname[1]);					strcpy (Txfname, attachlist + in_pos + 1);				}				else					outboundname[0] = 0;								in_pos += strlen (attachlist + in_pos) + 1;								if (Do_after != '~')					break;			}		}			if (Txfname[0])		{			touch_arcmail_suffix (operate_addr, (StringPtr)outboundname);						if (GetInfoFile (0, 0, (StringPtr)outboundname, &creator, &type, &create, &fst_mtime, &fst_size))				goto next_file;						if (FSOpen ((StringPtr)outboundname, 0, &Txfile))				goto next_file;			p = strchr (Txfname, '\0');			while (p >= Txfname && *p != ':')				--p;						p++;						UxConvertTime (false, (unsigned long *) &fst_mtime);			strcpy ((char *)Txbuf, p);			sprintf (strchr ((char *) Txbuf, '\0') + 1, "%lu %lo 0", Txlen = fst_size, fst_mtime);			eta = (short) (((Txlen * 10L) / cur_baud * 100L / JANUS_EFFICIENCY + 59L) / 60L);			putlog (lgNOPE, "J-Sending: %s (%ldb %d min)", Txbuf, Txlen, eta);			TxStart = LMGetTicks ();						newMessage (lTNAME, "J-Sending: %s", Txbuf);			newMessage (lTSTAT, "0:%ld (0) [%d min, 0 cps]", Txlen, eta);			drawProgressBar (ITBAR, -1, Txlen);		}	}	else	{		if (attachlist && flo_method >= 1)		{			pStrConc (flo_attacher, pollModes[flo_method], flopathname);						if (FSOpen (flopathname, 0, &florefnum) == noErr)			{				SetEOF (florefnum, 0);								for (in_pos = 0; in_pos < in_len; in_pos++)					if (attachlist[in_pos] == 0)						attachlist[in_pos] = 0x0D;				FSWrite (florefnum, &in_len, attachlist);				FSClose (florefnum);			}		}	}}/*****************************************************************************//* Build and send a packet of any type.                                      *//* Packet structure is: PKTSTRT,contents,packet_type,PKTEND,crc              *//* CRC is computed from contents and packet_type only; if PKTSTRT or PKTEND  *//* get munged we'll never even find the CRC.                                 *//*****************************************************************************/static void sendpkt (register unsigned char * buf, short len, short type){	register unsigned short crc;	if ((SharedCap & CANCRC32) && type != FNAMEPKT)		sendpkt32 (buf, len, type);	else	{		BUFFER_BYTE (DLE, slice);		BUFFER_BYTE (PKTSTRTCHR ^ 0x40, slice);		crc = 0;		while (--len >= 0)		{			txbyte (*buf);			crc = xcrc (crc, ((unsigned short) (*buf++)));		}		BUFFER_BYTE ((unsigned char) type, slice);		crc = xcrc (crc, type);		BUFFER_BYTE (DLE, slice);		BUFFER_BYTE (PKTENDCHR ^ 0x40, slice);		txbyte ((unsigned char) (crc >> 8));		txbyte ((unsigned char) (crc & 0xFF));		UNBUFFER_BYTES (slice);	}}/*****************************************************************************//* Build and send a packet using 32-bit CRC; same as sendpkt in other ways   *//*****************************************************************************/static void sendpkt32 (register unsigned char * buf, register short len, short type){	unsigned long crc32;	BUFFER_BYTE (DLE, slice);	BUFFER_BYTE (PKTSTRTCHR32 ^ 0x40, slice);	crc32 = 0xFFFFFFFF;	while (--len >= 0)	{		txbyte (*buf);		crc32 = Z_32UpdateCRC (((unsigned short) * buf), crc32);		++buf;	}	BUFFER_BYTE ((unsigned char) type, slice);	crc32 = Z_32UpdateCRC (type, crc32);	BUFFER_BYTE (DLE, slice);	BUFFER_BYTE (PKTENDCHR ^ 0x40, slice);	txbyte ((unsigned char) (crc32 >> 24));	txbyte ((unsigned char) ((crc32 >> 16) & 0xFF));	txbyte ((unsigned char) ((crc32 >> 8) & 0xFF));	txbyte ((unsigned char) (crc32 & 0xFF));	UNBUFFER_BYTES (slice);}/*****************************************************************************//* Transmit cooked escaped unsigned char(s) corresponding to raw input unsigned char.  Escape  *//* DLE, XON, and XOFF using DLE prefix unsigned char and ^ 0x40. Also escape          *//* CR-after-'@' to avoid Telenet/PC-Pursuit problems.                        *//*****************************************************************************/static void txbyte (register unsigned char c){	static unsigned char lastsent;	switch (c)	{	case CR:		if (lastsent != '@')			goto sendit;		/* fallthrough */	case DLE:	case XON:	case XOFF:		BUFFER_BYTE (DLE, slice);		c ^= 0x40;		/* fallthrough */	default:sendit:		BUFFER_BYTE (lastsent = c, slice);	}}/*****************************************************************************//* Process FNAMEPKT of file to be received.  Check for aborted-transfer      *//* recovery and solve filename collisions.    Check for enough disk space.   *//* Return initial file data position to start receiving at, or -1 if error   *//* detected to abort file reception.  Set Rxfname, Rxlen, Rxfile.            *//*****************************************************************************/static long procfname (void){	register char *p;	char /*linebuf[128],*/ *fileinfo, *badfname;	long filestart /*, bytes*/;	Str255		sptemp;//	short i;	long			fst_size;	long			fst_mtime;	OSType			creator, type;	long			create;		short			eta;		/*------------------------------------------------------------------------*/	/* Initialize for file reception                                          */	/*------------------------------------------------------------------------*/	badfname = NULL;	Rxfname[0] = 0;	/*------------------------------------------------------------------------*/	/* Save info on WaZOO transfer in case of abort                           */	/*------------------------------------------------------------------------*/	fileinfo = strchr (Rxbuf, '\0') + 1;	p = strchr (fileinfo, '\0') + 1;	SharedCap = (unsigned char) ((Rxblklen > p - Rxbuf) ? *p & joho : 0);	//	if (tmail_chat)//		SharedCap &= ~CANBINKCHAT;		putlog ('~', "[procfname] Shared %.2lX", (unsigned long)SharedCap);	putlog ('~', "[procfname] Fact   %.2lX", (SharedCap) ? (unsigned long)*p : 0L);//•••	chat workaround	if (!InitedChat)	{		chattimer = (SharedCap & CANBINKCHAT) ? 0L : -2L;		if (chattimer == -2 && tmail_chat)			chattimer = 0L;			if ((SharedCap & CANBINKCHAT) && tmail_chat)			tmail_chat = false;				putlog ('~', "[procfname] Chat initiated %ld", chattimer);		InitedChat = true;	}//•••	chat workaround	/*------------------------------------------------------------------------*/	/* If this is a null FNAMEPKT, return OK immediately                      */	/*------------------------------------------------------------------------*/	if (!Rxbuf[0])		return 0L;	p = Rxbuf + strlen ((char *) Rxbuf) - 1;	/* Find transmitted simple filename */	while (p >= Rxbuf && *p != '\\' && *p != '/' && *p != ':')		p--;	inboundPath[inboundPath[0]+1] = 0;	strcpy (Rxfname, (char *) &inboundPath[1]);	(void) strcat (Rxfname, ++p);	/*------------------------------------------------------------------------*/	/* Extract and validate filesize                                          */	/*------------------------------------------------------------------------*/	Rxlen = -1;	Rxfiletime = 0;	if (sscanf (fileinfo, "%ld %lo", &Rxlen, &Rxfiletime) < 1 || Rxlen < 0)	{//		j_status (MSG_TXT (M_NO_LENGTH));		return -1L;	}	UxConvertTime (true, (unsigned long *) &Rxfiletime);	strcpy ((char *) &sptemp[1], Rxfname);	sptemp[0] = strlen (Rxfname);	filestart = 0L;		if (GetInfoFile (0, 0, sptemp, &creator, &type, &create, &fst_mtime, &fst_size) == 0)	{//	••	If file already exists...		if (Rxlen == fst_size && Rxfiletime == fst_mtime)		{			putMessage (0, "\pSkip file");			putlog (lgNOPE, "Skip %s", trunc_path (Rxfname));			newMessage (lRNAME, "");			newMessage (lRSTAT, "");			drawProgressCircle (IRCIRCLE, fst_size, 0);//			drawProgressBar (IRBAR, -1, 0);			return -1;		}				if (creator == 'RvlM' && type == 'ZMPT')		{//	••	exist uncompleted…//	••	do concatenation?					if (Rxfiletime != fst_mtime)			{//	••	other file - kill it (maybe was addenum pack to it?)				FSDelete (sptemp, 0);				filestart = 0L;				Create (sptemp, 0, 'RvlM', 'ZMPT');			}			else			{			//	••	that file				filestart = fst_size;			}		}		else		{			Str255		newname;			short		iErr;			//	••	other file already present with this name			pStrCopy (sptemp, newname);			do {							newname[newname[0]]++;				if (newname[newname[0]] == ':')					newname[newname[0]]++;								iErr = HRename ( 0, 0, sptemp, newname );			} while (iErr == dupFNErr);						if (iErr)			{				putlog (lgATTN, "Kill dup file %s", trunc_path ((char *) &sptemp[1]));				FSDelete (sptemp, 0);			}			else			{				newname[newname[0]+1] = 0;				putlog (lgATTN, "Rename dup file %s to %s",											trunc_path ((char *) &sptemp[1]),											trunc_path ((char *) &newname[1]));							}						filestart = 0L;			Create (sptemp, 0, 'RvlM', 'ZMPT');		}	}						/* if exist */	else		Create (sptemp, 0, 'RvlM', 'ZMPT');	if (filestart)	{		putMessage (0, "\pResume");		putlog (lgNOPE, "Resume file from %ld", filestart);	}	FSOpen ( sptemp, 0, &Rxfile );	SetFPos ( Rxfile, fsFromStart, filestart );	eta = (short) ((((Rxlen - filestart) * 10L) / cur_baud * 100L / JANUS_EFFICIENCY + 59L) / 60L);putlog (lgNOPE, "J-Receiving: %s (%ldb %d min)", trunc_path (Rxfname), Rxlen, eta);	newMessage (lRNAME, "J-Receiving: %s", trunc_path (Rxfname));		RxStart = LMGetTicks ();		newMessage (lRSTAT, "%ld:%ld (0) [%d min, 0 cps]", filestart, Rxlen, eta);	drawProgressBar (IRBAR, -1, Rxlen);	drawProgressBar (IRBAR, filestart, Rxlen);	drawProgressCircle (IRCIRCLE, filestart, 0);//	(void) time ((time_t *) & Rxsttime);	return filestart;}/*****************************************************************************//* Receive, validate, and extract a packet if available.  If a complete      *//* packet hasn't been received yet, receive and store as much of the next    *//* packet as possible.    Each call to rcvpkt() will continue accumulating a *//* packet until a complete packet has been received or an error is detected. *//* Rxbuf must not be modified between calls to rcvpkt() if NOPKT is returned.*//* Returns type of packet received, NOPKT, or BADPKT.  Sets Rxblklen.        *//*****************************************************************************/static unsigned char rcvpkt (){	static unsigned char rxcrc32;	static unsigned short crc;	static unsigned long crc32;	register unsigned char *p;	register short c;	short i;	unsigned long pktcrc;	/*------------------------------------------------------------------------*/	/* Abort transfer if operator pressed ESC                                 */	/*------------------------------------------------------------------------*/	if (keyabort ())		//	give task chance by Cyril	{		putlog (lgALRT, "Aborted...");		return HALTPKT;	}	/*------------------------------------------------------------------------*/	/* If not accumulating packet yet, find start of next packet              */	/*------------------------------------------------------------------------*/	WaitFlag = FALSE;	p = Rxbufptr;	if (!p)	{		do			c = rxbyte ();		while (c >= 0 || c == PKTEND);		switch (c)		{		case PKTSTRT:			rxcrc32 = FALSE;			p = (unsigned char *) Rxbuf;			crc = 0;			break;		case PKTSTRT32:			rxcrc32 = TRUE;			p = (unsigned char *) Rxbuf;			crc32 = 0xFFFFFFFF;			break;		case NOCARRIER://			j_status (GenericError, &(MSG_TXT (M_NO_CARRIER)[1]));			return HALTPKT;		default:			return NOPKT;		}	}	/*------------------------------------------------------------------------*/	/* Accumulate packet data until we empty buffer or find packet delimiter  */	/*------------------------------------------------------------------------*/	if (rxcrc32)	{		while ((c = rxbyte ()) >= 0 && p < Rxbufmax)		{			*p++ = (unsigned char) c;			crc32 = Z_32UpdateCRC (c, crc32);		}	}	else	{		while ((c = rxbyte ()) >= 0 && p < Rxbufmax)		{			*p++ = (unsigned char) c;			crc = xcrc (crc, c);		}	}	/*------------------------------------------------------------------------*/	/* Handle whichever end-of-packet condition occurred                      */	/*------------------------------------------------------------------------*/	switch (c)	{		/*---------------------------------------------------------------------*/		/* PKTEND found; verify valid CRC                                      */		/*---------------------------------------------------------------------*/	case PKTEND:		WaitFlag = TRUE;		pktcrc = 0;		for (i = (rxcrc32) ? 4 : 2; i; --i)		{			if ((c = rxbyte ()) < 0)				break;			pktcrc = (pktcrc << 8) | c;		}		if (!i)		{			if ((rxcrc32 && pktcrc == crc32) || pktcrc == crc)			{				/*------------------------------------------------------------*/				/* Good packet verified; compute packet data length and       */				/* return packet type                                         */				/*------------------------------------------------------------*/				Rxbufptr = NULL;				Rxblklen = (short) (--p - (unsigned char *) Rxbuf);				return *p;			}		}//••	Workaround chat pkt		--p;				if (*p == CHATPKT)		{			Rxbufptr = NULL;			return NOPKT;			//	discard chat pkt		}		//••	Workaround chat pkt		/* fallthrough */		/*---------------------------------------------------------------------*/		/* Bad CRC, carrier lost, or buffer overflow from munged PKTEND        */		/*---------------------------------------------------------------------*/	default:		if (c == NOCARRIER)		{//			j_status (GenericError, &(MSG_TXT (M_NO_CARRIER)[1]));			return HALTPKT;		}		else		{			Rxbufptr = NULL;			return BADPKT;		}		/*---------------------------------------------------------------------*/		/* Emptied buffer; save partial packet and let sender do something     */		/*---------------------------------------------------------------------*/	case BUFEMPTY://		time_release ();		/* Also give other tasks a chance */		Rxbufptr = p;		return NOPKT;		/*---------------------------------------------------------------------*/		/* PKTEND was trashed; discard partial packet and prep for next one    */		/*---------------------------------------------------------------------*/	case PKTSTRT:		rxcrc32 = FALSE;		Rxbufptr = (unsigned char *) Rxbuf;		crc = 0;		return BADPKT;	case PKTSTRT32:		rxcrc32 = TRUE;		Rxbufptr = (unsigned char *) Rxbuf;		crc32 = 0xFFFFFFFF;		return BADPKT;	}}/*****************************************************************************//* Close file being received and perform post-reception aborted-transfer     *//* recovery cleanup if neccessary.                                           *//*****************************************************************************/static void rxclose (unsigned short xfer_flag){//	register char *p;//	char namebuf[PATHLEN], linebuf[128];//	unsigned char c;	short			rz123;	Str255		sptemp;	/*------------------------------------------------------------------------*/	/* Close file we've been receiving                                        */	/*------------------------------------------------------------------------*/	errno = 0;	FSClose (Rxfile);	strcpy ((char *) &sptemp[1], Rxfname);	sptemp[0] = strlen (Rxfname);	/*------------------------------------------------------------------------*/	/* If we completed a previously-aborted transfer, kill log entry & rename */	/*------------------------------------------------------------------------*/	if (xfer_flag == GOOD_XFER)	{//	1	-	arcmail//	2	-	pkt//	0	-	other files			switch (rz123 = ResolveExtension (sptemp))			{			case 0:							SetInfoFile (0, 0, sptemp, 'ALFA', 'TEXT', Rxfiletime, Rxfiletime);				break;						case 1:								SetInfoFile (0, 0, sptemp, 'ZIP ', '.PKT', Rxfiletime, Rxfiletime);				gotta_xmail = 1;				break;						case 2:							SetInfoFile (0, 0, sptemp, 'RvlM', '.PKT', Rxfiletime, Rxfiletime);				gotta_mail = 1;				break;			default:								if (rz123 < 0)				{//					SetInfoFile (0, 0, sptemp, (*pc_exch_pref)[-rz123-1].creator, (*pc_exch_pref)[-rz123-1].type, Rxfiletime, Rxfiletime);					SetInfoAndICTypeCreator (0, 0,	sptemp,	Rxfiletime, Rxfiletime, rz123);				}								break;			}	}	else		if (xfer_flag == FAILED_XFER)		{		//	1	-	arcmail		//	2	-	pkt		//	0	-	other files			if (ResolveExtension (sptemp) == 2)			{				putlog (lgATTN, "Kill aborted %s", trunc_path (Rxfname));				FSDelete (sptemp, 0);			}			else			{				SetInfoFile ( 0, 0, sptemp, 'RvlM', 'ZMPT', Rxfiletime, Rxfiletime );				history_add_traff (false, Rxpos - rxstpos1);				putlog (lgATTN, "Save partialy received %s (%ldb)", trunc_path (Rxfname), Rxpos);			}		}}/*****************************************************************************//* Try REAL HARD to disengage batch session cleanly                          *//*****************************************************************************/static void endbatch (void){	register short done, timeouts;	unsigned long timeval, _brain_dead;	/*------------------------------------------------------------------------*/	/* Tell the other end to halt if it hasn't already                        */	/*------------------------------------------------------------------------*/	done = timeouts = 0;	long_set_timer (&_brain_dead, 120);	sendpkt (NULL, 0, HALTPKT);	long_set_timer (&timeval, TimeoutSecs);	/*------------------------------------------------------------------------*/	/* Wait for the other end to acknowledge that it's halting                */	/*------------------------------------------------------------------------*/	while (!done)	{		if (long_time_gone (&_brain_dead) || !CARRIER)			break;		switch (rcvpkt ())		{		case NOPKT:		case BADPKT:			if (long_time_gone (&timeval))			{				if (++timeouts > 2)					++done;				else					goto reject;			}			break;		case HALTPKT:		case HALTACKPKT:			++done;			break;		default:			timeouts = 0;reject:			sendpkt (NULL, 0, HALTPKT);			long_set_timer (&timeval, TimeoutSecs);			break;		}	}	/*------------------------------------------------------------------------*/	/* Announce quite insistently that we're done now                         */	/*------------------------------------------------------------------------*/	for (done = 0; done < 10; ++done)		sendpkt (NULL, 0, HALTACKPKT);	while (!OUT_EMPTY() && !long_time_gone (&_brain_dead) && CARRIER)		slice ();}/*****************************************************************************//* Compute future timehack for later reference                               *//*****************************************************************************/static void long_set_timer (unsigned long *Buffer, unsigned short Duration){	*Buffer = LMGetTime () + Duration;}/*****************************************************************************//* Return TRUE if timehack has been passed, FALSE if not                     *//*****************************************************************************/static short long_time_gone (unsigned long *TimePtr){	return (((unsigned long) LMGetTime ()) > *TimePtr);}/*****************************************************************************//* Receive cooked escaped unsigned char translated to avoid various problems.         *//* Returns raw unsigned char, BUFEMPTY, PKTSTRT, PKTEND, or NOCARRIER.                *//*****************************************************************************/static short rxbyte (void){	register short c, w;	if ((c = rcvrawbyte ()) == DLE)	{		w = WaitFlag++;		if ((c = rcvrawbyte ()) >= 0)		{			switch (c ^= 0x40)			{			case PKTSTRTCHR:				c = PKTSTRT;				break;			case PKTSTRTCHR32:				c = PKTSTRT32;				break;			case PKTENDCHR:				c = PKTEND;				break;			}		}		WaitFlag = (unsigned char) w;	}	return c;}/*****************************************************************************//* Receive raw non-escaped byte.  Returns byte, BUFEMPTY, or NOCARRIER.      *//* If waitflag is true, will wait for a byte for Timeoutsecs; otherwise      *//* will return BUFEMPTY if a byte isn't ready and waiting in inbound buffer. *//*****************************************************************************/static short rcvrawbyte (void){	long timeval;	if ((short) PEEKBYTE () >= 0)		return MODEM_IN ();	if (!CARRIER)		return NOCARRIER;		if (!WaitFlag)		return BUFEMPTY;	timeval = time (NULL) + TimeoutSecs;	while ((short) PEEKBYTE () < 0)	{		if (!CARRIER)			return NOCARRIER;				if (time (NULL) > (time_t) timeval)			return BUFEMPTY;				slice ();	}	return MODEM_IN ();}/*****************************************************************************//* Get next file to request, if any                                          *//*****************************************************************************/static short get_filereq (unsigned char req_started){#pragma unused (req_started)	static long				in_pos_r, in_len_r;	Str255					frqpathname;	long					i;	short					gotone = false, frqrefnum;	if (!(remote_capabilities & WZ_FREQ))	{		putMessage (0, "\pRemote cannot accept freqs");		return false;	}	else		if (!(SharedCap & CANFREQ))		{			putMessage (0, "\pRemote cannot accept freqs");			return false;		}			if (!requestlist)	{		in_pos_r = 0;		in_len_r = 0;	}	while ((EMSI_flag && next_oper_frq) || (!EMSI_flag && !EMSI_raka))	{		if (in_pos_r >= in_len_r)		{			if (requestlist)			{				DisposePtr (requestlist);				requestlist = NULL;			}						frq_method++;						if (frq_method > 2)			{next_aka:				if (EMSI_flag)				{					next_oper_frq = next_oper_frq->next;					if (next_oper_frq)						operate_addr_frq = &(next_oper_frq->ad);				}				else					EMSI_raka = 1;								frq_method = 0;				continue;			}			if (frq_method == 1)			{				frq_over = LookForOutbound (operate_addr_frq);								if (!frq_over)					goto next_aka;									if (frq_over->requests)			// • virtual requests				{					requestlist = NewPtr (in_len_r = GetHandleSize ( frq_over->requests ));					memcpy (requestlist, *(frq_over->requests), in_len_r);					goto filter;				}				frq_method++;					// • go to .REQ			}			if (!PathForOutbound (operate_addr_frq, frq_attacher))	// • path is absent				goto next_aka;						pStrConc (frq_attacher, "\p.REQ", frqpathname);						if (FSOpen (frqpathname, 0, &frqrefnum))				goto next_aka;						// • go to next aka						GetEOF (frqrefnum, &in_len_r);						requestlist = NewPtr (in_len_r);						FSRead (frqrefnum, &in_len_r, requestlist);			FSClose (frqrefnum);	filter:			for (in_pos_r = 0, i = 0; i < in_len_r; in_pos_r++)				if (requestlist[in_pos_r] != 0x0A)				{					if (requestlist[in_pos_r] == 0x0D)						requestlist[i++] = 0;					else						requestlist[i++] = requestlist[in_pos_r];				}				else					in_len_r--;			in_pos_r = 0;		}		else		{			(void) strcpy (Rxbuf, requestlist + in_pos_r);			*(strchr (Rxbuf, '\0') + 1) = SharedCap;			gotone = true;			in_pos_r += strlen (requestlist + in_pos_r) + 1;			putMessage ( 0,"\pSending requests" );						break;		}	}	return gotone;}static char	*trailer = "\r=======================================================================\r\r\rSee ya!\r--- " MAILERNAME " " RAVELVERS " " RAVELISA "\r";static void append_trailer (StringPtr pktname){	short		refnum;	long		ioCount, zero = 0L;			if (FSOpen (pktname, 0, &refnum) == noErr)	{		SetFPos (refnum, fsFromLEOF, 0L);				ioCount = strlen (trailer);		FSWrite (refnum, &ioCount, trailer);		ioCount = 3L;		FSWrite (refnum, &ioCount, &zero);		FSClose (refnum);	}}static unsigned char get_reqname (unsigned char first_req){	long			fst_size;	long			fst_mtime;	OSType			creator, type;	long			create;		short			eta;	//	, boo;	Str255			stemp;	if (!first_req && Txfile != -1)	{		FSClose (Txfile);		Txfile = -1;	}	outboundname[0] = Txfname[0] = Txbuf[0] = Txbuf[1] = 0;	if (!freqchain)		return false;	if (!nextfreq)		return false;	if (nextfreq->sumsent)	{		pStrCopy (nextfreq->freqname, stemp);		append_trailer (stemp);	}	else		if (!parseFreqAliasFolder (nextfreq->freqname, stemp))		{			nextfreq = nextfreq->next;			return false;		}		else			putlog (lgNOPE, "Processing freq: %#s", nextfreq->freqname);			nextfreq->wassent = true;	nextfreq = nextfreq->next;	if (GetInfoFile (0, 0, stemp, &creator, &type, &create, &fst_mtime, &fst_size))		return false;		if (FSOpen (stemp, 0, &Txfile))		return false;		pStrCopy (stemp, (StringPtr)outboundname);	outboundname[outboundname[0]+1] = 0;	Do_after = NOTHING_AFTER;								//	??? no in Janus	strcpy (Txfname, &outboundname[1]);	strcpy ((char *)Txbuf, trunc_path (Txfname));		sprintf (strchr ((char *) Txbuf, '\0') + 1, "%lu %lo 0", Txlen = fst_size, fst_mtime);	eta = (short) (((Txlen * 10L) / cur_baud * 100L / JANUS_EFFICIENCY + 59L) / 60L);	putlog (lgNOPE, "J-Sending: %s (%ldb %d min)", Txbuf, Txlen, eta);	TxStart = LMGetTicks ();	newMessage (lTNAME, "J-Sending: %s", Txbuf);	newMessage (lTSTAT, "0:%ld (0) [%d min, 0 cps]", Txlen, eta);	drawProgressBar (ITBAR, -1, Txlen);	return true;}#endif