#ifndef LITE#include <ctype.h>#include <stdio.h>#include <string.h>#include <Sound.h>#include "Comm.h"#include "hydra_chat.h"#include "aglcrc.h"#include "zfiles.h"#include "Ravel_FTN.h"#include "Ravel_Prefs.h"#include "compatible.h"#include "Scheduler.h"#include "Unattended.h"#include "pmain.h"#include "stringutl.h"#include "Pathes.h"#include "myEnv.h"#include "Timing.h"#include "Modem.h"#include "freq.h"#include "PascalStr.h"#include "log.h"#include "history.h"#define	PATHLEN		256extern short			thy_request;			//	reote made file requestextern short			we_request;				//	we made file requestextern short			VMPresent;extern short			remote_capabilities;extern Boolean			Aborted;extern unsigned char	Txbuf[];extern short			isOriginator;extern unsigned long	cur_baud;				/* Current baud rate   */extern short			gotta_mail;				// somewhat received with ZedZapextern short			gotta_xmail;			// somewhat received with ZedZapextern Boolean			dos_names;				//	reservedextern	long			hiho_can;extern	long			hiho_want;extern	h_pc_exch		pc_exch_pref;static	long			hydra_txwindow = 0L;static	long			hydra_rxwindow = 0L;static unsigned long	RxStart, TxStart;static	long			hydra_modifier;static char	*mnt[12] = { "Jan", "Feb", "Mar",						 "Apr", "May", "Jun",						 "Jul", "Aug", "Sep",						 "Oct", "Nov", "Dec" };short xfer_init (char *fname, long fsize, long ftime);#define inteli(x) endshort(x)#define intell(x) endlong(x)/* HYDRA's memory ---------------------------------------------------------- */static Boolean originator;					/* are we the orig side?     */static short batchesdone;					/* No. HYDRA batches done    */static Boolean hdxlink;						/* hdx link & not orig side  */static unsigned long options;				/* INIT options hydra_init() */static unsigned short timeout;				/* general timeout in secs   */static char abortstr[] = {24, 24, 24, 24, 24, 24, 24, 24, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 0};static char *hdxmsg = "Fallback to one-way xfer";static char *pktprefix = "";static char *autostr = "hydra\r";static unsigned short *crc16tab;					/* CRC-16 table              */static unsigned long *crc32tab;						/* CRC-32 table              */static char *GenericError = "!%s";static unsigned char *txbuf, *rxbuf;				/* packet buffers            */static unsigned long txoptions, rxoptions;			/* HYDRA options (INIT seq)  */static char txpktprefix[H_PKTPREFIX + 1];			/* pkt prefix str they want  */static long txwindow, rxwindow;						/* window size (0=streaming) */static h_timer braindead;							/* braindead timer           */static unsigned char *txbufin;						/* read data from disk here  */static unsigned char txlastc;						/* last unsigned char put in txbuf    */static unsigned char rxdle;							/* count of received H_DLEs  */static unsigned char rxpktformat;					/* format of pkt receiving   */static unsigned char *rxbufptr;						/* current position in rxbuf */static unsigned char *rxbufmax;						/* highwatermark of rxbuf    */static char txfname[64], rxfname[64];				/* fname of current files    */static char rxpathname[PATHLEN];					/* pathname of currrent file */static long txftime, rxftime;						/* file timestamp (UNIX)     */static long txfsize, rxfsize;						/* file length               */static short txfd, rxfd;							/* file handles              */static unsigned short rxpktlen;						/* length of last packet     */static unsigned short rxblklen;						/* len of last good data blk */static short txstate, rxstate;						/* xmit/recv states          */static long txpos, rxpos;							/* current position in files */static long txoldpos, rxoldpos;						/* last position in files    */static unsigned short txblklen;						/* length of last block sent */static unsigned short txmaxblklen;					/* max block length allowed  */static long txlastack;								/* last dataack received     */static short txoldeta, rxoldeta;					/* last time needed          */static long txoffset, rxoffset;						/* offset in file we begun   */static h_timer txtimer, rxtimer;					/* retry timers              */static unsigned short txretries, rxretries;			/* retry counters            */static long rxlastsync;								/* filepos last sync retry   */static long txsyncid, rxsyncid;						/* id of last resync         */static unsigned short txgoodneeded;					/* to send before larger blk */static unsigned short txgoodbytes;					/* no. sent at this blk size */struct _h_flags{	char *str;	unsigned long val;};static struct _h_flags h_flags[] ={	{"XON", HOPT_XONXOFF},	{"TLN", HOPT_TELENET},	{"CTL", HOPT_CTLCHRS},	{"HIC", HOPT_HIGHCTL},	{"HI8", HOPT_HIGHBIT},	{"BRK", HOPT_CANBRK},	{"ASC", HOPT_CANASC},	{"UUE", HOPT_CANUUE},	{"C32", HOPT_CRC32},	{"DEV", HOPT_DEVICE},	{"FPT", HOPT_FPT},	{NULL, 0x0L}};/*-------------------------------------------------------------------------*//*static char *h_revdate (long revstamp){	static char buf[12];	struct tm *t;	t = localtime ((unsigned long *)&revstamp);	sprintf (buf, "%02d %s %d",		t->tm_mday, mtext[t->tm_mon], t->tm_year + 1900);	return (buf);}*//*---------------------------------------------------------------------------*//*---------------------------------------------------------------------------*/static char		*chatstart = "\007\007 * Chat mode start\r\n";static char		*chatend   = "\007\007\r\n * Chat mode end\r\n";static char		*chattime  = "\007\007\r\n * Chat mode end - timeout\r\n";static long		chattimer, lasttimer;static short	chatfill = 0;			//¥ ZERRRRO!static Boolean	nobell = false;extern	short		delaing;#define	CHAT_TIMEOUT	30L#define	local_win		1#define	remote_win		2void	win_putc (short win, short c);void	dispose_chat_window (short win);void	win_puts (short win, unsigned char *s);static void loc_puts (char *s){	win_puts (local_win, (unsigned char *) s);}/*loc_puts()*/#define CHATLEN 256static	unsigned char	chatbuf1[CHATLEN + 5],						chatbuf2[CHATLEN + 5],						*curbuf;static	Boolean			warned;static short keyabort (void){		Boolean			esc = false;		char			*p;		unsigned short	c;		EventRecord		event;		short			_delaing;		Boolean			tod;	if (Aborted)		return true;	if (chattimer > 0L)	{		if (LMGetTicks() > chattimer)		{			chattimer = lasttimer = 0L;			hydra_devsend("CON",(unsigned char *) chattime,strlen(chattime));			loc_puts(&chattime[2]);		}		else			if ((LMGetTicks() + 10L*60L) > chattimer && !warned)			{				loc_puts ("\007\r\n * Warning: chat mode timeout in 10 seconds\r\n");				warned = true;			}	}	else		if (chattimer != lasttimer)		{			if (chattimer ==  0L)			{//				if (!batchesdone)//				{					if (nobell) p = " * Remote has chat facility with bell disabled\n";					else        p = " * Remote has chat facility with bell enabled\n";					hydra_devsend ("CON",(unsigned char *) p,(short) strlen(p));//¥					loc_puts(" * Hydra session in progress, chat facility now available\r\n");//				}			}			else				if (chattimer == -1L)				{//					if (!batchesdone)//¥						loc_puts(" * Hydra session in init state, can't chat yet\r\n");				}				else					if (chattimer == -2L)					{//						if (!batchesdone)							loc_puts(" * Remote has no chat facility available (DEL - hide window)\r\n");					}					else						if (chattimer == -3L)						{							if (lasttimer > 0L)								loc_puts("\r\n");					//¥							loc_puts(" * Hydra session in exit state, can't chat anymore\r\n");						}						lasttimer = chattimer;		}	tod = WaitNextEvent (everyEvent, &event, gSleepTime, NULL);		if (!tod || (event.what != keyDown && event.what != autoKey))	{		_delaing = delaing;		delaing = 1;		DoEvent (&event);		delaing = _delaing;		tod = false;	}	if (Aborted)			//	made by ESC pressed	{		putMessage ( 0, "\pAbortedÉ" );		Aborted = true;		esc = true;		tod = false;	}	if (tod && (hiho_can & HOPT_DEVICE))	{		do		{			if ((event.modifiers & (cmdKey | optionKey | controlKey)) == controlKey)			{				switch (event.message & keyCodeMask)				{				case 0x0800:		//	Ctrl-C									c = 0x7F;		//	Map to DEL					break;								case 0x0500:		//	Ctrl-G									c = 0x05;		//	Map to Help					break;								default:									c = event.message & charCodeMask;					break;				}			}			else				c = event.message & charCodeMask;						switch (c)			{			case 0x1B:				putMessage ( 0, "\pAbortedÉ" );				Aborted = true;				esc = true;				break;			case 0x7F:			//	Alt_C:				if (chattimer == 0L)				{					hydra_devsend ("CON",(unsigned char *) chatstart,strlen(chatstart));					loc_puts(&chatstart[2]);					chattimer = lasttimer = LMGetTicks() + 60L*CHAT_TIMEOUT;				}				else					if (chattimer > 0L)					{						chattimer = lasttimer = 0L;						hydra_devsend("CON",(unsigned char *) chatend,strlen(chatend));						loc_puts(&chatend[2]);												dispose_chat_window (1);						dispose_chat_window (2);					}					else						if (chattimer <= -2)						{							dispose_chat_window (1);							dispose_chat_window (2);						}						else							SysBeep (10);				break;						default:				//			if (c < ' ' || c > 126)								if (c == 5)					c = 7;				else					if (c < ' ')						break;			case 13:			case 7:			case 8:				if (chattimer <= 0L)					break;				chattimer = LMGetTicks() + 60L*CHAT_TIMEOUT;				warned = false;				if (chatfill >= CHATLEN)					SysBeep (10);				else				{					switch (c)					{					case 13:						curbuf[chatfill++] = 10;						win_putc (local_win, 10);						break;					case 8:						if (chatfill > 0 && curbuf[chatfill - 1] != 10)							chatfill--;						else						{							curbuf[chatfill++] = '\x8';							curbuf[chatfill++] = ' ';							curbuf[chatfill++] = '\x8';						}						win_putc (local_win, 8);									break;					default:						curbuf[chatfill++] = (unsigned char) c;						if (c != 7)							win_putc (local_win, c);						else							SysBeep (10);													break;					}				}						break;			}			if (!WaitNextEvent (everyEvent, &event, gSleepTime, NULL))				break;		} while (!esc && (event.what == keyDown || event.what == autoKey));		_delaing = delaing;		delaing = 1;		DoEvent (&event);		delaing = _delaing;	}	if (chatfill > 0 && hydra_devsend ("CON",curbuf,chatfill))	{		curbuf = (curbuf == chatbuf1) ? chatbuf2 : chatbuf1;		chatfill = 0;	}		return (esc);}/*keyabort()*/static void slice (void){	keyabort ();}static void rem_chat (unsigned char *data, unsigned short len){	if (chattimer > 0)	{		chattimer = LMGetTicks() + 60L*CHAT_TIMEOUT;		warned = false;	}	data[len] = 0;	win_puts (remote_win,data);}/*rem_chat()*//*---------------------------------------------------------------------------*//*---------------------------------------------------------------------------*//*---------------------------------------------------------------------------*/static void hydra_msgdev (unsigned char *data, unsigned short len){								/* text is already NUL terminated by calling func hydra_devrecv() */	Str255	str;		if (len < 255)	{		memcpy (&str[1], data, len);		str[0] = len;		putMessage (0, str);	}}								/*hydra_msgdev()*//*---------------------------------------------------------------------------*/static short devtxstate;					/* dev xmit state            */static h_timer devtxtimer;					/* dev xmit retry timer      */static unsigned short devtxretries;			/* dev xmit retry counter    */static long devtxid, devrxid;				/* id of last devdata pkt    */static char devtxdev[H_FLAGLEN + 1];		/* xmit device ident flag    */static unsigned char *devtxbuf;				/* ptr to usersupplied dbuf  */static unsigned short devtxlen;				/* len of data in xmit buf   */struct _h_dev{	char *dev;	void (*func) (unsigned char *data, unsigned short len);};static struct _h_dev h_dev[] ={	{"MSG", hydra_msgdev},					/* internal protocol msg     */	{"CON", NULL},							/* text to console (chat)    */	{"PRN", NULL},							/* data to printer           */	{"ERR", NULL},							/* text to error output      */	{NULL, NULL}};/*---------------------------------------------------------------------------*/Boolean hydra_devfree (void){	if (devtxstate || !(txoptions & HOPT_DEVICE) || txstate >= HTX_END)		return (false);						/* busy or not allowed       */	else		return (true);						/* allowed to send a new pkt */}											/*hydra_devfree()*//*---------------------------------------------------------------------------*/Boolean hydra_devsend (char *dev, unsigned char *data, unsigned short len){	if (!dev || !data || !len || !hydra_devfree ())		return (false);	strncpy (devtxdev, dev, H_FLAGLEN);	devtxdev[H_FLAGLEN] = '\0';	UprText (devtxdev, strlen(devtxdev));	devtxbuf = data;	devtxlen = (len > H_MAXBLKLEN(hydra_modifier)) ? H_MAXBLKLEN(hydra_modifier) : len;	devtxid++;	devtxtimer = h_timer_reset ();	devtxretries = 0;	devtxstate = HTD_DATA;	/* special for chat, only prolong life if our side keeps typing! */	if (chattimer > 0L && !strcmp(devtxdev,"CON") && txstate == HTX_REND)		braindead = h_timer_set(H_BRAINDEAD);	return (true);}											/*hydra_devsend()*//*---------------------------------------------------------------------------*/Boolean hydra_devfunc (char *dev, void (*func) (unsigned char *data, unsigned short len)){	register short i;	for (i = 0; h_dev[i].dev; i++)	{		if (!strncasecmp (dev, h_dev[i].dev, H_FLAGLEN))		{			h_dev[i].func = func;			return (true);		}	}	return (false);}											/*hydra_devfunc()*//*---------------------------------------------------------------------------*/static void hydra_devrecv (void){	register char *p = (char *) rxbuf;	register short i;	unsigned short len = rxpktlen;	p += (short) sizeof (long);						/* skip the id long  */	len -= (short) sizeof (long);	for (i = 0; h_dev[i].dev; i++)	{												/* walk through devs */		if (!strncmp (p, h_dev[i].dev, H_FLAGLEN))		{			if (h_dev[i].func)			{				len -= ((short) strlen (p)) + 1;		/* sub devstr len    */				p += ((short) strlen (p)) + 1;		/* skip devtag       */				p[len] = '\0';						/* NUL terminate     */				(*h_dev[i].func) ((unsigned char *) p, len);	/* call output func  */			}			break;		}	}}													/*hydra_devrecv()*//*---------------------------------------------------------------------------*/short xfer_init (char *fname, long fsize, long ftime){//	short	i;//	char	namebuf[PATHLEN];	Str255	sptemp;	long			fst_size;	long			fst_mtime;	OSType			creator, type;	long			create;		inboundPath[inboundPath[0]+1] = 0;	strcpy (rxpathname, (char *) &inboundPath[1]);	strcat (rxpathname, fname);	strcpy ((char *) &sptemp[1], rxpathname);	sptemp[0] = strlen (rxpathname);	if (GetInfoFile (0, 0, sptemp, &creator, &type, &create, &fst_mtime, &fst_size) == 0)	{//	¥¥	If file already exists...		if (fsize == fst_size && ftime == fst_mtime)		{			putlog (lgNOPE, "Skip %s", trunc_path ((char *)&sptemp[1]));			newMessage (lRNAME, "");			newMessage (lRSTAT, "");			drawProgressCircle (IRCIRCLE, fst_size, 0);//			drawProgressBar (IRBAR, -1, 0);			return false;		}				if (creator == 'RvlM' && type == 'ZMPT')		{//	¥¥	exist uncompletedÉ//	¥¥	do concatenation?					if (ftime != fst_mtime)			{//	¥¥	other file - kill it (maybe was addenum pack to it?)				putlog (lgATTN, "Kill incompleted dup file %s", trunc_path ((char *) &sptemp[1]));				FSDelete (sptemp, 0);			}		}		else		{			Str255		newname;			short		iErr;			//	¥¥	other file already present with this name			pStrCopy (sptemp, newname);			newname[newname[0]+1] = 0;			do {							newname[newname[0]]++;				if (newname[newname[0]] == ':')					newname[newname[0]]++;								iErr = HRename ( 0, 0, sptemp, newname );			} while (iErr == dupFNErr);						if (iErr)			{				putlog (lgATTN, "Kill dup file %s", trunc_path ((char *) &sptemp[1]));				FSDelete (sptemp, 0);			}			else			{				newname[newname[0]+1] = 0;				putlog (lgATTN, "Rename dup file %s to %s",											trunc_path ((char *) &sptemp[1]),											trunc_path ((char *) &newname[1]));							}		}	}						/* if exist */	return (true);}											/*xfer_init()*//*---------------------------------------------------------------------------*/static void put_flags (char *buf, struct _h_flags flags[], long val){	register char *p;	register short i;	p = buf;	for (i = 0; flags[i].val; i++)	{		if (val & flags[i].val)		{			if (p > buf)				*p++ = ',';			strcpy (p, flags[i].str);			p += H_FLAGLEN;		}	}	*p = '\0';}											/*put_flags()*//*---------------------------------------------------------------------------*/static unsigned long get_flags (char *buf, struct _h_flags flags[]){	register unsigned long val;	register char *p;	register short i;	val = 0x0L;	for (p = strtok (buf, ","); p; p = strtok (NULL, ","))	{		for (i = 0; flags[i].val; i++)		{			if (!strcmp (p, flags[i].str))			{				val |= flags[i].val;				break;			}		}	}	return (val);}											/*get_flags()*//*---------------------------------------------------------------------------*//* CRC-16/32 code now separate source *//*AGL:10mar93*//*---------------------------------------------------------------------------*/static unsigned char *put_binbyte (register unsigned char *p, register unsigned char c){	register unsigned char n;	n = c;	if (txoptions & HOPT_HIGHCTL)		n &= 0x7f;	if (n == H_DLE ||		((txoptions & HOPT_XONXOFF) && (n == XON || n == XOFF)) ||		((txoptions & HOPT_TELENET) && n == '\r' && txlastc == '@') ||		((txoptions & HOPT_CTLCHRS) && (n < 32 || n == 127)))	{		*p++ = H_DLE;		c ^= 0x40;	}	*p++ = c;	txlastc = n;	return (p);}											/*put_binbyte()*//*---------------------------------------------------------------------------*/static void txpkt (register unsigned short len, short type){	register unsigned char *in, *out;	register unsigned short c, n;	Boolean crc32 = FALSE;	unsigned char format;	static char hexdigit[] = "0123456789abcdef";	txbufin[len++] = (unsigned char)type;	switch (type)	{	case HPKT_START:	case HPKT_INIT:	case HPKT_INITACK:	case HPKT_END:	case HPKT_IDLE:		format = HCHR_HEXPKT;		break;	default:		/* COULD do smart format selection depending on data and options! */		if (txoptions & HOPT_HIGHBIT)		{			if ((txoptions & HOPT_CTLCHRS) && (txoptions & HOPT_CANUUE))				format = HCHR_UUEPKT;			else if (txoptions & HOPT_CANASC)				format = HCHR_ASCPKT;			else				format = HCHR_HEXPKT;		}		else			format = HCHR_BINPKT;		break;	}	if (format != HCHR_HEXPKT && (txoptions & HOPT_CRC32))		crc32 = true;	if (crc32)	{		unsigned long crc = CRC32POST (crc32block (crc32tab, CRC32INIT, txbufin, len));	/*AGL:10mar93*/		txbufin[len++] = (unsigned char) crc;		txbufin[len++] = (unsigned char) (crc >> 8);		txbufin[len++] = (unsigned char) (crc >> 16);		txbufin[len++] = (unsigned char) (crc >> 24);	}	else	{		unsigned short crc = CRC16POST (crc16block (crc16tab, CRC16INIT, txbufin, len));	/*AGL:10mar93*/		txbufin[len++] = (unsigned char) crc;		txbufin[len++] = (unsigned char) (crc >> 8);	}	in = txbufin;	out = txbuf;	txlastc = 0;	*out++ = H_DLE;	*out++ = format;	switch (format)	{	case HCHR_HEXPKT:		for (; len > 0; len--, in++)		{			if (*in & 0x80)			{				*out++ = '\\';				*out++ = hexdigit[((*in) >> 4) & 0x0f];				*out++ = hexdigit[(*in) & 0x0f];			}			else if (*in < 32 || *in == 127)			{				*out++ = H_DLE;				*out++ = (unsigned char)((*in) ^ 0x40);			}			else if (*in == '\\')			{				*out++ = '\\';				*out++ = '\\';			}			else				*out++ = *in;		}		break;	case HCHR_BINPKT:		for (; len > 0; len--)			out = put_binbyte (out, *in++);		break;	case HCHR_ASCPKT:		for (n = c = 0; len > 0; len--)		{			c |= ((*in++) << n);			out = put_binbyte (out, (unsigned char)(c & 0x7f));			c >>= 7;			if (++n >= 7)			{				out = put_binbyte (out, (unsigned char)(c & 0x7f));				n = c = 0;			}		}		if (n > 0)			out = put_binbyte (out, (unsigned char)(c & 0x7f));		break;	case HCHR_UUEPKT:		for (; len >= 3; in += 3, len -= 3)		{			*out++ = (unsigned char) h_uuenc (in[0] >> 2);			*out++ = (unsigned char) h_uuenc (((in[0] << 4) & 0x30) | ((in[1] >> 4) & 0x0f));			*out++ = (unsigned char) h_uuenc (((in[1] << 2) & 0x3c) | ((in[2] >> 6) & 0x03));			*out++ = (unsigned char) h_uuenc (in[2] & 0x3f);		}		if (len > 0)		{			*out++ = (unsigned char) h_uuenc (in[0] >> 2);			*out++ = (unsigned char) h_uuenc (((in[0] << 4) & 0x30) | ((in[1] >> 4) & 0x0f));			if (len == 2)				*out++ = (unsigned char) h_uuenc ((in[1] << 2) & 0x3c);		}		break;	}	*out++ = H_DLE;	*out++ = HCHR_PKTEND;	if (type != HPKT_DATA && format != HCHR_BINPKT)	{		*out++ = '\r';		*out++ = '\n';	}	for (in = (unsigned char *) txpktprefix; *in; in++)	{		switch (*in)		{		case 221:				/* transmit break signal for one second */			do_break (true);			{				h_timer t = h_timer_set (2);				while (!h_timer_expired (t, h_timer_get ()))					slice ();//					time_release ();			}			do_break (false);			break;		case 222:			{				h_timer t = h_timer_set (2);				while (!h_timer_expired (t, h_timer_get ()))					slice ();//					time_release ();			}			break;		case 223:			SENDBYTE (0, slice);			break;		default:			SENDBYTE (*in, slice);			break;		}	}	SENDCHARS (txbuf, (long) (out - txbuf), braindead, slice);}								/*txpkt()*//*---------------------------------------------------------------------------*/static short rxpkt (void){	register unsigned char	*p, *q = rxbuf;	register unsigned short	n, i;	short					c;	h_timer					tnow = h_timer_get ();	/*AGL:16jul93*/	if (keyabort ())		return (H_SYSABORT);	if (!CARRIER)		return (H_CARRIER);	if (h_timer_running (braindead) && h_timer_expired (braindead, tnow))	{		return (H_BRAINTIME);	}	if (h_timer_running (txtimer) && h_timer_expired (txtimer, tnow))	{		return (H_TXTIME);	}	if (h_timer_running (devtxtimer) && h_timer_expired (devtxtimer, tnow))	{		return (H_DEVTXTIME);	}	p = rxbufptr;	while (CHAR_AVAIL ())	{		c = MODEM_IN ();		if (rxoptions & HOPT_HIGHBIT)			c &= 0x7f;		n = c;		if (rxoptions & HOPT_HIGHCTL)			n &= 0x7f;		if (n != H_DLE &&			(((rxoptions & HOPT_XONXOFF) && (n == XON || n == XOFF)) ||				((rxoptions & HOPT_CTLCHRS) && (n < 32 || n == 127))))			continue;		if (rxdle || c == H_DLE)		{			switch (c)			{			case H_DLE:				if (++rxdle >= 5)					return (H_CANCEL);				break;			case HCHR_PKTEND:				rxbufptr = p;				if (!rxbufptr)					c = H_NOPKT;  // BIG BUG, fixed 27/05/98 00:13 Igor Vanin				else					switch (rxpktformat)					{					case HCHR_BINPKT:						q = rxbufptr;						break;					case HCHR_HEXPKT:						for (p = q = rxbuf; p < rxbufptr; p++)						{							if (*p == '\\' && *++p != '\\')							{								i = *p;								n = *++p;								if ((i -= '0') > 9)									i -= ('a' - ':');								if ((n -= '0') > 9)									n -= ('a' - ':');								if ((i & ~0x0f) || (n & ~0x0f))								{									c = H_NOPKT;									break;								}								*q++ = (unsigned char) ((i << 4) | n);							}							else								*q++ = *p;						}						if (p > rxbufptr)							c = H_NOPKT;						break;					case HCHR_ASCPKT:						n = i = 0;						for (p = q = rxbuf; p < rxbufptr; p++)						{							i |= ((*p & 0x7f) << n);							if ((n += 7) >= 8)							{								*q++ = (unsigned char) (i & 0xff);								i >>= 8;								n -= 8;							}						}						break;					case HCHR_UUEPKT:						n = (short) (rxbufptr - rxbuf);						for (p = q = rxbuf; n >= 4; n -= 4, p += 4)						{							if (p[0] <= ' ' || p[0] >= 'a' ||								p[1] <= ' ' || p[1] >= 'a' ||								p[2] <= ' ' || p[2] >= 'a' ||								p[3] <= ' ' || p[3] >= 'a')							{								c = H_NOPKT;								break;							}							*q++ = (unsigned char) ((h_uudec (p[0]) << 2) | (h_uudec (p[1]) >> 4));							*q++ = (unsigned char) ((h_uudec (p[1]) << 4) | (h_uudec (p[2]) >> 2));							*q++ = (unsigned char) ((h_uudec (p[2]) << 6) | h_uudec (p[3]));						}						if (n >= 2)						{							if (p[0] <= ' ' || p[0] >= 'a' ||							    p[1] <= ' ' || p[1] >= 'a')							{								c = H_NOPKT;								break;							}							*q++ = (unsigned char) ((h_uudec (p[0]) << 2) | (h_uudec (p[1]) >> 4));							if (n == 3)							{								if (p[2] <= ' ' || p[2] >= 'a')								{									c = H_NOPKT;									break;								}								*q++ = (unsigned char) ((h_uudec (p[1]) << 4) | (h_uudec (p[2]) >> 2));							}						}						break;					default:		/* This'd mean internal fluke */						c = H_NOPKT;						break;					}				rxbufptr = NULL;				if (c == H_NOPKT)					break;				rxpktlen = (unsigned short) (q - rxbuf);				if (rxpktformat != HCHR_HEXPKT && (rxoptions & HOPT_CRC32))				{					if (rxpktlen < 5)					{						c = H_NOPKT;						break;					}					n = h_crc32test (crc32block (crc32tab, CRC32INIT, rxbuf, rxpktlen));	/*AGL:10mar93*/					rxpktlen -= (short) sizeof (long);	/* remove CRC-32 */				}				else				{					if (rxpktlen < 3)					{						c = H_NOPKT;						break;					}					n = h_crc16test (crc16block (crc16tab, CRC16INIT, rxbuf, rxpktlen));	/*AGL:10mar93*/					rxpktlen -= (short) sizeof (unsigned short);	/* remove CRC-16 */				}				rxpktlen--;		/* remove type  */				if (n)				{					return ((short) rxbuf[rxpktlen]);				}				/*goodpkt*/				break;			case HCHR_BINPKT:			case HCHR_HEXPKT:			case HCHR_ASCPKT:			case HCHR_UUEPKT:				rxpktformat = (unsigned char) c;				p = rxbufptr = rxbuf;				rxdle = 0;				break;			default:				if (p)				{					if (p < rxbufmax)						*p++ = (unsigned char) (c ^ 0x40);					else					{						p = NULL;					}				}				rxdle = 0;				break;			}					/* case c */		}		else			if (p)			{				if (p < rxbufmax)					*p++ = (unsigned char) c;				else				{					p = NULL;				}			}	}	rxbufptr = p;	return (H_NOPKT);}								/*rxpkt()*//*---------------------------------------------------------------------------*/static void hydra_badxfer (void){//	long			fst_size;//	long			fst_mtime;//	long			create;	Str255			sptemp;		if (rxfd != -1)	{		FSClose (rxfd);				strcpy ((char *)&sptemp[1], rxpathname);		sptemp[0] = strlen (rxpathname);		if (ResolveExtension (sptemp) == 2)		{			putlog (lgATTN, "Kill aborted %s", trunc_path (rxpathname));			FSDelete (sptemp, 0);		}		else		{			SetInfoFile (0, 0, sptemp, 'RvlM', 'ZMPT', rxftime, rxftime);			history_add_traff (false, rxpos-rxoffset);			putlog (lgATTN, "Save partialy received %s (%ldb)", trunc_path (rxpathname), rxpos);		}				rxfd = -1;	}}								/*hydra_badxfer()*//*---------------------------------------------------------------------------*/void hydra_init (unsigned long want_options, long hmodifier){#pragma unused (want_options)//	char *HoldName;	short	err;//	char	temp[128];		hydra_modifier = hmodifier;		txbuf = (unsigned char *) NewPtr (H_BUFLEN(hydra_modifier));	rxbuf = (unsigned char *) NewPtr (H_BUFLEN(hydra_modifier));	gotta_xmail = gotta_mail = 0;	crc16tab = (unsigned short *) NewPtr (CRC_TABSIZE * sizeof (unsigned short));	crc32tab = (unsigned long *) NewPtr (CRC_TABSIZE * sizeof (unsigned long));	while (VMPresent)	{		if (err = HoldMemory (txbuf, H_BUFLEN(hydra_modifier)))		{			putlog (lgALRT, "Can't hold VM for txbuf (err = %d)", err);			VMPresent = false;			break;		}				if (err = HoldMemory (rxbuf, H_BUFLEN(hydra_modifier)))		{			putlog (lgALRT, "Can't hold VM for rxbuf (err = %d)", err);			VMPresent = false;			break;		}		if (err = HoldMemory (crc16tab, CRC_TABSIZE * sizeof (unsigned short)))		{			putlog (lgALRT, "Can't hold VM for crc16tab (err = %d)", err);			VMPresent = false;			break;		}		if (err = HoldMemory (crc32tab, CRC_TABSIZE * sizeof (unsigned long)))		{			putlog (lgALRT, "Can't hold VM for crc32tab (err = %d)", err);			VMPresent = false;			break;		}		break;	}		if (!txbuf || !rxbuf || !crc16tab || !crc32tab)	{		mdm_hangup (NULL);		putlog (lgALRT, "hydra not enough memory!!!");		Aborted = true;				return;	}		txbufin = txbuf + ((H_MAXBLKLEN(hydra_modifier) + H_OVERHEAD + 5) * 2);	rxbufmax = rxbuf + H_MAXPKTLEN(hydra_modifier);	crc16init (crc16tab, CRC16POLY);	crc32init (crc32tab, CRC32POLY);	batchesdone = 0;	originator = remote_capabilities ? (isOriginator ? true : false) : true;	hdxlink = false;	options = (hiho_want & hiho_can);	// & ~(HUNN_OPTIONS & ~HOPT_CRC32);	timeout = (unsigned short) (40960L / cur_baud);	if (timeout < H_MINTIMER)		timeout = H_MINTIMER;	else if (timeout > H_MAXTIMER)		timeout = H_MAXTIMER;	if (hydra_modifier == 1)	{		txmaxblklen = (short) ((cur_baud / 300) * 128);		if (txmaxblklen < 256)			txmaxblklen = 256;		else if (txmaxblklen > H_MAXBLKLEN(1))			txmaxblklen = H_MAXBLKLEN(1);		rxblklen = txblklen = (cur_baud < 2400U) ? 256 : 512;	}	else	{		txmaxblklen = H_MAXBLKLEN(hydra_modifier);		rxblklen = txblklen = txmaxblklen / 4;	}		txgoodbytes = 0;	txgoodneeded = txmaxblklen;	/*AGL:23feb93*/	txstate = HTX_DONE;		hydra_devfunc ("CON", rem_chat);	chatfill  = 0;	lasttimer = 0L;		curbuf = chatbuf1;	warned = false;	if (hiho_can & HOPT_DEVICE)	{		lasttimer = 0L;		chattimer = -1L;		loc_puts (" *** Press DEL to start/end chat mode\r\n");	}	else	{		lasttimer = -2L;		chattimer = -2L;	}}								/*hydra_init()*//*---------------------------------------------------------------------------*/void hydra_deinit (void){	if (VMPresent)	{		UnholdMemory (txbuf, H_BUFLEN(hydra_modifier));		UnholdMemory (rxbuf, H_BUFLEN(hydra_modifier));		UnholdMemory (crc16tab, CRC_TABSIZE * sizeof (unsigned short));		UnholdMemory (crc32tab, CRC_TABSIZE * sizeof (unsigned long));	}	DisposePtr ((Ptr) crc16tab);	DisposePtr ((Ptr) crc32tab);	DisposePtr ((Ptr) txbuf);	DisposePtr ((Ptr) rxbuf);	dispose_chat_window (1);	dispose_chat_window (2);}								/*hydra_deinit()*//*---------------------------------------------------------------------------*//*---------------------------------------------------------------------------*//*---------------------------------------------------------------------------*/short hydra (char *txpathname, char *txalias){#pragma unused (txalias)	short			res = 0;	short			pkttype;	char			*p, *q;	short			i, eta;	Str255			sptemp;		short			rz123;//	long			fst_size;//	long			fst_mtime;	OSType			creator, type;	long			create;	long			ioCounter, cps;	/*-------------------------------------------------------------------*/	if (txstate == HTX_DONE)	{		txstate = HTX_START;		txoptions = HTXI_OPTIONS;		txpktprefix[0] = '\0';		rxstate = HRX_INIT;		rxoptions = (HRXI_OPTIONS & ~(HOPT_XONXOFF|HOPT_TELENET));		rxfd = -1;		rxdle = 0;		rxbufptr = NULL;		rxtimer = h_timer_reset ();		devtxid = devrxid = 0L;		devtxtimer = h_timer_reset ();		devtxstate = HTD_DONE;		braindead = h_timer_set (H_BRAINDEAD);	}	else		txstate = HTX_FINFO;	txtimer = h_timer_reset ();	txretries = 0;	/*-------------------------------------------------------------------*/	if (txpathname)	{		strcpy ((char *)&sptemp[1], txpathname);		sptemp[0] = strlen (txpathname);				if (GetInfoFile (0, 0, sptemp, &creator, &type, &create, &txftime, &txfsize))			return (XFER_SKIP);				UxConvertTime (false, (unsigned long *) &txftime);		if (FSOpen (sptemp, 0, &txfd))			return (XFER_SKIP);		for (p = txpathname, q = txfname; *p; p++)		{			if (*q = *p, *p == '\\' || *p == ':' || *p == '/')				q = txfname;			else				q++;		}		*q = '\0';		eta = (short) ((((txfsize * 10L) / cur_baud * 100L )/ 95L + 59L) / 60L);		putlog(lgNOPE, "H-Sending: %s (%ldb %d min)", trunc_path(txfname), txfsize, eta);		TxStart = LMGetTicks ();				newMessage (lTNAME, "H-Sending: %s", trunc_path(txfname));		newMessage (lTSTAT, "0:%ld (0) [%d min, 0 cps]", txfsize, eta);		drawProgressBar (ITBAR, -1, txfsize);		txsyncid = 0L;	}	else	{		txfd = -1;		strcpy (txfname, "");	}	/*-------------------------------------------------------------------*/	do	{		/*----------------------------------------------------------------*/		switch (devtxstate)		{			/*---------------------------------------------------------*/		case HTD_DATA:			if (txstate > HTX_RINIT)			{				h_long1 (txbufin) = intell (devtxid);				p = ((char *) txbufin) + ((short) sizeof (long));				strcpy (p, devtxdev);				p += H_FLAGLEN + 1;				memcpy (p, devtxbuf, devtxlen);				txpkt (((short) sizeof (long)) + H_FLAGLEN + 1 + devtxlen, HPKT_DEVDATA);				devtxtimer = h_timer_set ((!rxstate && txstate == HTX_REND) ? timeout / 2 : timeout);	/*AGL:10mar93*/				devtxstate = HTD_DACK;			}			break;			/*---------------------------------------------------------*/		default:			break;			/*---------------------------------------------------------*/		}		/*----------------------------------------------------------------*/		switch (txstate)		{			/*---------------------------------------------------------*/		case HTX_START:						SENDCHARS ((unsigned char *)autostr, (short) strlen (autostr), 1, slice);			txpkt (0, HPKT_START);			txtimer = h_timer_set (H_START);			txstate = HTX_SWAIT;			break;			/*---------------------------------------------------------*/		case HTX_INIT:			p = (char *) txbufin;			sprintf (p, "%08lx%s,%s Macintosh", H_REVSTAMP, MAILERNAME, RAVELVERS);			p += ((short) strlen (p)) + 1;		/* our app info & HYDRA rev. */			put_flags (p, h_flags, hiho_can);	/* what we CAN  */						putlog ('~', "Local  can: <<%s>>", p);						p += ((short) strlen (p)) + 1;			put_flags (p, h_flags, options);	/* what we WANT */			putlog ('~', "Local  wnt: <<%s>>", p);			p += ((short) strlen (p)) + 1;			sprintf (p, "%08lx%08lx",			/* TxRx windows */				hydra_txwindow, hydra_rxwindow);						p += ((short) strlen (p)) + 1;			strcpy (p, pktprefix);				/* pkt prefix string we want */			p += ((short) strlen (p)) + 1;			txoptions = HTXI_OPTIONS;			txpkt ((unsigned short) (((unsigned char *) p) - txbufin), HPKT_INIT);			txoptions = rxoptions;			txtimer = h_timer_set (timeout / 2);			txstate = HTX_INITACK;			break;			/*---------------------------------------------------------*/		case HTX_FINFO:			if (txfd >= 0)			{				short	i;				char	*dst, *src, c;											if (!txretries)				{					txoldpos = txoldeta = -1;				}				sptemp[0] = 0;				dst = (char *) sptemp;				src = txfname;				i = 0;								while (*src && i < 8)				{					c = *src;										if (isgraph(c) && (c != '\\' && c != '/' && c != ':' && c != '*' && c != '?' && c != '.'))					{						*dst = c;						dst++;					}					else						if (c == '.')						{							*dst = c;							dst++;							src++;							break;						}						else							i--;											i++;					src++;				}								if (*src)				{					if (i == 8)					{						*dst = '.';						dst++;											if (*src == '.')							src++;					}										i = 0;										while (*src && i < 3)					{						c = *src;												if (isgraph(c) && (c != '\\' && c != '/' && c != ':' && c != '*' && c != '?' && c != '.'))						{							*dst = c;							dst++;						}						else							i--;												i++;						src++;					}				}								*dst = 0;				sprintf ((char *) txbufin, "%08lx%08lx%08lx%08lx%08lx%s",					txftime, txfsize, 0L, 0L, 0L, sptemp);								if (!dos_names)				{					strcpy ((char *) &txbufin[strlen((char *) txbufin)+1], txfname);					putlog ('~', "%s|%s", (char *) txbufin, (char *) &txbufin[strlen((char *) txbufin)+1]);					txpkt (((short) strlen ((char *) txbufin)) + strlen ((char *) &txbufin[strlen((char *) txbufin)+1]) + 2, HPKT_FINFO);				}				else					txpkt (((short) strlen ((char *) txbufin)) + 1, HPKT_FINFO);			}			else			{				strcpy ((char *) txbufin, txfname);				txpkt (((short) strlen ((char *) txbufin)) + 1, HPKT_FINFO);			}			txtimer = h_timer_set (txretries ? timeout / 2 : timeout);			txstate = HTX_FINFOACK;			break;			/*---------------------------------------------------------*/		case HTX_XDATA:			if (txpos < 0L)				i = -1;			/* Skip */			else			{				h_long1 (txbufin) = intell (txpos);				ioCounter = txblklen;				FSRead (txfd, &ioCounter, txbufin + ((short) sizeof (long)));				i = ioCounter;			}			if (i > 0)			{				drawProgressCircle (ITCIRCLE, i, 0);							txpos += i;				txpkt (((short) sizeof (long)) + i, HPKT_DATA);				if (txblklen < txmaxblklen &&					(txgoodbytes += i) >= txgoodneeded)				{					txblklen <<= 1;					if (txblklen >= txmaxblklen)					{						txblklen = txmaxblklen;						txgoodneeded = 0;					}					txgoodbytes = 0;				}				if (txwindow && (txpos >= (txlastack + txwindow)))				{					txtimer = h_timer_set (txretries ? timeout / 2 : timeout);					txstate = HTX_DATAACK;				}				eta = (short) (((((txfsize - txpos) * 10L) / cur_baud * 100L )/ 95L + 59L) / 60L);								if ((LMGetTicks () - TxStart) != 0)					cps = (((txpos - txoffset) * 60L) / (LMGetTicks () - TxStart));				else					cps = 0;								newMessage (lTSTAT, "%ld:%ld (%d) [%d min, %ld cps]", txpos, txfsize, txblklen, eta, cps);				drawProgressBar (ITBAR, txpos, txfsize);								putMessage (0, "\pTransferring file(s)É");				break;			}			/* fallthrough to HTX_EOF */			/*---------------------------------------------------------*/		case HTX_EOF:			h_long1 (txbufin) = intell (txpos);			txpkt ((short) sizeof (long), HPKT_EOF);			txtimer = h_timer_set (txretries ? timeout / 2 : timeout);			txstate = HTX_EOFACK;			break;			/*---------------------------------------------------------*/		case HTX_END:			txpkt (0, HPKT_END);			txpkt (0, HPKT_END);			txtimer = h_timer_set (timeout / 2);			txstate = HTX_ENDACK;			break;			/*---------------------------------------------------------*/		default:			break;			/*---------------------------------------------------------*/		}		/*----------------------------------------------------------------*/		pkttype = rxpkt ();		/*----------------------------------------------------------*/		switch (pkttype)		{			/*---------------------------------------------------*/		case H_CARRIER:		case H_CANCEL:		case H_SYSABORT:		case H_BRAINTIME:			switch (pkttype)			{			case H_CARRIER:				break;			case H_CANCEL:				break;			case H_SYSABORT:				break;			case H_BRAINTIME:				break;			}			txstate = HTX_DONE;			res = XFER_ABORT;			break;			/*---------------------------------------------------*/		case H_TXTIME:			if (txstate == HTX_XWAIT || txstate == HTX_REND)			{				txpkt (0, HPKT_IDLE);				txtimer = h_timer_set (H_IDLE);				break;			}			if (++txretries > H_RETRIES)			{				txstate = HTX_DONE;				res = XFER_ABORT;				break;			}			putMessage (0, "\pTimeout");			txtimer = h_timer_reset ();			switch (txstate)			{			case HTX_SWAIT:				txstate = HTX_START;				break;			case HTX_INITACK:				txstate = HTX_INIT;				break;			case HTX_FINFOACK:				txstate = HTX_FINFO;				break;			case HTX_DATAACK:				txstate = HTX_XDATA;				break;			case HTX_EOFACK:				txstate = HTX_EOF;				break;			case HTX_ENDACK:				txstate = HTX_END;				break;			}			break;			/*---------------------------------------------------*/		case H_DEVTXTIME:			if (++devtxretries > H_RETRIES)			{				//putlog(MSG_TXT (M_FUBAR_MSG));				txstate = HTX_DONE;				res = XFER_ABORT;				break;			}			devtxtimer = h_timer_reset ();			devtxstate = HTD_DATA;			break;			/*---------------------------------------------------*/		case HPKT_START:			if (txstate == HTX_START || txstate == HTX_SWAIT)			{				txtimer = h_timer_reset ();				txretries = 0;				txstate = HTX_INIT;				braindead = h_timer_set (H_BRAINDEAD);			}			break;			/*---------------------------------------------------*/		case HPKT_INIT:			if (rxstate == HRX_INIT)			{				p = (char *) rxbuf;				p += ((short) strlen (p)) + 1;				q = p + ((short) strlen (p)) + 1;				putlog ('~', "Remote can: <<%s>>", p);				putlog ('~', "Remote wnt: <<%s>>", q);				rxoptions = options | (hiho_can & HOPT_CRC32) | (hiho_can & HOPT_DEVICE);				rxoptions |= get_flags (q, h_flags);				rxoptions &= get_flags (p, h_flags);				rxoptions &= hiho_can;				if (rxoptions < (options & HNEC_OPTIONS))				{					txstate = HTX_DONE;					res = XFER_ABORT;					break;				}				p = q + ((short) strlen (q)) + 1;				rxwindow = txwindow = 0L;				sscanf (p, "%08lx%08lx", &rxwindow, &txwindow);				if (rxwindow < 0L)					rxwindow = 0L;				if (hydra_rxwindow &&					(!rxwindow || hydra_rxwindow < rxwindow))					rxwindow = hydra_rxwindow;				if (txwindow < 0L)					txwindow = 0L;				if (hydra_txwindow &&					(!txwindow || hydra_txwindow < txwindow))					txwindow = hydra_txwindow;				p += ((short) strlen (p)) + 1;				strncpy (txpktprefix, p, H_PKTPREFIX);				txpktprefix[H_PKTPREFIX] = '\0';				if (!batchesdone)				{					unsigned long	hydrarev;					char			tempero[128];					DateTimeRec		dtr;					p = (char *) rxbuf;					sscanf (p, "%08lx%s", &hydrarev, tempero);					UxConvertTime (true, &hydrarev);					SecondsToDate (hydrarev, &dtr);					dtr.year %= 100;					putlog (lgNOPE, "Hydra: %s [%.2d %s %.2d  %.2d:%.2d:%.2d]", tempero,											dtr.day, mnt[dtr.month-1], dtr.year, dtr.hour,											dtr.minute, dtr.second);					put_flags ((char *) rxbuf, h_flags, rxoptions);					putlog ('~', "Common opt: <<%s>>", (char *) rxbuf);					if (txwindow || rxwindow)						putlog (lgNOPE, "Window Tx=%ld Rx=%ld", txwindow, rxwindow);				}				txoptions = rxoptions;				rxstate = HRX_FINFO;				chattimer = (rxoptions & HOPT_DEVICE) ? 0L : -2L;//				if (rxoptions & HOPT_DEVICE)//				{//					p = "Remote has no chat facility available\r\n";//					hydra_devsend ("CON", (unsigned char *) p, (short) strlen (p));//				}			}			txpkt (0, HPKT_INITACK);			break;			/*---------------------------------------------------*/		case HPKT_INITACK:			if (txstate == HTX_INIT || txstate == HTX_INITACK)			{				braindead = h_timer_set (H_BRAINDEAD);				txtimer = h_timer_reset ();				txretries = 0;				txstate = HTX_RINIT;			}			break;			/*---------------------------------------------------*/		case HPKT_FINFO:			if (rxstate == HRX_FINFO)			{				braindead = h_timer_set (H_BRAINDEAD);				if (!rxbuf[0])				{					rxpos = 0L;					rxstate = HRX_DONE;					batchesdone++;				}				else				{//					long diskfree;					rxfsize = rxftime = 0L;					rxoldpos = rxoldeta = -1;					rxfname[0] = '\0';					sscanf ((char *) rxbuf, "%08lx%08lx%*08lx%*08lx%*08lx%s", &rxftime, &rxfsize, rxfname);					if ((strlen ((char *) rxbuf) + 1) < rxpktlen )					{						strcpy ((char *) sptemp, (char *) &rxbuf[strlen ((char *) rxbuf) + 1]);											if (sptemp[0])						{							putlog ('~', "<%s>|<%s>", rxfname, sptemp);							for (p = (char *) sptemp, q = rxfname; *p; p++)							{								if (*q = *p, *p == '\\' || *p == ':' || *p == '/')									q = rxfname;								else									q++;							}							*q = '\0';						}						else						{							putlog ('~', "<%s>|<<empty>>", rxfname);						}					}					else					{						putlog ('~', "<%s>|<<empty>>", rxfname);					}										UxConvertTime (true, (unsigned long *)&rxftime);					if (!xfer_init (rxfname, rxfsize, rxftime))	/* Already have file */					{						rxpos = -1L;					}					else					{						strcpy ((char *)&sptemp[1], rxpathname);						sptemp[0] = strlen (rxpathname);												Create (sptemp, 0, 'RvlM', 'ZMPT');												if (FSOpen (sptemp, 0, &rxfd))						{							rxfd = -1;							rxpos = -2L;						}						if (rxfd != -1)						{							if (SetFPos (rxfd, fsFromLEOF, 0L))							{								hydra_badxfer ();								rxpos = -2L;							}							else							{								if (GetFPos (rxfd, &rxpos))									rxpos = -1;																rxoffset = rxpos;																eta = (short) (((((rxfsize - rxpos) * 10L) / cur_baud * 100L )/ 95L + 59L) / 60L);																putlog(lgNOPE, "H-Receiving: %s (%ldb %d min)", trunc_path(rxfname), rxfsize, eta);								newMessage (lRNAME, "H-Receiving: %s", trunc_path (rxfname));								putMessage (0, "\pTransferring file(s)É");								if (rxpos < 0L)								{									hydra_badxfer ();									rxpos = -2L;								}								else								{									RxStart = LMGetTicks ();																		newMessage (lRSTAT, "%ld:%ld (0) [%d min, 0 cps]", rxpos, rxfsize, eta);									drawProgressBar (IRBAR, -1, rxfsize);									drawProgressBar (IRBAR, rxpos, rxfsize);									drawProgressCircle (IRCIRCLE, rxpos, 0);									//									putMessage (0, "\pTransferring file(s)");									rxtimer = h_timer_reset ();									rxretries = 0;									rxlastsync = 0L;									rxsyncid = 0L;									if (rxpos > 0L)									{										putlog (lgNOPE, "Resume file from %ld", rxpos);									}									rxstate = HRX_DATA;								}							}						}					}				}			}			else				if (rxstate == HRX_DONE)					rxpos = (!rxbuf[0]) ? 0L : -2L;			h_long1 (txbufin) = intell (rxpos);			txpkt ((short) sizeof (long), HPKT_FINFOACK);			break;			/*---------------------------------------------------*/		case HPKT_FINFOACK:			if (txstate == HTX_FINFO || txstate == HTX_FINFOACK)			{				braindead = h_timer_set (H_BRAINDEAD);				txretries = 0;				if (!txfname[0])				{					txtimer = h_timer_set (H_IDLE);					txstate = HTX_REND;				}				else				{					txtimer = h_timer_reset ();					txpos = intell (h_long1 (rxbuf));					if (txpos >= 0L)					{						txoffset = txpos;						txlastack = txpos;						if (txpos > 0L)						{							putlog (lgNOPE, "Resume file from %ld", txpos);							if (SetFPos (txfd, fsFromStart, txpos))							{								FSClose (txfd);								txfd = -1;								txpos = -2L;								txstate = HTX_EOF;								break;							}						}						drawProgressCircle (ITCIRCLE, txpos, 0);						txstate = HTX_XDATA;					}					else					{						FSClose (txfd);						if (txpos == -1L)						{							putlog (lgNOPE, "Remote skipped %s", txfname);														newMessage (lTNAME, "");							newMessage (lTSTAT, "");							drawProgressBar (ITBAR, -1, 0);							drawProgressCircle (ITCIRCLE, txfsize, 0);														return (XFER_OK);						}						else						{							putlog (lgNOPE, "Remote refused %s", txfname);							newMessage (lTNAME, "");							newMessage (lTSTAT, "");							drawProgressBar (ITBAR, -1, 0);							drawProgressCircle (ITCIRCLE, txfsize, 0);							return (XFER_SKIP);						}					}				}			}			break;			/*---------------------------------------------------*/		case HPKT_DATA:			if (rxstate == HRX_DATA)			{				if (intell (h_long1 (rxbuf)) != rxpos ||					intell (h_long1 (rxbuf)) < 0L)				{					if (intell (h_long1 (rxbuf)) <= rxlastsync)					{						rxtimer = h_timer_reset ();						rxretries = 0;					}										rxlastsync = intell (h_long1 (rxbuf));					if (!h_timer_running (rxtimer) ||						h_timer_expired (rxtimer, h_timer_get ()))					{						if (rxretries > 4)						{							if (txstate < HTX_REND &&								!originator && !hdxlink)							{								hdxlink = true;								rxretries = 0;							}						}												if (++rxretries > H_RETRIES)						{							txstate = HTX_DONE;							res = XFER_ABORT;							break;						}						if (rxretries == 1 || rxretries == 4)	/*AGL:14may93*/							rxsyncid++;						rxblklen /= 2;						i = rxblklen;						if (i <= 64)							i = 64;						else if (i <= 128)							i = 128;						else if (i <= 256)							i = 256;						else if (i <= 512)							i = 512;						else if (i <= 1024)						  i = 1024;						else if (i <= 2048)						  i = 2048;						else if (i <= 4096)						  i = 4096;						else						  i = 8192;												if (hydra_modifier == 8 && i > 8192)						  i = 8192;						else if (hydra_modifier == 4 && i > 4096)						  i = 4096;						else if (hydra_modifier == 1 && i > 1024)						  i = 1024;												putMessage (0, "\pBad packet");												h_long1 (txbufin) = intell (rxpos);						h_long2 (txbufin) = intell ((long) i);						h_long3 (txbufin) = intell (rxsyncid);						txpkt (3 * ((short) sizeof (long)), HPKT_RPOS);						rxtimer = h_timer_set (timeout);					}				}				else				{					braindead = h_timer_set (H_BRAINDEAD);					rxpktlen -= (short) sizeof (long);					rxblklen = rxpktlen;					ioCounter = rxpktlen;					if (FSWrite (rxfd, &ioCounter, rxbuf + ((short) sizeof (long))))					{						hydra_badxfer ();						rxpos = -2L;						rxretries = 1;						rxsyncid++;						h_long1 (txbufin) = intell (rxpos);						h_long2 (txbufin) = intell (0L);						h_long3 (txbufin) = intell (rxsyncid);						txpkt (3 * ((short) sizeof (long)), HPKT_RPOS);						rxtimer = h_timer_set (timeout);						break;					}					rxretries = 0;					rxtimer = h_timer_reset ();					rxlastsync = rxpos;					rxpos += rxpktlen;					if (rxwindow)					{						h_long1 (txbufin) = intell (rxpos);						txpkt ((short) sizeof (long), HPKT_DATAACK);					}					eta = (short) (((((rxfsize - rxpos) * 10L) / cur_baud * 100L )/ 95L + 59L) / 60L);					if ((LMGetTicks () - RxStart) != 0)						cps = (((rxpos - rxoffset) * 60L) / (LMGetTicks () - RxStart));					else						cps = 0;					newMessage (lRSTAT, "%ld:%ld (%d) [%d min, %ld cps]", rxpos, rxfsize, rxpktlen, eta, cps);					drawProgressBar (IRBAR, rxpos, rxfsize);					drawProgressCircle (IRCIRCLE, rxpktlen, 0);					putMessage (0, "\pTransferring file(s)É");				}				/*badpkt*/			}					/*rxstate==HRX_DATA*/			break;			/*---------------------------------------------------*/		case HPKT_DATAACK:			if (txstate == HTX_XDATA || txstate == HTX_DATAACK ||				txstate == HTX_XWAIT ||				txstate == HTX_EOF || txstate == HTX_EOFACK)			{				if (txwindow && intell (h_long1 (rxbuf)) > txlastack)				{					txlastack = intell (h_long1 (rxbuf));					if (txstate == HTX_DATAACK &&						(txpos < (txlastack + txwindow)))					{						txstate = HTX_XDATA;						txretries = 0;						txtimer = h_timer_reset ();					}				}			}			break;			/*---------------------------------------------------*/		case HPKT_RPOS:			if (txstate == HTX_XDATA || txstate == HTX_DATAACK ||				txstate == HTX_XWAIT ||				txstate == HTX_EOF || txstate == HTX_EOFACK)			{				if (intell (h_long3 (rxbuf)) != txsyncid)				{					txsyncid = intell (h_long3 (rxbuf));					txretries = 1;				}				else /*AGL:14may93*/				{					if (++txretries > H_RETRIES)					{						txstate = HTX_DONE;						res = XFER_ABORT;						break;					}					if (txretries != 4)						break;	/*AGL:14may93*/				}				txtimer = h_timer_reset ();				txpos = intell (h_long1 (rxbuf));				if (txpos < 0L)				{					if (txfd >= 0)					{						FSClose (txfd);						txfd = -1;						txstate = HTX_EOF;					}					txpos = -2L;					break;				}				if (txblklen > (unsigned short) intell (h_long2 (rxbuf)))					txblklen = (unsigned short) intell (h_long2 (rxbuf));				else					txblklen >>= 1;				if (txblklen <= 64)					txblklen = 64;				else if (txblklen <= 128)					txblklen = 128;				else if (txblklen <= 256)					txblklen = 256;				else if (txblklen <= 512)					txblklen = 512;				else if (txblklen <= 1024)				  txblklen = 1024;				else if (txblklen <= 2048)				  txblklen = 2048;				else if (txblklen <= 4096)				  txblklen = 4096;				else				  txblklen = 8192;				if (hydra_modifier == 8 && txblklen > 8192)				  txblklen = 8192;				else if (hydra_modifier == 4 && txblklen > 4096)				  txblklen = 4096;				else if (hydra_modifier == 1 && txblklen > 1024)				  txblklen = 1024;				txgoodbytes = 0;				txgoodneeded += txmaxblklen * 2;	/*AGL:23feb93*/				if (txgoodneeded > txmaxblklen * 8)	/*AGL:23feb93*/					txgoodneeded = txmaxblklen * 8;	/*AGL:23feb93*/				putMessage (0, "\pResync offset");				if (SetFPos (txfd, fsFromStart, txpos))				{					FSClose (txfd);					txfd = -1;					txpos = -2L;					txstate = HTX_EOF;					break;				}				if (txstate != HTX_XWAIT)					txstate = HTX_XDATA;			}			break;			/*---------------------------------------------------*/		case HPKT_EOF:			if (rxstate == HRX_DATA)			{				if (intell (h_long1 (rxbuf)) < 0L)				{					hydra_badxfer ();					rxstate = HRX_FINFO;					braindead = h_timer_set (H_BRAINDEAD);				}				else					if (intell (h_long1 (rxbuf)) != rxpos)					{						if (intell (h_long1 (rxbuf)) <= rxlastsync)						{							rxtimer = h_timer_reset ();							rxretries = 0;						}						rxlastsync = intell (h_long1 (rxbuf));						if (!h_timer_running (rxtimer) ||							h_timer_expired (rxtimer, h_timer_get ()))						{							if (++rxretries > H_RETRIES)							{								txstate = HTX_DONE;								res = XFER_ABORT;								break;							}							if (rxretries == 1 || rxretries == 4)	/*AGL:14may93*/								rxsyncid++;							rxblklen /= 2;							i = rxblklen;							if (i <= 64)								i = 64;							else if (i <= 128)								i = 128;							else if (i <= 256)								i = 256;							else if (i <= 512)								i = 512;							else if (i <= 1024)							  i = 1024;							else if (i <= 2048)							  i = 2048;							else if (i <= 4096)							  i = 4096;							else							  i = 8192;														if (hydra_modifier == 8 && i > 8192)							  i = 8192;							else if (hydra_modifier == 4 && i > 4096)							  i = 4096;							else if (hydra_modifier == 1 && i > 1024)							  i = 1024;														h_long1 (txbufin) = intell (rxpos);							h_long2 (txbufin) = intell ((long) i);							h_long3 (txbufin) = intell (rxsyncid);							txpkt (3 * ((short) sizeof (long)), HPKT_RPOS);							rxtimer = h_timer_set (timeout);						}					}					else					{//						long rxtime;						FSClose (rxfd);						rxfd = -1;						rxfsize = rxpos - rxoffset;						if ((LMGetTicks () - RxStart) != 0)							cps = ((rxfsize * 60L) / (LMGetTicks () - RxStart));						else							cps = 0;						history_add_traff (false, rxfsize);						putlog(lgNOPE, "Received-H%s %s [%ld cps]", (txoptions & HOPT_CRC32) ? "/32" : "", trunc_path(rxpathname), cps);						newMessage (lRNAME, "");						newMessage (lRSTAT, "");						drawProgressBar (IRBAR, -1, 0);						strcpy ((char *)&sptemp[1], rxpathname);						sptemp[0] = strlen (rxpathname);						switch (rz123 = ResolveExtension (sptemp))						{						case 0:													SetInfoFile (0, 0, sptemp, 'ALFA', 'TEXT', rxftime, rxftime);							break;												case 1:														SetInfoFile (0, 0, sptemp, 'ZIP ', '.PKT', rxftime, rxftime);							gotta_xmail = 1;							break;												case 2:													SetInfoFile (0, 0, sptemp, 'RvlM', '.PKT', rxftime, rxftime);							gotta_mail = 1;							break;										case 3:		//	freq arrived!													thy_request = true;														{								long	eofreq;								short	reqref;								Ptr		ptmp;																								FSOpen (sptemp, 0, &reqref);								GetEOF (reqref, &eofreq);																if (eofreq < 1024)		//	whatta hell req file more than 1K? :-O								{									ptmp = NewPtr (eofreq + 1);									FSRead (reqref, &eofreq, ptmp);									ptmp[eofreq] = 0;									appendrequests (ptmp);								}																FSClose (reqref);								FSDelete (sptemp, 0);							}							break;						default:														if (rz123 < 0)							{//								SetInfoFile (0, 0, sptemp, (*pc_exch_pref)[-rz123-1].creator, (*pc_exch_pref)[-rz123-1].type, rxftime, rxftime);								SetInfoAndICTypeCreator (0, 0,	sptemp,	rxftime, rxftime, rz123);							}														break;						}						rxstate = HRX_FINFO;						braindead = h_timer_set (H_BRAINDEAD);					}				/*skip/badeof/eof*/			}					/*rxstate==HRX_DATA*/			if (rxstate == HRX_FINFO)				txpkt (0, HPKT_EOFACK);						break;			/*---------------------------------------------------*/		case HPKT_EOFACK:			if (txstate == HTX_EOF || txstate == HTX_EOFACK)			{				braindead = h_timer_set (H_BRAINDEAD);				if (txfd >= 0)				{//					long txtime;					FSClose (txfd);					txfsize = txpos - txoffset;					if ((LMGetTicks () - TxStart) != 0)						cps = ((txfsize * 60L) / (LMGetTicks () - TxStart));					else						cps = 0;					history_add_traff (true, txfsize);					putlog(lgNOPE, "Sent-H%s %s [%ld cps]", (txoptions & HOPT_CRC32) ? "/32" : "", trunc_path (txpathname), cps);					newMessage (lTNAME, "");					newMessage (lTSTAT, "");					drawProgressBar (ITBAR, -1, 0);					return (XFER_OK);				}				else					return (XFER_SKIP);			}			break;			/*---------------------------------------------------*/		case HPKT_IDLE:			if (txstate == HTX_XWAIT)			{				hdxlink = FALSE;				txtimer = h_timer_reset ();				txretries = 0;				txstate = HTX_XDATA;			}			else				if (txstate >= HTX_FINFO && txstate < HTX_REND)					braindead = h_timer_set (H_BRAINDEAD);			break;			/*---------------------------------------------------*/		case HPKT_END:			/* special for chat, other side wants to quit */			if (chattimer > 0L && txstate == HTX_REND)			{				chattimer = -3L;				break;			}			if (txstate == HTX_END || txstate == HTX_ENDACK)			{				txpkt (0, HPKT_END);				txpkt (0, HPKT_END);				txpkt (0, HPKT_END);				txstate = HTX_DONE;				res = XFER_OK;			}			break;			/*---------------------------------------------------*/		case HPKT_DEVDATA:			if (devrxid != intell (h_long1 (rxbuf)))			{				hydra_devrecv ();				devrxid = intell (h_long1 (rxbuf));			}			h_long1 (txbufin) = h_long1 (rxbuf);	/*AGL:10feb93*/			txpkt ((short) sizeof (long), HPKT_DEVDACK);			break;			/*---------------------------------------------------*/		case HPKT_DEVDACK:			if (devtxstate && (devtxid == intell (h_long1 (rxbuf))))			{				devtxtimer = h_timer_reset ();				devtxstate = HTD_DONE;			}			break;			/*---------------------------------------------------*/		default:				/* unknown packet types: IGNORE, no error! */			break;			/*---------------------------------------------------*/		}						/*(pkttype)*/		/*------------------------------------------------------*/		switch (txstate)		{			/*---------------------------------------------------*/		case HTX_START:		case HTX_SWAIT:			if (rxstate == HRX_FINFO)			{				txtimer = h_timer_reset ();				txretries = 0;				txstate = HTX_INIT;			}			break;			/*---------------------------------------------------*/		case HTX_RINIT:			if (rxstate == HRX_FINFO)			{				txtimer = h_timer_reset ();				txretries = 0;				txstate = HTX_FINFO;			}			break;			/*---------------------------------------------------*/		case HTX_XDATA:			if (rxstate && hdxlink)			{				hydra_devsend ("MSG", (unsigned char *) hdxmsg, (short) strlen (hdxmsg));				txtimer = h_timer_set (H_IDLE);				txstate = HTX_XWAIT;			}			break;			/*---------------------------------------------------*/		case HTX_XWAIT:			if (!rxstate)			{				txtimer = h_timer_reset ();				txretries = 0;				txstate = HTX_XDATA;			}			break;			/*---------------------------------------------------*/		case HTX_REND:			if (!rxstate && !devtxstate)			{				/* special for chat, braindead will protect */				if (chattimer > 0L) break;				if (chattimer == 0L) chattimer = -3L;				txtimer = h_timer_reset();				txretries = 0;				txstate = HTX_END;			}			break;			/*---------------------------------------------------*/		default:				/* any other state - nothing to do */			break;		}						/*switch(txstate)*/	} while (txstate);	if (txfd > 0)		FSClose (txfd);	hydra_badxfer ();	if (res == XFER_ABORT)	{//		if (remote_capabilities)			LOWER_DTR ();		CLEAR_OUTBOUND ();		if (CARRIER)		{			braindead = h_timer_set (10);	/* wait max. 10s after abort */						SENDCHARS ((unsigned char *)abortstr, (long) strlen (abortstr), braindead, NULL);						while (!OUT_EMPTY () && CARRIER && !h_timer_expired (braindead, h_timer_get ()))				time_release ();//			CLEAR_OUTBOUND ();		}		CLEAR_INBOUND ();		Aborted = true;	}	else	{		braindead = h_timer_set (10);	/* wait max. 10s after abort */		while (!OUT_EMPTY () && CARRIER && !h_timer_expired (braindead, h_timer_get ()))			time_release ();	}	return (res);}								/*hydra()*//* end of hydra.c */#endif