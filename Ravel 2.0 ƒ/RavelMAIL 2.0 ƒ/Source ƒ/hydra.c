/*--------------------------------------------------------------------------*//*                                                                          *//*                                                                          *//*      ------------         Bit-Bucket Software, Co.                       *//*      \ 10001101 /         Writers and Distributors of                    *//*       \ 011110 /          Freely Available<tm> Software.                 *//*        \ 1011 /                                                          *//*         ------                                                           *//*                                                                          *//*              (C) Copyright 1987-96, Bit Bucket Software Co.              *//*                                                                          *//*              This module was contributed by Michael Buenter              *//*                   Based on original code by Arjen Lentz                  *//*                    HydraCom adaptation for BinkleyTerm                   *//*                                                                          *//*                                                                          *//*    For complete  details  of the licensing restrictions, please refer    *//*    to the License  agreement,  which  is published in its entirety in    *//*    the MAKEFILE and BT.C, and also contained in the file LICENSE.260.    *//*                                                                          *//*    USE  OF THIS FILE IS SUBJECT TO THE  RESTRICTIONS CONTAINED IN THE    *//*    BINKLEYTERM  LICENSING  AGREEMENT.  IF YOU DO NOT FIND THE TEXT OF    *//*    THIS  AGREEMENT IN ANY OF THE  AFOREMENTIONED FILES,  OR IF YOU DO    *//*    NOT HAVE THESE FILES,  YOU  SHOULD  IMMEDIATELY CONTACT BIT BUCKET    *//*    SOFTWARE CO.  AT ONE OF THE  ADDRESSES  LISTED BELOW.  IN NO EVENT    *//*    SHOULD YOU  PROCEED TO USE THIS FILE  WITHOUT HAVING  ACCEPTED THE    *//*    TERMS  OF  THE  BINKLEYTERM  LICENSING  AGREEMENT,  OR  SUCH OTHER    *//*    AGREEMENT AS YOU ARE ABLE TO REACH WITH BIT BUCKET SOFTWARE, CO.      *//*                                                                          *//*                                                                          *//* You can contact Bit Bucket Software Co. at any one of the following      *//* addresses:                                                               *//*                                                                          *//* Bit Bucket Software Co.        FidoNet  1:104/501, 1:343/491             *//* P.O. Box 460398                AlterNet 7:42/1491                        *//* Aurora, CO 80046               BBS-Net  86:2030/1                        *//*                                Internet f491.n343.z1.fidonet.org         *//*                                                                          *//* Please feel free to contact us at any time to share your comments about  *//* our software and/or licensing policies.                                  *//*                                                                          *//*--------------------------------------------------------------------------*//*=============================================================================                              HydraCom Version 1.08                             (+ rev. upto 18 dec 93)                         A sample implementation of the                   HYDRA Bi-Directional File Transfer Protocol                             HydraCom was written by                   Arjen G. Lentz, LENTZ SOFTWARE-DEVELOPMENT                  COPYRIGHT (C) 1991-1993; ALL RIGHTS RESERVED                       The HYDRA protocol was designed by                 Arjen G. Lentz, LENTZ SOFTWARE-DEVELOPMENT and                            Joaquim H. Homrighausen                  COPYRIGHT (C) 1991-1993; ALL RIGHTS RESERVED  Revision history:  06 Sep 1991 - (AGL) First tryout  .. ... .... - Internal development  11 Jan 1993 - HydraCom version 1.00, Hydra revision 001 (01 Dec 1992)  13 Mar 1993 - HydraCom version 1.03, Hydra revision 001 (01 Dec 1992)  ..  Changes made by Michael Buenter:  03 Dec 1993 - adapted hydra for BT-EE and BT 2.58, many changes  ..  Updated source fixes by Arjen Lentz:  04 Sep 1993 - HydraCom version 1.08, Hydra revision 001 (01 Dec 1992)  23 Dec 1993 - updated to post-1.08 revisions upto 18 Dec 1993  For complete details of the Hydra and HydraCom licensing restrictions,  please refer to the license agreements which are published in their entirety  in HYDRACOM.C and LICENSE.DOC, and also contained in the documentation file  HYDRACOM.DOC  Use of this file is subject to the restrictions contained in the Hydra and  HydraCom licensing agreements. If you do not find the text of this agreement  in any of the aforementioned files, or if you do not have these files, you  should immediately contact LENTZ SOFTWARE-DEVELOPMENT and/or Joaquim  Homrighausen at one of the addresses listed below. In no event should you  proceed to use this file without having accepted the terms of the Hydra and  HydraCom licensing agreements, or such other agreement as you are able to  reach with LENTZ SOFTWARE-DEVELOMENT and Joaquim Homrighausen.  Hydra protocol design and HydraCom driver:         Hydra protocol design:  Arjen G. Lentz                                     Joaquim H. Homrighausen  LENTZ SOFTWARE-DEVELOPMENT                         389, route d'Arlon  Langegracht 7B                                     L-8011 Strassen  3811 BT  Amersfoort                                Luxembourg  The Netherlands  FidoNet 2:283/512, AINEX-BBS +31-33-633916         FidoNet 2:270/17  arjen_lentz@f512.n283.z2.fidonet.org               joho@ae.lu  Please feel free to contact us at any time to share your comments about our  software and/or licensing policies.=============================================================================*///#include "includes.h"#include <ctype.h>#include <stdio.h>#include <string.h>//	#include <time.h>#include "Comm.h"#include "hydra.h"#include "aglcrc.h"#include "zfiles.h"//#include "zmodem.h"#include "PKT.h"#include "Prefs.h"#include "compatible.h"#include "Scheduler.h"#include "Unattended.h"#include "pmain.h"#include "Pathes.h"#include "myEnv.h"#include "Timing.h"#include "Modem.h"#include "freq.h"#include "PascalStr.h"#include "log.h"#include "history.h"#define	PATHLEN		256//#define DEBUG//#define j_status(x)	//putlog('-', x)//static	short	debugging_log = 1;extern short		thy_request;				//	reote made file requestextern short		we_request;				//	we made file requestextern	short	VMPresent;extern short			remote_capabilities;extern Boolean			Aborted;extern unsigned char	Txbuf[];extern short			isOriginator;extern unsigned long	cur_baud;	/* Current baud rate   */extern short			gotta_mail;				// somewhat received with ZedZapextern short			gotta_xmail;				// somewhat received with ZedZapextern Boolean		dos_names;extern	long	hiho_can;extern	long	hiho_want;extern h_pc_exch	pc_exch_pref;static	long	hydra_txwindow = 0L;static	long	hydra_rxwindow = 0L;static unsigned long	RxStart, TxStart;/* external prototypes from janus.c *///	void j_status (char *,...);//	void j_msgend (unsigned short);//	void j_message (unsigned short, char *,...);//	short j_error (char *, char *);//	void xfer_summary (char *, char *, long *, short);//	void update_status (long *, long *, long, short *, short);//	long through (long *, long *);short xfer_init (char *fname, long fsize, long ftime);//	short xfer_okay (void);#define inteli(x) endshort(x)#define intell(x) endlong(x)/* HYDRA's memory ---------------------------------------------------------- */static Boolean originator;						/* are we the orig side?     */static short batchesdone;						/* No. HYDRA batches done    */static Boolean hdxlink;						/* hdx link & not orig side  */static unsigned long options;						/* INIT options hydra_init() */static unsigned short timeout;						/* general timeout in secs   */static char abortstr[] ={24, 24, 24, 24, 24, 24, 24, 24, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 0};#ifdef HYDRADEVstatic char *hdxmsg = "Fallback to one-way xfer";#endifstatic char *pktprefix = "";static char *autostr = "hydra\r";static unsigned short *crc16tab;						/* CRC-16 table              */static unsigned long *crc32tab;						/* CRC-32 table              */static char *GenericError = "!%s";static unsigned char *txbuf, *rxbuf;					/* packet buffers            */static unsigned long txoptions, rxoptions;			/* HYDRA options (INIT seq)  */static char txpktprefix[H_PKTPREFIX + 1];	/* pkt prefix str they want  */static long txwindow, rxwindow;				/* window size (0=streaming) */static h_timer braindead;					/* braindead timer           */static unsigned char *txbufin;						/* read data from disk here  */static unsigned char txlastc;						/* last unsigned char put in txbuf    */static unsigned char rxdle;							/* count of received H_DLEs  */static unsigned char rxpktformat;					/* format of pkt receiving   */static unsigned char *rxbufptr;						/* current position in rxbuf */static unsigned char *rxbufmax;						/* highwatermark of rxbuf    */static char txfname[64], rxfname[64];		/* fname of current files    */static char rxpathname[PATHLEN];			/* pathname of currrent file */static long txftime, rxftime;				/* file timestamp (UNIX)     */static long txfsize, rxfsize;				/* file length               */static short txfd, rxfd;						/* file handles              */static unsigned short rxpktlen;						/* length of last packet     */static unsigned short rxblklen;						/* len of last good data blk */static short txstate, rxstate;				/* xmit/recv states          */static long txpos, rxpos;					/* current position in files */static long txoldpos, rxoldpos;				/* last position in files    */static unsigned short txblklen;						/* length of last block sent */static unsigned short txmaxblklen;					/* max block length allowed  */static long txlastack;						/* last dataack received     *///static long txstart, rxstart;				/* time we started this file */static short txoldeta, rxoldeta;				/* last time needed          */static long txoffset, rxoffset;				/* offset in file we begun   */static h_timer txtimer, rxtimer;			/* retry timers              */static unsigned short txretries, rxretries;			/* retry counters            */static long rxlastsync;						/* filepos last sync retry   */static long txsyncid, rxsyncid;				/* id of last resync         */static unsigned short txgoodneeded;					/* to send before larger blk */static unsigned short txgoodbytes;					/* no. sent at this blk size */struct _h_flags{	char *str;	unsigned long val;};static struct _h_flags h_flags[] ={	{"XON", HOPT_XONXOFF},	{"TLN", HOPT_TELENET},	{"CTL", HOPT_CTLCHRS},	{"HIC", HOPT_HIGHCTL},	{"HI8", HOPT_HIGHBIT},	{"BRK", HOPT_CANBRK},	{"ASC", HOPT_CANASC},	{"UUE", HOPT_CANUUE},	{"C32", HOPT_CRC32},	{"DEV", HOPT_DEVICE},	{"FPT", HOPT_FPT},	{NULL, 0x0L}};/*-------------------------------------------------------------------------*/static short Next_y;		/* Number of next available line on screen         */static short Tx_y;		/* Line number of file transmission status display */static short Rx_y;		/* Line number of file reception status display    *//*static char *h_revdate (long revstamp){	static char buf[12];	struct tm *t;	t = localtime ((unsigned long *)&revstamp);	sprintf (buf, "%02d %s %d",		t->tm_mday, mtext[t->tm_mon], t->tm_year + 1900);	return (buf);}											/*h_revdate()*/#ifdef HYDRADEV/*---------------------------------------------------------------------------*/static void hydra_msgdev (unsigned char * data, unsigned short len){								/* text is already NUL terminated by calling func hydra_devrecv() */	len = len;	j_status ("*HMSGDEV: %s", data);}								/*hydra_msgdev()*//*---------------------------------------------------------------------------*/static short devtxstate;						/* dev xmit state            */static h_timer devtxtimer;					/* dev xmit retry timer      */static unsigned short devtxretries;					/* dev xmit retry counter    */static long devtxid, devrxid;				/* id of last devdata pkt    */static char devtxdev[H_FLAGLEN + 1];		/* xmit device ident flag    */static unsigned char *devtxbuf;						/* ptr to usersupplied dbuf  */static unsigned short devtxlen;						/* len of data in xmit buf   */struct _h_dev{	char *dev;	void (*func) (unsigned char * data, unsigned short len);};static struct _h_dev h_dev[] ={	{"MSG", hydra_msgdev},					/* internal protocol msg     */	{"CON", NULL},							/* text to console (chat)    */	{"PRN", NULL},							/* data to printer           */	{"ERR", NULL},							/* text to error output      */	{NULL, NULL}};/*---------------------------------------------------------------------------*/Boolean hydra_devfree (void){	if (devtxstate || !(txoptions & HOPT_DEVICE) || txstate >= HTX_END)		return (FALSE);						/* busy or not allowed       */	else		return (TRUE);						/* allowed to send a new pkt */}											/*hydra_devfree()*//*---------------------------------------------------------------------------*/Boolean hydra_devsend (char *dev, unsigned char * data, unsigned short len){	if (!dev || !data || !len || !hydra_devfree ())		return (FALSE);	strncpy (devtxdev, dev, H_FLAGLEN);	devtxdev[H_FLAGLEN] = '\0';	strupr (devtxdev);	devtxbuf = data;	devtxlen = (len > H_MAXBLKLEN) ? H_MAXBLKLEN : len;	devtxid++;	devtxtimer = h_timer_reset ();	devtxretries = 0;	devtxstate = HTD_DATA;	return (TRUE);}											/*hydra_devsend()*//*---------------------------------------------------------------------------*/Boolean hydra_devfunc (char *dev, void (*func) (unsigned char * data, unsigned short len)){	register short i;	for (i = 0; h_dev[i].dev; i++)	{		if (!strnicmp (dev, h_dev[i].dev, H_FLAGLEN))		{			h_dev[i].func = func;			return (TRUE);		}	}	return (FALSE);}											/*hydra_devfunc()*//*---------------------------------------------------------------------------*/static void hydra_devrecv (void){	register char *p = (char *) rxbuf;	register short i;	unsigned short len = rxpktlen;	p += (short) sizeof (long);						/* skip the id long  */	len -= (short) sizeof (long);	for (i = 0; h_dev[i].dev; i++)	{												/* walk through devs */		if (!strncmp (p, h_dev[i].dev, H_FLAGLEN))		{			if (h_dev[i].func)			{				len -= ((short) strlen (p)) + 1;		/* sub devstr len    */				p += ((short) strlen (p)) + 1;		/* skip devtag       */				p[len] = '\0';						/* NUL terminate     */				(*h_dev[i].func) ((unsigned char *) p, len);	/* call output func  */			}			break;		}	}}													/*hydra_devrecv()*/#endif/*---------------------------------------------------------------------------*/short xfer_init (char *fname, long fsize, long ftime){	short i;	char namebuf[PATHLEN];	Str255	sptemp;	long			fst_size;	long			fst_mtime;	OSType			creator, type;	long			create;	//	Resume_WaZOO = 0;//	strcpy (rxpathname, remote_capabilities ? CURRENT.sc_Inbound : download_path);	inboundPath[inboundPath[0]+1] = 0;	strcpy (rxpathname, (char *) &inboundPath[1]);	strcat (rxpathname, fname);	/*--------------------------------------------------------------------*/	/* Save info on WaZOO transfer in case of abort                       */	/*--------------------------------------------------------------------*///	if (remote_capabilities)//	{//		(void) strcpy (Resume_name, fname);//		(void) sprintf (Resume_info, "%ld %lo", fsize, ftime);//	}	/*--------------------------------------------------------------------*/	/* Check if this is a failed WaZOO transfer which should be resumed   */	/*--------------------------------------------------------------------*///	if (remote_capabilities && dexists (Abortlog_name))//	{//		Resume_WaZOO = (unsigned char) check_failed (Abortlog_name, fname, Resume_info, namebuf);//	}//	if (Resume_WaZOO)//	{//		strcpy (rxpathname, CURRENT.sc_Inbound);//		strcat (rxpathname, namebuf);//	}//	else//	{//		if (dexists (rxpathname))//		{//			struct stat f;////			stat (rxpathname, &f);//			if (fsize == f.st_size && ftime == f.st_mtime)//				return (FALSE);	/* already have file *///			else//			{//				i = strlen (rxpathname) - 1;//				if ((!overwrite) || (is_arcmail (rxpathname, i)))//				{//					unique_name (rxpathname);//				}//				else//				{//					(void) unlink (rxpathname);//				}//			}//		}									/* if exist *///	}										/* Resume_WaZOO */////	UxConvertTime (true, (unsigned long *) &ftime);	strcpy ((char *) &sptemp[1], rxpathname);	sptemp[0] = strlen (rxpathname);//	sptemp[sptemp[0]+1] = 0;	if (GetInfoFile (0, 0, sptemp, &creator, &type, &create, &fst_mtime, &fst_size) == 0)	{//	¥¥	If file already exists...		if (fsize == fst_size && ftime == fst_mtime)		{			putlog (lgNOPE, "Skip %s", trunc_path ((char *)&sptemp[1]));			return false;		}				if (creator == 'RvlM' && type == 'ZMPT')		{//	¥¥	exist uncompletedÉ//	¥¥	do concatenation?					if (ftime != fst_mtime)			{//	¥¥	other file - kill it (maybe was addenum pack to it?)				putlog (lgATTN, "Kill incompleted dup file %s", trunc_path ((char *) &sptemp[1]));				FSDelete (sptemp, 0);			}		}		else		{			Str255		newname;			short		iErr;			//	¥¥	other file already present with this name			pStrCopy (sptemp, newname);			newname[newname[0]+1] = 0;			do {							newname[newname[0]]++;				if (newname[newname[0]] == ':')					newname[newname[0]]++;								iErr = HRename ( 0, 0, sptemp, newname );			} while (iErr == dupFNErr);						if (iErr)			{				putlog (lgATTN, "Kill dup file %s", trunc_path ((char *) &sptemp[1]));				FSDelete (sptemp, 0);			}			else			{				newname[newname[0]+1] = 0;				putlog (lgATTN, "Rename dup file %s to %s",											trunc_path ((char *) &sptemp[1]),											trunc_path ((char *) &newname[1]));							}		}	}						/* if exist */	return (true);}											/*xfer_init()*//*---------------------------------------------------------------------------*short xfer_okay (void){	static char new_pathname[PATHLEN];	char *p;	remove_abort (Abortlog_name, Resume_name);	strcpy (new_pathname, CURRENT.sc_Inbound);	p = new_pathname + ((short) strlen (new_pathname));	/* start of fname *	strcat (new_pathname, Resume_name);					/* add real fname *	unique_name (new_pathname);							/* make it unique *	if (rename (rxpathname, new_pathname))				/* rename temp to real *		status_line ("!Could not rename '%s' to '%s'", rxpathname, new_pathname);	strcpy (rxpathname, new_pathname);	return (stricmp (p, Resume_name));					/* dup rename? *}/*---------------------------------------------------------------------------*/static void put_flags (char *buf, struct _h_flags flags[], long val){	register char *p;	register short i;	p = buf;	for (i = 0; flags[i].val; i++)	{		if (val & flags[i].val)		{			if (p > buf)				*p++ = ',';			strcpy (p, flags[i].str);			p += H_FLAGLEN;		}	}	*p = '\0';	//	putlog ('~', "opt> %s", buf);}											/*put_flags()*//*---------------------------------------------------------------------------*/static unsigned long get_flags (char *buf, struct _h_flags flags[]){	register unsigned long val;	register char *p;	register short i;	val = 0x0L;	for (p = strtok (buf, ","); p; p = strtok (NULL, ","))	{		for (i = 0; flags[i].val; i++)		{			if (!strcmp (p, flags[i].str))			{				val |= flags[i].val;				break;			}		}	}	return (val);}											/*get_flags()*//*---------------------------------------------------------------------------*//* CRC-16/32 code now separate source *//*AGL:10mar93*//*---------------------------------------------------------------------------*/static unsigned char *put_binbyte (register unsigned char * p, register unsigned char c){	register unsigned char n;	n = c;	if (txoptions & HOPT_HIGHCTL)		n &= 0x7f;	if (n == H_DLE ||		((txoptions & HOPT_XONXOFF) && (n == XON || n == XOFF)) ||		((txoptions & HOPT_TELENET) && n == '\r' && txlastc == '@') ||		((txoptions & HOPT_CTLCHRS) && (n < 32 || n == 127)))	{		*p++ = H_DLE;		c ^= 0x40;	}	*p++ = c;	txlastc = n;	return (p);}											/*put_binbyte()*//*---------------------------------------------------------------------------*/static void txpkt (register unsigned short len, short type){	register unsigned char *in, *out;	register unsigned short c, n;	Boolean crc32 = FALSE;	unsigned char format;	static char hexdigit[] = "0123456789abcdef";	txbufin[len++] = (unsigned char)type;	switch (type)	{	case HPKT_START:	case HPKT_INIT:	case HPKT_INITACK:	case HPKT_END:	case HPKT_IDLE:		format = HCHR_HEXPKT;		break;	default:		/* COULD do smart format selection depending on data and options! */		if (txoptions & HOPT_HIGHBIT)		{			if ((txoptions & HOPT_CTLCHRS) && (txoptions & HOPT_CANUUE))				format = HCHR_UUEPKT;			else if (txoptions & HOPT_CANASC)				format = HCHR_ASCPKT;			else				format = HCHR_HEXPKT;		}		else			format = HCHR_BINPKT;		break;	}	if (format != HCHR_HEXPKT && (txoptions & HOPT_CRC32))		crc32 = TRUE;#ifdef DEBUG	if (debugging_log)	{		char *s1, *s2, *s3, *s4;		//putlog('-', ">-> PKT (format='%c'  type='%c'  crc=%d  len=%d)",			(char) format, (char) type, crc32 ? 32 : 16, (short) len - 1);		switch (type)		{		case HPKT_START:			//putlog('-', ">   <autostr>START");			break;		case HPKT_INIT:			s1 = ((char *) txbufin) + ((short) strlen ((char *) txbufin)) + 1;			s2 = s1 + ((short) strlen (s1)) + 1;			s3 = s2 + ((short) strlen (s2)) + 1;			s4 = s3 + ((short) strlen (s3)) + 1;			/*                          //putlog('-', ">   INIT (appinfo='%s'  can='%s'  want='%s'  options='%s'  pktprefix='%s')",                                       (char *) txbufin, s1, s2, s3, s4); */			break;		case HPKT_INITACK:			//putlog('-', ">   INITACK");			break;		case HPKT_FINFO:			//putlog('-', ">   FINFO (%s)", txbufin);			break;		case HPKT_FINFOACK:			if (rxfd >= 0)			{				if (rxpos > 0L)					s1 = "RES";				else					s1 = "BOF";			}			else if (rxpos == -1L)				s1 = "HAVE";			else if (rxpos == -2L)				s1 = "SKIP";			else				s1 = "EOB";			//putlog('-', ">   FINFOACK (pos=%ld %s  rxstate=%d  rxfd=%d)",				rxpos, s1, (short) rxstate, rxfd);			break;		case HPKT_DATA:			//putlog('-', ">   DATA (ofs=%ld  len=%d)",				intell (h_long1 (txbufin)), (short) len - 5);			break;		case HPKT_DATAACK:			//putlog('-', ">   DATAACK (ofs=%ld)",				intell (h_long1 (txbufin)));			break;		case HPKT_RPOS:			//putlog('-', ">   RPOS (pos=%ld%s  blklen=%ld  syncid=%ld)",				rxpos, rxpos < 0L ? " SKIP" : "",				intell (h_long2 (txbufin)), rxsyncid);			break;		case HPKT_EOF:			//putlog('-', ">   EOF (ofs=%ld%s)",				txpos, txpos < 0L ? " SKIP" : "");			break;		case HPKT_EOFACK:			//putlog('-', ">   EOFACK");			break;		case HPKT_IDLE:			//putlog('-', ">   IDLE");			break;		case HPKT_END:			//putlog('-', ">   END");			break;#ifdef HYDRADEV		case HPKT_DEVDATA:			//putlog('-', ">   DEVDATA (id=%ld  dev='%s'  len=%hu)",			//	devtxid, devtxdev, devtxlen);			break;		case HPKT_DEVDACK:			//putlog('-', ">   DEVDACK (id=%ld)",			//	intell (h_long1 (rxbuf)));			break;#endif		default:				/* This couldn't possibly happen! ;-) */			break;		}	}#endif	if (crc32)	{		unsigned long crc = CRC32POST (crc32block (crc32tab, CRC32INIT, txbufin, len));	/*AGL:10mar93*/		txbufin[len++] = (unsigned char) crc;		txbufin[len++] = (unsigned char) (crc >> 8);		txbufin[len++] = (unsigned char) (crc >> 16);		txbufin[len++] = (unsigned char) (crc >> 24);	}	else	{		unsigned short crc = CRC16POST (crc16block (crc16tab, CRC16INIT, txbufin, len));	/*AGL:10mar93*/		txbufin[len++] = (unsigned char) crc;		txbufin[len++] = (unsigned char) (crc >> 8);	}	in = txbufin;	out = txbuf;	txlastc = 0;	*out++ = H_DLE;	*out++ = format;	switch (format)	{	case HCHR_HEXPKT:		for (; len > 0; len--, in++)		{			if (*in & 0x80)			{				*out++ = '\\';				*out++ = hexdigit[((*in) >> 4) & 0x0f];				*out++ = hexdigit[(*in) & 0x0f];			}			else if (*in < 32 || *in == 127)			{				*out++ = H_DLE;				*out++ = (unsigned char)((*in) ^ 0x40);			}			else if (*in == '\\')			{				*out++ = '\\';				*out++ = '\\';			}			else				*out++ = *in;		}		break;	case HCHR_BINPKT:		for (; len > 0; len--)			out = put_binbyte (out, *in++);		break;	case HCHR_ASCPKT:		for (n = c = 0; len > 0; len--)		{			c |= ((*in++) << n);			out = put_binbyte (out, (unsigned char)(c & 0x7f));			c >>= 7;			if (++n >= 7)			{				out = put_binbyte (out, (unsigned char)(c & 0x7f));				n = c = 0;			}		}		if (n > 0)			out = put_binbyte (out, (unsigned char)(c & 0x7f));		break;	case HCHR_UUEPKT:		for (; len >= 3; in += 3, len -= 3)		{			*out++ = (unsigned char) h_uuenc (in[0] >> 2);			*out++ = (unsigned char) h_uuenc (((in[0] << 4) & 0x30) | ((in[1] >> 4) & 0x0f));			*out++ = (unsigned char) h_uuenc (((in[1] << 2) & 0x3c) | ((in[2] >> 6) & 0x03));			*out++ = (unsigned char) h_uuenc (in[2] & 0x3f);		}		if (len > 0)		{			*out++ = (unsigned char) h_uuenc (in[0] >> 2);			*out++ = (unsigned char) h_uuenc (((in[0] << 4) & 0x30) | ((in[1] >> 4) & 0x0f));			if (len == 2)				*out++ = (unsigned char) h_uuenc ((in[1] << 2) & 0x3c);		}		break;	}	*out++ = H_DLE;	*out++ = HCHR_PKTEND;	if (type != HPKT_DATA && format != HCHR_BINPKT)	{		*out++ = '\r';		*out++ = '\n';	}	for (in = (unsigned char *) txpktprefix; *in; in++)	{		switch (*in)		{		case 221:				/* transmit break signal for one second */			do_break(true);			{				h_timer t = h_timer_set (2);				while (!h_timer_expired (t, h_timer_get ()))					time_release ();			}			do_break(false);			break;		case 222:			{				h_timer t = h_timer_set (2);				while (!h_timer_expired (t, h_timer_get ()))					time_release ();			}			break;		case 223:			SENDBYTE (0);			break;		default:			SENDBYTE (*in);			break;		}	}	SENDCHARS (txbuf, (long) (out - txbuf), braindead);//	ComTXBlockTimeout (txbuf, (USHORT) (out - txbuf), braindead);}								/*txpkt()*//*---------------------------------------------------------------------------*/static short rxpkt (void){	register unsigned char *p, *q = rxbuf;	register unsigned short n, i;	short c;	h_timer tnow = h_timer_get ();	/*AGL:16jul93*/	if (CheckCancel ())		return (H_SYSABORT);	if (!CARRIER)		return (H_CARRIER);	if (h_timer_running (braindead) && h_timer_expired (braindead, tnow))	{#ifdef DEBUG		if (debugging_log)			//putlog('-', " <- BrainDead (timer=%08lx  time=%08lx)", braindead, tnow);#endif		return (H_BRAINTIME);	}	if (h_timer_running (txtimer) && h_timer_expired (txtimer, tnow))	{#ifdef DEBUG		if (debugging_log)			//putlog('-', " <- TxTimer (timer=%08lx  time=%08lx)", txtimer, tnow);#endif		return (H_TXTIME);	}#ifdef HYDRADEV	if (h_timer_running (devtxtimer) && h_timer_expired (devtxtimer, tnow))	{#ifdef DEBUG		if (debugging_log)			//putlog('-', " <- DevTxTimer (timer=%08lx  time=%08lx)", devtxtimer, time (NULL));#endif		return (H_DEVTXTIME);	}#endif	p = rxbufptr;	while (CHAR_AVAIL ())	{		c = MODEM_IN ();		if (rxoptions & HOPT_HIGHBIT)			c &= 0x7f;		n = c;		if (rxoptions & HOPT_HIGHCTL)			n &= 0x7f;		if (n != H_DLE &&			(((rxoptions & HOPT_XONXOFF) && (n == XON || n == XOFF)) ||				((rxoptions & HOPT_CTLCHRS) && (n < 32 || n == 127))))			continue;		if (rxdle || c == H_DLE)		{			switch (c)			{			case H_DLE:				if (++rxdle >= 5)					return (H_CANCEL);				break;			case HCHR_PKTEND:				rxbufptr = p;				switch (rxpktformat)				{				case HCHR_BINPKT:					q = rxbufptr;					break;				case HCHR_HEXPKT:					for (p = q = rxbuf; p < rxbufptr; p++)					{						if (*p == '\\' && *++p != '\\')						{							i = *p;							n = *++p;							if ((i -= '0') > 9)								i -= ('a' - ':');							if ((n -= '0') > 9)								n -= ('a' - ':');							if ((i & ~0x0f) || (n & ~0x0f))							{								c = H_NOPKT;								break;							}							*q++ = (unsigned char) ((i << 4) | n);						}						else							*q++ = *p;					}					if (p > rxbufptr)						c = H_NOPKT;					break;				case HCHR_ASCPKT:					n = i = 0;					for (p = q = rxbuf; p < rxbufptr; p++)					{						i |= ((*p & 0x7f) << n);						if ((n += 7) >= 8)						{							*q++ = (unsigned char) (i & 0xff);							i >>= 8;							n -= 8;						}					}					break;				case HCHR_UUEPKT:					n = (short) (rxbufptr - rxbuf);					for (p = q = rxbuf; n >= 4; n -= 4, p += 4)					{						if (p[0] <= ' ' || p[0] >= 'a' ||							p[1] <= ' ' || p[1] >= 'a' ||							p[2] <= ' ' || p[2] >= 'a' ||							p[3] <= ' ' || p[3] >= 'a')						{							c = H_NOPKT;							break;						}						*q++ = (unsigned char) ((h_uudec (p[0]) << 2) | (h_uudec (p[1]) >> 4));						*q++ = (unsigned char) ((h_uudec (p[1]) << 4) | (h_uudec (p[2]) >> 2));						*q++ = (unsigned char) ((h_uudec (p[2]) << 6) | h_uudec (p[3]));					}					if (n >= 2)					{						if (p[0] <= ' ' || p[0] >= 'a' ||						    p[1] <= ' ' || p[1] >= 'a')						{							c = H_NOPKT;							break;						}						*q++ = (unsigned char) ((h_uudec (p[0]) << 2) | (h_uudec (p[1]) >> 4));						if (n == 3)						{							if (p[2] <= ' ' || p[2] >= 'a')							{								c = H_NOPKT;								break;							}							*q++ = (unsigned char) ((h_uudec (p[1]) << 4) | (h_uudec (p[2]) >> 2));						}					}					break;				default:		/* This'd mean internal fluke */#ifdef DEBUG					if (debugging_log)					{						//putlog('-', " <- <PKTEND> (pktformat='%c' dec=%d hex=%02x) ??",							(char) rxpktformat, (short) rxpktformat, (short) rxpktformat);					}#endif					c = H_NOPKT;					break;				}				rxbufptr = NULL;				if (c == H_NOPKT)					break;				rxpktlen = (unsigned short) (q - rxbuf);				if (rxpktformat != HCHR_HEXPKT && (rxoptions & HOPT_CRC32))				{					if (rxpktlen < 5)					{						c = H_NOPKT;						break;					}					n = h_crc32test (crc32block (crc32tab, CRC32INIT, rxbuf, rxpktlen));	/*AGL:10mar93*/					rxpktlen -= (short) sizeof (long);	/* remove CRC-32 */				}				else				{					if (rxpktlen < 3)					{						c = H_NOPKT;						break;					}					n = h_crc16test (crc16block (crc16tab, CRC16INIT, rxbuf, rxpktlen));	/*AGL:10mar93*/					rxpktlen -= (short) sizeof (unsigned short);	/* remove CRC-16 */				}				rxpktlen--;		/* remove type  */				if (n)				{#ifdef DEBUG					if (debugging_log)					{						char *s1, *s2, *s3, *s4;						//putlog('-', "><- PKT (format='%c'  type='%c'  len=%hd)",							(char) rxpktformat, rxbuf[rxpktlen], rxpktlen);						switch (rxbuf[rxpktlen])						{						case HPKT_START:							//putlog('-', "<   START");							break;						case HPKT_INIT:							s1 = ((char *) rxbuf) + ((short) strlen ((char *) rxbuf)) + 1;							s2 = s1 + ((short) strlen (s1)) + 1;							s3 = s2 + ((short) strlen (s2)) + 1;							s4 = s3 + ((short) strlen (s3)) + 1;							/*                                          //putlog('-', "<   INIT (appinfo='%s'  can='%s'  want='%s'  options='%s'  pktprefix='%s')",                                                     (char *) rxbuf, s1, s2, s3, s4);  */							break;						case HPKT_INITACK:							//putlog('-', "<   INITACK");							break;						case HPKT_FINFO:							//putlog('-', "<   FINFO ('%s'  rxstate=%d)", rxbuf, (short) rxstate);							break;						case HPKT_FINFOACK:							//putlog('-', "<   FINFOACK (pos=%ld  txstate=%d  txfd=%d)",								intell (h_long1 (rxbuf)), (short) txstate, txfd);							break;						case HPKT_DATA:							//putlog('-', "<   DATA (rxstate=%d  pos=%ld  len=%hu)",								(short) rxstate, intell (h_long1 (rxbuf)),								(unsigned short) (rxpktlen - ((short) sizeof (long))));							break;						case HPKT_DATAACK:							//putlog('-', "<   DATAACK (rxstate=%d  pos=%ld)",								(short) rxstate, intell (h_long1 (rxbuf)));							break;						case HPKT_RPOS:							//putlog('-', "<   RPOS (pos=%ld%s  blklen=%hu->%ld  syncid=%ld%s  txstate=%d  txfd=%d)",								intell (h_long1 (rxbuf)),								intell (h_long1 (rxbuf)) < 0L ? " SKIP" : "", txblklen, intell (h_long2 (rxbuf)),								intell (h_long3 (rxbuf)),								intell (h_long3 (rxbuf)) == rxsyncid ? " DUP" : "",								(short) txstate, txfd);							break;						case HPKT_EOF:							//putlog('-', "<   EOF (rxstate=%d  pos=%ld%s)",								(short) rxstate, intell (h_long1 (rxbuf)),								intell (h_long1 (rxbuf)) < 0L ? " SKIP" : "");							break;						case HPKT_EOFACK:							//putlog('-', "<   EOFACK (txstate=%d)", (short) txstate);							break;						case HPKT_IDLE:							//putlog('-', "<   IDLE");							break;						case HPKT_END:							//putlog('-', "<   END");							break;#ifdef HYDRADEV						case HPKT_DEVDATA:							s1 = ((char *) rxbuf) + ((short) sizeof (long));							//putlog('-', "<   DEVDATA (id=%ld  dev=%s  len=%u",								intell (h_long1 (rxbuf)), s1,								(short) rxpktlen - (((short) sizeof (long)) + ((short) strlen (s1)) + 1));							break;						case HPKT_DEVDACK:							//putlog('-', "<   DEVDACK (devtxstate=%d  id=%ld)",								(short) devtxstate, intell (h_long1 (rxbuf)));							break;#endif						default:							//putlog('-', "<   Unkown pkttype %c (txstate=%d  rxstate=%d)",								rxbuf[rxpktlen], (short) txstate, (short) rxstate);							break;						}					}#endif					return ((short) rxbuf[rxpktlen]);				}				/*goodpkt*/#ifdef DEBUG				if (debugging_log)					//putlog('-', ">Bad CRC (format='%c'  type='%c'  len=%d)",						(char) rxpktformat, rxbuf[rxpktlen], (short) rxpktlen);#endif				break;			case HCHR_BINPKT:			case HCHR_HEXPKT:			case HCHR_ASCPKT:			case HCHR_UUEPKT:#ifdef DEBUG				if (debugging_log)					//putlog('-', " <- <PKTSTART> (pktformat='%c')", (char) c);#endif				rxpktformat = (unsigned char) c;				p = rxbufptr = rxbuf;				rxdle = 0;				break;			default:				if (p)				{					if (p < rxbufmax)						*p++ = (unsigned char) (c ^ 0x40);					else					{#ifdef DEBUG						if (debugging_log)							//putlog('-', " <- Pkt too long - discarded");#endif						p = NULL;					}				}				rxdle = 0;				break;			}					/* case */		}		else if (p)		{			if (p < rxbufmax)				*p++ = (unsigned char) c;			else			{#ifdef DEBUG				if (debugging_log)					//putlog('-', " <- Pkt too long - discarded");#endif				p = NULL;			}		}	}	rxbufptr = p;//	time_release ();	return (H_NOPKT);}								/*rxpkt()*//*---------------------------------------------------------------------------*/static void hydra_badxfer (void){	long			fst_size;	long			fst_mtime;	OSType			creator, type;	long			create;	Str255			sptemp;	//putlog (lgALRT, "=> hydra_badxfer");//	Aborted = true;	if (rxfd != -1)	{		FSClose (rxfd);				strcpy ((char *)&sptemp[1], rxpathname);		sptemp[0] = strlen (rxpathname);		if (ResolveExtension (sptemp) == 2)		{			putlog (lgATTN, "Kill aborted %s", trunc_path (rxpathname));			FSDelete (sptemp, 0);		}		else		{			SetInfoFile (0, 0, sptemp, 'RvlM', 'ZMPT', rxftime, rxftime);			history_add_traff (false, rxpos-rxoffset);			putlog (lgATTN, "Save partialy received %s (%ldb)", trunc_path (rxpathname), rxpos);		}				rxfd = -1;//		if (remote_capabilities)//		{//			if (!Resume_WaZOO)//			{//				add_abort (Abortlog_name, Resume_name, rxpathname, CURRENT.sc_Inbound, Resume_info);//			}//		}//		else//		{//			(void) unlink (rxpathname);//		}	}}								/*hydra_badxfer()*//*---------------------------------------------------------------------------*/void hydra_init (unsigned long want_options){	char *HoldName;	short	err;	char	temp[128];	//	txbuf = Txbuf;//	rxbuf = txbuf + H_BUFLEN;	txbuf = (unsigned char *) NewPtr (H_BUFLEN);	rxbuf = (unsigned char *) NewPtr (H_BUFLEN);	gotta_xmail = gotta_mail = 0;	crc16tab = (unsigned short *) NewPtr (CRC_TABSIZE * sizeof (unsigned short));	crc32tab = (unsigned long *) NewPtr (CRC_TABSIZE * sizeof (unsigned long));	while (VMPresent)	{		if (err = HoldMemory (txbuf, H_BUFLEN))		{			putlog (lgALRT, "Can't hold VM for txbuf (err = %d)", err);			VMPresent = false;			break;		}				if (err = HoldMemory (rxbuf, H_BUFLEN))		{			putlog (lgALRT, "Can't hold VM for rxbuf (err = %d)", err);			VMPresent = false;			break;		}		if (err = HoldMemory (crc16tab, CRC_TABSIZE * sizeof (unsigned short)))		{			putlog (lgALRT, "Can't hold VM for crc16tab (err = %d)", err);			VMPresent = false;			break;		}		if (err = HoldMemory (crc32tab, CRC_TABSIZE * sizeof (unsigned long)))		{			putlog (lgALRT, "Can't hold VM for crc32tab (err = %d)", err);			VMPresent = false;			break;		}		break;	}		if (!txbuf || !rxbuf || !crc16tab || !crc32tab)	{//		status_line (MSG_TXT (M_MEM_ERROR));		mdm_hangup (NULL);		putlog (lgALRT, "hydra not enough memory!!!");		Aborted = true;				return;	}		txbufin = txbuf + ((H_MAXBLKLEN + H_OVERHEAD + 5) * 2);	rxbufmax = rxbuf + H_MAXPKTLEN;	crc16init (crc16tab, CRC16POLY);	crc32init (crc32tab, CRC32POLY);	batchesdone = 0;//	mail_finished = 1;	originator = remote_capabilities ? (isOriginator ? TRUE : FALSE) : TRUE;//	HoldName = HoldAreaNameMunge (&called_addr);//	(void) sprintf (Abortlog_name, "%s%s.Z\0",//		HoldName, Hex_Addr_Str (&remote_addr));//	if (originator)//		hdxlink = false;//	else		hdxlink = false;//	else//		hdxlink = !((janus_baud >= cur_baud.rate_value) || (janus_OK));//	want_options = hiho_can;//	options = (hiho_want & HCAN_OPTIONS) & ~HUNN_OPTIONS;	options = (hiho_want & hiho_can) & ~(HUNN_OPTIONS & ~HOPT_CRC32);	timeout = (unsigned short) (40960L / cur_baud);	if (timeout < H_MINTIMER)		timeout = H_MINTIMER;	else if (timeout > H_MAXTIMER)		timeout = H_MAXTIMER;	txmaxblklen = (short) ((cur_baud / 300) * 128);	if (txmaxblklen < 256)		txmaxblklen = 256;	else if (txmaxblklen > H_MAXBLKLEN)		txmaxblklen = H_MAXBLKLEN;	rxblklen = txblklen = (cur_baud < 2400U) ? 256 : 512;	txgoodbytes = 0;	txgoodneeded = txmaxblklen;	/*AGL:23feb93*/	txstate = HTX_DONE;//	set_prior (3);				/* Time Critical *///	XON_DISABLE ();/*	if (un_attended && fullscreen)	{		clear_filetransfer ();		sb_show ();		Tx_y = 1;		Rx_y = 2;	}	else	{		set_xy (NULL);		Rx_y = Tx_y = Next_y = locate_y;	}*/}								/*hydra_init()*//*---------------------------------------------------------------------------*/void hydra_deinit (void){	if (VMPresent)	{		UnholdMemory (txbuf, H_BUFLEN);		UnholdMemory (rxbuf, H_BUFLEN);		UnholdMemory (crc16tab, CRC_TABSIZE * sizeof (unsigned short));		UnholdMemory (crc32tab, CRC_TABSIZE * sizeof (unsigned long));	}	DisposePtr ((Ptr) crc16tab);	DisposePtr ((Ptr) crc32tab);	DisposePtr ((Ptr) txbuf);	DisposePtr ((Ptr) rxbuf);//	set_prior (4);				/* Always High */}								/*hydra_deinit()*//*---------------------------------------------------------------------------*/short hydra (char *txpathname, char *txalias){	short res = 0;	short pkttype;	char *p, *q;	short i, eta;//	struct stat f;	Str255	sptemp;		short			rz123;	long			fst_size;	long			fst_mtime;	OSType			creator, type;	long			create;	long			ioCounter, cps;	/*-------------------------------------------------------------------*/	if (txstate == HTX_DONE)	{//putlog(lgATTN, "HTX_DONE");		txstate = HTX_START;		txoptions = HTXI_OPTIONS;		txpktprefix[0] = '\0';		rxstate = HRX_INIT;		rxoptions = (HRXI_OPTIONS & ~(HOPT_XONXOFF|HOPT_TELENET));		rxfd = -1;		rxdle = 0;		rxbufptr = NULL;		rxtimer = h_timer_reset ();#ifdef HYDRADEV		devtxid = devrxid = 0L;		devtxtimer = h_timer_reset ();		devtxstate = HTD_DONE;#endif		braindead = h_timer_set (H_BRAINDEAD);	}	else		txstate = HTX_FINFO;	txtimer = h_timer_reset ();	txretries = 0;	/*-------------------------------------------------------------------*/	if (txpathname)	{//		stat (txpathname, &f);//		txfsize = f.st_size;//		txftime = f.st_mtime;		strcpy ((char *)&sptemp[1], txpathname);		sptemp[0] = strlen (txpathname);				if (GetInfoFile (0, 0, sptemp, &creator, &type, &create, &txftime, &txfsize))			return (XFER_SKIP);		UxConvertTime (false, (unsigned long *) &txftime);		if (FSOpen (sptemp, 0, &txfd))			return (XFER_SKIP);//		if ((txfd = share_open (txpathname, O_RDONLY | O_BINARY, DENY_WRITE)) < 0)//		{//			j_error (MSG_TXT (M_OPEN_MSG), txpathname);//			return (XFER_SKIP);//		}//		if (isatty (txfd))//		{//			errno = 1;//			(void) j_error (MSG_TXT (M_DEVICE_MSG), txpathname);//			close (txfd);//			return (XFER_SKIP);//		}//		UprText(txpathname, strlen(txpathname));//		strupr (txpathname);		for (p = txpathname, q = txfname; *p; p++)		{			if (*q = *p, *p == '\\' || *p == ':' || *p == '/')				q = txfname;			else				q++;		}		*q = '\0';//		if (txalias)//			strupr (txalias);		eta = (short) ((((txfsize * 10L) / cur_baud * 100L )/ 95L + 59L) / 60L);		putlog(lgNOPE, "H-Sending: %s (%ldb %d min)", trunc_path(txfname), txfsize, eta);		TxStart = LMGetTicks ();				newMessage (lTNAME, "H-Sending: %s", trunc_path(txfname));		newMessage (lTSTAT, "0:%ld (0) [%d min, 0 cps]", txfsize, eta);//		txstart = 0L;		txsyncid = 0L;//putlog(lgATTN, "good pathname");	}	else	{//putlog(lgATTN, "empty pathname");		txfd = -1;		strcpy (txfname, "");	}	/*-------------------------------------------------------------------*/	do	{#ifdef HYDRADEV		/*----------------------------------------------------------------*/		switch (devtxstate)		{			/*---------------------------------------------------------*/		case HTD_DATA:			if (txstate > HTX_RINIT)			{				h_long1 (txbufin) = intell (devtxid);				p = ((char *) txbufin) + ((short) sizeof (long));				strcpy (p, devtxdev);				p += H_FLAGLEN + 1;				memcpy (p, devtxbuf, devtxlen);				txpkt (((short) sizeof (long)) + H_FLAGLEN + 1 + devtxlen, HPKT_DEVDATA);				devtxtimer = h_timer_set ((!rxstate && txstate == HTX_REND) ? timeout / 2 : timeout);	/*AGL:10mar93*/				devtxstate = HTD_DACK;			}			break;			/*---------------------------------------------------------*/		default:			break;			/*---------------------------------------------------------*/		}#endif		/*----------------------------------------------------------------*/		switch (txstate)		{			/*---------------------------------------------------------*/		case HTX_START:			//putlog(lgATTN, "HTX_START");			SENDCHARS ((unsigned char *)autostr, (short) strlen (autostr), 1);			txpkt (0, HPKT_START);			txtimer = h_timer_set (H_START);			txstate = HTX_SWAIT;			break;			/*---------------------------------------------------------*/		case HTX_INIT://putlog(lgATTN, "HTX_INIT");			p = (char *) txbufin;			sprintf (p, "%08lx%s,%s", H_REVSTAMP, MAILERNAME, RAVELVERS);			p += ((short) strlen (p)) + 1;	/* our app info & HYDRA rev. *///			put_flags (p, h_flags, HCAN_OPTIONS);	/* what we CAN  */			put_flags (p, h_flags, hiho_can);	/* what we CAN  */						putlog ('~', "HTX_INIT We can:  %s", p);						p += ((short) strlen (p)) + 1;			put_flags (p, h_flags, options);	/* what we WANT */			putlog ('~', "HTX_INIT We want: %s", p);			p += ((short) strlen (p)) + 1;			sprintf (p, "%08lx%08lx",	/* TxRx windows */				hydra_txwindow, hydra_rxwindow);			p += ((short) strlen (p)) + 1;			strcpy (p, pktprefix);	/* pkt prefix string we want */			p += ((short) strlen (p)) + 1;			txoptions = HTXI_OPTIONS;			txpkt ((unsigned short) (((unsigned char *) p) - txbufin), HPKT_INIT);			txoptions = rxoptions;			txtimer = h_timer_set (timeout / 2);			txstate = HTX_INITACK;			break;			/*---------------------------------------------------------*/		case HTX_FINFO://putlog(lgATTN, "HTX_FINFO");			if (txfd >= 0)			{				short	i;				char	*dst, *src, c;											if (!txretries)				{					txoldpos = txoldeta = -1;/*					if (!un_attended || !fullscreen)						Tx_y = Next_y;					if (txalias)						xfer_summary (MSG_TXT (M_SEND), txalias, &txfsize, Tx_y);					else						xfer_summary (MSG_TXT (M_SEND), txfname, &txfsize, Tx_y);					strlwr (txfname);*/				}				sptemp[0] = 0;				dst = (char *) sptemp;				src = txfname;				i = 0;								while (*src && i < 8)				{					c = *src;										if (isgraph(c) && (c != '\\' && c != '/' && c != ':' && c != '*' && c != '?' && c != '.'))					{						*dst = c;						dst++;					}					else						if (c == '.')						{							*dst = c;							dst++;							src++;							break;						}						else							i--;											i++;					src++;				}								if (*src)				{					if (i == 8)					{						*dst = '.';						dst++;											if (*src == '.')							src++;					}										i = 0;										while (*src && i < 3)					{						c = *src;												if (isgraph(c) && (c != '\\' && c != '/' && c != ':' && c != '*' && c != '?' && c != '.'))						{							*dst = c;							dst++;						}						else							i--;												i++;						src++;					}				}								*dst = 0;				sprintf ((char *) txbufin, "%08lx%08lx%08lx%08lx%08lx%s",					txftime, txfsize, 0L, 0L, 0L, sptemp);//					txalias ? txalias : txfname);								if (!dos_names)				{					strcpy ((char *) &txbufin[strlen((char *) txbufin)+1], txfname);					putlog ('~', "%s|%s", (char *) txbufin, (char *) &txbufin[strlen((char *) txbufin)+1]);					txpkt (((short) strlen ((char *) txbufin)) + strlen ((char *) &txbufin[strlen((char *) txbufin)+1]) + 2, HPKT_FINFO);				}				else					txpkt (((short) strlen ((char *) txbufin)) + 1, HPKT_FINFO);			}			else			{				if (!txretries)				{//					j_msgend (Tx_y);#ifdef DEBUG					//putlog('-', "+HSEND: End of batch");#endif				}				strcpy ((char *) txbufin, txfname);				txpkt (((short) strlen ((char *) txbufin)) + 1, HPKT_FINFO);			}//putlog(lgATTN, "HTX_FINFO: %s", txbufin);			txtimer = h_timer_set (txretries ? timeout / 2 : timeout);			txstate = HTX_FINFOACK;			break;			/*---------------------------------------------------------*/		case HTX_XDATA://¥¥		if (ComTXRemain () > txmaxblklen)//¥¥			break;//putlog(lgATTN, "HTX_XDATA");			if (txpos < 0L)				i = -1;			/* Skip */			else			{				h_long1 (txbufin) = intell (txpos);//				if ((i = read (txfd, txbufin + ((short) sizeof (long)), txblklen)) < 0)				ioCounter = txblklen;/*				if (FSRead (txfd, &ioCounter, txbufin + ((short) sizeof (long))))				{					j_error (MSG_TXT (M_READ_MSG), txfname);					FSClose (txfd);					txfd = -1;					txpos = -2L;/* Skip *				}*/				FSRead (txfd, &ioCounter, txbufin + ((short) sizeof (long)));				i = ioCounter;			}			if (i > 0)			{				txpos += i;				txpkt (((short) sizeof (long)) + i, HPKT_DATA);				if (txblklen < txmaxblklen &&					(txgoodbytes += i) >= txgoodneeded)				{					txblklen <<= 1;					if (txblklen >= txmaxblklen)					{						txblklen = txmaxblklen;						txgoodneeded = 0;					}					txgoodbytes = 0;				}				if (txwindow && (txpos >= (txlastack + txwindow)))				{					txtimer = h_timer_set (txretries ? timeout / 2 : timeout);					txstate = HTX_DATAACK;				}//				if (!txstart)//					txstart = LMGetTime ();//					txstart = time (NULL);//				update_status (&txpos, &txoldpos, txfsize - txpos, &txoldeta, Tx_y);				eta = (short) (((((txfsize - txpos) * 10L) / cur_baud * 100L )/ 95L + 59L) / 60L);								if ((LMGetTicks () - TxStart) != 0)//					cps = ((((txfsize - txpos) * 60L) / (LMGetTicks () - TxStart)) * 1000L) / cur_baud;					cps = (((txpos - txoffset) * 60L) / (LMGetTicks () - TxStart));				else					cps = 0;								newMessage (lTSTAT, "%ld:%ld (%d) [%d min, %ld cps]", txpos, txfsize, txblklen, eta, cps);				putMessage (0, "\p");				break;			}			/* fallthrough to HTX_EOF */			/*---------------------------------------------------------*/		case HTX_EOF://putlog(lgATTN, "HTX_EOF");			h_long1 (txbufin) = intell (txpos);			txpkt ((short) sizeof (long), HPKT_EOF);			txtimer = h_timer_set (txretries ? timeout / 2 : timeout);			txstate = HTX_EOFACK;			break;			/*---------------------------------------------------------*/		case HTX_END://putlog(lgATTN, "HTX_END");			txpkt (0, HPKT_END);			txpkt (0, HPKT_END);			txtimer = h_timer_set (timeout / 2);			txstate = HTX_ENDACK;			break;			/*---------------------------------------------------------*/		default://putlog(lgATTN, "HTX_default");			break;			/*---------------------------------------------------------*/		}		/*----------------------------------------------------------------*/		pkttype = rxpkt ();		/*----------------------------------------------------------*/		switch (pkttype)		{			/*---------------------------------------------------*/		case H_CARRIER:		case H_CANCEL:		case H_SYSABORT:		case H_BRAINTIME:			switch (pkttype)			{			case H_CARRIER://				//putlog(GenericError, &(MSG_TXT (M_NO_CARRIER)[1]));				break;			case H_CANCEL://				//putlog(MSG_TXT (M_SESSION_ABORT));//putlog(lgATTN, "H_CANCEL");				break;			case H_SYSABORT://				//putlog(GenericError, &(MSG_TXT (M_KBD_MSG)[1]));//putlog(lgATTN, "H_SYSABORT");				break;			case H_BRAINTIME://				//putlog(MSG_TXT (M_OTHER_DIED));//putlog(lgATTN, "H_BRAINTIME");				break;			}			txstate = HTX_DONE;			res = XFER_ABORT;			break;			/*---------------------------------------------------*/		case H_TXTIME://putlog(lgATTN, "H_TXTIME");			if (txstate == HTX_XWAIT || txstate == HTX_REND)			{				txpkt (0, HPKT_IDLE);				txtimer = h_timer_set (H_IDLE);				break;			}			if (++txretries > H_RETRIES)			{//				//putlog(MSG_TXT (M_FUBAR_MSG));				txstate = HTX_DONE;				res = XFER_ABORT;				break;			}			putMessage (0, "\pTimeout");//			j_message (Tx_y, MSG_TXT (M_TIMEOUT));#ifdef DEBUG			//putlog('-', "-HSEND: Timeout - Retry %u", txretries);#endif			txtimer = h_timer_reset ();			switch (txstate)			{			case HTX_SWAIT://putlog(lgATTN, "HTX_SWAIT");				txstate = HTX_START;				break;			case HTX_INITACK://putlog(lgATTN, "HTX_INITACK");				txstate = HTX_INIT;				break;			case HTX_FINFOACK://putlog(lgATTN, "HTX_FINFOACK");				txstate = HTX_FINFO;				break;			case HTX_DATAACK://putlog(lgATTN, "HTX_DATAACK");				txstate = HTX_XDATA;				break;			case HTX_EOFACK://putlog(lgATTN, "HTX_EOFACK");				txstate = HTX_EOF;				break;			case HTX_ENDACK://putlog(lgATTN, "HTX_ENDACK");				txstate = HTX_END;				break;			}			break;			/*---------------------------------------------------*/#ifdef HYDRADEV		case H_DEVTXTIME:			if (++devtxretries > H_RETRIES)			{				//putlog(MSG_TXT (M_FUBAR_MSG));				txstate = HTX_DONE;				res = XFER_ABORT;				break;			}			j_message (Tx_y, MSG_TXT (M_TIMEOUT));#ifdef DEBUG			//putlog('-', "-HDEVTX: Timeout - Retry %u", devtxretries);#endif			devtxtimer = h_timer_reset ();			devtxstate = HTD_DATA;			break;#endif			/*---------------------------------------------------*/		case HPKT_START://putlog(lgATTN, "HPKT_START");			if (txstate == HTX_START || txstate == HTX_SWAIT)			{				txtimer = h_timer_reset ();				txretries = 0;				txstate = HTX_INIT;				braindead = h_timer_set (H_BRAINDEAD);			}			break;			/*---------------------------------------------------*/		case HPKT_INIT://putlog(lgATTN, "HPKT_INIT");			if (rxstate == HRX_INIT)			{				p = (char *) rxbuf;				p += ((short) strlen (p)) + 1;				q = p + ((short) strlen (p)) + 1;				rxoptions = options | (HUNN_OPTIONS & ~HOPT_CRC32) | (hiho_can & HOPT_CRC32);				rxoptions |= get_flags (q, h_flags);				putlog ('~', "HPKT_INIT Ye can:  %s", q);//				putlog ('~', "opt< %s", q);				rxoptions &= get_flags (p, h_flags);				putlog ('~', "HPKT_INIT Ye want: %s", p);//				putlog ('~', "opt< %s", p);//				rxoptions &= HCAN_OPTIONS;				rxoptions &= hiho_can;				if (rxoptions < (options & HNEC_OPTIONS))				{//putlog(lgALRT, "!HYDRA: Incompatible on this link");					txstate = HTX_DONE;					res = XFER_ABORT;					break;				}				p = q + ((short) strlen (q)) + 1;				rxwindow = txwindow = 0L;				sscanf (p, "%08lx%08lx", &rxwindow, &txwindow);				if (rxwindow < 0L)					rxwindow = 0L;				if (hydra_rxwindow &&					(!rxwindow || hydra_rxwindow < rxwindow))					rxwindow = hydra_rxwindow;				if (txwindow < 0L)					txwindow = 0L;				if (hydra_txwindow &&					(!txwindow || hydra_txwindow < txwindow))					txwindow = hydra_txwindow;				p += ((short) strlen (p)) + 1;				strncpy (txpktprefix, p, H_PKTPREFIX);				txpktprefix[H_PKTPREFIX] = '\0';				if (!batchesdone)				{					long revstamp;					p = (char *) rxbuf;					sscanf (p, "%08lx", &revstamp);//					//putlog('-', ">HYDRA: Other's HydraRev=%s",//						h_revdate (revstamp));					p += 8;					if ((q = strchr (p, ',')) != NULL)						*q = ' ';					if ((q = strchr (p, ',')) != NULL)						*q = '/';					put_flags ((char *) rxbuf, h_flags, rxoptions);					putlog ('~', "HPKT_INIT RX ???:  %s", (char *) rxbuf);//					putlog('~', "opt< %s", rxbuf);//					if (txwindow || rxwindow)//						//putlog('-', ">HYDRA: Window tx=%ld rx=%ld", txwindow, rxwindow);				}				txoptions = rxoptions;				rxstate = HRX_FINFO;#ifdef HYDRADEV				if (rxoptions & HOPT_DEVICE)				{					p = "Remote has no chat facility available\r\n";					hydra_devsend ("CON", (unsigned char *) p, (short) strlen (p));				}#endif			}			txpkt (0, HPKT_INITACK);			break;			/*---------------------------------------------------*/		case HPKT_INITACK://putlog(lgATTN, "HPKT_INITACK");			if (txstate == HTX_INIT || txstate == HTX_INITACK)			{				braindead = h_timer_set (H_BRAINDEAD);				txtimer = h_timer_reset ();				txretries = 0;				txstate = HTX_RINIT;			}			break;			/*---------------------------------------------------*/		case HPKT_FINFO://putlog(lgATTN, "HPKT_FINFO");			if (rxstate == HRX_FINFO)			{				braindead = h_timer_set (H_BRAINDEAD);				if (!rxbuf[0])				{//					j_msgend (Rx_y);#ifdef DEBUG					//putlog('-', "*HRECV: End of batch");#endif					rxpos = 0L;					rxstate = HRX_DONE;					batchesdone++;				}				else				{					long diskfree;					rxfsize = rxftime = 0L;					rxoldpos = rxoldeta = -1;					rxfname[0] = '\0';					sscanf ((char *) rxbuf, "%08lx%08lx%*08lx%*08lx%*08lx%s",						&rxftime, &rxfsize, rxfname);					if ((strlen ((char *) rxbuf) + 1) < rxpktlen )					{						strcpy ((char *) sptemp, (char *) &rxbuf[strlen ((char *) rxbuf) + 1]);											if (sptemp[0])						{							putlog ('~', "<%s>|<%s>", rxfname, sptemp);							for (p = (char *) sptemp, q = rxfname; *p; p++)							{								if (*q = *p, *p == '\\' || *p == ':' || *p == '/')									q = rxfname;								else									q++;							}							*q = '\0';						}						else						{//							LwrText (rxfname, strlen (rxfname));							putlog ('~', "<%s>|<<empty>>", rxfname);						}					}					else					{//						LwrText (rxfname, strlen (rxfname));						putlog ('~', "<%s>|<<empty>>", rxfname);					}										UxConvertTime (true, (unsigned long *)&rxftime);					if (!xfer_init (rxfname, rxfsize, rxftime))	/* Already have file */					{//						//putlog(MSG_TXT (M_ALREADY_HAVE), rxpathname);						rxpos = -1L;					}					else					{//						diskfree = zfree (rxpathname);//						if (rxfsize + 10240L > diskfree)//						{//							//putlog(MSG_TXT (M_OUT_OF_DISK_SPACE));//							rxpos = -2L;//						}//						else//						{/*¥¥¥¥¥						if (dexists (rxpathname))	// Resuming?							{								if ((rxfd = open (rxpathname, O_RDWR | O_BINARY, 0)) < 0)								{									j_error (MSG_TXT (M_OPEN_MSG), rxpathname);									rxpos = -2L;								}							}							else if ((rxfd = open (rxpathname, O_CREAT | O_RDWR | O_BINARY, S_IREAD | S_IWRITE)) < 0)							{								j_error (MSG_TXT (M_OPEN_MSG), rxpathname);								rxpos = -2L;							}*/							strcpy ((char *)&sptemp[1], rxpathname);							sptemp[0] = strlen (rxpathname);														Create (sptemp, 0, 'RvlM', 'ZMPT');														if (FSOpen (sptemp, 0, &rxfd))							{//								j_error (MSG_TXT (M_OPEN_MSG), rxpathname);								rxfd = -1;								rxpos = -2L;							}							if (rxfd != -1)							{//								p = check_netfile (rxfname);//								//putlog('-', "#%s %s %s", MSG_TXT (M_RECEIVING), (p) ? p : " ", rxfname);//								if (!un_attended || !fullscreen)//									Rx_y = Next_y;//								xfer_summary (MSG_TXT (M_RECV), rxfname, &rxfsize, Rx_y);																//								if (lseek (rxfd, 0L, SEEK_END) < 0L)								if (SetFPos (rxfd, fsFromLEOF, 0L))								{//									(void) j_error (MSG_TXT (M_SEEK_MSG), rxpathname);									hydra_badxfer ();									rxpos = -2L;								}								else								{//									diskfree = zfree (rxpathname);	/*AGL:07jul93*///									rxoffset = rxpos = tell (rxfd);									if (GetFPos (rxfd, &rxpos))										rxpos = -1;																		rxoffset = rxpos;									//									if (rxpos > 0)//										putlog (lgNOPE, "Resume file from %ld", rxpos);																	eta = (short) (((((rxfsize - rxpos) * 10L) / cur_baud * 100L )/ 95L + 59L) / 60L);																putlog(lgNOPE, "H-Receiving: %s (%ldb %d min)", trunc_path(rxfname), rxfsize, eta);								newMessage (lRNAME, "H-Receiving: %s", trunc_path (rxfname));								putMessage (0, "\p");									if (rxpos < 0L)									{//										(void) j_error (MSG_TXT (M_SEEK_MSG), rxfname);										hydra_badxfer ();										rxpos = -2L;									}									else									{//										if ((rxfsize - rxoffset) + 10240L > diskfree)//										{	/*AGL:07jul93*///											//putlog(MSG_TXT (M_OUT_OF_DISK_SPACE));//											hydra_badxfer ();//											rxpos = -2L;//										}//										else//										{								RxStart = LMGetTicks ();																newMessage (lRSTAT, "%ld:%ld (0) [%d min, 0 cps]", rxpos, rxfsize, eta);								putMessage (0, "\p");//											rxstart = 0L;											rxtimer = h_timer_reset ();											rxretries = 0;											rxlastsync = 0L;											rxsyncid = 0L;//											update_status (&rxpos, &rxoldpos, rxfsize - rxpos, &rxoldeta, Rx_y);											if (rxpos > 0L)											{								putlog (lgNOPE, "Resume file from %ld", rxpos);//												//putlog(MSG_TXT (M_SYNCHRONIZING_OFFSET), rxpos);											}											rxstate = HRX_DATA;//										}									}								}							}//						}					}				}			}			else if (rxstate == HRX_DONE)				rxpos = (!rxbuf[0]) ? 0L : -2L;			h_long1 (txbufin) = intell (rxpos);			txpkt ((short) sizeof (long), HPKT_FINFOACK);			break;			/*---------------------------------------------------*/		case HPKT_FINFOACK://putlog(lgATTN, "HPKT_FINFOACK");			if (txstate == HTX_FINFO || txstate == HTX_FINFOACK)			{				braindead = h_timer_set (H_BRAINDEAD);				txretries = 0;				if (!txfname[0])				{					txtimer = h_timer_set (H_IDLE);					txstate = HTX_REND;				}				else				{					txtimer = h_timer_reset ();					txpos = intell (h_long1 (rxbuf));					if (txpos >= 0L)					{						txoffset = txpos;						txlastack = txpos;//						update_status (&txpos, &txoldpos, txfsize - txpos, &txoldeta, Tx_y);						if (txpos > 0L)						{//							//putlog(MSG_TXT (M_SYNCHRONIZING_OFFSET), txpos);							putlog (lgNOPE, "Resume file from %ld", txpos);//							if (lseek (txfd, txpos, SEEK_SET) < 0L)							if (SetFPos (txfd, fsFromStart, txpos))							{//								(void) j_error (MSG_TXT (M_SEEK_MSG), txfname);								FSClose (txfd);								txfd = -1;								txpos = -2L;								txstate = HTX_EOF;								break;							}						}						txstate = HTX_XDATA;					}					else					{						FSClose (txfd);						if (txpos == -1L)						{							putlog (lgNOPE, "Remote refused %s", txfname);//							//putlog(MSG_TXT (M_REMOTE_REFUSED), txfname);							return (XFER_OK);						}						else							/* (txpos < -1L) file NOT sent */						{							putlog (lgNOPE, "Skipping %s", txfname);//							//putlog('-', "+HSEND: Skipping %s", txfname);							return (XFER_SKIP);						}					}				}			}			break;			/*---------------------------------------------------*/		case HPKT_DATA://putlog(lgATTN, "HPKT_DATA");			if (rxstate == HRX_DATA)			{				if (intell (h_long1 (rxbuf)) != rxpos ||					intell (h_long1 (rxbuf)) < 0L)				{					if (intell (h_long1 (rxbuf)) <= rxlastsync)					{						rxtimer = h_timer_reset ();						rxretries = 0;					}					rxlastsync = intell (h_long1 (rxbuf));					if (!h_timer_running (rxtimer) ||						h_timer_expired (rxtimer, h_timer_get ()))					{						if (rxretries > 4)						{							if (txstate < HTX_REND &&								!originator && !hdxlink)							{								hdxlink = TRUE;								rxretries = 0;							}						}						if (++rxretries > H_RETRIES)						{//							//putlog(MSG_TXT (M_FUBAR_MSG));							txstate = HTX_DONE;							res = XFER_ABORT;							break;						}						if (rxretries == 1 || rxretries == 4)	/*AGL:14may93*/							rxsyncid++;						rxblklen /= 2;						i = rxblklen;						if (i <= 64)							i = 64;						else if (i <= 128)							i = 128;						else if (i <= 256)							i = 256;						else if (i <= 512)							i = 512;						else							i = 1024;												putMessage (0, "\pBad packet");						//						j_message (Rx_y, MSG_TXT (M_J_BAD_PACKET), rxpos);#ifdef DEBUG						//putlog('-', "-HRECV: Bad pkt at %ld - Retry %u (newblklen=%u)",						//		rxpos, rxretries, i);#endif						h_long1 (txbufin) = intell (rxpos);						h_long2 (txbufin) = intell ((long) i);						h_long3 (txbufin) = intell (rxsyncid);						txpkt (3 * ((short) sizeof (long)), HPKT_RPOS);						rxtimer = h_timer_set (timeout);					}				}				else				{					braindead = h_timer_set (H_BRAINDEAD);					rxpktlen -= (short) sizeof (long);					rxblklen = rxpktlen;					ioCounter = rxpktlen;//					if (write (rxfd, rxbuf + ((short) sizeof (long)), rxpktlen) < 0)					if (FSWrite (rxfd, &ioCounter, rxbuf + ((short) sizeof (long))))					{//						j_error (MSG_TXT (M_WRITE_MSG), rxfname);						hydra_badxfer ();						rxpos = -2L;						rxretries = 1;						rxsyncid++;						h_long1 (txbufin) = intell (rxpos);						h_long2 (txbufin) = intell (0L);						h_long3 (txbufin) = intell (rxsyncid);						txpkt (3 * ((short) sizeof (long)), HPKT_RPOS);						rxtimer = h_timer_set (timeout);						break;					}					rxretries = 0;					rxtimer = h_timer_reset ();					rxlastsync = rxpos;					rxpos += rxpktlen;					if (rxwindow)					{						h_long1 (txbufin) = intell (rxpos);						txpkt ((short) sizeof (long), HPKT_DATAACK);					}//					if (!rxstart)//						rxstart = LMGetTime () -//							((rxpktlen * 10) / cur_baud);//						rxstart = time (NULL) -//							((rxpktlen * 10) / cur_baud);//					update_status (&rxpos, &rxoldpos, rxfsize - rxpos, &rxoldeta, Rx_y);					eta = (short) (((((rxfsize - rxpos) * 10L) / cur_baud * 100L )/ 95L + 59L) / 60L);					if ((LMGetTicks () - RxStart) != 0)//						cps = ((((rxfsize - rxpos) * 60L) / (LMGetTicks () - RxStart)) * 1000L) / cur_baud;						cps = (((rxpos - rxoffset) * 60L) / (LMGetTicks () - RxStart));					else						cps = 0;					newMessage (lRSTAT, "%ld:%ld (%d) [%d min, %ld cps]", rxpos, rxfsize, rxpktlen, eta, cps);					putMessage (0, "\p");									}				/*badpkt*/			}					/*rxstate==HRX_DATA*/			break;			/*---------------------------------------------------*/		case HPKT_DATAACK://putlog(lgATTN, "HPKT_DATAACK");			if (txstate == HTX_XDATA || txstate == HTX_DATAACK ||				txstate == HTX_XWAIT ||				txstate == HTX_EOF || txstate == HTX_EOFACK)			{				if (txwindow && intell (h_long1 (rxbuf)) > txlastack)				{					txlastack = intell (h_long1 (rxbuf));					if (txstate == HTX_DATAACK &&						(txpos < (txlastack + txwindow)))					{						txstate = HTX_XDATA;						txretries = 0;						txtimer = h_timer_reset ();					}				}			}			break;			/*---------------------------------------------------*/		case HPKT_RPOS://putlog(lgATTN, "HPKT_RPOS");			if (txstate == HTX_XDATA || txstate == HTX_DATAACK ||				txstate == HTX_XWAIT ||				txstate == HTX_EOF || txstate == HTX_EOFACK)			{				if (intell (h_long3 (rxbuf)) != txsyncid)				{					txsyncid = intell (h_long3 (rxbuf));					txretries = 1;				}				else					/*AGL:14may93*/				{					if (++txretries > H_RETRIES)					{//						//putlog(MSG_TXT (M_FUBAR_MSG));						txstate = HTX_DONE;						res = XFER_ABORT;						break;					}					if (txretries != 4)						break;	/*AGL:14may93*/				}				txtimer = h_timer_reset ();				txpos = intell (h_long1 (rxbuf));				if (txpos < 0L)				{					if (txfd >= 0)					{//						//putlog('-', "+HSEND: Skipping %s", txfname);						FSClose (txfd);						txfd = -1;						txstate = HTX_EOF;					}					txpos = -2L;					break;				}				if (txblklen > (unsigned short) intell (h_long2 (rxbuf)))					txblklen = (unsigned short) intell (h_long2 (rxbuf));				else					txblklen >>= 1;				if (txblklen <= 64)					txblklen = 64;				else if (txblklen <= 128)					txblklen = 128;				else if (txblklen <= 256)					txblklen = 256;				else if (txblklen <= 512)					txblklen = 512;				else					txblklen = 1024;				txgoodbytes = 0;				txgoodneeded += txmaxblklen * 2;	/*AGL:23feb93*/				if (txgoodneeded > txmaxblklen * 8)	/*AGL:23feb93*/					txgoodneeded = txmaxblklen * 8;	/*AGL:23feb93*///				update_status (&txpos, &txoldpos, txfsize - txpos, &txoldeta, Tx_y);//				//putlog(MSG_TXT (M_SYNCHRONIZING_OFFSET), txpos);//				putlog (lgNOPE, "Resume file from %ld", txpos);				putMessage (0, "\pResync offset");//				if (lseek (txfd, txpos, SEEK_SET) < 0L)				if (SetFPos (txfd, fsFromStart, txpos))				{//					(void) j_error (MSG_TXT (M_SEEK_MSG), txfname);					FSClose (txfd);					txfd = -1;					txpos = -2L;					txstate = HTX_EOF;					break;				}				if (txstate != HTX_XWAIT)					txstate = HTX_XDATA;			}			break;			/*---------------------------------------------------*/		case HPKT_EOF://putlog(lgATTN, "HPKT_EOF");			if (rxstate == HRX_DATA)			{				if (intell (h_long1 (rxbuf)) < 0L)				{					hydra_badxfer ();//					//putlog('-', "+HRECV: Skipping %s", rxfname);					rxstate = HRX_FINFO;					braindead = h_timer_set (H_BRAINDEAD);				}				else if (intell (h_long1 (rxbuf)) != rxpos)				{					if (intell (h_long1 (rxbuf)) <= rxlastsync)					{						rxtimer = h_timer_reset ();						rxretries = 0;					}					rxlastsync = intell (h_long1 (rxbuf));					if (!h_timer_running (rxtimer) ||						h_timer_expired (rxtimer, h_timer_get ()))					{						if (++rxretries > H_RETRIES)						{//							//putlog(MSG_TXT (M_FUBAR_MSG));							txstate = HTX_DONE;							res = XFER_ABORT;							break;						}						if (rxretries == 1 || rxretries == 4)	/*AGL:14may93*/							rxsyncid++;						rxblklen /= 2;						i = rxblklen;						if (i <= 64)							i = 64;						else if (i <= 128)							i = 128;						else if (i <= 256)							i = 256;						else if (i <= 512)							i = 512;						else							i = 1024;//						//putlog('-', "-HRECV: Bad EOF at %ld - Retry %u (newblklen=%u)",//							rxpos, rxretries, i);						h_long1 (txbufin) = intell (rxpos);						h_long2 (txbufin) = intell ((long) i);						h_long3 (txbufin) = intell (rxsyncid);						txpkt (3 * ((short) sizeof (long)), HPKT_RPOS);						rxtimer = h_timer_set (timeout);					}				}				else				{					long rxtime;					FSClose (rxfd);					rxfd = -1;//					if (Resume_WaZOO)	/* resumed transfer? *///					{//						if (xfer_okay ())//						{//							//putlog(MSG_TXT (M_RENAME_MSG), rxpathname);//						}//					}//					if (rxftime > 0) /* utime doesn't like negative numbers *///					{//						struct utimbuf utimes;////						utimes.UT_ACTIME = rxftime;//						utimes.modtime = rxftime;//						(void) utime (rxpathname, (UTIMBUF *) & utimes);//					}//					rxtime = through (&rxfsize, &rxstart);					rxfsize = rxpos - rxoffset;					if ((LMGetTicks () - RxStart) != 0)//						cps = (((rxfsize * 60L) / (LMGetTicks () - RxStart)) * 1000L) / cur_baud;						cps = ((rxfsize * 60L) / (LMGetTicks () - RxStart));					else						cps = 0;					history_add_traff (false, rxfsize);					putlog(lgNOPE, "Received-H%s %s [%ld cps]", (txoptions & HOPT_CRC32) ? "/32" : "", trunc_path(rxpathname), cps);					newMessage (lRNAME, "");					newMessage (lRSTAT, "");//¥¥¥¥					strcpy ((char *)&sptemp[1], rxpathname);					sptemp[0] = strlen (rxpathname);					switch (rz123 = ResolveExtension (sptemp))					{					case 0:											SetInfoFile (0, 0, sptemp, 'ALFA', 'TEXT', rxftime, rxftime);						break;										case 1:												SetInfoFile (0, 0, sptemp, 'ZIP ', '.PKT', rxftime, rxftime);						gotta_xmail = 1;						break;										case 2:											SetInfoFile (0, 0, sptemp, 'RvlM', '.PKT', rxftime, rxftime);						gotta_mail = 1;						break;								case 3:		//	freq arrived!											thy_request = true;												{							long	eofreq;							short	reqref;							Ptr		ptmp;																					FSOpen (sptemp, 0, &reqref);							GetEOF (reqref, &eofreq);														if (eofreq < 1024)		//	whatta hell req file more than 1K? :-O							{								ptmp = NewPtr (eofreq + 1);								FSRead (reqref, &eofreq, ptmp);								ptmp[eofreq] = 0;								appendrequests (ptmp);							}														FSClose (reqref);							FSDelete (sptemp, 0);						}						break;					default:												if (rz123 < 0)						{							SetInfoFile (0, 0, sptemp, (*pc_exch_pref)[-rz123-1].creator, (*pc_exch_pref)[-rz123-1].type, rxftime, rxftime);						}												break;					}//¥¥¥¥//					//putlog('-', "%s-H%s %s", MSG_TXT (M_FILE_RECEIVED), (txoptions & HOPT_CRC32) ? "/32" : " ", rxpathname);//					j_msgend (Rx_y);//					update_files (0, rxpathname, rxfsize, rxtime, 0);					rxstate = HRX_FINFO;					braindead = h_timer_set (H_BRAINDEAD);				}				/*skip/badeof/eof*/			}					/*rxstate==HRX_DATA*/			if (rxstate == HRX_FINFO)				txpkt (0, HPKT_EOFACK);			break;			/*---------------------------------------------------*/		case HPKT_EOFACK://putlog(lgATTN, "HPKT_EOFACK");			if (txstate == HTX_EOF || txstate == HTX_EOFACK)			{				braindead = h_timer_set (H_BRAINDEAD);				if (txfd >= 0)				{					long txtime;					FSClose (txfd);					txfsize = txpos - txoffset;//					txtime = through (&txfsize, &txstart);					if ((LMGetTicks () - TxStart) != 0)//						cps = (((txfsize * 60L) / (LMGetTicks () - TxStart)) * 1000L) / cur_baud;						cps = ((txfsize * 60L) / (LMGetTicks () - TxStart));					else						cps = 0;					history_add_traff (true, txfsize);					putlog(lgNOPE, "Sent-H%s %s [%ld cps]", (txoptions & HOPT_CRC32) ? "/32" : "", trunc_path (txpathname), cps);					newMessage (lTNAME, "");					newMessage (lTSTAT, "");//					j_msgend (Tx_y);//					update_files (1, txpathname, txfsize, txtime, 0);					return (XFER_OK);				}				else					return (XFER_SKIP);			}			break;			/*---------------------------------------------------*/		case HPKT_IDLE://putlog(lgATTN, "HPKT_IDLE");			if (txstate == HTX_XWAIT)			{				hdxlink = FALSE;				txtimer = h_timer_reset ();				txretries = 0;				txstate = HTX_XDATA;			}			else if (txstate >= HTX_FINFO && txstate < HTX_REND)				braindead = h_timer_set (H_BRAINDEAD);			break;			/*---------------------------------------------------*/		case HPKT_END://putlog(lgATTN, "HPKT_END");			if (txstate == HTX_END || txstate == HTX_ENDACK)			{				txpkt (0, HPKT_END);				txpkt (0, HPKT_END);				txpkt (0, HPKT_END);#ifdef DEBUG				//putlog('-', "+HYDRA: Completed");#endif				txstate = HTX_DONE;				res = XFER_OK;			}			break;#ifdef HYDRADEV			/*---------------------------------------------------*/		case HPKT_DEVDATA:			if (devrxid != intell (h_long1 (rxbuf)))			{				hydra_devrecv ();				devrxid = intell (h_long1 (rxbuf));			}			h_long1 (txbufin) = h_long1 (rxbuf);	/*AGL:10feb93*/			txpkt ((short) sizeof (long), HPKT_DEVDACK);			break;			/*---------------------------------------------------*/		case HPKT_DEVDACK:			if (devtxstate && (devtxid == intell (h_long1 (rxbuf))))			{				devtxtimer = h_timer_reset ();				devtxstate = HTD_DONE;			}			break;#endif			/*---------------------------------------------------*/		default:				/* unknown packet types: IGNORE, no error! */			break;			/*---------------------------------------------------*/		}						/*(pkttype)*/		/*------------------------------------------------------*/		switch (txstate)		{			/*---------------------------------------------------*/		case HTX_START://putlog(lgATTN, "HTX_START");		case HTX_SWAIT://putlog(lgATTN, "HTX_SWAIT");			if (rxstate == HRX_FINFO)			{				txtimer = h_timer_reset ();				txretries = 0;				txstate = HTX_INIT;			}			break;			/*---------------------------------------------------*/		case HTX_RINIT://putlog(lgATTN, "HTX_RINIT");			if (rxstate == HRX_FINFO)			{				txtimer = h_timer_reset ();				txretries = 0;				txstate = HTX_FINFO;			}			break;			/*---------------------------------------------------*/		case HTX_XDATA://putlog(lgATTN, "HTX_XDATA");			if (rxstate && hdxlink)			{//				//putlog(MSG_TXT (M_GOING_ONE_WAY));#ifdef HYDRADEV				hydra_devsend ("MSG", (unsigned char *) hdxmsg, (short) strlen (hdxmsg));#endif				txtimer = h_timer_set (H_IDLE);				txstate = HTX_XWAIT;			}			break;			/*---------------------------------------------------*/		case HTX_XWAIT://putlog(lgATTN, "HTX_XWAIT");			if (!rxstate)			{				txtimer = h_timer_reset ();				txretries = 0;				txstate = HTX_XDATA;			}			break;			/*---------------------------------------------------*/		case HTX_REND://putlog(lgATTN, "HTX_REND");#ifdef HYDRADEV			if (!rxstate && !devtxstate)#else			if (!rxstate)#endif			{				txtimer = h_timer_reset ();				txretries = 0;				txstate = HTX_END;			}			break;			/*---------------------------------------------------*/		default:				/* any other state - nothing to do */			break;		}						/*switch(txstate)*/	}	while (txstate);	if (txfd >= 0)		FSClose (txfd);	hydra_badxfer ();	if (res == XFER_ABORT)	{//putlog(lgATTN, "!XFER_ABORT");		CLEAR_OUTBOUND ();		if (remote_capabilities)			LOWER_DTR ();		if (CARRIER)		{			braindead = h_timer_set (10);	/* wait max. 10s after abort */			//			ComTXBlockTimeout (abortstr, (short) strlen (abortstr), braindead);			SENDCHARS ((unsigned char *)abortstr, (long) strlen (abortstr), braindead);						while (!OUT_EMPTY () && CARRIER && !h_timer_expired (braindead, h_timer_get ()))				time_release ();			CLEAR_OUTBOUND ();		}		CLEAR_INBOUND ();//		mail_finished = 0;		Aborted = true;	}	else	{		braindead = h_timer_set (10);	/* wait max. 10s after abort */		while (!OUT_EMPTY () && CARRIER && !h_timer_expired (braindead, h_timer_get ()))			time_release ();	}	return (res);}								/*hydra()*//* end of hydra.c */