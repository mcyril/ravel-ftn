#include <CommResources.h>#include <CRMSerialDevices.h>#include <Connections.h>#include <CTBUtilities.h>#include <Sound.h>#include <stdio.h>#include <Serial.h>#include <string.h>#include <stdarg.h>#include <AppleEvents.h>#include <Icons.h>#include "PopList.h"#include "Main.h"//#include "Port.h"#include "Comm.h"#include "PascalStr.h"#include "Modem.h"//#include "ZMisc.h"#include "Session.h"#include "Timing.h"#include "compatible.h"#include "zfiles.h"#include "log.h"#include "Ravel_FTN.h"#include "Ravel_Prefs.h"#include "ascii.h"#include "Scheduler.h"#include "Unattended.h"#include "Manual.h"#include "pmain.h"#include "stringutl.h"#include "MenuItems.h"#include "visual.h"#include "nodelist.h"#include "myEnv.h"#include "Pathes.h"#include "NodeCookie.h"#include "freq.h"#include "do_about.h"#include "history.h"#include "key.h"Boolean			gAppearance = false;in_outboundPtr	outbound;in_outboundPtr	cur_over;manual_chainPtr	manual_outbound;short			outbound_slice;short			current_link;short			links_count;short			VMPresent;DialogPtr		RavelWindow;ListHandle		RavelList, IHSList, OHSList;Options			Settings;				/* Current options */Configuration	Config;					/* Configuration parameters */Boolean			DTR;Str255			Pathes[6];Str255			init_string;//	extern short cur_baud;//	extern short zretries;short	no_EMSI;						/* Global EMSI disable */short	no_WaZOO;						/* Global WaZOO/YooHoo disable */short	auto_scan;						/* auto toss sublaunch enable */short	auto_toss;						/* auto toss sublaunch enable *///extern	short		ZMAXSPLEN;			//	tuning now!extern	char		YesZedZip;extern	char		YesZedZap;extern	char		YesDirZap;extern	char		YesJanus;extern	char		YesHydra;extern	char		YesxHydra;extern	char		YesHydra8K;extern	char		YesHydra16K;extern	char		YesClasp;extern	short		CONNECTION;			//	connection mode == port number or -1 for CTBextern	Boolean		BUSY;			/* Processing send operation */extern	ADDR	remote_addr;extern	short	no_sealink;//extern	short		Transfer;			/* File transfer in progress */extern	Boolean		Sending;		Boolean		SessionActive;//		Boolean		EventsPossible;		Boolean		Background;		Boolean		Aborted;		long		gSleepTime = 6;		Boolean		force_answer;		// Answer menu item was selected.		short		delaing;		short	gotta_mail;				// nemail received		short	gotta_xmail;			// arcmail received		short	FLAG;		MenuHandle		nodeAddrs;extern	short			NodesNumber;		//	•	Linked Nodes structs listextern	nodePrefHndl	*nodesHndls;extern	homeHndl		homesystem;			//	•	Home system struct		Boolean	multiline_flag = false;		short	multiline_line = 0;extern	Str255			ShufflerPathName;extern	long			accept_calls_mask;#define FAILURE   0#define IGNORE    1#define CONNECTED 2#define RINGING   3#define INCOMING  4//	n*60 == n sec#define DTRSLICE			18000L//#define UNATTENDEDSLICE		1800Lextern	long	UNATTENDEDSLICE;extern	long	fUNATTENDEDSLICE;extern	long	current_events;long	dtrslice;long	unattendedslice;static	Boolean	gQuit;static	Boolean	gRemindAsked;//	static DateTimeRec	ZTimeDestruct = { 1996, 10, 3, 0, 0, 0, 0 };//	static unsigned long	TimeDestructSec = 0xAEEF5980L ^ 0xFAFAFAFAL;static	UniversalProcPtr	uupMyHandleQuit, uupMyHandleDie, uupMyHandleRemind, uupMyHandleRescan;enum {	uppAEHandlerProcInfo = kPascalStackBased		 | RESULT_SIZE(SIZE_CODE(sizeof(OSErr)))		 | STACK_ROUTINE_PARAMETER(1, SIZE_CODE(sizeof(Ptr)))		 | STACK_ROUTINE_PARAMETER(2, SIZE_CODE(sizeof(Ptr)))		 | STACK_ROUTINE_PARAMETER(3, SIZE_CODE(sizeof(long))),//	pascal Boolean myAlertProc (DialogPtr theDialog, EventRecord *theEvent, short *itemHit)	uppModalProcInfo = kPascalStackBased		 | RESULT_SIZE(SIZE_CODE(sizeof(Boolean)))		 | STACK_ROUTINE_PARAMETER(1, SIZE_CODE(sizeof(Ptr)))		 | STACK_ROUTINE_PARAMETER(2, SIZE_CODE(sizeof(Ptr)))		 | STACK_ROUTINE_PARAMETER(3, SIZE_CODE(sizeof(Ptr))),};#define	kRavelEventClass	'R&vl'#define	kAEEnqueueCmd		'enQu'#define	kAENotifyQuill		'ntQu'#define	kAEScanComplete		'scQu'#define	kAEAskRemind		'rmQu'#define	kAERescan			'rsQu'static	RGBColor	barcolor = {10000, 10000, 65535};const RGBColor	Color_PlatinumDimText		= { 29555, 29555, 29555 };const RGBColor	Color_PlatinumMediumGray	= { 57054, 57054, 57054 };const RGBColor	Color_PlatinumLightGray		= { 61423, 61423, 61423 };const RGBColor	Color_BarDeepBlue			= { 10000, 10000, 65535 };const RGBColor	Color_BarDarkBlue			= { 5000,   5000, 30000 };const RGBColor	Color_BarBorder				= { 10000, 10000, 10000 };const RGBColor	Color_White					= { 65535, 65535, 65535 };void	PopListDestruct (ListHandle list);void	DrawEmbossedRect (const Rect *iRect);static	UniversalProcPtr	uupLDEFHistProc;static pascal void LDEFHist (short lMessage, Boolean lSelect, Rect *lRect, Cell lCell,				short lDataOffset, short lDataLen, ListHandle lHandle){#pragma unused (lCell)	short 		leftDraw, topDraw;	//, k, locked;	FontInfo 	fi;//	long		i, j;//	pktmsg		*m;	Point		drawpt;	char		tmp[128], temp[64];//	long		lr, nm;//	Boolean		yeah;		p_hist_rec	histor_rec_ptr;	DateTimeRec	dtr;		if ((lMessage == lInitMsg) || (lMessage == lCloseMsg))		return;		leftDraw = lRect->left+(*lHandle)->indent.h;	topDraw = lRect->top+(*lHandle)->indent.v;		switch (lMessage)	{	case lDrawMsg:			SetPort ((*lHandle)->port);			if (lDataLen == sizeof (p_hist_rec))		{			short	oldTx = ((*lHandle)->port)->txFont;					TextFont (3);			GetFontInfo (&fi);			SetPt ( &drawpt, leftDraw, topDraw+fi.leading+fi.ascent );			memcpy ( (Ptr) &histor_rec_ptr, *((*lHandle)->cells)+lDataOffset, 4 );						EraseRect (lRect);			MoveTo (drawpt.h + 1, drawpt.v);			sprintf (tmp, "%s", printaddr (&histor_rec_ptr->operate, temp));			TextFace (bold);			DrawText (tmp, 0, strlen (tmp));					TextFont (1);			TextFace (0);			drawpt.v += fi.leading+fi.ascent+fi.descent;			MoveTo (drawpt.h + 1, drawpt.v);			SecondsToDate (histor_rec_ptr->time_start, &dtr);			sprintf (tmp, "%.2d/%.2d/%.2d %.2d:%.2d (%.2ld:%.2ld)",				dtr.day, dtr.month, dtr.year%100, dtr.hour, dtr.minute,				(long) (histor_rec_ptr->time_sess / 60L),				(long) (histor_rec_ptr->time_sess % 60L));						DrawText (tmp, 0, strlen (tmp));			drawpt.v += fi.leading+fi.ascent+fi.descent;			MoveTo (drawpt.h + 1, drawpt.v);			sprintf (tmp, "%ld%c/%ld%c/%ld%c",					(histor_rec_ptr->was_sent > 1023) ? histor_rec_ptr->was_sent / 1024 : histor_rec_ptr->was_sent,					(histor_rec_ptr->was_sent > 1023) ? 'K' : 'b',					(histor_rec_ptr->was_received > 1023) ? histor_rec_ptr->was_received / 1024 : histor_rec_ptr->was_received,					(histor_rec_ptr->was_received > 1023) ? 'K' : 'b',					(histor_rec_ptr->was_requested > 1023) ? histor_rec_ptr->was_requested / 1024 : histor_rec_ptr->was_requested,					(histor_rec_ptr->was_requested > 1023) ? 'K' : 'b');			DrawText (tmp, 0, strlen (tmp));						TextFont (oldTx);		}		else			EraseRect (lRect);		if (!lSelect)			break;			case lHiliteMsg:	//		BitClr ( (Ptr) 0x0938, pHiliteBit);//		InvertRect (lRect);		break;	}}void PopListDestruct (ListHandle list){	short	i;	Cell	theCell;		for (i=0; i<(*list)->dataBounds.bottom; i++)	{		SetPt ( &theCell, 0, i );		PopListDelCell (theCell, list);	}		LDelRow (0, 0, list);}static short isPressed (unsigned short k){	unsigned char km[16];	GetKeys ((unsigned long *)km);	return ( ( km[k>>3] >> (k & 7) ) & 1);}void InitToolbox(){	MaxApplZone ();	MoreMasters ();	MoreMasters ();	MoreMasters ();	MoreMasters ();	InitGraf ((Ptr) &qd.thePort);	InitFonts ();	InitWindows ();	InitMenus ();	FlushEvents (everyEvent,0);	InitCRM ();	InitCM ();		InitDialogs (0L);	InitCursor ();		SetEventMask(everyEvent);}void main (){	Str255		mailername;	Handle		htmp;	short		i;	OSErr		err;	long		result;	char		sss[128];	short			iType;	Handle			iHandle;	Rect			iRect;	InitToolbox();#ifndef LITE	pStrCopy (LMGetCurApName (), mailername);	if (mailername[mailername[0]-1] == '#')	{		multiline_flag = true;		multiline_line = mailername[mailername[0]] - '0';	}#endif		if (!ReadPreference ())	{		SysBeep (10);		ExitToShell ();	}//	EventsPossible = true;		err = Gestalt( gestaltAppearanceAttr, &result );	if ( err == noErr )		gAppearance = true;	if (!gAppearance)		RavelWindow = GetNewDialog ( 1024, NULL, (WindowPtr) -1L );	else	{		RavelWindow = GetNewDialog ( 1025, NULL, (WindowPtr) -1L );		for (i=0; i<4; i++)		{			GetDialogItem (RavelWindow, 20+i, &iType, &iHandle, &iRect);			iHandle = (Handle)NewControl (RavelWindow, &iRect, "\p", true, 0, 0, 100, (5 << 4) + 0, 0);			SetDialogItem (RavelWindow, 20+i, kResourceControlDialogItem, iHandle, &iRect);			HideControl ((ControlHandle)iHandle);		}	}#ifndef LITE	if (multiline_flag)	{		pStrCopy ("\pRavelMAIL/Line #0", mailername);		mailername[mailername[0]] += multiline_line;		SetWTitle (RavelWindow, mailername);	}	else#endif		SetWTitle (RavelWindow, "\pRavelMAIL");		htmp = Get1Resource ( 'WLOC', 128 );	if (htmp)	{		if (PtInRect (*(Point*)(*htmp), &(*LMGetGrayRgn ())->rgnBBox))			MoveWindow ( RavelWindow, ((Point*)(*htmp))->h, ((Point*)(*htmp))->v, true );		ReleaseResource (htmp);	}		ShowWindow (RavelWindow);		htmp = Get1Resource ( 'LDEF', 129 );#if defined(powerc) || defined(__powerc)	uupLDEFHistProc = NewRoutineDescriptor ((ProcPtr) LDEFHist, uppListDefProcInfo, GetCurrentISA ());	*((long *)((*htmp)+2)) = (long) uupLDEFHistProc;#else	*((long *)((*htmp)+2)) = (long) LDEFHist;#endif	openlog ();		if (multiline_flag)		sprintf (sss, "; Line #%d%s", multiline_line, (Settings.portName[0] == -1) ? " (IP)" : "");	else		if (Settings.portName[0] == -1)			strcpy (sss, " (IP)");		else			sss[0] = 0;		#ifndef LITE	putlog (lgNOPE, "Begin, " MAILERNAME " " RAVELVERS " " RAVELISA " " RAVELBUILD "%s", sss);#else	putlog (lgNOPE, "Begin, " MAILERNAME " " RAVELVERS " " RAVELBUILD "%s", sss);#endif	if (Gestalt (gestaltVMAttr, &result) == noErr)	{		if (result)			VMPresent = true;		else			VMPresent = false;	}	else		VMPresent = false;		putlog (lgNOPE, "VM is %s", (VMPresent) ? "On" : "Off");		putlog ( '+', "FTS-0001%s%s.",				(!no_WaZOO) ? "/WaZOO" : "",				(!no_EMSI) ? "/EMSI" : "");		strcpy (sss, "Telink");	strcat (sss, (!no_sealink) ? "/SEAlink" : "");	strcat (sss, (YesZedZip) ? "/ZedZip" : "");	strcat (sss, (YesZedZap) ? "/ZedZap" : "");	strcat (sss, (YesDirZap) ? "/DirZap" : "");#ifndef LITE	strcat (sss, (YesJanus) ? "/Janus" : "");		if (YesHydra)	{		strcat (sss, "/");		strcat (sss, (YesxHydra) ? "x" : "");		strcat (sss, "Hydra");			if (YesHydra16K)			strcat (sss, "(16K)");		else			if (YesHydra8K)				strcat (sss, "(8K)");	}#endif	strcat (sss, (YesClasp) ? "/Clasp" : "");	putlog ( '+', "%s.", sss);	if (!OpenSerial (Settings.portName, Settings.portSetup, Settings.handshake))	{		putlog ( lgALRT, "SerialOpen fault" );		closelog ();		ExitToShell ();	}		switch (ResolveExtensionInit ())	{	case 0:	putlog ('+', "No file mapping");					break;	case 1:	putlog ('+', "Using PCExchange for file mapping");	break;	case 2:	putlog ('+', "Using InternetConfig file mapping");	break;	}		ReadNodeList ();	/* ZModem options */	Settings.ZEscapeCtl = FALSE;	Settings.ZTimeout = 600;//	Settings.ZBuffer = ZMAXSPLEN;//	Settings.ZRetries = (zretries) ? zretries : 64;	Settings.ZPacket = 1024;	Settings.ZWindow = 0;	Settings.Zcrcq = 0;	Settings.textCreator = 'ALFA';		/* TEXT file creator */	Settings.binType = '.PKT';			/* Non-MacBinary file type */	Settings.binCreator = 'RvlM';		/* Non-MacBinary file creator */	Settings.volume = 0;				/* Volume reference (down- & uploads) */	Settings.directory = 0;				/* Directory id (down- & uploads) */		/*	if ( !InitializeBuffer () )	{		putlog (lgALRT, "Can't initialize buffer for ZModem");		closelog ();		ExitToShell ();	}*/	StartAll ();	}void putMessage (short line, StringPtr msg){#pragma unused (line)	short			iType;	Handle			iHandle;	Rect			iRect;//	GetDialogItem ( RavelWindow, line+2, &iType, &iHandle, &iRect );	GetDialogItem ( RavelWindow, 6, &iType, &iHandle, &iRect );	SetDialogItemText ( iHandle, (msg[0]) ? msg : (CheckEventNow (accept_calls_mask)) ? "\pWaiting for call…" : "\pIdle…" );}static void ShowAction (short active){	short		iType;	CIconHandle	iHandle;	Rect		iRect;	GrafPtr		oldGraf;			GetPort (&oldGraf);	SetPort (RavelWindow);	GetDialogItem ( RavelWindow, 1, &iType, (Handle *) &iHandle, &iRect );	if (active)		EraseRect (&iRect);	else	{		iHandle = GetCIcon (128);		PlotCIcon (&iRect, iHandle);		DisposeCIcon (iHandle);	}		SetPort (oldGraf);}void newMessage (short line, char *msg, ...){	short			iType;	Handle			iHandle;	Rect			iRect;	Str255			tmp;	va_list			va;	char			t[1024];		va_start ( va, msg );	vsprintf ( t, msg, va );	va_end ( va );	strncpy ((char *)&tmp[1], t, 230);	tmp[0] = strlen ((char *)&tmp[1]);		GetDialogItem ( RavelWindow, line+2, &iType, &iHandle, &iRect );	SetDialogItemText ( iHandle, tmp );}void DrawEmbossedRect (const Rect *iRect){	RGBColor	oldFore;	Rect		theRect = *iRect;			GetForeColor (&oldFore);	RGBForeColor(&Color_BarBorder);	FrameRect (&theRect);	InsetRect (&theRect, 1, 1);		RGBForeColor(&Color_PlatinumDimText);	MoveTo (theRect.left, theRect.bottom);	LineTo (theRect.left, theRect.top);	LineTo (theRect.right-1, theRect.top);		RGBForeColor(&Color_PlatinumMediumGray);	MoveTo (theRect.right-1, theRect.top+1);	LineTo (theRect.right-1, theRect.bottom-1);	LineTo (theRect.left+1, theRect.bottom-1);	RGBForeColor (&oldFore);}static void DrawEmbossedBar (const Rect *iRect, float ratio){	RGBColor	oldFore;	Rect		theRect = *iRect, vRect;	Str255		str;			GetForeColor (&oldFore);	InsetRect (&theRect, 2, 2);	vRect = theRect;		vRect.right = vRect.left+(vRect.right-vRect.left)*ratio;	RGBForeColor(&Color_BarDeepBlue);	FrameRect (&vRect);	RGBForeColor(&Color_BarDarkBlue);	InsetRect (&vRect, 1, 1);	FillRect (&vRect, &qd.black);	vRect.left = vRect.right+1;	vRect.right = theRect.right;	vRect.top = theRect.top;	vRect.bottom = theRect.bottom;	EraseRect (&vRect);		RGBForeColor(&Color_PlatinumDimText);	TextMode (srcOr);	TextFace (bold);	TextSize (9);	NumToString (ratio*100, str);	str[str[0]+1] = '%';	str[0]++;	MoveTo (theRect.left+(theRect.right-theRect.left)/2-StringWidth (str)/2, theRect.bottom-2);	DrawString (str);	TextFace (0);	TextMode (srcCopy);	RGBForeColor (&oldFore);}static void DrawEmbossedOval (const Rect *iRect){	RGBColor	oldFore;	Rect		theRect = *iRect;			GetForeColor (&oldFore);	RGBForeColor(&Color_BarBorder);	FrameOval (&theRect);	InsetRect (&theRect, 1, 1);		RGBForeColor(&Color_PlatinumDimText);	FrameArc (&theRect, 230, 170);	RGBForeColor(&Color_PlatinumMediumGray);	FrameArc (&theRect, 90, 90);	RGBForeColor (&oldFore);}static void DrawEmbossedSect (const Rect *iRect, float ratio){	short		value;	RGBColor	oldFore;	Rect		theRect = *iRect;	//	, vRect;	Str255		str;//	float		ytn, xtn;	GetForeColor (&oldFore);	InsetRect (&theRect, 2, 2);	value = 360*ratio;	RGBForeColor(&Color_BarDeepBlue);	FrameArc (&theRect, 0, value);	RGBForeColor(&Color_BarDarkBlue);	InsetRect (&theRect, 1, 1);	PaintArc (&theRect, 0, value);		InsetRect (&theRect, -1, -1);	EraseArc (&theRect, value, 360-value);	RGBForeColor(&Color_PlatinumDimText);	TextMode (srcOr);	TextFace (bold);	TextSize (9);	NumToString (ratio*100, str);	str[str[0]+1] = '%';	str[0]++;	MoveTo (theRect.left+(theRect.right-theRect.left)/2-StringWidth (str)/2,		theRect.top+(theRect.bottom-theRect.top)/2+4);	DrawString (str);	TextFace (0);	TextMode (srcCopy);	RGBForeColor (&oldFore);}//	pos = -1 init//	pos = total = 0 redrawvoid drawProgressBar (short line, long pos, long total){static	long	_total[2] = {0,0};static	long	_pos[2] = {0,0};static	float	_limit[2] = {0.0,0.0};static	float	_ratio[2] = {1.0,1.0};static	Boolean	_inited[2] = {false,false};	short			iType;	Handle			iHandle, iHandle2;	Rect			iRect;	Str255			str;	GetDialogItem (RavelWindow, line, &iType, &iHandle, &iRect);	if (pos < 0)	{		_total[line-20] = total;		_pos[line-20] = 0;				_limit[line-20] = ((float)(iRect.right - iRect.left - 4))/total;		_inited[line-20] = (total) ? true : false;	}	else		if (pos != 0)			_pos[line-20] = pos;	if (!gAppearance)	{		EraseRect (&iRect);		if (!_inited[line-20])			return;		DrawEmbossedRect (&iRect);		DrawEmbossedBar (&iRect, ((float)_pos[line-20])/_total[line-20]);	}	else	{		GetDialogItem (RavelWindow, line+5, &iType, &iHandle2, &iRect);		if ((*(ControlHandle)iHandle)->contrlVis == 255 && !_inited[line-20])		{			HideControl ((ControlHandle)iHandle);			SetDialogItemText (iHandle2, "\p");			return;		}		else			if ((*(ControlHandle)iHandle)->contrlVis != 255 && !_inited[line-20])				return;			else				if ((*(ControlHandle)iHandle)->contrlVis != 255 && _inited[line-20])				{					if (_total[line-20] > 32000)						_ratio[line-20] = 32000.0 / _total[line-20];					else						_ratio[line-20] = 1.0;										SetControlMinimum ((ControlHandle)iHandle, 0);					SetControlMaximum ((ControlHandle)iHandle, _ratio[line-20] * _total[line-20]);					SetControlValue ((ControlHandle)iHandle, _ratio[line-20] * _pos[line-20]);					ShowControl ((ControlHandle)iHandle);				}				else					SetControlValue ((ControlHandle)iHandle, _ratio[line-20] * _pos[line-20]);		NumToString ((((float)_pos[line-20])/_total[line-20])*100, str);		str[str[0]+1] = '%';		str[0]++;		SetDialogItemText (iHandle2, str);	}}//	pos = -1 init//	pos = total = 0 redrawvoid drawProgressCircle (short line, long pos, long total){static	long	_total[2] = {0,0};static	long	_pos[2] = {0,0};static	float	_limit[2] = {0.0,0.0};static	float	_ratio[2] = {1.0,1.0};static	Boolean	_inited[2] = {false,false};	short			iType;	Handle			iHandle, iHandle2;	Rect			iRect;	Str255			str;	long			theValue, theMaximum;	GetDialogItem (RavelWindow, line, &iType, &iHandle, &iRect);	if (pos < 0)	{		_total[line-22] = total;		_pos[line-22] = 0;				_limit[line-22] = 360.0/total;				_inited[line-22] = (total) ? true : false;	}	else		if (pos != 0)			_pos[line-22] += pos;	if (!gAppearance)	{		EraseRect (&iRect);				if (!_inited[line-22])			return;				DrawEmbossedOval (&iRect);		DrawEmbossedSect (&iRect, ((float)_pos[line-22])/_total[line-22]);	}	else	{		GetDialogItem (RavelWindow, line+5, &iType, &iHandle2, &iRect);		if ((*(ControlHandle)iHandle)->contrlVis == 255 && !_inited[line-22])		{			HideControl ((ControlHandle)iHandle);			SetDialogItemText (iHandle2, "\p");			return;		}		else			if ((*(ControlHandle)iHandle)->contrlVis != 255 && !_inited[line-22])				return;			else				if ((*(ControlHandle)iHandle)->contrlVis != 255 && _inited[line-22])				{					if (_total[line-22] > 32000)						_ratio[line-22] = 32000.0 / _total[line-22];					else						_ratio[line-22] = 1.0;										SetControlMinimum ((ControlHandle)iHandle, 0);					theMaximum = _ratio[line-22] * _total[line-22];					SetControlMaximum ((ControlHandle)iHandle, theMaximum);					theValue = _ratio[line-22] * _pos[line-22];					if (theValue > theMaximum)						theValue = theMaximum;					SetControlValue ((ControlHandle)iHandle, theValue);					ShowControl ((ControlHandle)iHandle);				}				else				{					theMaximum = _ratio[line-22] * _total[line-22];					theValue = _ratio[line-22] * _pos[line-22];					if (theValue > theMaximum)						theValue = theMaximum;					SetControlValue ((ControlHandle)iHandle, theValue);				}				theValue = (((float)_pos[line-22])/_total[line-22])*100;		if (theValue > 100)			theValue = 100;		NumToString (theValue , str);		str[str[0]+1] = '%';		str[0]++;		SetDialogItemText (iHandle2, str);	}}static void NextOutbound (void){	Cell			theCell;	if (outbound)	{		//	•	delight current outbound selection…		SetPt ( &theCell, 0, current_link );		LSetSelect ( FALSE, theCell, RavelList );				if ( !(cur_over = cur_over->next) )			cur_over = outbound;		current_link++;		if (current_link >= links_count)			current_link = 0;			//	•	light current outbound selection…		SetPt ( &theCell, 0, current_link );		LSetSelect ( TRUE, theCell, RavelList );		LAutoScroll (RavelList);	}	unattendedslice = timerset (UNATTENDEDSLICE);}static void PrevOutbound (void){	Cell			theCell;	in_outboundPtr	over;	if (outbound)	{		//	•	delight current outbound selection…		SetPt ( &theCell, 0, current_link );		LSetSelect ( FALSE, theCell, RavelList );		if (cur_over == outbound)		{	//	•	Prev is last			cur_over = outbound;			current_link = 0;						while (cur_over->next)			{				cur_over = cur_over->next;				current_link++;			}		}		else		{			over = cur_over;						do {								if ( !(cur_over = cur_over->next) )					cur_over = outbound;				current_link++;				if (current_link >= links_count)					current_link = 0;							} while (cur_over->next != over);		}			//	•	light current outbound selection…		SetPt ( &theCell, 0, current_link );		LSetSelect ( TRUE, theCell, RavelList );		LAutoScroll (RavelList);	}	unattendedslice = timerset (UNATTENDEDSLICE);}static void SyncNextOutbound (void){	Cell			theCell;	in_outboundPtr	over;	long			slice = UNATTENDEDSLICE;	if (outbound)	{		//	•	delight current outbound selection…		if (!cur_over->force)		{			SetPt ( &theCell, 0, current_link );			LSetSelect ( FALSE, theCell, RavelList );				over = cur_over;						do {							if ( !(cur_over = cur_over->next) )					cur_over = outbound;						current_link++;				if (current_link >= links_count)					current_link = 0;								if ((cur_over->poll & (CRASH | DIRECT)) != 0 && cur_over->callphone[0] != 0)					break;						} while ( cur_over != over );					//	•	light current outbound selection…				SetPt ( &theCell, 0, current_link );			LSetSelect ( TRUE, theCell, RavelList );			LAutoScroll (RavelList);		}		else			slice = fUNATTENDEDSLICE;	}	unattendedslice = timerset (slice);}static void AdjustMenus (void){	MenuHandle		menu;	Boolean			canoperate = false;	Cell			theCell;		SetPt ( &theCell, 0, 0 );	if ( LGetSelect ( 1, &theCell, RavelList) )		canoperate = true;		menu = GetMenuHandle (MENU_APPLE);			//	•••	About	if (SessionActive || delaing)	{		DisableItem (menu, ITEM_ABOUT);	}	else	{		EnableItem (menu, ITEM_ABOUT);	}	menu = GetMenuHandle (MENU_FILE);			//	•••	File	if (SessionActive || delaing)	{		DisableItem (menu, ITEM_ATTACH);		DisableItem (menu, ITEM_REQUEST);		DisableItem (menu, ITEM_QUIT);	}	else	{		if (canoperate)		{			EnableItem (menu, ITEM_ATTACH);			EnableItem (menu, ITEM_REQUEST);		}		else		{			DisableItem (menu, ITEM_ATTACH);			DisableItem (menu, ITEM_REQUEST);		}		EnableItem (menu, ITEM_QUIT);	}	menu = GetMenuHandle (MENU_EDIT);			//	•••	Edit	if (SessionActive || delaing)	{		DisableItem (menu, ITEM_CLEAR);	}	else	{		EnableItem (menu, ITEM_CLEAR);	}	menu = GetMenuHandle (MENU_SESSION);		//	•••	Session	if (SessionActive || delaing)	{		DisableItem (menu, ITEM_NEWPOLL);		DisableItem (menu, ITEM_POLL);		DisableItem (menu, ITEM_RESCAN);		DisableItem (menu, ITEM_FLAVOR);		DisableItem (menu, ITEM_ANSWER);		DisableItem (menu, ITEM_WHOIS);		DisableItem (menu, ITEM_BROWSE);		//		if (delaing)//			DisableItem (menu, ITEM_CANCEL);//		else//			EnableItem (menu, ITEM_CANCEL);	}	else	{		EnableItem (menu, ITEM_NEWPOLL);		if (canoperate)		{			EnableItem (menu, ITEM_POLL);			EnableItem (menu, ITEM_FLAVOR);		}		else		{			DisableItem (menu, ITEM_POLL);			DisableItem (menu, ITEM_FLAVOR);		}		EnableItem (menu, ITEM_RESCAN);				if (CONNECTION != -2)			EnableItem (menu, ITEM_ANSWER);		else			DisableItem (menu, ITEM_ANSWER);				if (yep ())		{			if (canoperate)				EnableItem (menu, ITEM_WHOIS);			else				DisableItem (menu, ITEM_WHOIS);						EnableItem (menu, ITEM_BROWSE);		}		else		{			DisableItem (menu, ITEM_WHOIS);			DisableItem (menu, ITEM_BROWSE);		}		//		DisableItem (menu, ITEM_CANCEL);	}}/* ----- Check if canceled --------------------------------------------- */Boolean CheckCancel (void){	EventRecord		event;//	DialogPtr		dialog;//	short			button;	short			_delaing;	if (Aborted)		return true;	WaitNextEvent (everyEvent, &event, gSleepTime, NULL);	_delaing = delaing;	delaing = 1;	DoEvent (&event);	delaing = _delaing;		if (Aborted)			//	made by ESC pressed	{		putMessage ( 0, "\pAborted…" );		Aborted = true;		return true;	/* Cancel by button */	}	return false;			/* Not yet canceled */}static void DoMenuCommand(	register long menuResult,	short options){	register short	menuItem;	Str255			daName;//	short			i;//	DialogPtr		doom;//	PicHandle		hPic;//	GrafPtr			oldGraf;	addr			tempaddr;		menuItem = LoWrd(menuResult);	switch(HiWrd(menuResult))	{		case MENU_APPLE:					//	•••	Apple Menu					switch(menuItem)			{				case ITEM_ABOUT:			//	•••	"About RavelMAIL…"							SessionActive = TRUE;					HiliteMenu (0);					do_about (options);/*Debugger ();remote_addr.Zone = 2;remote_addr.Net = 5030;remote_addr.Node = 700;remote_addr.Point = 2;create_receipt ("\pTESTS");doCommandForSHUFFLER ( "BEEP" );ApplicationLaunch (ShufflerPathName);*/					SessionActive = FALSE;					break;				default:		//	•••	Others…										GetMenuItemText (GetMenuHandle(1), menuItem, (Byte *)&daName);					OpenDeskAcc((Byte *)&daName);										break;			}			break;		case MENU_FILE:						//	•••	File menu			switch(menuItem)			{				case ITEM_ATTACH:			//	•••	File attach									SessionActive = TRUE;					ManualAttach ();					SessionActive = FALSE;									break;									case ITEM_REQUEST:			//	•••	File request									SessionActive = TRUE;					ManualRequest ();					SessionActive = FALSE;									break;									case ITEM_QUIT:				//	•••	Qiut now									exitAfterAll ();										break;			}			break;		case MENU_EDIT:						//	•••	Edit menu			switch(menuItem)			{				case ITEM_UNDO:				//	•••	Undo									SysBeep (10);					break;									case ITEM_CUT:				//	•••	Cut									SysBeep (10);					break;									case ITEM_COPY:				//	•••	Copy									SysBeep (10);									break;														case ITEM_PASTE:			//	•••	Paste									SysBeep (10);									break;									case ITEM_CLEAR:			//	•••	Clear									SessionActive = TRUE;					KillManualPoll (cur_over);					SessionActive = FALSE;									break;			}			break;					case MENU_SESSION:					//	•••	Session					switch(menuItem)			{				case ITEM_NEWPOLL:				//	•••	Poll node									SessionActive = TRUE;//					ManualPoll (cur_over);					ManualPoll (NULL);					SessionActive = FALSE;									break;								case ITEM_POLL:				//	•••	Poll node									SessionActive = TRUE;					EditManualPoll (cur_over);					SessionActive = FALSE;									break;								case ITEM_FLAVOR:				//	••• Change Flavor									SessionActive = TRUE;					ChangeFlavorPoll (cur_over);					SessionActive = FALSE;									break;				case ITEM_ANSWER:										force_answer = true;										break;					case ITEM_RESCAN:			//	•••	Cancel									RescanOutbound ();					break;				case ITEM_WHOIS:									if (cur_over)					{						SessionActive = TRUE;						WhoIs (cur_over);						SessionActive = FALSE;					}					break;				case ITEM_BROWSE:									SessionActive = TRUE;										if (cur_over)					{						tempaddr = cur_over->calladdr;					}					else					{						tempaddr.zone = (*homesystem)->mainAddr.ad.zone;						tempaddr.net = (*homesystem)->mainAddr.ad.net;						tempaddr.node = (*homesystem)->mainAddr.ad.node;						tempaddr.point = 0;					}										NodeBrowse (&tempaddr);					SessionActive = FALSE;					break;			}			break;	}	HiliteMenu(0);}//static void IsaInboundYep (void){	short		zdir;	Str255		filename;	short		empty = 0;	CInfoPBRec	cipbr;						/* local pb */	HFileInfo	*fpb = (HFileInfo *)&cipbr;	/* to pointers */	short		rc;	short		iType;	CIconHandle	iHandle;	Rect		iRect;	GrafPtr		oldGraf;		inboundPath[inboundPath[0]+1] = 0;	if ( ( zdir = myOpenWD (inboundPath) ) == 0 )		return;	fpb->ioNamePtr = filename;	fpb->ioDirID = 0L;	fpb->ioFDirIndex = 1;	fpb->ioVRefNum = zdir;	filename[0] = 0;			rc = PBGetCatInfoSync (&cipbr);	if (rc == noErr)		empty = 1;	GetPort (&oldGraf);	SetPort (RavelWindow);	GetDialogItem ( RavelWindow, 11, &iType, (Handle *) &iHandle, &iRect );	if (empty)	{		iHandle = GetCIcon (133);		PlotCIcon (&iRect, iHandle);		DisposeCIcon (iHandle);	}	else		EraseRect (&iRect);	SetPort (oldGraf);}/* ----- Handle new event ---------------------------------------------- */static pascal OSErr MyHandleQuit (const AppleEvent *theAppleEvent, AppleEvent *reply, long handlerRefcon){#pragma unused (handlerRefcon, reply, theAppleEvent)	if (SessionActive)		return	userCanceledErr;	else	{		gQuit = true;		return	noErr;	}}static pascal OSErr MyHandleDie (const AppleEvent *theAppleEvent, AppleEvent *reply, long handlerRefcon){#pragma unused (handlerRefcon, reply, theAppleEvent)	IsaInboundYep ();	return	noErr;}static pascal OSErr MyHandleRemind (const AppleEvent *theAppleEvent, AppleEvent *reply, long handlerRefcon){#pragma unused (handlerRefcon, reply, theAppleEvent)	if (SessionActive)		gRemindAsked = true;	return	noErr;}static pascal OSErr MyHandleRescan (const AppleEvent *theAppleEvent, AppleEvent *reply, long handlerRefcon){#pragma unused (handlerRefcon, reply, theAppleEvent)	if (!SessionActive)	{		RescanOutbound ();//		IsaInboundYep ();		outbound_slice = 0;	}	else		outbound_slice = 3;	return	noErr;}#define SuspendResume	1#define ResumeMask		1void DoEvent(register EventRecord *event){	register short	part;	WindowPtr		window;	register Byte	key;			/* ASCII key code *///	short			iType;//	Handle			iHandle;//	Rect			iRect;	short			i, j;	Cell			theCell;	DialogPtr		dialog;//	Boolean			wasdouble;	long			growBytes;	mioCMIdle ();	if (event->what != updateEvt &&		!SessionActive &&		IsDialogEvent(event) &&		DialogSelect(event, &dialog, &i) &&		dialog == RavelWindow)		switch (i)		{		case 12:					{				Point	localPt = event->where;								SetPort (RavelWindow);				GlobalToLocal ( &localPt );				LClick ( localPt, event->modifiers, IHSList);			}			break;				case 13:					{				Point	localPt = event->where;								SetPort (RavelWindow);				GlobalToLocal ( &localPt );				LClick ( localPt, event->modifiers, OHSList);			}			break;				case 9:			{				Point				localPt = event->where, pt;				in_outboundPtr		over, oper_over;				PopListClickState	popState;				short				oper_link;				MenuHandle			popMenu;				Rect				iRect;				long				done;												SetPort (RavelWindow);				GlobalToLocal ( &localPt );//				wasdouble = LClick ( localPt, event->modifiers, RavelList);				popState = PopListClick (RavelList, event, &theCell);				if (popState == kPopListClickPopUp)				{					oper_link = theCell.v;					over = outbound;										oper_over = NULL;					j = 0;									while (over)					{						if (j == oper_link)							oper_over = over;												over = over->next;						j++;					}										if (oper_over)					{						LRect (&iRect, theCell, RavelList);						//						iRect.top++;						iRect.right -= 3;						iRect.left = iRect.right - 16;						iRect.bottom = iRect.top + 16;												PlotIconID (&iRect, atNone, (((WindowPeek)RavelWindow)->hilited) ? ttNone : ttDisabled, 5011);						pt.h = iRect.right-2;						pt.v = iRect.top-10;						LocalToGlobal (&pt);												popMenu = GetMenu (1001);						InsertMenu (popMenu, -1);												if (oper_over->tempstop)							SetItemMark (popMenu, 6, checkMark);												if (oper_over->force)							SetItemMark (popMenu, 7, checkMark);												done = PopUpMenuSelect (popMenu, pt.v, pt.h, 0);												DeleteMenu (1001);						DisposeMenu (popMenu);						LDraw (theCell, RavelList);												if (HiWord (done) == 1001)						{							switch (LoWord (done))							{							case 1:		//	Edit poll															SessionActive = TRUE;								EditManualPoll (oper_over);								SessionActive = FALSE;								break;														case 2:		//	Kill poll															SessionActive = TRUE;								KillManualPoll (oper_over);								SessionActive = FALSE;								break;														case 4:		//	Outbound manager															break;															case 6:		//	Defer																OverrideManual (&oper_over->calladdr, 0, true, false, false, false);								RescanOutbound ();								break;														case 7:		//	Force																OverrideManual (&oper_over->calladdr, 0, false, false, false, true);								RescanOutbound ();								break;							case 8:		//	Clear badcalls																OverrideManual (&oper_over->calladdr, 0, false, false, true, false);								RescanOutbound ();								break;							}						}					}				}				else				{					SetPt ( &theCell, 0, 0 );					if ( LGetSelect ( 1, &theCell, RavelList) )					{						current_link = theCell.v;						over = outbound;												j = 0;											while (over)						{							if (j == current_link)								cur_over = over;														over = over->next;							j++;						}					}					for (i=0; i<(*RavelList)->dataBounds.bottom; i++)					{						SetPt ( &theCell, 0, i );						LSetSelect ( FALSE, theCell, RavelList );					}										SetPt ( &theCell, 0, current_link );					LSetSelect ( TRUE, theCell, RavelList );					if (popState == kPopListDoubleClick)						unattendedslice = 0;				}			}						break;		}		switch( event->what )	{		case mouseDown:					switch ( part = FindWindow(event->where, &window) )			{				case inMenuBar:									AdjustMenus ();					DoMenuCommand (MenuSelect(event->where), event->modifiers);					break;								case inSysWindow:									SystemClick(event, window);					break;								case inContent:									if (window != FrontWindow())						SelectWindow(window);					else					{						if (window == RavelWindow)						{							SetPort(window);							GlobalToLocal(&event->where);	//						DocumentClick((DocumentPeek)window, event->where, event->modifiers);						}						window = FrontWindow ();						mioCMEvent (((WindowPeek) window)->refCon, event);					}										break;				case inDrag:					DragWindow ( window, event->where, &qd.screenBits.bounds );					break;				case inGoAway:									if (TrackGoAway(window, event->where))					{						if (window == RavelWindow)						{							if (SessionActive)								SysBeep(1);							else							{								exitAfterAll ();							}						}						else							if ( ((WindowPeek) window)->windowKind < 0 )								CloseDeskAcc(((WindowPeek)window)->windowKind);					}					window = FrontWindow ();					mioCMEvent (((WindowPeek) window)->refCon, event);					break;									default:									window = FrontWindow ();					mioCMEvent (((WindowPeek) window)->refCon, event);					break;				}				break;							case autoKey:				//				break;							case keyDown:								window = FrontWindow ();				mioCMEvent (((WindowPeek) window)->refCon, event);				if ( ((WindowPeek) FrontWindow())->windowKind < 0 )					break;								key = event->message & charCodeMask;								if ( (key == 0x1B || (key == '.' && (event->modifiers & cmdKey))) && SessionActive )					Aborted = TRUE;				else					if ( (event->modifiers & (cmdKey | optionKey | controlKey)) == 0 && !SessionActive )					{						switch (event->message & keyCodeMask)						{						case 0x7E00:														PrevOutbound ();							break;													case 0x7D00:													NextOutbound ();							break;													default:							switch (key)							{							case 0x1B:								SyncNextOutbound ();																break;												case 0x03:							case 0x0D:							case 0x20:															unattendedslice = 0;																break;														case '.':															if (cur_over)								{									OverrideManual (&cur_over->calladdr, 0, true, false, false, false);									RescanOutbound ();								}								break;														case '/':															if (cur_over)								{									OverrideManual (&cur_over->calladdr, 0, false, false, true, false);									RescanOutbound ();								}								break;														case 0x08:															SessionActive = TRUE;								KillManualPoll (cur_over);								SessionActive = FALSE;																break;							}						}					}					else						if ( (event->modifiers & cmdKey) && !SessionActive )						{							AdjustMenus();							DoMenuCommand ( MenuKey(key), event->modifiers );						}				break;			case activateEvt:							if ( (WindowPtr) event->message == RavelWindow )				{					SetPort (RavelWindow);					InvalRect (&(RavelWindow->portRect));//					IsaInboundYep ();				}									InitCursor ();					window = (WindowPtr) event->message;				mioCMEvent (((WindowPeek) window)->refCon, event);				break;				case updateEvt:					if ( (WindowPtr) event->message == RavelWindow )				{					SetPort ( RavelWindow );					BeginUpdate((WindowPtr)event->message);					UpdateDialog ( RavelWindow, RavelWindow->visRgn );					ShowAction ((SessionActive) ? 0 : 1);					LUpdate ( RavelWindow->visRgn, RavelList );					LUpdate ( RavelWindow->visRgn, IHSList );					LUpdate ( RavelWindow->visRgn, OHSList );					updtlog ();					drawProgressBar (IRBAR, 0, 0);					drawProgressBar (ITBAR, 0, 0);					drawProgressCircle (IRCIRCLE, 0, 0);					drawProgressCircle (ITCIRCLE, 0, 0);					IsaInboundYep ();					EndUpdate ((WindowPtr)event->message);				}				window = (WindowPtr) event->message;				mioCMEvent (((WindowPeek) window)->refCon, event);				break;						case osEvt:	/*				if ( ((unsigned long) event->message >> 24) == SuspendResume )				{					InitCursor ();									if ( (WindowPtr) event->message == RavelWindow )					{						SetPort (RavelWindow);						InvalRect (&(RavelWindow->portRect));												if ( event->message & ResumeMask )						{							Background = FALSE;							HiliteWindow (RavelWindow, TRUE);						}						else						{							Background = TRUE;							HiliteWindow (RavelWindow, FALSE);						}					}//					IsaInboundYep ();					mioCMResume (((event->message & ResumeMask) != 0));				}*/				break;							case kHighLevelEvent:							AEProcessAppleEvent (event);				break;							case nullEvent:				CheckHappened ();								if (delaing)					break;								if (!SessionActive && timeup(dtrslice))				{					SessionActive = true;					ShowAction ((SessionActive) ? 0 : 1);									if (CONNECTION == -2)						putMessage ( 2, "\pReinit TCP/IP…" );					else						putMessage ( 2, "\pChecking Modem…" );					SerialReset (Settings.portSetup);					mdm_init ("AT");										if (CONNECTION == -2)						dtrslice = timerset (45L*60L);					else						dtrslice = timerset (DTRSLICE);#ifndef LITE#ifdef PROTECTED					if (keys.crc != keys.oldcrc)						exitAfterAll ();					if ((keys.oldcs+1+keys.cs)&0xFFFF)						exitAfterAll ();					pStrCopy (keys.regName, (*homesystem)->sysop);					(*homesystem)->mainAddr.ad = keys.regAddr;#endif#endif					MaxMem (&growBytes);					putMessage ( 2, "\pFlushing history…" );					history_deinit ();					putMessage ( 2, "\p" );					SessionActive = false;					ShowAction ((SessionActive) ? 0 : 1);				}								if (!SessionActive && !letsMisbehave())				{					ShowAction ((SessionActive) ? 0 : 1);					break;				}								if (SessionActive)			// • in session state					break;				SessionActive = true;#ifndef LITE				if ( (CONNECTION >= 0 && force_answer) || INVOKE () )		// • gotta somewhat...				{					ShowAction ((SessionActive) ? 0 : 1);										CheckService ();					Aborted = false;					SessionActive = false;					ShowAction ((SessionActive) ? 0 : 1);					IsaInboundYep ();					break;				}#endif				force_answer = false;				if (gRemindAsked)				{					doCommandForSHUFFLER ( "REMIND" );					ApplicationLaunch (ShufflerPathName);					gRemindAsked = false;				}								Aborted = false;				if (!timeup(unattendedslice))				{					SessionActive = false;					break;				}								if (outbound_slice++ > 2)				{					RescanOutbound ();					outbound_slice = 0;										IsaInboundYep ();				}				if  (!outbound)				{					unattendedslice = timerset (UNATTENDEDSLICE);					SessionActive = false;					break;				}				ShowAction ((SessionActive) ? 0 : 1);				Unattended ();				Aborted = false;				SyncNextOutbound ();				SessionActive = false;				ShowAction ((SessionActive) ? 0 : 1);				IsaInboundYep ();				break;		}}/* ----- Universal main event loop ------------------------------------- */void Loop (void){	EventRecord		event;//	do {		WaitNextEvent (everyEvent, &event, gSleepTime, NULL);		DoEvent (&event);//	} while (BUSY);}static void killBusyFlags (void){	Handle		busytogo;	Str255		subfolder, subfolder1, subfolder2;	Str31		filename;	short		zdir, ndir, pdir;			// working directory reference number…	CInfoPBRec	cipbr;						/* local pb */	HFileInfo	*fpb = (HFileInfo *)&cipbr;	/* to pointers */	short		rc, idx;	short		idx1, idx2;	long		dummy, yup;	putlog ('~', "Cleaning up expired BUSY flags.");	busytogo = NewHandle (0);	workPath[workPath[0]+1] = 0;	if ( ( zdir = myOpenWD ( workPath ) ) == 0 )	{		putlog ( lgALRT, "Unable to open directory %s", &workPath[1] );		return;	}	fpb->ioNamePtr = filename;	for ( idx=1; true; idx++)	{											/* indexing loop */		fpb->ioDirID = 0L;						/* must set on each loop */		fpb->ioFDirIndex = idx;		fpb->ioVRefNum = zdir;		filename[0] = 0;				rc = PBGetCatInfoSync (&cipbr);				if (rc) break;							/* exit when no more entries */		if ( (fpb->ioFlAttrib & 16) && filename[0] == 9 )		{										/* zone folder: Zone_XXXX */			filename[filename[0]+1] = 0;						if ( strncmp ( (char *) &filename[1], "Zone_", 5 ) )				continue;							pStrConc ( workPath, filename, subfolder );						ndir = myOpenWD ( subfolder );						for ( idx1=1; TRUE; idx1++)			{											/* indexing loop */				fpb->ioDirID = 0L;						/* must set on each loop */				fpb->ioFDirIndex = idx1;				fpb->ioVRefNum = ndir;				filename[0] = 0;								rc = PBGetCatInfoSync (&cipbr);								if (rc) break;							/* exit when no more entries */						if ( filename[0] == 12 )				{										/* look up for nodes attaches & pts */					filename[filename[0]+1] = 0;		/* NNNNnnnn.?LO or NNNNnnnn.PTS */										if ( !(fpb->ioFlAttrib & 16) &&			//	•	NODE busied						 !strncmp ( (char *) &filename[9], ".BSY", 4 ) )					{		//	•	Check up it here for nodes								if ((!multiline_flag && fpb->ioFlFndrInfo.fdType != 'BSY!') ||							(multiline_flag && (fpb->ioFlFndrInfo.fdType - 'BSY0') == multiline_line))						{							pStrConc ( subfolder, "\p:", subfolder1 );							pStrConc ( subfolder1, filename, subfolder1 );							putlog (lgATTN, "BSY to remove: %#s", subfolder1);							PtrAndHand ( subfolder1, busytogo, subfolder1[0]+1 );						}					}					else						if ( (fpb->ioFlAttrib & 16) &&		//	•	Point folder							 !strncmp ( (char *) &filename[9], ".PTS", 4 ) )						{							pStrConc ( subfolder, "\p:", subfolder1 );							pStrConc ( subfolder1, filename, subfolder1 );														pdir = myOpenWD ( subfolder1 );														for ( idx2=1; TRUE; idx2++)							{											/* indexing loop */								fpb->ioDirID = 0L;						/* must set on each loop */								fpb->ioFDirIndex = idx2;								fpb->ioVRefNum = pdir;								filename[0] = 0;																rc = PBGetCatInfoSync (&cipbr);																if (rc) break;							/* exit when no more entries */														if ( filename[0] == 12 )								{										/* look up for pts attaches */									filename[filename[0]+1] = 0;		/* NNNNNNNN.?LO */												if ( !(fpb->ioFlAttrib & 16) &&			//	•	point attach										 !strncmp ( (char *) &filename[9], ".BSY", 4 ) )									{		//	•	Check up it here for points																				if (!multiline_flag ||											(multiline_flag && (fpb->ioFlFndrInfo.fdType - 'BSY0') == multiline_line))										{											pStrConc ( subfolder1, "\p:", subfolder2 );											pStrConc ( subfolder2, filename, subfolder2 );											putlog (lgATTN, "BSY to remove: %#s", subfolder2);											PtrAndHand ( subfolder2, busytogo, subfolder2[0]+1 );										}									}								}														}	/* points cycle */														myCloseWD ( pdir );						}				}							}	/* node cycle */					myCloseWD ( ndir );		}	}			/* zone cycle */	myCloseWD ( zdir );	HLock (busytogo);	dummy = GetHandleSize (busytogo);		if (dummy)	{		for (yup = 0; yup < dummy; )		{			pStrCopy ( (StringPtr) &((*busytogo)[yup]), subfolder );			subfolder[subfolder[0]+1] = 0;			FSDelete ( subfolder, 0 );			yup += subfolder[0] + 1;		}	}		DisposeHandle (busytogo);}/* ----- Universal main event loop ------------------------------------- */static MenuHandle myMenus[4];void StartAll ( void ){	short	iType, i, j, ii;	Handle	iHandle;	Rect	rView, rDataBnds;	Point	cellSize;	Str255	tmp;	unsigned long	checksum = 0;		myMenus[0] = GetMenu ( 1 );	myMenus[1] = GetMenu ( 2 );	myMenus[2] = GetMenu ( 3 );	myMenus[3] = GetMenu ( 4 );	AppendResMenu ( myMenus[0], 'DRVR' );	InsertMenu ( myMenus[0], 0 );	InsertMenu ( myMenus[1], 0 );	InsertMenu ( myMenus[2], 0 );	InsertMenu ( myMenus[3], 0 );	DrawMenuBar();		gQuit = false;	gRemindAsked = false;#if defined(powerc) || defined(__powerc)	uupMyHandleQuit = NewRoutineDescriptor ((ProcPtr) MyHandleQuit, uppAEHandlerProcInfo, GetCurrentISA ());	uupMyHandleDie = NewRoutineDescriptor ((ProcPtr) MyHandleDie, uppAEHandlerProcInfo, GetCurrentISA ());	uupMyHandleRemind = NewRoutineDescriptor ((ProcPtr) MyHandleRemind, uppAEHandlerProcInfo, GetCurrentISA ());	uupMyHandleRescan = NewRoutineDescriptor ((ProcPtr) MyHandleRescan, uppAEHandlerProcInfo, GetCurrentISA ());	if (AEInstallEventHandler (kCoreEventClass, kAEQuitApplication, uupMyHandleQuit, 0, false))		DebugStr ("\pAE Installation failed!");	if (AEInstallEventHandler (kCoreEventClass, kAEApplicationDied, uupMyHandleDie, 0, false))		DebugStr ("\pAE Installation failed!");	if (AEInstallEventHandler (kRavelEventClass, kAEAskRemind, uupMyHandleRemind, 0, false))		DebugStr ("\pAE Installation failed!");	if (AEInstallEventHandler (kRavelEventClass, kAERescan, uupMyHandleRescan, 0, false))		DebugStr ("\pAE Installation failed!");#else	if (AEInstallEventHandler (kCoreEventClass, kAEQuitApplication, &MyHandleQuit, 0, false))		DebugStr ("\pAE Installation failed!");	if (AEInstallEventHandler (kCoreEventClass, kAEApplicationDied, &MyHandleDie, 0, false))		DebugStr ("\pAE Installation failed!");	if (AEInstallEventHandler (kRavelEventClass, kAEAskRemind, &MyHandleRemind, 0, false))		DebugStr ("\pAE Installation failed!");	if (AEInstallEventHandler (kRavelEventClass, kAERescan, &MyHandleRescan, 0, false))		DebugStr ("\pAE Installation failed!");#endif//	•••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••	nodeAddrs = GetMenu (1000);		for ( ii = 0; ii < NodesNumber; ii++ )	{		printaddr ( &(*(nodesHndls[ii]))->Addr, (char *) &tmp[1] );		tmp[0] = strlen ( (char *) &tmp[1] );	//		for ( j = 1; j <= tmp[0]; j++ )//			if ( tmp[j] == '/' )//				tmp[j] = '|';				AppendMenu ( nodeAddrs, "\pdummy" );		SetMenuItemText ( nodeAddrs, ii+4, tmp );	}		InsertMenu ( nodeAddrs, -1 );//	•••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••//	RavelWindow = GetNewDialog ( 128, NULL, (WindowPtr) -1L );//	RavelWindow = GetNewDialog ( 777, NULL, (WindowPtr) -1L );//	GetDialogItem ( RavelWindow, 1, &iType, &iHandle, &iRect );//	HiliteControl ( (ControlHandle) iHandle, 255 );	SetPort ( RavelWindow );	TextFont ( 4 );	TextSize ( 9 );	GetDialogItem ( RavelWindow, 9, &iType, &iHandle, &rView );	SetRect ( &rDataBnds, 0, 0, 1, 0 );//	rView.right -= 15;	rView.right -= 8;	SetPt ( &cellSize, 0, 0 );	RavelList = NewPopList (&rView, &cellSize, NULL, 0x82);//	(*RavelList)->selFlags = 0x82;//	(*RavelList)->port->txFont = 4;//	(*RavelList)->port->txSize = 9;	(*RavelList)->indent.h = 3;	(*RavelList)->indent.v = 0;	SizeControl ((*RavelList)->vScroll, 9, (*(*RavelList)->vScroll)->contrlRect.bottom - (*(*RavelList)->vScroll)->contrlRect.top);	GetDialogItem ( RavelWindow, 12, &iType, &iHandle, &rView );	SetRect ( &rDataBnds, 0, 0, 1, 0 );//	rView.right -= 15;	rView.right -= 8;	SetPt ( &cellSize, rView.right - rView.left, rView.bottom - rView.top );	IHSList = LNew (							&rView,							&rDataBnds,							cellSize,							129,							RavelWindow,							true,							false,							false,							true				);	(*IHSList)->selFlags = 0x82;	(*IHSList)->indent.h = 3;	(*IHSList)->indent.v = 0;		SizeControl ((*IHSList)->vScroll, 9, (*(*IHSList)->vScroll)->contrlRect.bottom - (*(*IHSList)->vScroll)->contrlRect.top);	GetDialogItem ( RavelWindow, 13, &iType, &iHandle, &rView );	SetRect ( &rDataBnds, 0, 0, 1, 0 );//	rView.right -= 15;	rView.right -= 8;	SetPt ( &cellSize, rView.right - rView.left, rView.bottom - rView.top );	OHSList = LNew (							&rView,							&rDataBnds,							cellSize,							129,							RavelWindow,							true,							false,							false,							true				);	(*OHSList)->selFlags = 0x82;	(*OHSList)->indent.h = 3;	(*OHSList)->indent.v = 0;		SizeControl ((*OHSList)->vScroll, 9, (*(*OHSList)->vScroll)->contrlRect.bottom - (*(*OHSList)->vScroll)->contrlRect.top);		DrawDialog ( RavelWindow );		LActivate ( true, RavelList );	LSetDrawingMode ( true, RavelList );	LUpdate ( RavelWindow->visRgn, RavelList );	LActivate ( true, IHSList );	LSetDrawingMode ( true, IHSList );	LUpdate ( RavelWindow->visRgn, IHSList );	LActivate ( true, OHSList );	LSetDrawingMode ( true, OHSList );	LUpdate ( RavelWindow->visRgn, OHSList );	killBusyFlags ();	Background = false;	Aborted = false;	force_answer = false;	delaing = 0;	gotta_xmail = gotta_mail = 0;	outbound_slice = 0;	current_link = 0;	InitEvents ();#ifndef LITE#ifdef PROTECTED	if (!CheckKey())	{		exitAfterAll ();	}		j = GetHandleSize (keys.Invalidater)/4;	for (i=0;i<j-1;i++)	{		if (((unsigned long *)*keys.Invalidater)[i] == keys.crc)			checksum++;		checksum += ((unsigned long *)*keys.Invalidater)[i];	}		if (checksum != ((unsigned long *)*keys.Invalidater)[i] || j<0x200/4)	{		Alert (127, NULL);		exitAfterAll ();	}#endif#endif	outbound = NULL;	manual_outbound = NULL;		RescanOutbound ();	history_init ();	if (CONNECTION == -2)		dtrslice = timerset (45L*60L);	else		dtrslice = timerset (DTRSLICE);		unattendedslice = timerset (fUNATTENDEDSLICE);	hang_up ();	CLEAR_OUTBOUND ();	CLEAR_INBOUND ();	mdm_init (NULL);	SessionActive = FALSE;//	•••••••••••••••••••••••••••••••••••••••••••••	if (auto_scan && !isPressed (0x003B))	{//		EventsPossible = FALSE;			doCommandForSHUFFLER ( "SCAN" );		if ( !ApplicationLaunch (ShufflerPathName) )		{//			EventsPossible = TRUE;		}	}//	else//		EventsPossible = TRUE;	ShowAction ((SessionActive) ? 0 : 1);//	ShowAction ((EventsPossible) ? ((SessionActive) ? 0 : 1 ) : 2);//	•••••••••••••••••••••••••••••••••••••••••••••	unattendedslice = timerset (UNATTENDEDSLICE);		gSleepTime = 20;	while (!gQuit) Loop ();	exitAfterAll ();}static void killEmptyFolders1 (StringPtr pathname){	short			zdir, ndir;			// working directory reference number…	CInfoPBRec		cipbr;						/* local pb */	HFileInfo		*fpb = (HFileInfo *)&cipbr;	/* to pointers */	short			rc, idx;	short			idx1;	Str32			filename;	Str255			subfolder, subfolder1;	long			dummy, dummy1, yup;		Handle			zonal, points;		pathname[pathname[0]+1] = 0;	if ( ( zdir = myOpenWD ( pathname ) ) == 0 )	{		putlog ( lgALRT, "Unable to open directory %s", &pathname[1] );		return;	}	zonal = NewHandle (0);	points = NewHandle (0);		fpb->ioNamePtr = filename;	for ( idx=1; TRUE; idx++)	{											/* indexing loop */		fpb->ioDirID = 0L;						/* must set on each loop */		fpb->ioFDirIndex = idx;		fpb->ioVRefNum = zdir;		filename[0] = 0;				rc = PBGetCatInfoSync (&cipbr);				if (rc) break;							/* exit when no more entries */		if ( (fpb->ioFlAttrib & 16) && filename[0] == 9 )		{										/* zone folder: Zone_XXXX */			filename[filename[0]+1] = 0;						if ( strncmp ( (char *) &filename[1], "Zone_", 5 ) )				continue;			if ( sscanf ( (char *) &filename[6], "%lX", &dummy ) == EOF )				continue;						pStrConc ( pathname, filename, subfolder );						PtrAndHand ( subfolder, zonal, subfolder[0]+1 );						ndir = myOpenWD ( subfolder );						for ( idx1=1; TRUE; idx1++)			{											/* indexing loop */				fpb->ioDirID = 0L;						/* must set on each loop */				fpb->ioFDirIndex = idx1;				fpb->ioVRefNum = ndir;				filename[0] = 0;								rc = PBGetCatInfoSync (&cipbr);								if (rc) break;							/* exit when no more entries */						if ( filename[0] == 12 )				{										/* look up for nodes attaches & pts */					filename[filename[0]+1] = 0;		/* NNNNnnnn.?LO or NNNNnnnn.PTS */										if ( (fpb->ioFlAttrib & 16) &&		//	•	Point folder						 !strncmp ( (char *) &filename[9], ".PTS", 4 ) )					{						if ( sscanf ( (char *) &filename[1], "%lX", &dummy ) == EOF )							continue;												pStrConc ( subfolder, "\p:", subfolder1 );						pStrConc ( subfolder1, filename, subfolder1 );						PtrAndHand ( subfolder1, points, subfolder1[0]+1 );					}				}							}	/* node cycle */					myCloseWD ( ndir );		}	}			/* zone cycle */		myCloseWD ( zdir );		HLock (zonal);	HLock (points);	dummy = GetHandleSize (zonal);		if (dummy)	{		dummy1 = GetHandleSize (points);				if (dummy1)			for (yup = 0; yup < dummy1; )			{				pStrCopy ( (StringPtr) &((*points)[yup]), subfolder );				subfolder[subfolder[0]+1] = 0;				if ( FSDelete ( subfolder, 0 ) )					putlog ( '~', "Points folder %s not empty", trunc_path ((char *)&subfolder[1]) );				else					putlog ( '~', "Points folder %s has been killed", trunc_path ((char *)&subfolder[1]) );				yup += subfolder[0] + 1;			}			for (yup = 0; yup < dummy; )		{			pStrCopy ( (StringPtr) &((*zonal)[yup]), subfolder );			subfolder[subfolder[0]+1] = 0;			if ( FSDelete ( subfolder, 0 ) )				putlog ( '~', "Zonal folder %s not empty", trunc_path ((char *)&subfolder[1]) );			else				putlog ( '~', "Zonal folder %s has been killed", trunc_path ((char *)&subfolder[1]) );						yup += subfolder[0] + 1;		}	}		DisposeHandle (zonal);	DisposeHandle (points);}static void killEmptyFolders (void){	killEmptyFolders1 (outboundPath);	killEmptyFolders1 (workPath);}void exitAfterAll (void){	Handle	htmp;		HiliteMenu (0);	killEmptyFolders ();	PopListDestruct (RavelList);	LDispose (RavelList);		//	leaks possible… (for pop list)	LDispose (IHSList);	LDispose (OHSList);	history_deinit ();	putlog ( lgNOPE, "End." );		htmp = Get1Resource ( 'WLOC', 128 );	if (htmp)		RemoveResource (htmp);	htmp = NewHandle (sizeof (Point));	HLock (htmp);		memcpy ( *htmp, &((DialogPeek)RavelWindow)->window.port.portRect, sizeof (Point) );	LocalToGlobal ( (Point*)*htmp );	AddResource ( htmp, 'WLOC', 128, "\p" );			DisposeDialog (RavelWindow);//	SerialClose ();	CloseSerial ();	CloseNodeList ();#if defined(powerc) || defined(__powerc)	AERemoveEventHandler (kCoreEventClass, kAEQuitApplication, uupMyHandleQuit, false);	AERemoveEventHandler (kCoreEventClass, kAEApplicationDied, uupMyHandleDie, false);	AERemoveEventHandler (kRavelEventClass, kAEAskRemind, uupMyHandleRemind, false);	AERemoveEventHandler (kRavelEventClass, kAERescan, uupMyHandleRescan, false);	DisposeRoutineDescriptor (uupMyHandleQuit);	DisposeRoutineDescriptor (uupMyHandleDie);	DisposeRoutineDescriptor (uupMyHandleRemind);	DisposeRoutineDescriptor (uupMyHandleRescan);	DisposeRoutineDescriptor (uupLDEFHistProc);#else	AERemoveEventHandler (kCoreEventClass, kAEQuitApplication, &MyHandleQuit, false);	AERemoveEventHandler (kCoreEventClass, kAEApplicationDied, &MyHandleDie, false);	AERemoveEventHandler (kRavelEventClass, kAEAskRemind, &MyHandleRemind, false);	AERemoveEventHandler (kRavelEventClass, kAERescan, &MyHandleRescan, false);#endif	ExitToShell ();}