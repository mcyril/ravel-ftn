#include <Sound.h>#include <string.h>#include "visual.h"#include "Ravel_FTN.h"#include "Ravel_Prefs.h"#include "compatible.h"#include "mFilter.h"#include "PascalStr.h"#include "Scheduler.h"#include "Unattended.h"#include "Manual.h"#include "Attacher.h"#include "stringutl.h"#include "addresses.h"#include "NodeCookie.h"#include "log.h"extern	in_outboundPtr	outbound;		// original ptrextern	in_outboundPtr	cur_over;		// current ptrextern	short			current_link;extern	short			links_count;extern	manual_chainPtr	manual_outbound;extern	short			NodesNumber;		//	¥	Linked Nodes structs listextern	nodePrefHndl	*nodesHndls;extern	MenuHandle		nodeAddrs;static	ListHandle	FileList;static	StringPtr	pollModes[3] = { "\p.CLO", "\p.DLO", "\p.HLO" };static	StringPtr	requestSuffix = "\p.REQ";//extern	Boolean		SessionActive;enum {	uppAEHandlerProcInfo = kPascalStackBased		 | RESULT_SIZE(SIZE_CODE(sizeof(OSErr)))		 | STACK_ROUTINE_PARAMETER(1, SIZE_CODE(sizeof(Ptr)))		 | STACK_ROUTINE_PARAMETER(2, SIZE_CODE(sizeof(Ptr)))		 | STACK_ROUTINE_PARAMETER(3, SIZE_CODE(sizeof(long))),//	pascal Boolean myAlertProc (DialogPtr theDialog, EventRecord *theEvent, short *itemHit)	uppModalProcInfo = kPascalStackBased		 | RESULT_SIZE(SIZE_CODE(sizeof(Boolean)))		 | STACK_ROUTINE_PARAMETER(1, SIZE_CODE(sizeof(Ptr)))		 | STACK_ROUTINE_PARAMETER(2, SIZE_CODE(sizeof(Ptr)))		 | STACK_ROUTINE_PARAMETER(3, SIZE_CODE(sizeof(Ptr))),};/* * Pascal string utilities *//* * pstrcat - add string 'src' to end of string 'dst' */static void pstrcat ( StringPtr dst, StringPtr src ){		/* copy string in */	BlockMove(src + 1, dst + *dst + 1, *src);		/* adjust length byte */	*dst += *src;}/* * pstrinsert - insert string 'src' at beginning of string 'dst' */static void pstrinsert( StringPtr dst, StringPtr src ){		/* make room for new string */	BlockMove(dst + 1, dst + *src + 1, *dst);		/* copy new string in */	BlockMove(src + 1, dst + 1, *src);		/* adjust length byte */	*dst += *src;}void PathNameFromDirID ( long dirID, short vRefNum, StringPtr fullPathName ){	DirInfo	block;	Str255	directoryName;	OSErr	err;	fullPathName[0] = '\0';	block.ioDrParID = dirID;	block.ioNamePtr = directoryName;	do	{				block.ioVRefNum = vRefNum;		block.ioFDirIndex = -1;		block.ioDrDirID = block.ioDrParID;		err = PBGetCatInfoSync ((CInfoPBPtr) &block);		pstrcat(directoryName, (StringPtr)"\p:");		pstrinsert(fullPathName, directoryName);		} while (block.ioDrDirID != 2);}/*PathNameFromWD:Given an HFS working directory, this routine returns the full pathname thatcorresponds to it. It does this by calling PBGetWDInfo to get the VRefNum andDirID of the real directory. It then calls PathNameFromDirID, and returns itsresult.*/void PathNameFromWD ( long vRefNum, StringPtr pathName ){	WDPBRec	myBlock;	OSErr	err;		/* 	PBGetWDInfo has a bug under A/UX 1.1.  If vRefNum is a real	 vRefNum and not a wdRefNum, then it returns garbage. 	Since A/UX has only 1 volume (in the Macintosh sense) and 	only 1 root directory, this can occur only when a file has been 	selected in the root directory (/). 	So we look for this and hardcode the DirID and vRefNum.	*/		myBlock.ioNamePtr = nil;	myBlock.ioVRefNum = vRefNum;	myBlock.ioWDIndex = 0;	myBlock.ioWDProcID = 0;		/*	 Change the Working Directory number in vRefnum into a real	vRefnum and DirID. The real vRefnum is returned in ioVRefnum,	 and the real DirID is returned in ioWDDirID.	*/	err = PBGetWDInfoSync (&myBlock);	if (err != noErr)			return;	PathNameFromDirID(myBlock.ioWDDirID, myBlock.ioWDVRefNum,			pathName);}static Boolean AlreadyInList (ListHandle list, StringPtr str){	short	dummy;	Str255	temp;	short	len;	Cell	theCell;	for ( dummy = 0; dummy < (*list)->dataBounds.bottom; dummy++ )	{		SetPt ( &theCell, 0, dummy );		len = 255;		LGetCell ( &temp[1], &len, theCell, list );		temp[0] = len;			if (!pStrComp (temp, str))			break;	}		if (dummy == (*list)->dataBounds.bottom)		return false;	else		return true;}void AddManual ( addr *addtoaddr, StringPtr phone, StringPtr password, StringPtr fname, Boolean attach, short poll, Boolean force ){	manual_chainPtr	manual_over = manual_outbound;	long			l;	char			ty[128];	if (!manual_over)	{//		putlog ('~', "AddManual: Create new outbound chain");		manual_outbound = manual_over = (manual_chainPtr) NewPtr (sizeof(manual_chainType));	}	else	{		do {			if ( manual_over->calladdr.zone == addtoaddr->zone &&				 manual_over->calladdr.net == addtoaddr->net &&				 manual_over->calladdr.node == addtoaddr->node &&				 manual_over->calladdr.point == addtoaddr->point )			{//				putlog ('~', "AddManual: Append to exist element");				goto already;			}						if (manual_over->next)				manual_over = manual_over->next;			else				break;		} while (1);//		putlog ('~', "AddManual: Create new element");		manual_over->next = (manual_chainPtr) NewPtr (sizeof(manual_chainType));		manual_over = manual_over->next;	}//	if (!SessionActive)	putlog ('~', "Create manual outbound to %s", printaddr (addtoaddr, ty) );//	¥	Simplyfied for first	manual_over->next = NULL;	manual_over->calladdr.zone = addtoaddr->zone;	manual_over->calladdr.net = addtoaddr->net;	manual_over->calladdr.node = addtoaddr->node;	manual_over->calladdr.point = addtoaddr->point;	manual_over->callphone[0] = 0;	manual_over->password[0] = 0;	manual_over->poll = 0;	manual_over->force = false;	manual_over->requests = NULL;	manual_over->attaches = NULL;	manual_over->tempstop = 0;	manual_over->badcount = 0;already:	manual_over->poll = poll;	manual_over->force = force;	if (phone)//		if (phone[0])			pStrCopy ( phone, manual_over->callphone );//		else//			manual_over->callphone[0] = 0;		if (password)//		if (password[0])			strncpy ( manual_over->password, (char *) &password[1], 8 );//		else//			manual_over->password[0] = 0;	if (fname)	{		if (!attach)		{									//	request			if (manual_over->requests)			{				l = GetHandleSize ( manual_over->requests );				SetHandleSize ( manual_over->requests, l + fname[0] + 2 );			}			else			{				manual_over->requests = NewHandle ( (long) fname[0] + 2 );				l = 0L;			}						memcpy ( (*manual_over->requests)+l, &fname[1], (long) fname[0] );			(*manual_over->requests)[l+fname[0]] = '\xD';			(*manual_over->requests)[l+fname[0]+1] = '\xA';		}		else		{									//	attach			if (manual_over->attaches)			{				l = GetHandleSize ( manual_over->attaches );				SetHandleSize ( manual_over->attaches, l + fname[0] + 1 );			}			else			{				manual_over->attaches = NewHandle ( (long) fname[0] + 1 );				l = 0L;			}						memcpy ( (*manual_over->attaches)+l, &fname[1], (long) fname[0] );			(*manual_over->attaches)[l+fname[0]] = 0;		}	}}void OverrideManual (addr *addtoaddr, short tempstop, Boolean do_tempstop, Boolean add_badcount, Boolean kill_badcount, Boolean do_force){#pragma unused (tempstop)	manual_chainPtr	manual_over = manual_outbound;//	long			l;	char			ty[128];	if (!manual_over)	{//		putlog ('~', "AddManual: Create new outbound chain");		manual_outbound = manual_over = (manual_chainPtr) NewPtr (sizeof(manual_chainType));	}	else	{		do {			if ( manual_over->calladdr.zone == addtoaddr->zone &&				 manual_over->calladdr.net == addtoaddr->net &&				 manual_over->calladdr.node == addtoaddr->node &&				 manual_over->calladdr.point == addtoaddr->point )			{//				putlog ('~', "AddManual: Append to exist element");				goto already;			}						if (manual_over->next)				manual_over = manual_over->next;			else				break;		} while (1);//		putlog ('~', "AddManual: Create new element");		manual_over->next = (manual_chainPtr) NewPtr (sizeof(manual_chainType));		manual_over = manual_over->next;	}//	if (!SessionActive)	putlog ('~', "Create manual outbound to %s", printaddr (addtoaddr, ty) );//	¥	Simplyfied for first	manual_over->next = NULL;	manual_over->calladdr.zone = addtoaddr->zone;	manual_over->calladdr.net = addtoaddr->net;	manual_over->calladdr.node = addtoaddr->node;	manual_over->calladdr.point = addtoaddr->point;	manual_over->callphone[0] = 0;	manual_over->password[0] = 0;	manual_over->poll = 0;	manual_over->force = false;	manual_over->requests = NULL;	manual_over->attaches = NULL;	manual_over->tempstop = 0;	manual_over->badcount = 0;already:	if (do_tempstop)		manual_over->tempstop = 1 - manual_over->tempstop;	if (do_force)		manual_over->force = !manual_over->force;	if (add_badcount)	{		if (kill_badcount)			manual_over->badcount = 0x7FFF;		else			manual_over->badcount++;	}	else		if (kill_badcount)			manual_over->badcount = 0;}void KillManual ( addr *addtoaddr ){	char			ty[128];	manual_chainPtr	manual_prev, manual_over;		manual_prev = NULL;	manual_over = manual_outbound;//	if (!SessionActive)	putlog ('~', "Kill manual outbound to %s", printaddr (addtoaddr, ty) );	if (!manual_over)		return;	else	{		do {			if ( manual_over->calladdr.zone == addtoaddr->zone &&				 manual_over->calladdr.net == addtoaddr->net &&				 manual_over->calladdr.node == addtoaddr->node &&				 manual_over->calladdr.point == addtoaddr->point )				break;						if (manual_over->next)			{				manual_prev = manual_over;				manual_over = manual_over->next;			}			else				return;		} while (1);		if (manual_prev)		// not first!		{			manual_prev->next = manual_over->next;		}		else		{			manual_outbound = manual_over->next;		}		if (manual_over->attaches)			DisposeHandle (manual_over->attaches);				if (manual_over->requests)			DisposeHandle (manual_over->requests);				DisposePtr ( (Ptr) manual_over );	}}static void KillManualFiles ( addr *addtoaddr, Boolean request ){//	char			ty[128];	manual_chainPtr	manual_over = manual_outbound;		if (!manual_over)		return;	else	{		do {			if ( manual_over->calladdr.zone == addtoaddr->zone &&				 manual_over->calladdr.net == addtoaddr->net &&				 manual_over->calladdr.node == addtoaddr->node &&				 manual_over->calladdr.point == addtoaddr->point )				break;						if (manual_over->next)				manual_over = manual_over->next;			else				return;		} while (1);		if (!request)		{			if (manual_over->attaches)			{				DisposeHandle (manual_over->attaches);				manual_over->attaches = NULL;			}		}		else		{			if (manual_over->requests)			{				DisposeHandle (manual_over->requests);				manual_over->requests = NULL;			}		}	}}static pascal Boolean RequestFilterProc ( DialogPtr theDialog, EventRecord *theEvent, short *itemHit ){	Boolean result = false;	char	tmp[128];	short	pump;		if (theEvent->what == mouseDown)	{		Point		localWhere = theEvent->where;		GrafPtr		savePort;				GetPort (&savePort);		SetPort (theDialog);		GlobalToLocal (&localWhere);			pump = FindDialogItem (theDialog, localWhere);				if (pump == 3)	// 4 is popdown pump!		{			short	iType, inx;			Handle	iHandle;			Rect	iRect;			Point	popWhere;			GetDialogItem ( theDialog, 3, &iType, &iHandle, &iRect );			popWhere.v = iRect.bottom;			popWhere.h = iRect.left;			LocalToGlobal (&popWhere);						GetDialogItem ( theDialog, 4, &iType, &iHandle, &iRect );			PlotIconID (&iRect, atNone, (((WindowPeek)theDialog)->hilited) ? ttNone : ttDisabled, 5013);//			InvertRect (&iRect);			DisableItem (nodeAddrs, 1);			DisableItem (nodeAddrs, 2);			inx = PopUpMenuSelect ( nodeAddrs, popWhere.v, popWhere.h, 1 ) & 0xFFFF;						if (inx > 3)			{				inx -= 4;								printaddr ( &(*(nodesHndls[inx]))->Addr, &tmp[1] );				tmp[0] = strlen ( &tmp[1] );							GetDialogItem ( theDialog, 3, &iType, &iHandle, &iRect );				SetDialogItemText ( iHandle, (StringPtr) tmp );			}			else				if (inx == 1)				{					SysBeep (10);								}				else					if (inx == 2)					{			//	insert address attributes						SysBeep (10);					}						GetDialogItem ( theDialog, 4, &iType, &iHandle, &iRect );			PlotIconID (&iRect, atNone, (((WindowPeek)theDialog)->hilited) ? ttNone : ttDisabled, 5012);//			InvertRect (&iRect);		}		else			if (pump == 6)		//	7 list			{				LClick (localWhere, theEvent->modifiers, FileList);				result = true;			}		SetPort (savePort);	}	else		if (theEvent->what == keyDown)		{			char	key = theEvent->message & 0xFFL;			char	code;			short	linx = -1;									*itemHit = 0;/*			if ((theEvent->modifiers & (optionKey | cmdKey)) == (optionKey | cmdKey))			{				switch (code = (theEvent->message & 0xFF00L) >> 8)				{				case 0x12:								// 1				case 0x13:								// 2				case 0x14:								// 3				case 0x15:	linx = code - 0x12;	break;	// 4				case 0x17:	linx = 4;			break;	// 5				case 0x16:	linx = 5;			break;	// 6				case 0x1A:	linx = 6;			break;	// 7				case 0x1C:	linx = 7;			break;	// 8				case 0x19:	linx = 8;			break;	// 9								default:	break;				}								if (linx >= 0 && linx < NodesNumber)				{					short	iType;					Handle	iHandle;					Rect	iRect;					printaddr ( &(*(nodesHndls[linx]))->Addr, &tmp[1] );					tmp[0] = strlen ( &tmp[1] );									GetDialogItem ( theDialog, 3, &iType, &iHandle, &iRect );					SetDialogItemText ( iHandle, (StringPtr) tmp );				}								result = true;			}			else*/				if (key == 0x1B)				{					*itemHit = 2;					result = true;				}				else					if (key == 0x03 || key == 0x0D)					{						*itemHit = 1;						result = true;					}				if (*itemHit)				{					FalseClick (theDialog, *itemHit);				}		}		else			if (theEvent->what == updateEvt)			{				short	iType;				Handle	iHandle;				Rect	iRect;				GrafPtr		savePort;				GetPort (&savePort);				SetPort (theDialog);				GetDialogItem ( theDialog, 4, &iType, &iHandle, &iRect );				PlotIconID (&iRect, atNone, (((WindowPeek)theDialog)->hilited) ? ttNone : ttDisabled, 5012);				SetPort (savePort);			}	return result;}void ManualRequest (){	Str255		s_Addr, fName;		ADDR		addr1;	addr		addr2;		DialogPtr	theDialog;	Handle		iHandle;	short		iType, i;	Rect		iRect, rView, rDataBnds;	short		iHit, len;	Point		cellSize, theCell;	long		lll, ill, jll;		addr		wasa;	#if defined(powerc) || defined(__powerc)	UniversalProcPtr	uupRequestFilterProc;	uupRequestFilterProc = NewRoutineDescriptor ((ProcPtr) RequestFilterProc, uppModalProcInfo, GetCurrentISA ());#endif	if (cur_over)	{		wasa = cur_over->calladdr;		printaddr ( &cur_over->calladdr, (char *) &s_Addr[1] );		s_Addr[0] = strlen ( (char *) &s_Addr[1] );	}	else	{		wasa.zone = 0;		s_Addr[0] = 0;	}		theDialog = GetNewDialog ( 140, NULL, (WindowPtr) -1L );	SetPort ( theDialog );	GetDialogItem ( theDialog, 7, &iType, &iHandle, &rView );	SetRect ( &rDataBnds, 0, 0, 1, 0 );	rView.right -= 15;	SetPt ( &cellSize, 0, 0 );	FileList = LNew (							&rView,							&rDataBnds,							cellSize,							0,							theDialog,							TRUE,							FALSE,							FALSE,							TRUE				);	InsetRect (&rView, -1, -1);	FrameRect (&rView);	(*FileList)->selFlags = 0x82;	if (cur_over && cur_over->requests)	{		lll = GetHandleSize (cur_over->requests);		HLock (cur_over->requests);		ill = 0;				while (ill < lll)		{			jll = ill;					while (ill < lll && (*cur_over->requests)[ill] != 0x0D)				ill++;						i = LAddRow ( 1, 0x7FFF, FileList );			SetPt ( &theCell, 0, i );			LSetCell ( &(*cur_over->requests)[jll], ill - jll, theCell, FileList );						ill += 2;		}			HUnlock (cur_over->requests);		}		default_button ( theDialog, 1 );	GetDialogItem ( theDialog, 3, &iType, &iHandle, &iRect );	SetDialogItemText ( iHandle, s_Addr );		do {	#if defined(powerc) || defined(__powerc)		ModalDialog ( uupRequestFilterProc, &iHit );#else		ModalDialog ( RequestFilterProc, &iHit );#endif				switch (iHit)		{		case 1:			// check here address & filename					GetDialogItem ( theDialog, 3, &iType, &iHandle, &iRect );			GetDialogItemText ( iHandle, s_Addr );					s_Addr[s_Addr[0]+1] = 0;						addr1.Zone = -1;			addr1.Net = -1;			addr1.Node = -1;			addr1.Point = -1;			addr1.Domain = NULL;			find_address ( (char *) &s_Addr[1], &addr1 );						if ( addr1.Zone == 0 ||//				 addr1.Net == 0 ||//				 addr1.Node == 0 ||				 addr1.Point == -1 )				iHit = -1;//			GetDialogItem ( theDialog, 4, &iType, &iHandle, &iRect );//			GetIText ( iHandle, fName );			//			if (!fName[0])//				iHit = -1;						break;					case 2:					break;		case 5:			//	add					GetDialogItem ( theDialog, 8, &iType, &iHandle, &iRect );			GetDialogItemText ( iHandle, fName );					if (!fName[0] || fName[0] > 16)			{				SysBeep (10);				break;			}						GetDialogItem ( theDialog, 9, &iType, &iHandle, &iRect );			GetDialogItemText ( iHandle, s_Addr );					if (s_Addr[0] > 16)			{				SysBeep (10);				break;			}						if (s_Addr[0])			{				pStrConc (fName, "\p !", fName);				pStrConc (fName, s_Addr, fName);						}					if ( !AlreadyInList (FileList, fName) )			{				i = LAddRow ( 1, 0x7FFF, FileList );				SetPt ( &theCell, 0, i );				LSetCell ( &fName[1], fName[0], theCell, FileList );				}			else			{				SysBeep (10);				break;			}						LUpdate ( theDialog->visRgn, FileList );			break;				case 6:			//	remove			SetPt ( &theCell, 0, 0 );				if ( LGetSelect ( 1, &theCell, FileList) )			{				LDelRow ( 1, theCell.v, FileList );			}				break;					}			} while ( iHit != 1 && iHit != 2 );		DisposeDialog ( theDialog );		if ( iHit == 1 )	{		addr2.zone = addr1.Zone;		addr2.net = addr1.Net;		addr2.node = addr1.Node;		addr2.point = addr1.Point;				KillManualFiles ( &addr2, true );				for ( i = 0; i < (*FileList)->dataBounds.bottom; i++ )		{			SetPt ( &theCell, 0, i );			len = 255;			LGetCell ( &fName[1], &len, theCell, FileList );			fName[0] = len;						AddManual ( &addr2, NULL, NULL, fName, false,				(cur_over && cmp2addrs (&addr2, &wasa)) ? cur_over->poll : 0,				(cur_over && cmp2addrs (&addr2, &wasa)) ? cur_over->force : 0 );		}			RescanOutbound ();	}#if defined(powerc) || defined(__powerc)	DisposeRoutineDescriptor (uupRequestFilterProc);#endif}//static void __ManualAttach ()void ManualAttach (){	Str255		s_Addr, fName;		ADDR		addr1;	addr		addr2;		DialogPtr	theDialog;	Handle		iHandle;	short		iType, i;	Rect		iRect, rView, rDataBnds;	short		iHit, len;	Point		cellSize, theCell;	long		lll, ill, jll;		addr		wasa;#if defined(powerc) || defined(__powerc)	UniversalProcPtr	uupRequestFilterProc;	uupRequestFilterProc = NewRoutineDescriptor ((ProcPtr) RequestFilterProc, uppModalProcInfo, GetCurrentISA ());#endif	if (cur_over)	{		wasa = cur_over->calladdr;		printaddr ( &cur_over->calladdr, (char *) &s_Addr[1] );		s_Addr[0] = strlen ( (char *) &s_Addr[1] );	}	else	{		wasa.zone = 0;		s_Addr[0] = 0;	}		theDialog = GetNewDialog ( 141, NULL, (WindowPtr) -1L );	SetPort ( theDialog );	GetDialogItem ( theDialog, 7, &iType, &iHandle, &rView );	SetRect ( &rDataBnds, 0, 0, 1, 0 );	rView.right -= 15;	SetPt ( &cellSize, 0, 0 );	FileList = LNew (							&rView,							&rDataBnds,							cellSize,							0,							theDialog,							TRUE,							FALSE,							FALSE,							TRUE				);	InsetRect (&rView, -1, -1);	FrameRect (&rView);	(*FileList)->selFlags = 0x82;	if (cur_over && cur_over->attaches)	{		lll = GetHandleSize (cur_over->attaches);		HLock (cur_over->attaches);		ill = 0;				while (ill < lll)		{			jll = ill;					while (ill < lll && (*cur_over->attaches)[ill])				ill++;						i = LAddRow ( 1, 0x7FFF, FileList );			SetPt ( &theCell, 0, i );			LSetCell ( &(*cur_over->attaches)[jll], ill - jll, theCell, FileList );						ill++;		}			HUnlock (cur_over->attaches);		}		default_button ( theDialog, 1 );	GetDialogItem ( theDialog, 3, &iType, &iHandle, &iRect );	SetDialogItemText ( iHandle, s_Addr );		do {	#if defined(powerc) || defined(__powerc)		ModalDialog ( uupRequestFilterProc, &iHit );#else		ModalDialog ( RequestFilterProc, &iHit );#endif				switch (iHit)		{		case 1:			// check here address & filename					GetDialogItem ( theDialog, 3, &iType, &iHandle, &iRect );			GetDialogItemText ( iHandle, s_Addr );					s_Addr[s_Addr[0]+1] = 0;						addr1.Zone = -1;			addr1.Net = -1;			addr1.Node = -1;			addr1.Point = -1;			addr1.Domain = NULL;			find_address ( (char *) &s_Addr[1], &addr1 );						if ( addr1.Zone == 0 ||//				 addr1.Net == 0 ||//				 addr1.Node == 0 ||				 addr1.Point == -1 )				iHit = -1;//			GetDialogItem ( theDialog, 4, &iType, &iHandle, &iRect );//			GetIText ( iHandle, fName );			//			if (!fName[0])//				iHit = -1;						break;					case 2:					break;		case 5:			//	add					{				Point		where = { 0, 0 };				SFReply		reply;												SFGetFile ( where, NULL, NULL, -1, NULL, NULL, &reply );				FrameRect (&rView);				if ( reply.good )				{					PathNameFromWD ( reply.vRefNum, s_Addr );					pStrConc ( s_Addr, reply.fName, s_Addr );				}				else					break;			}					GetDialogItem ( theDialog, 10, &iType, &iHandle, &iRect );			fName[1] = (GetControlValue ( (ControlHandle) iHandle )) ? '-' : '+';			fName[0] = 1;			pStrConc (fName, s_Addr, fName);			if ( !AlreadyInList (FileList, fName) )			{				i = LAddRow ( 1, 0x7FFF, FileList );				SetPt ( &theCell, 0, i );				LSetCell ( &fName[1], fName[0], theCell, FileList );				}			else			{				SysBeep (10);//				break;			}						LUpdate ( theDialog->visRgn, FileList );			break;				case 6:			//	remove			SetPt ( &theCell, 0, 0 );				if ( LGetSelect ( 1, &theCell, FileList) )			{				LDelRow ( 1, theCell.v, FileList );			}				break;					case 10:		// kill/sent checkbox					GetDialogItem ( theDialog, 10, &iType, &iHandle, &iRect );			SetControlValue ( (ControlHandle) iHandle, !GetControlValue ( (ControlHandle) iHandle ) );			break;				}			} while ( iHit != 1 && iHit != 2 );		DisposeDialog ( theDialog );		if ( iHit == 1 )	{		addr2.zone = addr1.Zone;		addr2.net = addr1.Net;		addr2.node = addr1.Node;		addr2.point = addr1.Point;				KillManualFiles ( &addr2, false );				for ( i = 0; i < (*FileList)->dataBounds.bottom; i++ )		{			SetPt ( &theCell, 0, i );			len = 255;			LGetCell ( &fName[1], &len, theCell, FileList );			fName[0] = len;						AddManual ( &addr2, NULL, NULL, fName, true,				(cur_over && cmp2addrs (&addr2, &wasa)) ? cur_over->poll : 0,				(cur_over && cmp2addrs (&addr2, &wasa)) ? cur_over->force : 0 );		}			RescanOutbound ();	}#if defined(powerc) || defined(__powerc)	DisposeRoutineDescriptor (uupRequestFilterProc);#endif}void KillManualPoll (in_outboundPtr do_over){	Str255		s_Addr, temp, temp1, temp2, temp3;	Boolean		wasa, wannadel;	FSSpec		spec;	ADDR		addr1;	addr		addr2;		DialogPtr	theDialog;	Handle		iHandle, att;	short		iType, i, attFile;	Rect		iRect;	short		iHit;	char		*zzz;	long		t, cnt;#if defined(powerc) || defined(__powerc)	UniversalProcPtr	uupClearFilterProc;	uupClearFilterProc = NewRoutineDescriptor ((ProcPtr) ModalClearFilterProc, uppModalProcInfo, GetCurrentISA ());#endif	if (!do_over)	{		SysBeep (10);		return;	}		theDialog = GetNewDialog ( 133, NULL, (WindowPtr) -1L );	default_button ( theDialog, 1 );	printaddr ( &do_over->calladdr, (char *) &s_Addr[1] );	s_Addr[0] = strlen ( (char *) &s_Addr[1] );			GetDialogItem ( theDialog, 3, &iType, &iHandle, &iRect );	SetDialogItemText ( iHandle, s_Addr );		do {	#if defined(powerc) || defined(__powerc)		ModalDialog ( uupClearFilterProc, &iHit );#else		ModalDialog ( ModalClearFilterProc, &iHit );#endif		switch (iHit)		{		case 1:			// check here address & cbs						addr2 = do_over->calladdr;/*					GetDialogItem ( theDialog, 3, &iType, &iHandle, &iRect );			GetDialogItemText ( iHandle, s_Addr );					s_Addr[s_Addr[0]+1] = 0;						addr1.Zone = -1;			addr1.Net = -1;			addr1.Node = -1;			addr1.Point = -1;			addr1.Domain = NULL;			find_address ( (char *) &s_Addr[1], &addr1 );						if ( addr1.Zone == 0 ||//				 addr1.Net == 0 ||//				 addr1.Node == 0 ||				 addr1.Point == -1 )				iHit = -1;*/			break;					case 2:					break;		}			} while ( iHit != 1 && iHit != 2 );		DisposeDialog ( theDialog );		if ( iHit == 1 )	{/*		addr2.zone = addr1.Zone;		addr2.net = addr1.Net;		addr2.node = addr1.Node;		addr2.point = addr1.Point;*/		addr1.Zone = addr2.zone;		addr1.Net = addr2.net;		addr1.Node = addr2.node;		addr1.Point = addr2.point;		KillManual ( &addr2 );				while (PathForOutbound (&addr1, temp))		{			pStrConc ( temp, requestSuffix, temp2 );						if (FSMakeFSSpec ( 0, 0, temp2, &spec ) == noErr)			{				iHit = Alert (128, NULL);								if (iHit == 1)					break;								FSDelete (temp2, 0);								wasa = true;			}			else				wasa = false;						for (i=0; i<3; i++)			{				pStrConc ( temp, pollModes[i], temp2 );				temp2[temp2[0]+1] = 0;						if (FSOpen (temp2, 0, &attFile))					continue;								if (!wasa)				{					iHit = Alert (128, NULL);										if (iHit == 1)					{						FSClose (attFile);						break;					}										wasa = true;				}								GetEOF (attFile, &cnt);				att = NewHandleClear (cnt);				HLock (att);				zzz = *att;								FSRead (attFile, &cnt, zzz);								for (t = 0; t < cnt; t++)					if (zzz[t] == 0x0D)						zzz[t] = 0;				t = 0;								while (t < cnt)				{					strcpy ( (char *) &temp1[1], zzz+1 );					wannadel = (*zzz) == '-';					temp1[0] = strlen ( (char *) &temp1[1] );					t += temp1[0]+2;					zzz += temp1[0]+2;										pStrCopy ( temp1, temp3 );	// file attach with full pathname										temp3[temp3[0]+1] = 0;							if ( FSMakeFSSpec ( 0, 0, temp3, &spec ) == 0 )						if (wannadel)							FSDelete ( temp3, 0 );		// Clear outbound file by file thats was sent				}				DisposeHandle (att);								FSClose (attFile);								FSDelete ( temp2, 0 );			}			break;		}				RescanOutbound ();	}#if defined(powerc) || defined(__powerc)	DisposeRoutineDescriptor (uupClearFilterProc);#endif}void EditManualPoll (in_outboundPtr do_over){	Str255		s_Addr, s_Phone, s_Pwd;		ADDR		addr1;	addr		addr2;		DialogPtr	theDialog;	short		poll;	Boolean		force;	Handle		iHandle;	short		iType;	Rect		iRect;	short		iHit;		addr		wasa;#if defined(powerc) || defined(__powerc)	UniversalProcPtr	uupPollFilterProc;	uupPollFilterProc = NewRoutineDescriptor ((ProcPtr) ModalEditPollFilterProc, uppModalProcInfo, GetCurrentISA ());#endif		theDialog = GetNewDialog ( 135, NULL, (WindowPtr) -1L );	default_button ( theDialog, 1 );	if (do_over)	{		printaddr ( &do_over->calladdr, (char *) &s_Addr[1] );		s_Addr[0] = strlen ( (char *) &s_Addr[1] );				pStrCopy ( do_over->callphone, s_Phone );				strncpy ( (char *) &s_Pwd[1], do_over->password, 8 );		s_Pwd[9] = 0;		s_Pwd[0] = strlen ( (char *) &s_Pwd[1] );		poll = do_over->poll;		force = do_over->force;		wasa = do_over->calladdr;	}	else	{		wasa.zone = 0;		s_Addr[0] = 0;		s_Phone[0] = 0;		s_Pwd[0] = 0;		poll = 0;		force = false;	}		GetDialogItem ( theDialog, 3, &iType, &iHandle, &iRect );	SetDialogItemText ( iHandle, s_Addr );		GetDialogItem ( theDialog, 4, &iType, &iHandle, &iRect );	SetDialogItemText ( iHandle, s_Phone );		GetDialogItem ( theDialog, 10, &iType, &iHandle, &iRect );	SetDialogItemText ( iHandle, s_Pwd );		GetDialogItem ( theDialog, 5, &iType, &iHandle, &iRect );	SetControlValue ( (ControlHandle) iHandle, (poll & HOLD) ? 1 : 0 );	GetDialogItem ( theDialog, 6, &iType, &iHandle, &iRect );	SetControlValue ( (ControlHandle) iHandle, (poll & DIRECT) ? 1 : 0 );	GetDialogItem ( theDialog, 7, &iType, &iHandle, &iRect );	SetControlValue ( (ControlHandle) iHandle, (poll & CRASH) ? 1 : 0 );	GetDialogItem ( theDialog, 12, &iType, &iHandle, &iRect );	SetControlValue ( (ControlHandle) iHandle, (force) ? 1 : 0 );	do {	#if defined(powerc) || defined(__powerc)		ModalDialog ( uupPollFilterProc, &iHit );#else		ModalDialog ( ModalEditPollFilterProc, &iHit );#endif		switch (iHit)		{		case 1:			// check here address & cbs					GetDialogItem ( theDialog, 3, &iType, &iHandle, &iRect );			GetDialogItemText ( iHandle, s_Addr );					s_Addr[s_Addr[0]+1] = 0;						addr1.Zone = -1;			addr1.Net = -1;			addr1.Node = -1;			addr1.Point = -1;			addr1.Domain = NULL;			find_address ( (char *) &s_Addr[1], &addr1 );						if ( addr1.Zone == 0 ||//				 addr1.Net == 0 ||//				 addr1.Node == 0 ||				 addr1.Point == -1 )				iHit = -1;			break;					case 2:					break;					case 5:					poll = poll ^ HOLD;						GetDialogItem ( theDialog, 5, &iType, &iHandle, &iRect );			SetControlValue ( (ControlHandle) iHandle, (poll & HOLD) ? 1 : 0 );			break;				case 6:					poll = poll ^ DIRECT;						GetDialogItem ( theDialog, 6, &iType, &iHandle, &iRect );			SetControlValue ( (ControlHandle) iHandle, (poll & DIRECT) ? 1 : 0 );			break;				case 7:					poll = poll ^ CRASH;						GetDialogItem ( theDialog, 7, &iType, &iHandle, &iRect );			SetControlValue ( (ControlHandle) iHandle, (poll & CRASH) ? 1 : 0 );			break;				case 12:					force = !force;						GetDialogItem ( theDialog, 12, &iType, &iHandle, &iRect );			SetControlValue ( (ControlHandle) iHandle, (force) ? 1 : 0 );			break;		}			} while ( iHit != 1 && iHit != 2 );		GetDialogItem ( theDialog, 4, &iType, &iHandle, &iRect );	GetDialogItemText ( iHandle, s_Phone );		GetDialogItem ( theDialog, 10, &iType, &iHandle, &iRect );	GetDialogItemText ( iHandle, s_Pwd );		s_Pwd[s_Pwd[0]+1] = 0;		DisposeDialog ( theDialog );		if ( iHit == 1 )	{		addr2.zone = addr1.Zone;		addr2.net = addr1.Net;		addr2.node = addr1.Node;		addr2.point = addr1.Point;			AddManual ( &addr2, s_Phone, s_Pwd, NULL, FALSE,			poll & ((cmp2addrs (&addr2, &wasa)) ? -1 : (HOLD | DIRECT |CRASH)), force );		RescanOutbound ();	}#if defined(powerc) || defined(__powerc)	DisposeRoutineDescriptor (uupPollFilterProc);#endif}void ManualPoll (in_outboundPtr do_over){	Str255		s_Addr, s_Phone, s_Pwd;		ADDR		addr1;	addr		addr2;		DialogPtr	theDialog;	short		poll;	Boolean		force;	Handle		iHandle;	short		iType;	Rect		iRect;	short		iHit;		addr		wasa;#if defined(powerc) || defined(__powerc)	UniversalProcPtr	uupPollFilterProc;	uupPollFilterProc = NewRoutineDescriptor ((ProcPtr) ModalPollFilterProc, uppModalProcInfo, GetCurrentISA ());#endif		theDialog = GetNewDialog ( 132, NULL, (WindowPtr) -1L );	default_button ( theDialog, 1 );	if (do_over)	{		printaddr ( &do_over->calladdr, (char *) &s_Addr[1] );		s_Addr[0] = strlen ( (char *) &s_Addr[1] );				pStrCopy ( do_over->callphone, s_Phone );				strncpy ( (char *) &s_Pwd[1], do_over->password, 8 );		s_Pwd[9] = 0;		s_Pwd[0] = strlen ( (char *) &s_Pwd[1] );		poll = do_over->poll;		force = do_over->force;		wasa = do_over->calladdr;	}	else	{		wasa.zone = 0;		s_Addr[0] = 0;		s_Phone[0] = 0;		s_Pwd[0] = 0;		poll = 0;		force = false;	}		GetDialogItem ( theDialog, 3, &iType, &iHandle, &iRect );	SetDialogItemText ( iHandle, s_Addr );		GetDialogItem ( theDialog, 4, &iType, &iHandle, &iRect );	SetDialogItemText ( iHandle, s_Phone );		GetDialogItem ( theDialog, 10, &iType, &iHandle, &iRect );	SetDialogItemText ( iHandle, s_Pwd );		GetDialogItem ( theDialog, 5, &iType, &iHandle, &iRect );	SetControlValue ( (ControlHandle) iHandle, (poll & HOLD) ? 1 : 0 );	GetDialogItem ( theDialog, 6, &iType, &iHandle, &iRect );	SetControlValue ( (ControlHandle) iHandle, (poll & DIRECT) ? 1 : 0 );	GetDialogItem ( theDialog, 7, &iType, &iHandle, &iRect );	SetControlValue ( (ControlHandle) iHandle, (poll & CRASH) ? 1 : 0 );	GetDialogItem ( theDialog, 12, &iType, &iHandle, &iRect );	SetControlValue ( (ControlHandle) iHandle, (force) ? 1 : 0 );	do {	#if defined(powerc) || defined(__powerc)		ModalDialog ( uupPollFilterProc, &iHit );#else		ModalDialog ( ModalPollFilterProc, &iHit );#endif		switch (iHit)		{		case 1:			// check here address & cbs					GetDialogItem ( theDialog, 3, &iType, &iHandle, &iRect );			GetDialogItemText ( iHandle, s_Addr );					s_Addr[s_Addr[0]+1] = 0;						addr1.Zone = -1;			addr1.Net = -1;			addr1.Node = -1;			addr1.Point = -1;			addr1.Domain = NULL;			find_address ( (char *) &s_Addr[1], &addr1 );						if ( addr1.Zone == 0 ||//				 addr1.Net == 0 ||//				 addr1.Node == 0 ||				 addr1.Point == -1 )				iHit = -1;			break;					case 2:					break;					case 5:					poll = poll ^ HOLD;						GetDialogItem ( theDialog, 5, &iType, &iHandle, &iRect );			SetControlValue ( (ControlHandle) iHandle, (poll & HOLD) ? 1 : 0 );			break;				case 6:					poll = poll ^ DIRECT;						GetDialogItem ( theDialog, 6, &iType, &iHandle, &iRect );			SetControlValue ( (ControlHandle) iHandle, (poll & DIRECT) ? 1 : 0 );			break;				case 7:					poll = poll ^ CRASH;						GetDialogItem ( theDialog, 7, &iType, &iHandle, &iRect );			SetControlValue ( (ControlHandle) iHandle, (poll & CRASH) ? 1 : 0 );			break;				case 12:					force = !force;						GetDialogItem ( theDialog, 12, &iType, &iHandle, &iRect );			SetControlValue ( (ControlHandle) iHandle, (force) ? 1 : 0 );			break;					case 8:		//	invoke addr changer					GetDialogItem ( theDialog, 12, &iType, &iHandle, &iRect );			SetControlValue ( (ControlHandle) iHandle, 0 );			poll = 0;						GetDialogItem ( theDialog, 5, &iType, &iHandle, &iRect );			poll |= (GetControlValue ( (ControlHandle) iHandle) != 0) ? HOLD : 0 ;						GetDialogItem ( theDialog, 6, &iType, &iHandle, &iRect );			poll |= (GetControlValue ( (ControlHandle) iHandle) != 0) ? DIRECT : 0 ;						GetDialogItem ( theDialog, 7, &iType, &iHandle, &iRect );			poll |= (GetControlValue ( (ControlHandle) iHandle) != 0) ? CRASH : 0 ;			break;				case 9:		//	pwd cleaner					break;		}			} while ( iHit != 1 && iHit != 2 );		GetDialogItem ( theDialog, 4, &iType, &iHandle, &iRect );	GetDialogItemText ( iHandle, s_Phone );		GetDialogItem ( theDialog, 10, &iType, &iHandle, &iRect );	GetDialogItemText ( iHandle, s_Pwd );		s_Pwd[s_Pwd[0]+1] = 0;		DisposeDialog ( theDialog );		if ( iHit == 1 )	{		addr2.zone = addr1.Zone;		addr2.net = addr1.Net;		addr2.node = addr1.Node;		addr2.point = addr1.Point;			AddManual ( &addr2, s_Phone, s_Pwd, NULL, FALSE,			poll & ((cmp2addrs (&addr2, &wasa)) ? -1 : (HOLD | DIRECT |CRASH)), force );		RescanOutbound ();	}#if defined(powerc) || defined(__powerc)	DisposeRoutineDescriptor (uupPollFilterProc);#endif}void ChangeFlavorPoll (in_outboundPtr do_over){	Str255		s_Addr, temp, temp2, temp3;	Boolean		wasa1, wasa2;	FSSpec		spec;	ADDR		addr1;//	addr		addr2;		DialogPtr	theDialog;	Handle		iHandle;	short		iType, i;	Rect		iRect;	short		iHit, last1, last2;#if defined(powerc) || defined(__powerc)	UniversalProcPtr	uupClearFilterProc;	uupClearFilterProc = NewRoutineDescriptor ((ProcPtr) ModalClearFilterProc, uppModalProcInfo, GetCurrentISA ());#endif	if (!do_over)	{		SysBeep (10);		return;	}	addr1.Zone = do_over->calladdr.zone;	addr1.Net = do_over->calladdr.net;	addr1.Node = do_over->calladdr.node;	addr1.Point = do_over->calladdr.point;	if (!PathForOutbound (&addr1, temp))	{		SysBeep (10);		return;	}	theDialog = GetNewDialog ( 134, NULL, (WindowPtr) -1L );	default_button ( theDialog, 1 );	wasa1 = false;	wasa2 = false;		for (i=2; i>=0; i--)	{		pStrConc ( temp, pollModes[i], temp2 );				if (FSMakeFSSpec (0, 0, temp2, &spec))		{			GetDialogItem (theDialog, 6+(2-i), &iType, &iHandle, &iRect);			HiliteControl ((ControlHandle) iHandle, 255);			if (!wasa1)			{				GetDialogItem (theDialog, 9+(2-i), &iType, &iHandle, &iRect);				SetControlValue ((ControlHandle) iHandle, 1);				wasa1 = true;				last1 = 9+(2-i);			}		}		else		{			GetDialogItem (theDialog, 9+(2-i), &iType, &iHandle, &iRect);			HiliteControl ((ControlHandle) iHandle, 255);			if (!wasa2)			{				GetDialogItem (theDialog, 6+(2-i), &iType, &iHandle, &iRect);				SetControlValue ((ControlHandle) iHandle, 1);				wasa2 = true;				last2 = 6+(2-i);			}		}	}		iHit = 2;		if (wasa2 && wasa1)	{		printaddr ( &do_over->calladdr, (char *) &s_Addr[1] );		s_Addr[0] = strlen ( (char *) &s_Addr[1] );		GetDialogItem ( theDialog, 3, &iType, &iHandle, &iRect );		SetDialogItemText ( iHandle, s_Addr );		do {			#if defined(powerc) || defined(__powerc)			ModalDialog ( uupClearFilterProc, &iHit );	#else			ModalDialog ( ModalClearFilterProc, &iHit );	#endif			switch (iHit)			{			case 1:			// check here address & cbs							break;							case 2:							break;							case 6:			case 7:			case 8:							GetDialogItem (theDialog, 6, &iType, &iHandle, &iRect);				SetControlValue ((ControlHandle) iHandle, 0);				GetDialogItem (theDialog, 7, &iType, &iHandle, &iRect);				SetControlValue ((ControlHandle) iHandle, 0);				GetDialogItem (theDialog, 8, &iType, &iHandle, &iRect);				SetControlValue ((ControlHandle) iHandle, 0);				GetDialogItem (theDialog, iHit, &iType, &iHandle, &iRect);				SetControlValue ((ControlHandle) iHandle, 1);				last2 = iHit;								break;			case 9:			case 10:			case 11:							GetDialogItem (theDialog, 9, &iType, &iHandle, &iRect);				SetControlValue ((ControlHandle) iHandle, 0);				GetDialogItem (theDialog, 10, &iType, &iHandle, &iRect);				SetControlValue ((ControlHandle) iHandle, 0);				GetDialogItem (theDialog, 11, &iType, &iHandle, &iRect);				SetControlValue ((ControlHandle) iHandle, 0);				GetDialogItem (theDialog, iHit, &iType, &iHandle, &iRect);				SetControlValue ((ControlHandle) iHandle, 1);				last1 = iHit;				break;			}					} while ( iHit != 1 && iHit != 2 );	}		DisposeDialog ( theDialog );		if ( iHit == 1 )	{		pStrConc ( temp, pollModes[2-(last2-6)], temp2 );		pStrConc ( temp, pollModes[2-(last1-9)], temp3 );				if (Rename (temp2, 0, temp3))		{			SysBeep (10);		}				RescanOutbound ();	}#if defined(powerc) || defined(__powerc)	DisposeRoutineDescriptor (uupClearFilterProc);#endif}