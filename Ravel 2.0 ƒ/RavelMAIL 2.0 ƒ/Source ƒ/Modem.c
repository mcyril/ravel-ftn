#include <ctype.h>#include <string.h>#include <stdlib.h>#include <Serial.h>#include "Main.h"//#include "Port.h"#include "Comm.h"#include "Modem.h"#include "Timing.h"#include "Ravel_FTN.h"#include "Ravel_Prefs.h"#include "compatible.h"#include "stringutl.h"#include "ascii.h"//#include "ZMisc.h"#include "log.h"#include "pmain.h"#define	FAILURE		0#define	IGNORE		1#define	CONNECTED	2#define	RINGING		3#define INCOMING	4#define	FAULTCOUNT	5#define	FAULTIMMED	6struct resp_str{    char *resp;    unsigned disp;};unsigned long		cur_baud;extern	Options		Settings;				/* Current options */extern	Str255		init_string;extern	short		CONNECTION;			//	connection mode == port number or -1 for CTBstatic	short		resp_echo = 1;extern	short	isdcd;static struct resp_str mdm_resps[] = {    { "RINGING",        IGNORE },    { "RINGBACK",       IGNORE },    { "RING RESPONSE",  IGNORE },    { "RING",           RINGING },    { "CONNECT",        CONNECTED },    { "V.23 CONNECT",   CONNECTED },    { "RRING",          IGNORE },    { "BUSY",           FAILURE },    { "VOICE",          FAULTIMMED },    { "ERROR",          FAULTIMMED },    { "OK",             FAILURE },    { "NO CARRIER",     FAULTCOUNT },    { "NO DIAL",        FAULTCOUNT },    /* "NO DIAL TONE" or "NO DIALTONE" */    { "DIALING",        IGNORE },    { "NO ANSWER",      FAULTCOUNT },    { "DIAL TONE",      IGNORE },    { NULL,             0 }};/*ееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееее*/static void empty_delay (){    long t;    t = timerset (500);    while ((!OUT_EMPTY ()) && (!timeup (t)))		time_release ();                               /* wait for output to finish */    if (!OUT_EMPTY ())    {//        MDM_DISABLE ();//        (void) Cominit (port_ptr);		RAISE_DTR ();        CLEAR_OUTBOUND ();        CLEAR_INBOUND ();    }}void mdm_cmd_char (short outchr){	switch (outchr)	{	case '-':                                       /* if it's a dash (phone no) */		return;                                      /* ignore it                 */		case '|':                                       /* if the CR character,      */		outchr = CR;                                /* substitute a real CR here */		break;		case '.':                                        /* Substitute ',' for '.'    */				if (!(isdcd & 0xFF00))			outchr = ',';                             /* for compatibility         */		break;		case '~':                                       /* if the "delay" character, */		empty_delay ();                              /* wait for buffer to clear, */		timer (10);                              /* then wait 1 second        */		return;                                      /* and return                */		case '^':                                        /* Raise DTR                 */		empty_delay ();                              /* wait for buffer to clear, */		RAISE_DTR ();                                    /* Turn on DTR               */		return;                                      /* and return                */		case 'v':                                        /* Lower DTR            */		empty_delay ();                              /* wait for buffer to clear, */		LOWER_DTR ();                              /* Turn off DTR              */	return;                                      /* and return                */		case '`':                                        /* Short delay          */		timer (6);                                    /* short pause, .1 second    */		return;                                      /* and return                */		default:		break;	}		SENDBYTE ((unsigned char) outchr, NULL);              /* then write the character  */		if (outchr == CR)                                    /* if it was a CR,       */	{		empty_delay ();		timer (6);                                       /* allow .1 sec line quiet   */	}	else if (TRUE/*slowmodem*/)	{		timer (6);                                       /* wait .1 sec for output    */	}}/*ееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееее*/void mdm_cmd_string (char *mdm_cmd, short dospace){	char	*c;	short	escaped = 0;//	putlog ( '#', mdm_cmd );	if (mdm_cmd == NULL)				/* defense from shit         */		return;	for (c = mdm_cmd; *c; c++)	{		if (escaped)		{			SENDBYTE (*c, NULL);			escaped = 0;			continue;		}		if (*c == '\\')		{			escaped = 1;			continue;		}      		if (!isspace (*c) || dospace)              /* don't output spaces       */			mdm_cmd_char (*c);                      /* output the next character */	}}/*ееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееее*/static char *get_response (long end_time){	static char response_string[128];	char *p = response_string;                      /* points to character cell  */	char c;                                        /* current modem character   */	short count = 0;                                  /* count of characters       */		while ((count < 120)                            /* until we have 120 chars,   */		&& (!timeup (end_time))                     /* or out of time,           */		&& (!CheckCancel ())                           /* or user gets impatient    */        )	{		if (!CHAR_AVAIL ())                             /* if nothing ready yet,     */		{			continue;                                          /* just process timeouts */		}				c = MODEM_IN ();                                /* get a character           */				if (c == '\r' || c == '\n')                     /* if a line ending      */		{			if (count != 0)                                      /* and we have something,    */		        break;                                         /* get out                   */			else				continue;                                    /* otherwise just keep going */		}				*p++ = c;                                         /* store the character       */		++count;                                           /* increment the counter */    }    *p = '\0';                                      /* terminate the new string  *///	if (count != 0 && strncmp (response_string, "AT", 2))//	{//		fancy_str (response_string);                   /* make it pretty            *///		status_line ("#%s", response_string);            /* pop it out on the screen  *///	}    return (response_string);                        /* return the pointer        */}/*ееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееее*/static short parse_response (response)char *response;{    char *p;                                          /* temp character pointer    */    register short i;                                /* array pointer         */    for (i = 0; mdm_resps[i].resp != NULL; i++)    /* scan through array        */    {        p = mdm_resps[i].resp;                     /* point at possible                                                          * response */        if (strncmp (response, p, strlen (p)) == 0)                  /* if a match,         */            return ((short) (mdm_resps[i].disp));              /* return disposition of it  */    }    return IGNORE;                                    /* ignore all unknowns           */}/*ееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееее*///	Obtain text sequence from modemvoid mdm_flush_diagnosis (char *modem_diagnosis){	char			*str;	short			i, j;    long			end_time;					/* holds time at end of 2min */		if (CARRIER)	{		hang_up ();		mdm_hangup ("AT");	}	else	{		CLEAR_INBOUND ();		CLEAR_OUTBOUND ();	}		mdm_cmd_string (modem_diagnosis, 0);    mdm_cmd_char (CR);                          /* terminate the string      */	end_time = timerset (60*30);				/* arm the timeout           */	do {		str = get_response (end_time);		if (!strncmp (str, "OK", 2))			break;				for (i=0, j=0; str[i]; i++)			if (str[i]>=0x20)				str[j++] = str[i];		str[j] = 0;				if (str[0])			putlog ('#', "%s", str);			} while (str[0] && !timeup (end_time));}/*ееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееее*//* * Wait for modem response * ths is time in milliseconds to wait */static short Baud[] = {			/* Baud rates we support */	baud300,					/* 0 */	baud600,					/* 1 */	baud1200,					/* 2 */	baud2400,					/* 3 */	baud4800,					/* 4 */	baud9600,					/* 5 */	baud19200,					/* 6 */	baud38400,					/* 7 */	baud57600					/* 8 */};static unsigned long B[] = {			/* Baud rates we support */	300,		/* 0 */	600,		/* 1 */	1200,		/* 2 */	2400,		/* 3 */	4800,		/* 4 */	9600,		/* 5 */	19200,		/* 6 */	38400,		/* 7 */	57600,		/* 8 */	0};short modem_response (short ths){    unsigned long	baudrate;    long			end_time;					/* holds time at end of 2min */    char			*response = NULL;			/* pointer to modem response */    char			*c;							/* miscellaneous pointer     */    short			result = IGNORE;			/* result code               */    short			i;    short			ring_count = 0;				/* # of RINGING responses    */	Str255			respa;		short			baud;	short			data;	short			parity;	short			stop;	short			setup;//	putlog ( lgNOPE, "modem_response" );//	/* If this modem doesn't differentiate between RING and RINGING *///	if (modemring)//		mdm_resps[0].disp = IGNORE;//	scr_refresh();	end_time = timerset ((long)ths);			/* arm the timeout           */	while ((result == IGNORE)					/* until success or failure, */		&& (!timeup (end_time))					/* or out of time,           */		&& (!CheckCancel ())						/* or user gets impatient    */		)    {  /*   *  See if we've been through this code enough times to reach   *  the user-defined failure threshold. For this purpose,   *  we crudely assume that all IGNORE cases are rings.   *   *  Henry Clark and Ron Bemis get credit for this one.   *///	if (ring_count++ >= ring_tries)//	{//		response = "NO ANSWER";//		(void) fancy_str (response);//		status_line ("#%s", response);//		result = parse_response(response);//		break;//	}  /*   *  We're still here. So get the next modem response    *  (or time out trying).   */		response = get_response (end_time);		/* get a response            */		result = parse_response (response);		/* parse, determine status   */	}	if (response)	{		if (response[0])			putlog ( (resp_echo) ? '&' : '~', "%s", response );		else		{			result = IGNORE;			putlog ( (resp_echo) ? '&' : '~', "Escaped" );		}		strcpy ( (char *) &respa[1], response );		respa[0] = strlen ( (char *) &respa[1] );//		putMessage ( 3, respa );	}		if (result == CONNECTED)					/* Got to be a CONNECT msg   */	{//		mdm_reliable[0] = '\0';					/* Start with nothing        */        if (strncasecmp (response, "connect", 7) == 0)	/* if this is a CONNECT,     */        {//			c = skip_blanks (&response[7]);				/* get past the blanks       */						for ( c = &response[7]; *c && isspace (*c); ++c );						if (*c == '\0')								/* if nothing there,         */			{				baudrate = (unsigned long) 300;			/* say that it's 300 baud    */			//				putlog ('~', "say that it's 300 (0) baud");			}			else			{				baudrate = (unsigned long) atol (c);	/* else do baudrate fallback */			//				putlog ('~', "say that it's %ld baud", baudrate);				/* For 1200/75 split speed modems and "Connect 212" */								if ((baudrate == 1275) || (baudrate == 7512)				||  (baudrate == 75) || (baudrate == 212) || (baudrate == 12))					baudrate = 1200;								/* For "Connect 103" */				if (baudrate == 103)					baudrate = 300;			}						cur_baud = baudrate;//			putlog ('~', "current %ld baud", cur_baud);			/*ееееееееееееееееееееееееееееееееееееееееееееееееееееееееее*/			if (!(Settings.lockPort & 0x0F))			{				for ( i=0; B[i]; i++ )				{					if (cur_baud <= B[i])					{//						putlog ('~', "adjust to %ld baud", B[i]);						SerialGetSetup ( Settings.portSetup, &baud, &data, &parity, &stop );						SerialSetSetup ( i, data, parity, stop, &setup );						SerialReset (setup);						break;					}				}								if (!B[i])					SerialReset (Settings.portSetup);			}	//		if (baudrate) {	//			if (!lock_baud)	//				set_baud (baudrate, 1);	//			else	//				cur_baud = baudrate;	//		}        }	//	else	//		if(strncasecmp(response, "v.23", 4) == 0)	//		{	//			baudrate = 1200;	//			set_baud (baudrate, 1);	//			mdm_reliable[0] = 0;	//			/* can_Janus(mdm_reliable); */	//		}	//	MNP_Filter ();	}	if (CHAR_AVAIL())		MODEM_IN ();    return (result);                                  /* timeout or failure or OK  */}/*ееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееее*/short dial_modem (char *number){	short		resp;//	char		translated[50];	char		current_phone_list[50] = "";//	char		phone_cut[50];//	char		*current_phone, *next_phone;//	Boolean		avoid_loop;	if (CONNECTION >= 0)	{		if (Settings.lockPort & 0xF0)		    mdm_cmd_string ( "ATDT", 0);				/* transmit the dial prefix  */	    else	    	mdm_cmd_string ( "ATDP", 0);				/* transmit the dial prefix  */	    mdm_cmd_string ( number, 0);				/* then the phone number     */	    mdm_cmd_string ( "", 0);					/* finally the dial suffix   */	    mdm_cmd_char (CR);                          /* terminate the string      */	    resp = modem_response (7000);			// 900 - 1.5min, 7500 - 12min???	}	else	{		if (CONNECTION == -1)			resp = MakeCMOpen (number);		else			if (CONNECTION == -2)				resp = MakeTCPOpen (number);			else			{				putlog (lgALRT, "Big bad error - no such connection method (impossible situation).");				resp = FAULTIMMED;			}	}	    return (resp);									/* no good */}/*ееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееее*//*void send_break (short t){	long t1;		t1 = timerset ((long)t);	//	do_break (1);//	TIOCSBRK		while (!timeup (t1))	    time_release ();	//	do_break (0);//	TIOCCBRK}*/void hang_up (){	long t;		t = timerset(120);  /* max 2 seconds */	LOWER_DTR ();	while (CARRIER && !timeup(t))		time_release ();		timer(5);	CLEAR_INBOUND ();}void mdm_hangup (char *a_string){    /*    * First, if a dial command is in progress, try to get the modem to abort    * it...        */		CLEAR_OUTBOUND ();	CLEAR_INBOUND ();	RAISE_DTR ();	timer (30);								/* Wait another .5 sec       */	if (CONNECTION < 0)		return;	SerialReset (Settings.portSetup);	if (a_string)		mdm_init (a_string+1);	/* re-initialize the modem   */	else	{		init_string[init_string[0]+1] = 0;		mdm_init ( (char *) &init_string[1] );	/* re-initialize the modem   */	}	timer (30);								/* Wait another .5 sec       *///	resp_echo = 0;//	modem_response (120);//	resp_echo = 1;	CLEAR_INBOUND ();						/* then flush input and exit */}void mdm_init (char *str){//	putlog (lgNOPE, "+ modem init╔");	CLEAR_OUTBOUND ();	CLEAR_INBOUND ();	//	hang_up ();	if (CONNECTION < 0)	{		RAISE_DTR ();					/* Raise DTR,                */		return;	}		mdm_cmd_char (CR);				/* output a CR, then         */	RAISE_DTR ();					/* Raise DTR,                */	timer (30);						/* Then hold it up for .5 sec *///	modem_response (60);	mdm_cmd_char (' ');				/* output a space            */	mdm_cmd_char (CR);				/* then another CR           *///	modem_response (60);		if (!str)	{		init_string[init_string[0]+1] = 0;		putlog ('~', "%s", (char *) &init_string[1]);		mdm_cmd_string ( (char *) &init_string[1], 0 );	/* re-initialize the modem   */	}	else	{		putlog ('~', "%s", str);		mdm_cmd_string (str, 0);		/* then the modem init string */	}		mdm_cmd_char (CR);				/* then another CR           */	timer (60);						/* Hold DTR for 1 sec more  */	resp_echo = 0;	modem_response (120);	resp_echo = 1;	CLEAR_INBOUND ();				/* then flush input and exit *///	RAISE_DTR ();//	putlog (lgNOPE, "- modem init╔");}