#include <stdio.h>#include <ctype.h>#include <string.h>//#include "Port.h"#include "Comm.h"#include "Timing.h"#include "Ravel_FTN.h"#include "Ravel_Prefs.h"#include "myEnv.h"#include "wazoo.h"#include "compatible.h"#include "addresses.h"#include "Pathes.h"#include "zm.h"#include "stringutl.h"#include "ascii.h"#include "log.h"#include "aglcrc.h"#include "YooHoo.h"#include "Scheduler.h"#include "Unattended.h"#include "pmain.h"#include "busy.h"#include "history.h"extern short		remote_capabilities;extern long			freq_event_mask;extern	homeHndl		homesystem;			//	¥	Home system structextern	short			NodesNumber;		//	¥	Linked Nodes structs listextern	nodePrefHndl	*nodesHndls;extern ADDR			remote_addr;extern ADDR			called_addr;extern char			*session_password;extern short		current_aka;extern	char	YesZedZip;extern	char	YesZedZap;extern	char	YesJanus;extern	char	YesHydra;extern	short	CONNECTION;			//	connection mode == port number or -1 for CTBextern	Boolean	Aborted;Boolean haspassword ( ADDR *addr, char **pass );Boolean check_no_protocol ( ADDR *called_addr, long protocol );short	matchaka ( ADDR *addrs );/*--------------------------------------------------------------------------*//* SEND HELLO PACKET                                                        *//*--------------------------------------------------------------------------*/static short Send_Hello_Packet (Boolean Sender){	short			i;	struct _Hello	Hello;	char			*sptr;	long			response_timer;	unsigned short	crc;	short			num_errs = 0;	short			can_do_domain = 0;	short			capabilities;	char			tmp[280];	daddr			tmpaddr;	//	ADDRESS			*ad = &alias[assumed];	/*--------------------------------------------------------------------*/	/* Setup HELLO structure                                              */	/*--------------------------------------------------------------------*///	putlog ( lgNOPE, "Creating outgone Hello packet" );	memset ((char *) &Hello, 0, sizeof (struct _Hello));	Hello.signal = endshort('o');	Hello.hello_version = endshort(1);//	if (PRODUCT_LO == 0)//		Hello.product = -1;//	else		Hello.product = endshort((PRODUCT_HI << 8) | PRODUCT_LO);	Hello.product_maj = endshort(MAJOR_VRS);	Hello.product_min = endshort(MINOR_VRS);	(*homesystem)->sysop[(*homesystem)->sysop[0]+1] = 0;	strncpy (Hello.sysop, (char *) &(*homesystem)->sysop[1], 19);	Hello.sysop[19] = '\0';//	putlog ( lgNOPE, "SysOp: %s", Hello.sysop );	tmpaddr = (current_aka == 0) ? (*homesystem)->mainAddr : (*homesystem)->AKAAddr[current_aka-1];	Hello.my_zone = endshort(tmpaddr.ad.zone);	Hello.my_net = endshort(tmpaddr.ad.net);	Hello.my_node = endshort(tmpaddr.ad.node);	Hello.my_point = endshort(tmpaddr.ad.point);//	putlog ( lgNOPE, "Address: %s", printaddr ( &tmpaddr.ad, tmp ) );		capabilities = Y_DIETIFNA;	if (YesZedZip &&		(!Sender || (Sender && !check_no_protocol (&called_addr, NODE_NOZEDZIP))))		capabilities |= ZED_ZIPPER;	if (YesZedZap &&		(!Sender || (Sender && !check_no_protocol (&called_addr, NODE_NOZEDZAP))))		capabilities |= ZED_ZAPPER;#ifndef LITE	if (YesHydra &&		(!Sender || (Sender && !check_no_protocol (&called_addr, NODE_NOHYDRA))))		capabilities |= DOES_HYDRA;	if (YesJanus &&		(!Sender || (Sender && !check_no_protocol (&called_addr, NODE_NOJANUS))))		capabilities |= DOES_IANUS;#endif//	can_do_domain = alias[0].ad.Domain ? DO_DOMAIN : 0;	can_do_domain = 0;	if (!Sender)	{		can_do_domain = remote_capabilities & can_do_domain;		if (remote_capabilities & capabilities & DOES_HYDRA)			capabilities = DOES_HYDRA;		else			if (remote_capabilities & capabilities & DOES_IANUS)				capabilities = DOES_IANUS;			else				if (remote_capabilities & capabilities & ZED_ZAPPER)					capabilities = ZED_ZAPPER;				else					if (remote_capabilities & capabilities & ZED_ZIPPER)						capabilities = ZED_ZIPPER;					else						capabilities = Y_DIETIFNA;	}	(*homesystem)->system[(*homesystem)->system[0]+1] = 0;	strcpy (tmp, (char *) &(*homesystem)->system[1]);		switch (CONNECTION)	{	case -1:			strcat (tmp, " (CTB Line)");			// ********* +++ sysname		break;		case -2:			strcat (tmp, " (IP Line)");			// ********* +++ sysname		break;		default:			break;	}	strncpy (Hello.my_name, tmp, 58);	Hello.my_name[58] = '\0';//	putlog ( lgNOPE, "Station: %s", Hello.my_name );	capabilities |= can_do_domain;//	if (can_do_domain)//	{//		if (strlen (system_name) + strlen (alias[assumed].ad.Domain) > 57)//		{//			Hello.my_name[57 - strlen (alias[assumed].ad.Domain)] = '\0';//		}//	//		sptr = Hello.my_name + strlen (Hello.my_name) + 1;//		strcpy (sptr, alias[assumed].ad.Domain);//	}	if (session_password)	{		strncpy ((char *)Hello.my_password, session_password, 8);	}//	if ((matrix_mask & TAKE_REQ) && (DEFAULT.rq_OKFile != NULL) && //				(!Sender || check_reqonus(&remote_addr)) )//		capabilities |= WZ_FREQ;#ifndef LITE	if (CheckEventNow (freq_event_mask))		capabilities |= WZ_FREQ;#endif	Hello.capabilities = endshort(capabilities);	/*--------------------------------------------------------------------*/	/* Disable handshaking and ^C/^K handling                             */	/*--------------------------------------------------------------------*///	XON_DISABLE ();	/*--------------------------------------------------------------------*/	/* Send the packet.                                                   */	/* Load outbound buffer quickly, and get modem busy sending.          */	/*--------------------------------------------------------------------*/xmit_packet:	SENDBYTE (0x1f, NULL);	sptr = (char *) &Hello;	SENDCHARS ((unsigned char *) sptr, 128, 1, NULL);		// ", 1" was	//	putlog ( lgNOPE, "Hello sent." );		/*--------------------------------------------------------------------*/	/* Calculate CRC while modem is sending its buffer                    */	/*--------------------------------------------------------------------*/	for (crc = i = 0; i < 128; i++)	{		crc = xcrc (crc, (Byte) sptr[i]);	}//was//		CLEAR_INBOUND ();		SENDBYTE ((Byte) (crc >> 8), NULL);	SENDBYTE ((Byte) crc, NULL);		response_timer = timerset (4000);	while (!timeup(response_timer) && CARRIER)	{		if (!CHAR_AVAIL ())		{			if (CheckCancel ())			{	//			hang_up ();	//			sptr  = msgtxt[M_KBD_MSG];				goto no_response;			}				time_release ();			continue;		}		switch (i = Z_GetByte (0))		{		case ACK:			putlog ( '~', "SHP: Got 'ACK'" );			return (1);				case '?':		case ENQ:				putlog ( '~', "SHP: Got 'ENQ' or '?'" );			if (++num_errs == 2)			{				goto no_response;			}					goto xmit_packet;				default:					if (i > 0)                   /* Could just be line noise */			{//			putlog ( lgATTN, "Gotta 'noise'" );			}						break;		}	}//	if (!CARRIER)//		sptr = &(msgtxt[M_NO_CARRIER][1]);//	else//		sptr  = msgtxt[M_TIMEOUT];	//	putlog ( lgATTN, "timeout" );no_response:		putlog ( lgATTN, "No response" );	Aborted = true;//	message (sptr);	return (0);}                                                /* Send Hello *//*--------------------------------------------------------------------------*//* RECEIVE HELLO PACKET                                                     *//*--------------------------------------------------------------------------*/static short Recv_Hello_Packet (Boolean Sender){	short			i;	short			c;	short			j;	struct _Hello	Hello;	char			*sptr, *p;	Byte			num_errs = 0;	unsigned short	crc;	Byte			lsb;	Byte			msb;	long			master_timeout, hello_timeout;//	char			junkbuff[128];	short			capabilities;		sptr = NULL;	/*--------------------------------------------------------------------*/	/* Get the Hello structure                                            */	/*--------------------------------------------------------------------*/	//	putlog ( lgATTN, " + Recv_Hello_Packet" );	big_pause (1);                             /* Wait for quiet. */	//	if (un_attended && fullscreen)//	{//		sb_move (filewin, 2, 2);//		sb_puts (filewin, "YooHoo/2U2");//		sb_show ();//	}//	else//	{//		set_xy ("YooHoo/2U2 ");//		scr_refresh();//	}		putMessage ( 2, "\pYooHoo/2U2" );	SENDBYTE (ENQ, NULL);                               /* Let the other system know	                                          * we heard YooHoo. */	master_timeout = timerset (12000);		/* No more than 2 mins! */watch_for_header://	putlog ( lgATTN, "watch for header" );	while (1)	{		if (sptr)		{//			message (sptr);			sptr = NULL;		}			if ((c = Z_GetByte (20)) == 0x1f)			break;			if (CheckCancel ())		{//			sptr = msgtxt[M_KBD_MSG];			goto receive_failed;		}			if (!CARRIER)		{//			sptr = &(msgtxt[M_NO_CARRIER][1]);			goto receive_failed;		}			if (timeup(master_timeout))			goto timeout;				if (c >= 0)                               /* noise? */		{			hello_timeout = timerset (1000);       /* Look for up to 10 secs  */						while (CARRIER)			{				if ( CHAR_AVAIL() )				{					c = MODEM_IN ();										if (c == 0x1f)						break;				}								if (CheckCancel ())				{		//			sptr = msgtxt[M_KBD_MSG];					goto receive_failed;				}				if (timeup(hello_timeout))					break;			}			if (c != 0x1f)                         /* If we didn't get YooHoo */			{				CLEAR_INBOUND ();                   /* Throw out what we have  */				SENDBYTE (ENQ, NULL);                     /* Start over with ENQ     */			}			else				break;		}	}												/* while *//*receive_packet:*///	putlog ( lgATTN, "receive packet" );	sptr = (char *) (&Hello);	hello_timeout = timerset (3000);		for (i = 0, crc = 0; i < 128; i++)	{		while (!CHAR_AVAIL ())		{			if (timeup (master_timeout) || timeup (hello_timeout))				goto timeout;				if (CheckCancel ())			{	//			sptr = msgtxt[M_KBD_MSG];				goto receive_failed;			}				if (!CARRIER)			{	//			sptr = &(msgtxt[M_NO_CARRIER][1]);				goto receive_failed;			}						time_release ();		}				c = Z_GetByte (0);				sptr[i] = c;		crc = xcrc (crc, (Byte) c);			}	if (!CARRIER)	{//		sptr = &(msgtxt[M_NO_CARRIER][1]);		goto receive_failed;	}		if (((i = Z_GetByte (10)) < 0) || ((j = Z_GetByte (10)) < 0))	{//		sptr = msgtxt[M_SHRT_MSG];		putlog ( lgATTN, "YooHoo receive failed" );		goto hello_error;	}	msb = i;	lsb = j;//	putlog ( lgATTN, "checking crc" );		if (((msb << 8) + lsb) == crc)		goto process_hello;			putlog (lgALRT, "Bad packet CRC, retry.");//	sptr = msgtxt[M_CRC_MSG];hello_error://	putlog ( lgATTN, "Hello error" );	if (timeup(master_timeout))		goto timeout;		if ((num_errs++) > 2)	{//		sptr = msgtxt[M_FUBAR_MSG];		goto receive_failed;	}		CLEAR_INBOUND ();	SENDBYTE ('?', NULL);	goto watch_for_header;process_hello://	putlog ( lgATTN, "process hello" );		/* The idea for removing junk characters came from Holger Schurig */	/* Get rid of junk characters */	for (p = Hello.my_name; *p != '\0'; p++)		if (*p < ' ')			*p = ' ';		/* Get rid of junk characters */	for (p = Hello.sysop; *p != '\0'; p++)		if (*p < ' ')			*p = ' ';		remote_addr.Zone = endshort(Hello.my_zone);	remote_addr.Net = endshort(Hello.my_net);	remote_addr.Node = endshort(Hello.my_node);	remote_addr.Point = endshort(Hello.my_point);		{		addr	tad;				tad.zone = remote_addr.Zone;		tad.net = remote_addr.Net;		tad.node = remote_addr.Node;		tad.point = remote_addr.Point;		history_add_address (&tad);		if (!Sender || (Sender && !cmp2addrs1 (&tad, &called_addr)))			if (bsy_raise (&tad, workPath))			{				Aborted = true;				return (0);			}		//		bsy_raise (&tad, workPath);	}	putlog ( lgNOPE, "Address:     %d:%d/%d.%d",		remote_addr.Zone, remote_addr.Net, remote_addr.Node, remote_addr.Point );		capabilities = endshort(Hello.capabilities);	//	if ((capabilities & DO_DOMAIN) && alias[0].ad.Domain)//	{//		remote_addr.Domain = find_domain (&(Hello.my_name[strlen (Hello.my_name) + 1]));//	}	/*	 * Try to convert silly 3D address into 4D address if net is one of	 * our fakenets	 */	//	if(remote_addr.Point == 0)//		make4d(&remote_addr);	if (strlen (Hello.my_name) > 42)		Hello.my_name[42] = '\0';		Hello.sysop[19] = '\0';	if ( endshort (Hello.product) < 0 )		putlog ( lgNOPE, "Remote uses: Unknown Version %d.%d",					endshort(Hello.product_maj), endshort(Hello.product_min) );	else	{		Str255		pname;				if ((endshort (Hello.product) & 0x00FF) == 0x00FF)			GetIndString ( pname, 6, (endshort (Hello.product) >> 8)+1 );		else			GetIndString ( pname, 5, endshort (Hello.product)+1 );		if (pname[0])			putlog ( lgNOPE, "Remote uses: %#s [#%.4X] Version %d.%d", pname, endshort (Hello.product),						endshort(Hello.product_maj), endshort(Hello.product_min) );		else			putlog ( lgNOPE, "Remote uses: Unknown [#%.4X] Version %d.%d", endshort (Hello.product),						endshort(Hello.product_maj), endshort(Hello.product_min) );	}		putlog ( lgNOPE, "System:      %s", Hello.my_name );	putlog ( lgNOPE, "SysOp:       %s", Hello.sysop );	remote_capabilities = (capabilities) | Y_DIETIFNA;	//	if (nodefind (&remote_addr, 0) && !remote_addr.Zone)//		remote_addr.Zone = found_zone;	//	sprintf (junkbuff, "*%s (%s)",//									Hello.my_name,//									Pretty_Addr_Str (&remote_addr));//	status_line (junkbuff);	//	log_product (endshort(Hello.product.w),//					endshort(Hello.product_maj.w),//					endshort(Hello.product_min.w));//	if (Hello.sysop[0])//		status_line (msgtxt[M_EMSI_SYSOP], Hello.sysop);	if (!Sender)	{		char	*pass;					session_password = NULL;		if (haspassword (&remote_addr, &pass))									//	link present		{			if (pass[0])														//	pwd for link present			{				if (!strncasecmp (pass,(char *)Hello.my_password,6))	//	yep remote && equal					session_password = pass;				else					goto receive_failed;			}		}//																	//	no this link	}/*	if(!Sender && session_password)	{		if (strncmp (session_password, (char *)Hello.my_password, 8))			goto receive_failed;	}*///	if((j = n_password(&remote_addr, (char *)Hello.my_password, TRUE)) != 0)//	{//		if (j == 1 || (j == 2 && !Sender))//		{//			hang_up ();//			sptr = NULL;                           /* Already logged something *///			goto receive_failed;//		}//		else//		{//			status_line (msgtxt[M_PASSWORD_OVERRIDE]);//		}//	}	CLEAR_INBOUND ();	SENDBYTE (ACK, NULL);	SENDBYTE (YOOHOO, NULL);	return (1); timeout://	sptr = msgtxt[M_TIMEOUT];receive_failed://	message (sptr);//	b_init ();	Aborted = true;	return (0);}                                               /* Recv Hello *//*--------------------------------------------------------------------------*//* YOOHOO SENDER    (used when I am the CALLING system)                     *//*--------------------------------------------------------------------------*/short YooHoo_Sender (void){//	char	*sptr;	//	putlog ( lgATTN, " + YooHoo_Sender" );//	if (un_attended && fullscreen)//	{//		sb_move (filewin, 2, 2);//		sb_puts (filewin, "YooHoo");//		sb_show ();//	}//	else//	{//		set_xy ("YooHoo ");//		scr_refresh();//	}		putMessage ( 2, "\pYooHoo" );	/*--------------------------------------------------------------------*/	/* Clean up any mess that may be around                               */	/*--------------------------------------------------------------------*/	CLEAR_OUTBOUND ();	CLEAR_INBOUND ();//	XON_DISABLE ();		if (!Send_Hello_Packet (1))	{//		sptr = msgtxt[M_HE_HUNG_UP];		putlog ( lgATTN, "Can't send Hello packet." );	}	else	{//		putlog ( lgATTN, "Hello packet sent. Try establish" );		if (Z_GetByte (30) == YOOHOO)			return Recv_Hello_Packet (1);			putlog ( lgATTN, "Can't receive Hello packet." );//		status_line (msgtxt[M_NOYOOHOO]);//		sptr = IDUNNO_msg;	}		Aborted = true;	//	message (sptr);	return (0);}/*--------------------------------------------------------------------------*//* YOOHOO RECEIVER  (Used when I am the CALLED system)                      *//*--------------------------------------------------------------------------*/short YooHoo_Receiver (void){	short	i;	short	c;//	char	buf[10];	//	if (un_attended && fullscreen)//	{//		sb_move (filewin, 2, 2);//		sb_puts (filewin, "YooHoo");//		sb_show ();//	}//	else//	{//		set_xy ("YooHoo ");//		scr_refresh();//	}		putMessage ( 2, "\pYooHoo" );	/*--------------------------------------------------------------------*/	/* Clean up any mess that may be around                               */	/*--------------------------------------------------------------------*/	CLEAR_OUTBOUND ();	CLEAR_INBOUND ();//	XON_DISABLE ();		if (!(i = Recv_Hello_Packet(0)))	{		Aborted = true;		return (0);	}		for (i = 0; (CARRIER) && (i < 2); i++)	{		if ((c = Z_GetByte (10)) == ENQ)		{			current_aka = matchaka (&remote_addr);			if (Send_Hello_Packet (0))				return 1;			else			{				Aborted = true;				return 0;			}		}		//			return Send_Hello_Packet (0) ? 1 : (b_init (), 0);			if (c > 0)		{//			message (NULL);//			sprintf (buf, "[%x] ", c);//			scr_printf (buf);			/* Delay one second, then try again */				big_pause (1);				CLEAR_INBOUND ();		}			SENDBYTE (YOOHOO, NULL);	}	//	message (msgtxt[M_FUBAR_MSG]);//	b_init ();	Aborted = true;		return (0);	}                                                /* YooHoo Receiver */