#include <ctype.h>#include <string.h>#include <stdio.h>//#include "Port.h"#include "Comm.h"#include "Timing.h"#include "aglcrc.h"#include "EMSI.h"#include "ascii.h"#include "ftsc.h"#include "wazoo.h"#include "state.h"#include "Session.h"#include "Ravel_FTN.h"#include "Ravel_Prefs.h"#include "Pathes.h"#include "compatible.h"#include "addresses.h"#include "stringutl.h"#include "log.h"#include "zm.h"#include "zmodem.h"#include "hydra_chat.h"#include "janus_chat.h"#include "clasp.h"#include "zfiles.h"#include "pmain.h"#include "Main.h"#include "PascalStr.h"#include "key.h"#include "Scheduler.h"#include "Unattended.h"#include "Attacher.h"#include "freq.h"#include "busy.h"#include "history.h"extern	homeHndl		homesystem;			//	е	Home system structextern	short			NodesNumber;		//	е	Linked Nodes structs listextern	nodePrefHndl	*nodesHndls;Boolean	cantdo_EMSI = FALSE;			/* Local EMSI disable for this session */Boolean	cantdo_WaZOO = FALSE;			/* Local WaZOO disable for this session */extern	short	no_EMSI;				/* Global EMSI disable */extern	short	no_WaZOO;				/* Global WaZOO/YooHoo disable */extern	char	YesZedZip;extern	char	YesZedZap;extern	char	YesDirZap;extern	char	YesJanus;extern	char	YesHydra;extern	char	YesClasp;extern	char	YesxHydra;		//ееextern	short	xHydraPhase;	//ееextern	char	YesHydra8K;extern	char	YesHydra16K;extern	short	no_sealink;//long			BBStimeout = 10*60;		/* 15s BBS timeout... let debug 10s */extern	tsend	tobesend;extern	unsigned char	timesyncbounds;extern	short			timesynclink;extern short		Rxtimeout;			/* Tenths of seconds to wait for something */extern unsigned long	cur_baud;extern ADDR			remote_addr;extern ADDR			called_addr;extern ADDR_LIST	remote_ads;extern char			*session_password;extern short		thy_request;				//	reote made file requestextern short		we_request;				//	we made file requestextern long			freq_event_mask;extern short		got_arcmail;extern short		got_packet;extern short		Netmail_Session;extern short		isOriginator;extern short		sent_mail;extern short		mail_finished;extern short		remote_capabilities;extern Boolean		Aborted;extern Boolean		dos_names;extern	short		current_aka;extern	short		CONNECTION;			//	connection mode == port number or -1 for CTBextern	short		tmail_chat;extern	long		joho;		short		mail_only = true;static	char		exhibit_pass[64];/* * define the packet strings */#define EMSI_IDLEN 14char *emsi_pkt[] = {    "**EMSI_INQ",    "**EMSI_REQ",    "**EMSI_CLI",    "**EMSI_HBT",    "**EMSI_DAT",    "**EMSI_ACK",    "**EMSI_NAK",    NULL};static char	*mnt[12] = { "Jan", "Feb", "Mar",						 "Apr", "May", "Jun",						 "Jul", "Aug", "Sep",						 "Oct", "Nov", "Dec" };//	static unsigned long	TimeDestructSec = 0xAEEF5980L ^ 0x5A5A5A5AL;#define EMSI_INQ 0#define EMSI_REQ 1#define EMSI_CLI 2#define EMSI_HBT 3#define EMSI_DAT 4#define EMSI_ACK 5#define EMSI_NAK 6#define MAX_DATLEN 4096         /* Maximum size of EMSI_DAT packet */Boolean haspassword ( ADDR *addr, char **pass );Boolean check_no_protocol ( ADDR *called_addr, long protocol );short	matchaka ( ADDR *addrs );short	getlinkinx ( ADDR *addrs );tsend	*calcoutbound (ADDR *addr);static Boolean check_no_emsi ( ADDR *called_addr ){	Boolean		res = false;	short		i;			//	return false if EMSI is possible for this node...	if (!called_addr)		return false;	for ( i=0; i<NodesNumber; i++ )	{		if ( (*(nodesHndls[i]))->Addr.zone == called_addr->Zone &&		 	 (*(nodesHndls[i]))->Addr.net == called_addr->Net &&		 	 (*(nodesHndls[i]))->Addr.node == called_addr->Node &&		 	 (*(nodesHndls[i]))->Addr.point == called_addr->Point )		{			res = ((*(nodesHndls[i]))->nodeflags & NODE_NOEMSI) != 0;			break;		}	}		return res;}static Boolean check_no_yoohoo ( ADDR *called_addr ){	Boolean		res = false;	short		i;			//	return false if EMSI is possible for this node...	if (!called_addr)		return false;	for ( i=0; i<NodesNumber; i++ )	{		if ( (*(nodesHndls[i]))->Addr.zone == called_addr->Zone &&		 	 (*(nodesHndls[i]))->Addr.net == called_addr->Net &&		 	 (*(nodesHndls[i]))->Addr.node == called_addr->Node &&		 	 (*(nodesHndls[i]))->Addr.point == called_addr->Point )		{			res = ((*(nodesHndls[i]))->nodeflags & NODE_NOYOOHOO) != 0;			break;		}	}		return res;}Boolean check_no_protocol ( ADDR *called_addr, long protocol ){	Boolean		res = false;	short		i;			//	return false if EMSI is possible for this node...	if (!called_addr)		return false;	for ( i=0; i<NodesNumber; i++ )	{		if ( (*(nodesHndls[i]))->Addr.zone == called_addr->Zone &&		 	 (*(nodesHndls[i]))->Addr.net == called_addr->Net &&		 	 (*(nodesHndls[i]))->Addr.node == called_addr->Node &&		 	 (*(nodesHndls[i]))->Addr.point == called_addr->Point )		{			res = ((*(nodesHndls[i]))->nodeflags & protocol) != 0;			break;		}	}		return res;}/* * Check incomming character for completion of EMSI packet name * * Return: *  -1 : no completion *  0..5 : EMSI_type * * buf must be at least EMSI_IDLEN+1 bytes and the 1st element initialised * to 0 before first call. * * This could be simplified by making it modal, i.e.: *  if(c == '*') *    c = modem_in *    if(c == '*') *      read 8 bytes *      compare to emsi_packet sequences *      read 4 byte CRC * * However this may cause the calling routine to miss characters particularly * if any external mailer strings have '**' in them, etc... */static short check_emsi(char c, char *buf){    char		*s;    long		l;    char		**id;    short			n;    /* Add character to end of buffer */    s = buf;    while(*s)        s++;    *(s++) = c & 0x7f;    *s = 0;    /* Compare to Packet ID's */    l = strlen (buf);    if(l == EMSI_IDLEN)     /* Enough for full ID name + crc16 or len16 */    {        id = emsi_pkt;        n = 0;        while(*id)        {            if(strncmp(*id, buf, 10) == 0)            {                unsigned short	crc;                unsigned short	val;                unsigned long	l_l;                buf[0] = 0;     /* Clear buffer to restart next time */                if(sscanf(&buf[10], "%04lx", &l_l) != 1)/* read hex-value */                    return -1;								val = l_l;				                if(n != EMSI_DAT)                {                    crc = crc_block((unsigned char *)buf+2, 8);                    if(crc != val)                    {                 //     status_line("+%s %s (CRC=%04x, VAL=%04x)", msgtxt[M_CRC_MSG], buf+2, crc, val);                        return -1;                    }                    else                        return n;                }                else                    return n;            }            n++;            id++;        }        /* should never get here... */        buf[0] = 0;        return -1;    }    /*     * We get here if we have less than 14 characters or it doesn't match     * any of the packet types     *     * Shift buffer along to 1st possible match     *     * This probably doesn't need to be this complex, but I want to make     * it handle all cases, e.g.     *   ***EMSI_REQ      : must ignore the 1st * instead of resetting at the 3rd     *   **EMS**EMSI_REQ  : Must not reset at the 2nd group of '*'.     *     * In fact we could probably assume that all sequences start at the     * start of a line (except for the double EMSI_INQ sent during initialisation     */    l = strlen(buf);    if(l <= 10)         /* Any bigger than 10 and we are into the <crc16> and must have already matched */    {        s = buf;        while(l)        {            id = emsi_pkt;            while(*id)            {                if(strncmp(*id, s, l) == 0)                {                    if(s != buf)                        strcpy(buf, s);                    return -1;                }                id++;            }            l--;            s++;        }        buf[0] = 0;     /* No matches */    }    return -1;}static char hex[16] = { '0','1','2','3','4','5','6','7','8','9','A','B','C','D','E','F' };static short put_hex(unsigned short val){	SENDBYTE (hex[(val >> 12) & 0xf], NULL);	SENDBYTE (hex[(val >>  8) & 0xf], NULL);	SENDBYTE (hex[(val >>  4) & 0xf], NULL);	SENDBYTE (hex[ val        & 0xf], NULL);		return 0;}static short byte_to_hex(short c){    c = toupper (c);    c -= '0';    if (c > 9)        c -= ('A' - '9' - 1);    return c;}static short send_string(char *s){    while(*s)        SENDBYTE(*(s++), NULL);    return 0;}static short send_emsi(short type, Boolean cr){    char *s = emsi_pkt[type];    unsigned short crc;    send_string(s);    if(type != EMSI_DAT)    {        crc = 0;        s += 2;     /* Skip over "**" */        while(*s)	    crc = xcrc (crc, (char)*(s++));        put_hex(crc);        if(cr)            SENDBYTE('\r', NULL);    }//	SENDBYTE(XON);		//	ееееееееее WATCH IT ! ееееееееееееееее	return 0;}/* * Initiate call and return type of session unless its EMSI in which * case it goes ahead and does it! *//*  State table for TxEmsi: This is the 1st table I've ever written  state|function     Conditions                Actions                next /-----+------------+------------------------+--------------------------+------\ | TS0 | WhackInit  |                        | Start 10 second timer    |      | |     |            |                        | Init Line buffer         | TS1  | +-----+------------+------------------------+--------------------------+------+ | TS1 | WhackCR    | 1. Timer expired       | Nobody Home              | exit | |     |            +------------------------+--------------------------+------+ |     |            | 2. Lost carrier        | Lost Carrier             | exit | |     |            +------------------------+--------------------------+------+ |     |            | 3. Something received  | Someone home             | TS2  | |     |            +------------------------+--------------------------+------+ |     |            | 4. Nothing received    | Send <CR>, wait 1 sec    | TS1  | |     |------------+------------------------+--------------------------+------+ |(TS2)| RxInit     |                        | Init Line buffer         |      | |     |            |                        | Start 10 second timer    | TS3  | |     |------------+------------------------+--------------------------+------+ |(TS3)| RxIntro    | 1. Timer expired       | Nobody Home              | exit | |     |            +------------------------+--------------------------+------+ |     |            | 2. Lost carrier        | Lost Carrier             | exit | |     |            +------------------------+--------------------------+------+ |     |            | 3. EMSI_REQ recieved   | Send EMSI_INQ twice      |      | |     |            |                        | select EMSI              | exit | |     |            +------------------------+--------------------------+------+ |     |            | 3. <CR> received       | Show Intro               | TS4  | |     |            +------------------------+--------------------------+------+ |     |            | 4. printable char rx   | Put it in buffer         | TS3  | +-----+------------+------------------------+--------------------------+------+ | TS4 | InitTxEmsi |                        | Prepare 3 sec Sync timer |      | |     |            |                        | Prepare .5 sec NAK timer |      | |     |            |                        | Init NAK count           |      | |     |            |                        | Init Line buffer         |      | |     |            |                        | Start 60 sec master tmr  | TS5  | |     |------------+------------------------+--------------------------+------+ |(TS5)| SendSync   | 1. 60 seconds elapsed  |                          |      | |     |            |    or no carrier       | no response              | exit | |     |            +------------------------+--------------------------+------+ |     |            | 2. 3 sec timer elapsed | Send EMSI_INQ twice      |      | |     |            |    or never started    | Send YOOHOO TSYNC CR     | TS6  | |     |            +------------------------+--------------------------+------+ |     |            | 3. EMSI_REQ received   | Send EMSI_INQ twice      |      | |     |            |                        | Select EMSI              | exit | |     |            +------------------------+--------------------------+------+ |     |            | 4. Otherwise...        |                          | TS6  | |     |------------+------------------------+--------------------------+------+ |(TS6)| WaitResp   | 1. Nothing received    | need response            | TS5  | |     |            +------------------------+--------------------------+------+ |     |            | 2. ENQ received        | Wazoo selected           | exit | |     |            +------------------------+--------------------------+------+ |     |            | 3. 'C' or NAK received | Maybe FTS-0001           | TS7  | |     |            +------------------------+--------------------------+------+ |     |            | 4. CR                  | Init Line buffer&NAK cnt | TS5  | |     |            +------------------------+--------------------------+------+ |     |            | 5. Other character     | Init NAK /into buffer    | TS5  | |     |------------+------------------------+--------------------------+------+ |(TS7)| NAKtmr     | 1. Timer expired       | NAK count++              | TS8  | |     |            +------------------------+--------------------------+------+ |     |            | 2. Timer not expired   | Zero NAK count           |      | |     |            |                        | Start .5 sec NAK timer   | TS5  | |     |------------+------------------------+--------------------------+------+ |(TS8)| NAKcount   | 1. Count >= 2          | Select FTS-0001          | exit | |     |            +------------------------+--------------------------+------+ |     |            | 2. count < 2           | continue                 | TS5  | +-----+------------+------------------------+--------------------------+------+ I can't help feeling that this would be a lot cleaner just as a single function As these state diagrams when you look at them are really going back to the days of Spaghetti Basic!  In fact I've cut it down to just 2 states!*/#define INTRO_LEN 180       /* Maximum size of intro/banner *//* * Data structure used by TxEmsiInit */typedef struct {    short result;} TSARGS;#define TS0     0#define TSexit  0#define TS1     2#define TS4     3/* /-----+------------+------------------------+--------------------------+------\ | TS0 | WhackInit  |                        | Start 10 second timer    |      | |     |            |                        | Init Line buffer         | TS1  | +-----+------------+------------------------+--------------------------+------+*/static short TSWhackInit (TSARGS *args, short start_state){#pragma unused (start_state)//	putlog ( lgNOPE, " + TSWhackInit" );    args->result = SESSION_FAIL;        /* Default to failure *///	cantdo_EMSI = check_noemsi(&called_addr);    cantdo_EMSI = no_EMSI || check_no_emsi (&called_addr);    cantdo_WaZOO = no_WaZOO || check_no_yoohoo (&called_addr);    return TS1;}static short TSExit (TSARGS *args, short cur_state){#pragma unused (cur_state)//	putlog ( lgNOPE, " + TSExit" );    return args->result;}/* * Check for abort or timeout */static short check_abort(long timer, char *msg){#pragma unused (msg)	if (CheckCancel())	{//		putlog ( lgALRT, "Aborted..." );		return -1;	}	if(!CARRIER)	{//		status_line(msgtxt[M_NO_CARRIER]);		return -1;	}	if(timer && timeup(timer))	{//		if(msg)//			status_line(msg);//		else//			status_line("!Timeout");		return -1;	}	return 0;}/* +-----+------------+------------------------+--------------------------+------+ | TS1 | WhackCR    | 1. Timer expired       | Nobody Home              | exit | |     |            +------------------------+--------------------------+------+ |     |            | 2. Lost carrier        | Lost Carrier             | exit | |     |            +------------------------+--------------------------+------+ |     |            | 3. Something received  | Someone home             | TS2  | |     |            +------------------------+--------------------------+------+ |     |            | 4. Nothing received    | Send <CR>, wait 1 sec    | TS1  | |     +------------+------------------------+--------------------------+------+ |(TS2)| RxInit     |                        | Init Line buffer         |      | |     |            |                        | Start 10 second timer    | TS3  | |     +------------+------------------------+--------------------------+------+ |(TS3)| RxIntro    | 1. Timer expired       | Nobody Home              | exit | |     |            +------------------------+--------------------------+------+ |     |            | 2. Lost carrier        | Lost Carrier             | exit | |     |            +------------------------+--------------------------+------+ |     |            | 3. EMSI_REQ recieved   | Send EMSI_INQ twice      |      | |     |            |                        | select EMSI              | exit | |     |            +------------------------+--------------------------+------+ |     |            | 3. <CR> received       | Show intro               | TS4  | |     |            +------------------------+--------------------------+------+ |     |            | 4. printable char rx   | Put it in buffer         | TS3  | +-----+------------+------------------------+--------------------------+------+*/static short TSWhackCR (TSARGS *args){    long sectimer = 0L;    long bigtimer;    char c = '\r';    short pos;    char buffer[INTRO_LEN];    char emsibuf[EMSI_IDLEN+1];//	putlog ( lgNOPE, " + TSWhackCR" );    /*     * Send <CR> once per second until anything is received     * or until carrier lost/timeout/keyboard escape     */    pos = 0;    emsibuf[0] = '\0';	time_release ();		//е Added 22.06.98	time_release ();		//е	SENDBYTE (c, NULL);		//е	Uncommented 22.06.98    bigtimer = timerset(30*60);          /* Up to 30 seconds */    for(;;)    {        if( check_abort (bigtimer, NULL /*msgtxt[M_NOBODY_HOME]*/))        {//			putlog ( lgALRT, "Nobody Home." );            			if (timeup(bigtimer))	//е	Added force TS4 22.06.98				return TS4;     /* Get on with next section */						args->result = SESSION_FAIL;			return TSexit;        }        else	        if(!CHAR_AVAIL())	        {         //   	putlog ( lgNOPE, "Nope Rx" );	            	            if(!sectimer || timeup(sectimer))	            {	            //	putlog ( lgNOPE, "Sent: %d", c );	            	                SENDBYTE(c, NULL);	                c ^= ' ' ^ '\r';    /* Alternate space/CR */	                sectimer = timerset (60);	//	changed to 1sec.	            }				else				{	     //       	putlog ( lgNOPE, "..1sec" );					time_release ();				}			}	        else	        {		            /*	             * Input line and treat it as either a banner or an EMSI_REQ	             */		            unsigned char c = MODEM_IN();				//	putlog ( lgNOPE, ":%c", c );					            if(c == '\r')   /* CR = end of banner/intro */	            {	                if(pos)	                {	                    buffer[pos] = '\0'; /* Make sure null terminated */		                    SENDBYTE ('\013', NULL);                /* Try to stop output on an Opus */												putlog ( lgNOPE, "Intro: %s", buffer );							                    return TS4;     /* Get on with next section */	                }	            }	            else	            {	                if( (c >= ' ') && (pos < (INTRO_LEN-2)) )	                    buffer[pos++] = c;				//		putlog ( lgNOPE, ": not xD & check EMSI" );	                	                /* Check it against EMSI_REQ */		                if(!cantdo_EMSI && check_emsi(c, emsibuf) == EMSI_REQ)	                {			//			putlog ( lgNOPE, ": EMSI_REQ, wanna sent EMSI_INQ." );		                    send_emsi(EMSI_INQ, TRUE);									//			putlog ( lgNOPE, "~TSWhackCR SESSION_EMSI" );	                    args->result = SESSION_EMSI;	                    return TSexit;	                }	            }        	}    }}/* +-----+------------+------------------------+--------------------------+------+ | TS4 | InitTxEmsi |                        | Prepare 3 sec Sync timer |      | |     |            |                        | Prepare .5 sec NAK timer |      | |     |            |                        | Init NAK count           |      | |     |            |                        | Init Line buffer         |      | |     |            |                        | Start 60 sec master tmr  | TS5  | |     |------------+------------------------+--------------------------+------+ |(TS5)| SendSync   | 1. 60 seconds elapsed  |                          |      | |     |            |    or no carrier       | no response              | exit | |     |            +------------------------+--------------------------+------+ |     |            | 2. 3 sec timer elapsed | Send EMSI_INQ twice      |      | |     |            |    or never started    | Send YOOHOO TSYNC CR     | TS6  | |     |            +------------------------+--------------------------+------+ |     |            | 3. EMSI_REQ received   | Send EMSI_INQ twice      |      | |     |            |                        | Select EMSI              | exit | |     |            +------------------------+--------------------------+------+ |     |            | 4. Otherwise...        |                          | TS6  | |     |------------+------------------------+--------------------------+------+ |(TS6)| WaitResp   | 1. Nothing received    | need response            | TS5  | |     |            +------------------------+--------------------------+------+ |     |            | 2. ENQ received        | Wazoo selected           | exit | |     |            +------------------------+--------------------------+------+ |     |            | 3. 'C' or NAK received | Maybe FTS-0001           | TS7  | |     |            +------------------------+--------------------------+------+ |     |            | 4. CR                  | Init Line buffer&NAK cnt | TS5  | |     |            +------------------------+--------------------------+------+ |     |            | 5. Other character     | Init NAK /into buffer    | TS5  | |     |------------+------------------------+--------------------------+------+ |(TS7)| NAKtmr     | 1. Timer expired       | NAK count++              | TS8  | |     |            +------------------------+--------------------------+------+ |     |            | 2. Timer not expired   | Zero NAK count           |      | |     |            |                        | Start .5 sec NAK timer   | TS5  | |     |------------+------------------------+--------------------------+------+ |(TS8)| NAKcount   | 1. Count >= 2          | Select FTS-0001          | exit | |     |            +------------------------+--------------------------+------+ |     |            | 2. count < 2           | continue                 | TS5  | +-----+------------+------------------------+--------------------------+------+*/static short TSInitTxEMSI (TSARGS *args){    long bigtimer;    long naktimer = 0L;    long synctimer = 0L;    short nakcount = 0;    char emsibuf[EMSI_IDLEN+1];//	putlog ( lgNOPE, " + TSInitTxEMSI" );    bigtimer = timerset(6000);      /* Up to 1 minute */    emsibuf[0] = '\0';    for(;;)    {        /*         * Check for:         *  keyboard abort         *  timeout         *  Carrier loss         */        if(check_abort(bigtimer, NULL))        {            args->result = SESSION_FAIL;//			putlog ( lgNOPE, "Aborted." );            return TSexit;        }        /*         * Send handshake start stuff every 3 seconds...         */		if(!synctimer || timeup(synctimer))		{//			putlog ( lgNOPE, "Send handshake start stuff every 3 seconds..." );						if(!cantdo_EMSI)			{ //           	putlog ( lgNOPE, "Sent EMSI_INQ once." );				send_emsi(EMSI_INQ, FALSE);				send_emsi(EMSI_INQ, FALSE);			}						if(!cantdo_WaZOO)				SENDBYTE(YOOHOO, NULL);						SENDBYTE(TSYNC, NULL);						if(!cantdo_EMSI)				SENDBYTE('\r', NULL);						synctimer = timerset(300);		}		if(CHAR_AVAIL())		{		//	char c = PEEKBYTE();						char c = MODEM_IN();				//		putlog ( lgALRT, ":%c", c );						/*			* We must fiddle about like this because FTS-0001 expects			* the NAK or 'C' to still be available			*			* It would be easier to implement a unget function			*/						switch(c)			{			/* Check for Wazoo */							case ENQ:					//		c = MODEM_IN();		//		putlog ( lgALRT, "MODEM_IN -- %x", c );						if(!cantdo_WaZOO)				{					args->result = SESSION_WAZOO;//					putlog ( lgNOPE, "~TSInitTxEMSI SESSION_WAZOO" );					return TSexit;				}				goto bad_char;							case 'C':			case NAK:							if(!naktimer || !timeup(naktimer))				{					nakcount = 0;					naktimer = timerset(50);			//		MODEM_IN();				}				else				{					nakcount++;					if(nakcount >= 2)					{						args->result = SESSION_FTSC;//						putlog ( lgNOPE, "~TSInitTxEMSI SESSION_FTSC" );						return TSexit;					}				}								break;							default:						bad_char:							/* Check it against EMSI_REQ */						//	c = MODEM_IN();						//	putlog ( lgALRT, "MODEM_IN -- %x", c );				if(!cantdo_EMSI && check_emsi(c, emsibuf) == EMSI_REQ)				{//					putlog ( lgALRT, "REQ arrived! Try EMSI_INQ" );					send_emsi(EMSI_INQ, TRUE);					args->result = SESSION_EMSI;//					putlog ( lgNOPE, "~TSInitTxEMSI SESSION_EMSI" );					return TSexit;				}						if(naktimer)					naktimer = timerset(50);							break;							}		}	}    /* return TSexit; */}/* * State machine table */static STATES States_TxEmsiInit[] = {	{ "TSWhackInit",	(ProcPtr) TSWhackInit	},	{ "TSExit",			(ProcPtr) TSExit		},	{ "TSWhackCR",		(ProcPtr) TSWhackCR		},	{ "TSInitTxEMSI",	(ProcPtr) TSInitTxEMSI	}};short TxEmsiInit(void){    TSARGS args;	//	putlog ( lgNOPE, " + TxEmsiInit" );	    return state_machine ( States_TxEmsiInit, &args, TS1 );}/*----------------------------------------------------------------- * Receiver intialisation *//* State Machine: /-----+----------+--------------------------------+--------------------+-----\ | RS0 | IdleWait | 1. 5 seconds elapsed           | Take initiative    | RS1 | |     |          +--------------------------------+--------------------+-----+ |     |          | 2. No carrier or keypress      | Abort              | exit| |     |          +--------------------------------+--------------------+-----+ |     |          | 3. YOOHOO or TSYNC peeked      | Get on with it!    | RS2 | |     |          +--------------------------------+--------------------+-----+ |     |          | 4. CR, LF, Space, Esc          | Something's there  | RS1 | |     |          +--------------------------------+--------------------+-----+ |     |          | 5. EMSI sequence?              | Get on with it     | RS2 | |     |          +--------------------------------+--------------------+-----+ |     |          | 6. Any other character...      | Eat it             | RS0 | +-----+----------+--------------------------------+--------------------+-----+ | RS1 | Sendintro| 1. Error sending /carrier drop | Abort              | exit| |     |  and     +--------------------------------+--------------------+-----+ |     | EMSI_REQ | 2. Sent OK                     |                    | RS2 | +-----+----------+--------------------------------+--------------------+-----+ | RS2 | RxInit   |                                | Init ext-mail      | RS3 | |     |          |                                | Start 20sec time   |     | |     |          |                                | Init 10 sec time   |     | +-----+----------+--------------------------------+--------------------+-----+ | RS3 | SendSync | 1. Error sending / no carrier  | Abort              | exit| |     |          +--------------------------------+--------------------+-----+ |     |          | 2. Sent OK                     |                    | RS4 | +-----+----------+--------------------------------+--------------------+-----+ | RS4 | WaitSync | 1. Carrier lost/keypress       | Abort              | exit| |     |          +--------------------------------+--------------------+-----+ |     |          | 2. YOOHOO received             | Do WaZOO           | exit| |     |          +--------------------------------+--------------------+-----+ |     |          | 3. TSYNC rx + timer not running| Start 10 sec timer | RS4 | |     |          +--------------------------------+--------------------+-----+ |     |          | 4. CR received                 | resend sync        | RS3 | |     |          +--------------------------------+--------------------+-----+ |     |          | 5. Esc received                | BBS                | exit| |     |          +--------------------------------+--------------------+-----+ |     |          | 6. EMSI_INQ received           | EMSI               | exit| |     |          +--------------------------------+--------------------+-----+ |     |          | 7. 10 second timer             | FSC001             | exit| |     |          +--------------------------------+--------------------+-----+ |     |          | 8. 20 second timer             | BBS                | exit| +-----+----------+--------------------------------+--------------------+-----+*/typedef struct {    short result;} RSARGS;#define RS0     0#define RSexit  0#define RS1     2#define RS2     3static short RSExit(RSARGS *args){//	putlog ( lgNOPE, " + RSExit" );	    return args->result;}/* * RS0: * * For a short while see if there are any shortcut characters */static short RSIdleWait(RSARGS *args){    long idletimer;    char emsibuf[EMSI_IDLEN+1];//	putlog ( lgNOPE, " + RSIdleWait" );    emsibuf[0] = '\0';    idletimer = timerset(60);       /* Up to 5 seconds.. cut down to .5 seconds! */    for(;;)    {        if(check_abort(0L, NULL))       /* No carrier or keypress */        {            args->result = SESSION_FAIL;            return TSexit;        }        if(timeup(idletimer))            return RS1;        if(CHAR_AVAIL())		{			unsigned char c = PEEKBYTE();//			unsigned char c = MODEM_IN();                        switch(c)            {            case TSYNC:     /* Bypass intro... */            case YOOHOO:                return RS2;            case CR:        /* Signs of life */            case LF:    /* Line feed! */            case ' ':            case ESC:            case ENQ:                return RS1;            default:				c = MODEM_IN();     /* Eat the character */                /* And see if its EMSI_REQ */                if(!cantdo_EMSI && check_emsi(c, emsibuf) == EMSI_INQ)                {	//		putlog ( lgNOPE, "EMSI_INQ" );                    args->result = SESSION_EMSI;                    return RSexit;                }            }        }    }    /* return RSexit; */}/* * RS1: Send intro and banners and things */static short RSSendBanner (RSARGS *args){    char	buff[128], tmp[64];//	putlog ( lgNOPE, " + RSSendBanner" );    /* Intro = "\r\r* Address %s Using %s\r\n" */#ifndef LITE	sprintf(buff, "\r\r * Address %s Using " MAILERNAME " " RAVELVERS " " RAVELISA "\r\n",			printaddr ( &(*homesystem)->mainAddr.ad, tmp ) );#else	sprintf(buff, "\r\r * Address %s Using " MAILERNAME " " RAVELVERS "\r\n",			printaddr ( &(*homesystem)->mainAddr.ad, tmp ) );#endif    if(!SendBanner(buff))    {    fail:        args->result = SESSION_FAIL;        return RSexit;    }/*//	Banner, e.g. the BBS name *    if(BBSbanner && strlen(BBSbanner))    {        SENDBYTE('\r');        SENDBYTE('\n');        if(!SendBanner(BBSbanner))            goto fail;        SENDBYTE('\r');        SENDBYTE('\n');    }//	The welcome file//	if(!mail_only)//		if(!SendBanner(BBSwelcome))//			goto fail;	//	Banner, e.g. the BBS name*/    {        SENDBYTE('\r', NULL);        SENDBYTE('\n', NULL);		(*homesystem)->system[(*homesystem)->system[0]+1] = 0;		if(!SendBanner((char *) &(*homesystem)->system[1]))            goto fail;        SENDBYTE('\r', NULL);        SENDBYTE('\n', NULL);    }	    if(!cantdo_EMSI)    {        send_emsi(EMSI_REQ, TRUE);	}        return RS2;}/* * RS2: * *  Init Sync timers *  Send Sync line *  Wait for sync line */static short RSSendSync (RSARGS *args){	Boolean			needbanner = TRUE;//	unsigned char	*ExtMailScan[16];	char			emsibuf[EMSI_IDLEN+1];	long			bigtimer;	long			synctimer = 0L;	unsigned char	lastchar = 0;//	putlog ( lgNOPE, " + RSSendSync" );//	for(k = 0; k < num_ext_mail; k++)//		ExtMailScan[k] = ext_mail_string[k];		emsibuf[0] = '\0';//	bigtimer = timerset((long)BBStimeout);			/* 20 seconds timeout */	bigtimer = timerset ( 30*60 );					/* 20 seconds timeout ++C/30sec */		for(;;)	{		/* Send synchronisation string (press esc for BBS) */		if(needbanner)		{			char	*c;					if (mail_only)				c = "No BBS here... Close connection, please.\xD";			else				c = "Press <ESC> twice to enter BBS.\xD";						if(!SendBanner(c))			{				args->result = SESSION_FAIL;				return RSexit;			}			needbanner = FALSE;		}				if(check_abort(0L, NULL))           /* No carrier or keyboard escape */		{			args->result = SESSION_FAIL;			return RSexit;		}				if(CHAR_AVAIL())		{			unsigned char	c = MODEM_IN();						switch (c)			{			case YOOHOO:				if(!cantdo_WaZOO)				{					CLEAR_OUTBOUND();				/* Stop any outgoing banner */					args->result = SESSION_WAZOO;					return RSexit;				}			break;						case TSYNC:				CLEAR_OUTBOUND();				if (cantdo_WaZOO)				{					args->result = SESSION_FTSC;					return RSexit;				}				else				{					if(!synctimer)					{						synctimer = timerset(10*60);         /* 10 seconds *///						bigtimer = timerset((long)BBStimeout);  /* Reset sync timer */						bigtimer = timerset(30*60);  /* Reset sync timer */					}				}				break;						case CR:							needbanner = TRUE;				break;						case ESC:							if (lastchar == ESC)				{					putlog ( lgNOPE, "Calling for BBS" );					if(!mail_only)					{						args->result = SESSION_BBS;						return RSexit;					}				}				break;						default:						/* Check for EMSI */							if(!cantdo_EMSI && check_emsi(c, emsibuf) == EMSI_INQ)				{					args->result = SESSION_EMSI;					return RSexit;				}								break;			}						lastchar = c;		}		else    /* !CHAR_AVAIL() */		{			if(synctimer && timeup(synctimer))			{				args->result = SESSION_FTSC;				return RSexit;			}					if(timeup(bigtimer))			{				if(mail_only)					args->result = SESSION_FAIL;				else					args->result = SESSION_BBS;				return RSexit;			}		}	}}static STATES States_RxEmsiInit[] = {	{ "RSIdleWait",		(ProcPtr) RSIdleWait	},	{ "RSExit",			(ProcPtr) RSExit		},	{ "RSSendBanner",	(ProcPtr) RSSendBanner	},	{ "RSSendSync",		(ProcPtr) RSSendSync	}};short RxEmsiInit(void){	TSARGS args;	//	putlog ( lgNOPE, " + RxEmsiInit" );//	cantdo_EMSI = check_noemsi (NULL);	cantdo_EMSI = no_EMSI || check_no_emsi(NULL);    cantdo_WaZOO = no_WaZOO || check_no_yoohoo (NULL);		return state_machine ( States_RxEmsiInit, &args, RS0 );}/*------------------------------------------------------------ * Send EMSI_DAT packet */EMSI_CAPABILITY emsi_capability;        /* Capability we can do */EMSI_CAPABILITY emsi_remote_capability; /* What the other guy can do */EMSI_CAPABILITY emsi_protocol;          /* What we are doing */EMSI_CALL_OPTIONS emsi_options;/* add character to buffer with escaping */static char *add_char(char c, char *s){    while(*s)        s++;        /* Get to end of string */    if( (c == '\\') || (c == '}') || (c == ']'))    {        *(s++) = c;        *(s++) = c;    }    else if(isprint(c))        *(s++) = c;    else    {        *(s++) = '\\';        *(s++) = hex[(c >> 4) & 0xf];        *(s++) = hex[ c       & 0xf];    }    *s = 0;    return s;}/* add's character without any escaping */static char *add_field(char c, char *s){    while(*s)        s++;    *(s++) = c;    *s = 0;    return s;}/* Add string to buffer with escaping */static char *add_str (char *str, char *s){    while(*str)        s = add_char(*(str++), s);    return s;}static short TxEMSI_DAT (Boolean sender){	short				i;	size_t			length;	unsigned short	crc;	short				tries;	long			t1, t2;	char			emsibuf[EMSI_IDLEN+1];	char			*buffer;	char			*ptr;		char			ttt[128];	daddr			tmpaddr;			/* Create the Data */	//	if (!sender)//		current_aka = 0;		// let assumed will be my main address until.... Hz.	buffer = NewPtr (MAX_DATLEN);		if(!buffer)	{		putlog ( lgALRT, "Cant create buffer" );		return EMSI_ABORT;	}		ptr = buffer;	strcpy(buffer, "**EMSI_DAT0000{EMSI}");     /* DAT+len+Fingerprint */		/* System addresses... assumed goes first */	ptr = add_field('{', ptr);	tmpaddr = (current_aka == 0) ? (*homesystem)->mainAddr : (*homesystem)->AKAAddr[current_aka-1];		ptr = add_str ( printaddr ( &tmpaddr.ad, ttt ), ptr );		if (tmpaddr.domain[0])	{		ptr = add_char ('@', ptr);		tmpaddr.domain[tmpaddr.domain[0]+1] = 0;		ptr = add_str ( (char *) &tmpaddr.domain[1], ptr );	}	for(i = 0; i < (*homesystem)->AKAcount+1; i++)		if ( i != current_aka )		{			tmpaddr = (i == 0) ? (*homesystem)->mainAddr : (*homesystem)->AKAAddr[i-1];			ptr = add_char (' ', ptr);			ptr = add_str ( printaddr ( &tmpaddr.ad, ttt ), ptr );			if (tmpaddr.domain[0])			{				ptr = add_char ('@', ptr);				tmpaddr.domain[tmpaddr.domain[0]+1] = 0;				ptr = add_str ( (char *) &tmpaddr.domain[1], ptr );			}		}	ptr = add_field('}', ptr);	/* Password */	ptr = add_field('{', ptr);	if (session_password)		ptr = add_str(session_password, ptr);	ptr = add_field('}', ptr);	/* Link codes */	ptr = add_field('{', ptr);	ptr = add_str("8N1", ptr);	if (sender)	{		add_str(",PUA", ptr);       /* Pick up all mail */	}	else	{		/* Disable FREQ's */	#ifndef LITE		if (!CheckEventNow (freq_event_mask))#endif			ptr = add_str(",HRQ", ptr);	}//ее	/* Work out what we can do first */		emsi_capability = 0;	if (YesClasp && 		((!sender && !check_no_protocol (&remote_addr, NODE_NOCLASP)) ||		  (sender && !check_no_protocol (&called_addr, NODE_NOCLASP))))			emsi_capability |= EMSI_P_CLP;#ifndef LITE	if (cur_baud >= 28800 && YesHydra16K &&		((!sender && !check_no_protocol (&remote_addr, NODE_NOHYDRA)) ||		  (sender && !check_no_protocol (&called_addr, NODE_NOHYDRA))))			emsi_capability |= EMSI_P_H16;	if (cur_baud >= 14400 && YesHydra8K &&		((!sender && !check_no_protocol (&remote_addr, NODE_NOHYDRA)) ||		  (sender && !check_no_protocol (&called_addr, NODE_NOHYDRA))))			emsi_capability |= EMSI_P_HY8;	if (YesHydra && 		((!sender && !check_no_protocol (&remote_addr, NODE_NOHYDRA)) ||		  (sender && !check_no_protocol (&called_addr, NODE_NOHYDRA))))			emsi_capability |= EMSI_P_HYD;	if (YesJanus && 		((!sender && !check_no_protocol (&remote_addr, NODE_NOJANUS)) ||		  (sender && !check_no_protocol (&called_addr, NODE_NOJANUS))))			emsi_capability |= EMSI_P_JAN;#endif	if (YesZedZap && 		((!sender && !check_no_protocol (&remote_addr, NODE_NOZEDZAP)) ||		  (sender && !check_no_protocol (&called_addr, NODE_NOZEDZAP))))			emsi_capability |= EMSI_P_ZAP;	if (YesDirZap && 		((!sender && !check_no_protocol (&remote_addr, NODE_NODIRZAP)) ||		  (sender && !check_no_protocol (&called_addr, NODE_NODIRZAP))))			emsi_capability |= EMSI_P_DZA;	if (YesZedZip && 		((!sender && !check_no_protocol (&remote_addr, NODE_NOZEDZIP)) ||		  (sender && !check_no_protocol (&called_addr, NODE_NOZEDZIP))))		emsi_capability |= EMSI_P_ZMO;//	emsi_capability |= EMSI_P_ZMO;						/* Minimum spec of ZedZip */	/* We can't do Kermit or DZA */	/* NRQ? *///	if( (DEFAULT.rq_OKFile == NULL) ||//		(sender && !check_reqonus(&remote_addr)) )#ifndef LITE	if (sender && !CheckEventNow (freq_event_mask))#endif		emsi_capability |= EMSI_P_NRQ;#ifndef LITE	if (sender)	{		if (emsi_capability & EMSI_P_HYD)			if (YesxHydra && !check_no_protocol (&called_addr, NODE_NOXHYDRA))			{				ptr = add_str(",RH1", ptr);				xHydraPhase = 1;			}	}	else	{		if (emsi_capability & emsi_remote_capability & EMSI_P_HYD)		{			if (YesxHydra && xHydraPhase == 1 && !check_no_protocol (&remote_addr, NODE_NOXHYDRA))				ptr = add_str(",RH1", ptr);			else				xHydraPhase = 0;		}		else			xHydraPhase = 0;	}#endif	ptr = add_field('}', ptr);	/* Compatibility codes */	ptr = add_field('{', ptr);	if (sender)      /* Send everything we can do */	{		tmail_chat = false;			if(emsi_capability & EMSI_P_CLP)			ptr = add_str("CLP,", ptr);#ifndef LITE		if(emsi_capability & EMSI_P_H16)			ptr = add_str("H16,", ptr);		if(emsi_capability & EMSI_P_HY8)			ptr = add_str("HY8,", ptr);		if(emsi_capability & EMSI_P_HYD)			ptr = add_str("HYD,", ptr);		if(emsi_capability & EMSI_P_JAN)			ptr = add_str("JAN,", ptr);#endif		if(emsi_capability & EMSI_P_DZA)			ptr = add_str("DZA,", ptr);				if(emsi_capability & EMSI_P_ZAP)			ptr = add_str("ZAP,", ptr);				if(emsi_capability & EMSI_P_ZMO)			ptr = add_str("ZMO,", ptr);					if (!no_sealink)			ptr = add_str("SLK,", ptr);#ifndef LITE		if ((joho & CANBINKCHAT) && (emsi_capability & (EMSI_P_JAN|EMSI_P_DZA|EMSI_P_ZAP|EMSI_P_ZMO)))			ptr = add_str("CHT,", ptr);#endif	}	else            /* Pick best protocol */    {		if (emsi_capability & emsi_remote_capability & EMSI_P_CLP)		{			ptr = add_str("CLP,", ptr);			emsi_protocol = EMSI_P_CLP;		}		else#ifndef LITE		if (emsi_capability & emsi_remote_capability & EMSI_P_H16)		{			ptr = add_str("H16,", ptr);			emsi_protocol = EMSI_P_H16;		}		else if (emsi_capability & emsi_remote_capability & EMSI_P_HY8)		{			ptr = add_str("HY8,", ptr);			emsi_protocol = EMSI_P_HY8;		}		else if (emsi_capability & emsi_remote_capability & EMSI_P_HYD)		{			ptr = add_str("HYD,", ptr);			emsi_protocol = EMSI_P_HYD;		}		else if (emsi_capability & emsi_remote_capability & EMSI_P_JAN)		{			ptr = add_str("JAN,", ptr);			emsi_protocol = EMSI_P_JAN;			if (tmail_chat && (joho & CANBINKCHAT))				ptr = add_str("CHT,", ptr);		}		else#endif		if (emsi_capability & emsi_remote_capability & EMSI_P_DZA)		{			ptr = add_str("DZA,", ptr);			emsi_protocol = EMSI_P_DZA;#ifndef LITE			if (tmail_chat && (joho & CANBINKCHAT))				ptr = add_str("CHT,", ptr);#endif		}		else if (emsi_capability & emsi_remote_capability & EMSI_P_ZAP)		{			ptr = add_str("ZAP,", ptr);			emsi_protocol = EMSI_P_ZAP;#ifndef LITE			if (tmail_chat && (joho & CANBINKCHAT))				ptr = add_str("CHT,", ptr);#endif		}		else if (emsi_capability & emsi_remote_capability & EMSI_P_ZMO)		{			ptr = add_str("ZMO,", ptr);			emsi_protocol = EMSI_P_ZMO;#ifndef LITE			if (tmail_chat && (joho & CANBINKCHAT))				ptr = add_str("CHT,", ptr);#endif		}		else		{			ptr = add_str("SLK,", ptr);			emsi_protocol = 0;		}    }	if (emsi_capability & EMSI_P_NRQ)		ptr = add_str("NRQ,", ptr);//	ptr = add_str ("ARC,XMA,FNC", ptr);	ptr = add_str ("ARC,XMA", ptr);	ptr = add_field ('}', ptr);	/* mailer_product_code */		ptr = add_field ('{', ptr);	sprintf (ptr, "%x", (PRODUCT_HI << 8) | PRODUCT_LO );		// was isBINKST	ptr = add_field ('}', ptr);		/* mailer_name */		ptr = add_field ('{', ptr);	ptr = add_str (MAILERNAME, ptr);		// *********	ptr = add_field ('}', ptr);		/* mailer_version */		ptr = add_field ('{', ptr);#ifndef LITE	ptr = add_str (RAVELVERS " " RAVELISA, ptr);		// *********#else	ptr = add_str (RAVELVERS, ptr);		// *********#endif	ptr = add_field ('}', ptr);		/* mailer_serial */		ptr = add_field ('{', ptr);#ifndef LITE#ifdef PROTECTED	sprintf (ptr, "%.8lX-%.4X", keys.oldcrc, keys.oldcs );		// was isBINKST#else	sprintf (ptr, "00000000-0000");		// was isBINKST#endif#endif	ptr = add_field ('}', ptr);	/* Do the IDENT fields */		ptr = add_field ('{', ptr);	ptr = add_str ("IDENT", ptr);	ptr = add_field ('}', ptr);		ptr = add_field ('{', ptr);        {		/* Find ourself in the nodelist */		//		BOOLEAN inlist = nodefind(&alias[assumed].ad, FALSE);				/* System name */				ptr = add_field('[', ptr);				(*homesystem)->system[(*homesystem)->system[0]+1] = 0;		ptr = add_str( (char *) &(*homesystem)->system[1], ptr );			// ********* +++ sysname		switch (CONNECTION)		{		case -1:					ptr = add_str (" (CTB Line)", ptr);			// ********* +++ sysname			break;				case -2:					ptr = add_str (" (IP Line)", ptr);			// ********* +++ sysname			break;				default:					break;		}		ptr = add_field(']', ptr);				/* City */		ptr = add_field('[', ptr);		(*homesystem)->location[(*homesystem)->location[0]+1] = 0;		ptr = add_str( (char *) &(*homesystem)->location[1], ptr );	// ********* +++ location				ptr = add_field(']', ptr);				/* Operator Name */				ptr = add_field('[', ptr);		(*homesystem)->sysop[(*homesystem)->sysop[0]+1] = 0;		ptr = add_str( (char *) &(*homesystem)->sysop[1], ptr );	// ********* +++ sysop		ptr = add_field(']', ptr);				/* Phone number */				ptr = add_field('[', ptr);		(*homesystem)->phone[(*homesystem)->phone[0]+1] = 0;		ptr = add_str( (char *) &(*homesystem)->phone[1], ptr );	// ********* +++ phone		ptr = add_field(']', ptr);				/* baud-rate */				ptr = add_field('[', ptr);		(*homesystem)->baud[(*homesystem)->baud[0]+1] = 0;		ptr = add_str( (char *) &(*homesystem)->baud[1], ptr );	// ********* +++ baud		ptr = add_field(']', ptr);				/* flags */				ptr = add_field('[', ptr);				(*homesystem)->emsi_flags[(*homesystem)->emsi_flags[0]+1] = 0;		ptr = add_str ((char *) &(*homesystem)->emsi_flags[1], ptr);	// ********* +++ flags				if (CONNECTION == -2)			ptr = add_str (",TCP,IFC", ptr);	// ********* +++ flag IFC (ifcico - raw tcp/ip)				ptr = add_field(']', ptr);	}		ptr = add_field('}', ptr);	/* my time */	//	{TRX#}{[32a398f2]}		{		unsigned long	tit;				GetDateTime ( &tit );		UxConvertTime ( false, &tit );		sprintf (ptr, "{TRX#}{[%lx]}", tit );		ptr += strlen (ptr);	}	/* my traff */	//	{MOH#}{[d87d]}		if (!sender)	{		ADDR_LIST	*ads;		tsend		ts;		tobesend.pkt = 0;		tobesend.other = 0;				if(emsi_options & PUP)      /* Only send to primary address */		{			tobesend = *calcoutbound (&remote_addr);		}		else    /* Assume PUA */		{			/* Process each address */				ads = remote_ads.next;  /* This should be empty, but we'll go to the end anyway! */			while(ads)			{				ts = *calcoutbound (&ads->ad);				tobesend.pkt += ts.pkt;				tobesend.other += ts.other;								ads = ads->next;			}		}	}		if (tobesend.pkt || tobesend.other)	{		sprintf (ptr, "{TRAF}{%lx %lx}", tobesend.pkt, tobesend.other);		ptr += strlen (ptr);		sprintf (ptr, "{MOH#}{[%lx]}", (tobesend.pkt+tobesend.other));		ptr += strlen (ptr);		drawProgressCircle (ITCIRCLE, -1, tobesend.pkt+tobesend.other);	}#ifndef LITE	if (tmail_chat && !(joho & CANBINKCHAT))	{		putlog ('~', "[TxEMSI_DAT] remote has tmail_chat & we don't");		tmail_chat = false;	}		putlog ('~', "[TxEMSI_DAT] t-mail chat %s", (joho & CANBINKCHAT) ? "sent" : "missed");	putlog ('~', "[TxEMSI_DAT] tmail_chat %s", (tmail_chat) ? "true" : "false");#endif	length = strlen(buffer) - 14;       /* Length of packet [not **EMSI_DATllll] */	buffer[10] = hex[(length >> 12) & 0xf];	buffer[11] = hex[(length >>  8) & 0xf];	buffer[12] = hex[(length >>  4) & 0xf];	buffer[13] = hex[ length        & 0xf];	length += 14;		/*	 * Calculate CRC	 */		crc = crc_block((unsigned char *)&buffer[2], length-2);	    /*---------*     | State 1 |     ----------*/	tries = 0;	t1 = timerset(120L*60);		//	2min, was 12000	//	putlog ( lgALRT, "Timer for dat %ld against %ld", t1, LMGetTicks ());	emsibuf[0] = '\0';		CLEAR_INBOUND();	    for(;;)	{		/*---------*		 | State 2 |		 ----------*/			tries++;			if (tries > 6)		{			putlog ( lgALRT, "Can't establish EMSI");	        DisposePtr (buffer);	        return EMSI_ABORT;	    }			if ( check_abort (0L, NULL) )		{			DisposePtr (buffer);//			putlog ( lgALRT, "Aborted in state 2");			return EMSI_ABORT;		}		SENDCHARS ((unsigned char *)buffer, length, 1, NULL);        /* Transmit EMSI_DAT *///		SENDCHARS ((unsigned char *)buffer, length );		//	, TRUE); - carrier check															/* Transmit EMSI_DAT */	    buffer[length] = 0;	    putelog ( '>', "%s", &buffer[2] );	    	    put_hex (crc);	    SENDBYTE ('\r', NULL);		while (!timeup (t1) && !OUT_EMPTY () && CARRIER)		time_release ();                     /* Give up slice while	                                              * waiting  */	    /*---------*	     | State 3 |	     ----------*/		    t2 = timerset (10*60);		    /*---------*	     | State 4 |	     ----------*/		    for(;;)	    {	        if(check_abort(t1, NULL))	        {	            DisposePtr (buffer);//				putlog ( lgALRT, "Abort in state 4");	            return EMSI_ABORT;	        }	        	        if(timeup(t2))				 break;	        if(CHAR_AVAIL())	        {	            unsigned char c = MODEM_IN();	            short pkt;	//			putlog ( lgNOPE, ":%c", c );	            pkt = check_emsi(c, emsibuf);	            //	            if (pkt >= 0)//	            	putlog ( lgALRT, "somewhat!!!! pkt type = %s", emsi_pkt[pkt] );					            if(pkt == EMSI_ACK)	            {	                DisposePtr (buffer);//					putlog ( lgALRT, "EMSI_SUCCESS");	                return EMSI_SUCCESS;	            }	            	            if((pkt >= 0) && (pkt != EMSI_REQ))	                break;	        }	    }	}}/*------------------------------------------------------------ * Receive EMSI_DAT packet * * I'm going to do this just as one function instead of a state machine * * * Extract a field from the data * * Similar to strtok() but understands escape sequences \ab \\ }} and ]] * * The first time it is called you should pass the buffer address * future calls may pass NULL to continmue with next field * * fields are {...} and [...] * double }} and ]] are converted to single characters * * Note the actual data buffer is altered by having nulls put in * * returns NULL if any error. */static char *last_field = NULL;static char *get_field(char *dat){	unsigned char sep;	unsigned char *s, *s1;		if (dat == NULL)		dat = last_field;		if (dat == NULL)		return NULL;		sep = *(dat++);		if (sep == '{')		sep = '}';	else		if(sep == '[')			sep = ']';		else			return NULL;	s = s1 = (unsigned char *)dat;	while(*s)	{        unsigned char c = *(s++);        if(c == sep)        {            if(*s == sep)   /* Double end brace */                s++;            else            /* Single end brace marks end */            {                *s1 = 0;                last_field = (char *)s;                                return dat;            }        }//      else if( (c == '\\') && (sep == '}') )  /* hex escape */        else        if (c == '\\')        {            short n;            c = *(s++);            n = byte_to_hex(c);            if(!(n & ~15))            {                c = n;                n = byte_to_hex(*s);                if(!(n & ~15))          /* If 2nd digit is not hex?? */                {                    s++;                    c = (c << 4) | n;                }            }        }        *(s1++) = c;    }    return NULL;}/* * Add an address to the list of remote addresses */static short add_remotead(ADDR *ad){	ADDR_LIST	*ads;	ADDR_LIST	*newad;		ads = &remote_ads;					// This should be empty, but we'll go to the end anyway!		while(ads->next)		ads = ads->next;		newad = (ADDR_LIST *) NewPtr (sizeof(ADDR_LIST));	if(newad)	{		newad->ad = *ad;				// Structure copy		newad->next = NULL;		ads->next = newad;		ads = newad;	}	else	{//		status_line(msgtxt[M_EMSI_NOMEM]);		return EMSI_ABORT;	}		return EMSI_SUCCESS;}static Boolean has_remotead(ADDR *ad){	ADDR_LIST	*ads;	ads = &remote_ads;					// This should be empty, but we'll go to the end anyway!	ads = ads->next;	while(ads)	{		if (cmp2addrs2 (ad, &ads->ad))			break;		ads = ads->next;	}	return (ads == NULL);}/* * Process the incoming EMSI_DAT packet */static short process_dat (char *dat, Boolean sender){	char		*s, *s1, *s2, *s3, temp[128], tmp[64];	ADDR		ad;	addr		tad;	short		n;	short		ret = EMSI_SUCCESS;	Boolean		first, needtimesync = false;	long		nml = 0, aml = 0, ttl = 0;							/* fingerprint */    s = get_field(dat);     /* Finger print */    if(!s || strcasecmp (s, "EMSI"))        return EMSI_ABORT;    /* Addresses */    s = get_field(NULL);    if(!s)        return EMSI_ABORT;	first = true;	temp[0] = 0;    n = 0;    s = strtok(s, " ");    while(s)    {		if(find_address(s, &ad))		{	//		if(fullscreen)	//		{	//			if(n && (n < 6))			//	Display AKA's (not 1st address)	//			{	//				if(n == 1)				//	Clear Window on 1st pass	//					sb_fill(holdwin, ' ', colors.hold);	//		//				sb_move(holdwin, n, 1);	//				sb_puts(holdwin, Pretty_Addr_Str(&ad));	//			}	//			n++;	//		}					tad.zone = ad.Zone;			tad.net = ad.Net;			tad.node = ad.Node;			tad.point = ad.Point;//			if (bsy_check (&tad, workPath))			if (timesynclink != -1 && timesynclink == getlinkinx (&ad))				needtimesync = true;			if (!sender || (sender && !cmp2addrs1 (&tad, &called_addr)))				if (has_remotead (&ad) && bsy_raise (&tad, workPath))				{					putlog (lgALRT, "AKA %s is busy now. Drop connection.", printaddr1 (&ad, tmp));					return EMSI_ABORT;				}			//			bsy_raise (&tad, workPath);						if (!first)			{				strcat (temp, printaddr1 (&ad, tmp));				strcat (temp, " ");								if (strlen (temp) > 25)				{					putlog (lgNOPE, "Aka(s):      %s", temp);					temp[0] = 0;				}			}						if(first)			{				first = false;				remote_addr = ad;	/*	еее	Make 1st address the remote_addr */				printaddr1 (&ad, tmp);				putlog (lgNOPE, "Address:     %s", tmp);				history_add_address1 (&ad);			}					if ( add_remotead (&ad) != EMSI_SUCCESS )				return EMSI_ABORT;		}			s = strtok(NULL, " ");	}	if (temp[0])	{		putlog (lgNOPE, "Aka(s):      %s", temp);	}//	sb_move (wholewin, cursor_row, cursor_col);//	sb_show();    /* Password */    s = get_field(NULL);    if(!s)        return EMSI_ABORT;		strcpy (exhibit_pass, s);	if (s[0])		putlog (lgNOPE, "             Password protected session");		putlog ('~', "exhibit_pass = '%s'", exhibit_pass);		if (!sender)	{		char	*pass;					session_password = NULL;		if (haspassword (&remote_addr, &pass))						//	link present		{			if (pass[0])												//	pwd for link present			{				if (s[0] && !strncasecmp (pass,s,8))				{					ret = EMSI_SUCCESS;									//	yep remote && equal					session_password = pass;				}				else				{					putlog (lgALRT, "Password produced: '%s', expected: '%s'", s, pass);					ret = EMSI_ABORT;									//	empty remote || notequ				}			}			else			{				if (s[0])					putlog (lgALRT, "Password produced: '%s', no password expected", s);				session_password = exhibit_pass;				ret = EMSI_SUCCESS;			}		}		else		{			if (s[0])			{				putlog (lgATTN, "Password produced by unlisted link: '%s'", s);				session_password = exhibit_pass;			}		}//																	//	no this link	}	putlog ('~', "session_password = '%s'", (session_password) ? session_password : "<<nope>>");    /* Link codes */    s = get_field(NULL);    if(!s)        return EMSI_ABORT;    emsi_options = PUA; /* Default to all addresses */    s = strtok(s, ",");    while(s)    {		if(!strcmp(s, "PUA"))			emsi_options = PUA;		else			if(!strcmp(s, "PUP"))				emsi_options = PUP;			else				if(!strcmp(s, "NPU"))					emsi_options = NPU;				else					if(!strcmp(s, "HAT"))						emsi_remote_capability |= EMSI_O_HAT;					else						if(!strcmp(s, "HXT"))							emsi_remote_capability |= EMSI_O_HXT;						else							if(!strcmp(s, "HRQ"))								emsi_remote_capability |= EMSI_O_HRQ;#ifndef LITE							else								if(!strcmp(s, "RH1"))								{									xHydraPhase++;								}#endif		s = strtok(NULL, ",");    }#ifndef LITE	if (sender)	{		if (xHydraPhase > 1)			xHydraPhase = 1;		else			xHydraPhase = 0;	}	else	{		if (xHydraPhase > 0)			xHydraPhase = 1;	}#endif    /* Ignore this for time being     *  We should be looking for:     *      PUA/PUP/NPU if we are receiver     *      HAT/HXT/HRQ if we are sender     */    /* Compatibility */    s = get_field(NULL);    s = strtok(s, ",");    while(s)    {		if(!strcmp(s, "DZA"))			emsi_remote_capability |= EMSI_P_DZA;				if(!strcmp(s, "ZAP"))			emsi_remote_capability |= EMSI_P_ZAP;				if(!strcmp(s, "ZMO"))			emsi_remote_capability |= EMSI_P_ZMO;				if(!strcmp(s, "JAN"))			emsi_remote_capability |= EMSI_P_JAN;				if(!strcmp(s, "HYD"))			emsi_remote_capability |= EMSI_P_HYD;				if(!strcmp(s, "HY8"))			emsi_remote_capability |= EMSI_P_HY8;				if(!strcmp(s, "H16"))			emsi_remote_capability |= EMSI_P_H16;				if(!strcmp(s, "CLP"))			emsi_remote_capability |= EMSI_P_CLP;        /* Also check for NCP/NRQ/ARC/XMA/FNC */		if(!strcmp(s, "NRQ"))			emsi_remote_capability |= EMSI_P_NRQ;		if(!strcmp(s, "FNC"))			dos_names = true;		if(!strcmp(s, "CHT"))			tmail_chat = true;		/* Check for xHydra for old Bink/+ */		//		if(!strcmp(s, "RH1"))//			xHydraPhase++;		s = strtok(NULL, ",");    }//	if (sender)//	{//		if (xHydraPhase > 1)//			xHydraPhase = 1;//		else//			xHydraPhase = 0;//	}//	else//	{//		if (xHydraPhase > 0)//			xHydraPhase = 1;//	}    if(sender)    {#ifndef LITE        if (!(joho & CANBINKCHAT))#endif        	tmail_chat = false;                emsi_protocol = emsi_remote_capability & emsi_capability &            (EMSI_P_DZA | EMSI_P_ZAP | EMSI_P_ZMO | EMSI_P_JAN | EMSI_P_HYD | EMSI_P_HY8 | EMSI_P_H16 | EMSI_P_CLP);	}	    /* Mailer code */    s = get_field(NULL);        /* Code */    s1 = get_field(NULL);       /* Name */    s2 = get_field(NULL);       /* Version */    s3 = get_field(NULL);       /* Revision */	if (*s3)		putlog ( lgNOPE, "Remote uses: %s %s/%s (#%s)", s1, s2, s3, s );	else		putlog ( lgNOPE, "Remote uses: %s %s (#%s)", s1, s2, s );	    /* Extra fields */    while ( s = get_field(NULL) )    {        /* 1st field is identifier */		if(!strcmp(s, "IDENT"))		{			char *last_tok;			s = get_field(NULL);    /* Identifier */			last_tok = last_field;				//		putlog ( lgATTN, "Parse IDENT" );						/* Parse IDENT */						s = get_field(s);			if(s && *s)				putlog ( lgNOPE, "System:      %s", s );						s = get_field(NULL);			if(s && *s)				putlog ( lgNOPE, "Located in:  %s", s );						s = get_field(NULL);			if(s && *s)				putlog ( lgNOPE, "SysOp:       %s", s );						s = get_field(NULL);			if(s && *s)				putlog ( lgNOPE, "Phone:       %s", s );						s = get_field(NULL);			if(s && *s)				putlog ( lgNOPE, "Baud:        %s", s );						s = get_field(NULL);			if(s && *s)				putlog ( lgNOPE, "Flags:       %s", s );						last_field = last_tok;		}		else			if(!strcmp(s, "TRX#"))			{				char *last_tok;				s = get_field(NULL);    /* timer */				last_tok = last_field;						//	putlog ( lgATTN, "Parse Remote Time" );			//	s = get_field(NULL);				if(s && *s)				{					unsigned long	tt, tt1;					DateTimeRec		dtr;															if ( sscanf ( s, "[%lx]", &tt ) != EOF )					{						UxConvertTime ( true, &tt );						SecondsToDate ( tt, &dtr );											dtr.year %= 100;						putlog ( lgNOPE, "Remote time: %.2d %s %.2d  %.2d:%.2d:%.2d",												dtr.day, mnt[dtr.month-1], dtr.year, dtr.hour,												dtr.minute, dtr.second );#ifndef LITE#ifdef PROTECTED						if (keys.crc != keys.oldcrc)							exitAfterAll ();										if ((keys.oldcs+1+keys.cs)&0xFFFF)							exitAfterAll ();										if (pStrComp (keys.regName, (*homesystem)->sysop))							exitAfterAll ();						(*homesystem)->mainAddr.ad = keys.regAddr;#endif						if (needtimesync)						{							GetDateTime (&tt1);														if (tt1 > (tt+timesyncbounds) || tt1 < (tt-timesyncbounds))							{								SetDateTime (tt);								putlog (lgATTN, "Clock has been synchronized with remote.");							}						}#endif					}				}								last_field = last_tok;			}			else				if(!strcmp(s, "MOH#"))				{//					long		tt;					char *last_tok;													s = get_field(NULL);    /* remote's volume */					last_tok = last_field;							//		s = get_field(NULL);								//		if((nml == 0 && aml == 0) && s && *s)					if(s && *s)						if ( sscanf ( s, "[%lx]", &ttl ) != EOF )						{							putlog ( lgNOPE, "Remote has for us %ld bytes", ttl );						}										last_field = last_tok;				}				else					if(!strcmp(s, "TRAF"))					{						s = get_field(NULL);						if (s && sscanf ( s, "%lx %lx", &nml, &aml ) == 2)						{							if (nml)								putlog ( lgNOPE, "Remote has for us %ld bytes of NetMail", nml );							if (aml)								putlog ( lgNOPE, "Remote has for us %ld bytes of ArcMail", aml );						}					}					else					{						char *last_tok = s;						s = get_field(NULL);						putlog ( lgNOPE, "Addon:       %s {%s}", last_tok, s );					}	}	if (!ttl)		ttl = aml+nml;		drawProgressCircle (IRCIRCLE, -1, ttl);	if (sender)	{		ADDR_LIST	*ads;		tsend		ts;		tobesend.pkt = 0;		tobesend.other = 0;				if(emsi_options & PUP)      /* Only send to primary address */		{			tobesend = *calcoutbound (&remote_addr);		}		else    /* Assume PUA */		{			/* Process each address */				ads = remote_ads.next;  /* This should be empty, but we'll go to the end anyway! */			while(ads)			{				ts = *calcoutbound (&ads->ad);				tobesend.pkt += ts.pkt;				tobesend.other += ts.other;								ads = ads->next;			}		}	}		if (tobesend.pkt || tobesend.other)	{		drawProgressCircle (ITCIRCLE, -1, tobesend.pkt+tobesend.other);	}	putlog ('~', "[process_dat] t-mail chat %s", (tmail_chat) ? "detected" : "missed");		return ret;}/* * Read the actual packet and its crc * * return 0: EMSI_SUCCESS : OK *       -1: EMSI_ABORT   : abort (no carrier or keyboard escape) *       -2: EMSI_RETRY   : Timeout or CRC error * * emsibuf excludes the **, i.e. it is "EMSI_DAT<len16>" */static short read_emsi_dat(char *emsibuf, Boolean sender){    char *dat;    long length;    char *ptr;    short count;    unsigned short crc;    unsigned short check;//	putlog  ( lgATTN, " + read_emsi_dat" );    /* Get the packet length */    if(sscanf(&emsibuf[8], "%04lx", &length) != 1)   /* read hex-value */        return EMSI_RETRY;    if(length > 4096)       /* Assume >4K is silly */        return EMSI_RETRY;    dat = NewPtrClear ((size_t)length+16);    if(!dat)    /* Out of memory! */    {//		status_line(msgtxt[M_EMSI_NOMEM]);		return EMSI_ABORT;	}		/*	 * Initialise the CRC:	 * The specs aren't very clear on this, but I'll assume	 * for now that it includes all of "EMSI_DAT<len16><data>"	 *	 * Also is the length and crc apply to the data before or after	 * escaping 8 bit data?  I will assume it applies to the binary data	 */		crc = crc_block((unsigned char *)emsibuf, 8+4);  /* EMSI_DAT <len16> */		/* Read in all the data */		count = length;	ptr = dat;	while(count--)	{		short c;//		long my;			if(check_abort(0L, NULL))   /* Abort if no carrier or keypress */		{			DisposePtr (dat);			return EMSI_ABORT;		}	    		c = Z_GetByte (Rxtimeout); //                     /* Wait up to 10 seconds */	    if(c < 0)	    {	        DisposePtr (dat);	        return EMSI_RETRY;	    }		    crc = xcrc(crc, c);	    *(ptr++) = c;	}		*ptr = 0;		/* Get the checksum */		count = 4;	check = 0;	while(count--)	{			short c = Z_GetByte(Rxtimeout);	    	    if(c < 0)	    {	        DisposePtr (dat);	        return EMSI_RETRY;	    }	    	    c = byte_to_hex(c);	    	    if(c & ~0xf)	    {	        DisposePtr (dat);	        return EMSI_RETRY;	    }	    check = (check << 4) | c;	}		putelog ( '<', "%s%s", emsibuf, dat );    if(check != crc)	{		putlog ( lgALRT, "CRC fault... (Estimated = %04x, Arrived = %04x)", crc, check);        DisposePtr (dat);        return EMSI_RETRY;    }    /*     * Acknowledge it     */	send_emsi(EMSI_ACK, TRUE);	send_emsi(EMSI_ACK, TRUE);	    /*     * Process it     */    if(process_dat(dat, sender) < 0)    {        DisposePtr (dat);        putlog ( lgALRT, "EMSI fault..." );        return EMSI_ABORT;    }    DisposePtr (dat);    //	putlog ( lgALRT, "read_emsi_dat is OK..." );        return EMSI_SUCCESS;}static short RxEMSI_DAT(Boolean sender){    char emsibuf[EMSI_IDLEN+1];    short tries;    long t1;    long t2;    /*---------*     | State 1 |     *---------*///	putlog ( lgATTN, " + RxEMSI_DAT" );    tries = 0;    t1 = timerset(1000);    /* 20 seconds */    t2 = timerset(1000);    /* 60 second timer */    emsibuf[0] = '\0';    for(;;)    {        /*---------*         | State 2 |         *---------*/        tries++;        if(tries > 2)		// was 6            return -1;          /* Terminate and report failure */                if(!sender)        {            send_emsi(EMSI_REQ, TRUE);//			putlog ( lgNOPE, "Sent EMSI_REQ" );        }        else        	if(tries > 1)        	{            	send_emsi(EMSI_NAK, TRUE);//				putlog ( lgNOPE, "Sent EMSI_NAK" );			}			        /*---------*         | State 3 |         *---------*/        t1 = timerset(1000);        /*---------*         | State 4 |         *---------*/        for(;;)        {            if(check_abort(t2, NULL))       /* If Timer2 expired, terminate */            {//           		putlog  ( lgATTN, "t2 expired" );                return -1;            }                        if(timeup(t1))                  /* If timer1 expired goto state 2 */            {//           		putlog  ( lgATTN, "t1 expired" );                break;            }                        if(CHAR_AVAIL())            {                unsigned char c = MODEM_IN();                short pkt;                pkt = check_emsi(c, emsibuf);				//	            if (pkt >= 0)//	            	putlog ( lgALRT, "somewhat!!!! pkt type = %s", emsi_pkt[pkt] );		//		putlog ( lgNOPE, ": %c", c );                if(pkt == EMSI_HBT)         /* Heartbeat */                {	//				putlog ( lgNOPE, ": EMSI_HBT" );                    t1 = timerset(1000);                }                else	                if(pkt == EMSI_DAT)    /* Data packet */	                {	                    short val = read_emsi_dat(&emsibuf[2], sender);	//					putlog ( lgNOPE, ": EMSI_DAT" );		                    if(val == EMSI_SUCCESS)	                        return EMSI_SUCCESS;	                    else if(val == EMSI_ABORT)	                        return EMSI_ABORT;	                    else	                        break;          /* Goto step 2 */	                }            }        }    }}/*--------------------------------------------------------------------------*//* Send files for one address                                               *//*   returns TRUE (1) for good xfer, FALSE (0) for bad                      *//*--------------------------------------------------------------------------*/static short fsent;/* * EMSI_callback () -- send requested file using WaZOO method. * *//*commented out - now use WaZOO_callbackstatic short EMSI_callback (StringPtr reqs){	short		res;#ifndef LITE	if (remote_capabilities & DOES_HYDRA)	{//	putlog (lgATTN, "hydra callback %#s", reqs);			reqs[reqs[0]+1] = 0;		fsent++;		res = hydra ((char *)&reqs[1], NULL);//	putlog (lgATTN, "%d => %s aborted", res, (Aborted) ? "Was" : "Not");		switch (res)		{		case XFER_ABORT:					res = 1;			break;				case XFER_SKIP:					res = SPEC_COND;			break;				default:					res = OK;			break;		}				return res;	}	else#endif		return (Send_Zmodem (reqs, NULL, fsent++, DO_WAZOO));}*/static short send_to_address(ADDR *ad){	char	*pass, temp[128];		/* Ignore unknown domains */			if (haspassword (ad, &pass))						//	link present	{		if (session_password)							//	pwd for link present		{			if (strncasecmp (pass,session_password,8))			{				putlog (lgATTN, "Bad password produced for %s: '%s', expected: '%s'", printaddr1 (ad, temp), session_password, pass);				return true;			}			else				putlog ('~', "Password produced for %s: '%s' accepted", printaddr1 (ad, temp), pass);		}		else		{			if (pass[0])			{				putlog (lgATTN, "No password produced for %s, expected: '%s'", printaddr1 (ad, temp), pass);				return true;			}		}	}	else	{		putlog ('~', "Unlisted link %s don't required password", printaddr1 (ad, temp));	}    /*--------------------------------------------------------------------*/    /* Send files listed in ?LO files (attached files)                    */    /*--------------------------------------------------------------------*/	if (!do_FLOfile (ad, WaZOO_callback /*EMSI_callback*/))		return false;done_send:    return true;}                                                /* WaZOO *//*--------------------------------------------- * Send files for all addresses using send_to_address * * Loop through all addresses and set called_addr */static void send_all_files (Boolean sender){	ADDR_LIST *ads;		/* intialise */		fsent = 0;		if((emsi_options != NPU) && !(emsi_remote_capability & EMSI_O_HAT))	{		if(emsi_options & PUP)      /* Only send to primary address */		{			if(!send_to_address(&remote_addr))			{				Aborted = true;				return;			}		}		else    /* Assume PUA */		{			/* Process each address */				ads = remote_ads.next;  /* This should be empty, but we'll go to the end anyway! */			while(ads)			{				if (!send_to_address(&ads->ad))		/* Send the mail */				{					Aborted = true;					return;				}				ads = ads->next;			}		}		if (remote_capabilities & (DOES_HYDRA|DOES_CLASP))		{			if (Aborted)				return;			if (xHydraPhase == 2)			{				if (thy_request)					respond_to_file_requests (fsent, WaZOO_callback /*EMSI_callback*/);				if (Aborted)					return;			}			if (remote_capabilities & DOES_CLASP)				Clasp(NULL, NULL, CL_ENDBATCH);#ifndef LITE			else				hydra (NULL, NULL);#endif		}	/*	* respond_to_file_requests acts on all addresses so do it here	*	* If receiver then files are to be sent with main batch	* otherwise they are sent as a seperate phase later	*/#ifndef LITE		if(thy_request && !sender && !(remote_capabilities & (DOES_HYDRA|DOES_CLASP)))			fsent = respond_to_file_requests (fsent, WaZOO_callback /*EMSI_callback*/);#endif	}	if (Aborted)		return;		if (!(remote_capabilities & DOES_CLASP))	{#ifndef LITE		if (remote_capabilities & DOES_HYDRA)		{			if (xHydraPhase == 0)			{				if (thy_request)					respond_to_file_requests (fsent, WaZOO_callback /*EMSI_callback*/);								if (Aborted)					return;								hydra (NULL, NULL);			}		}		else#endif		    Send_Zmodem (NULL, NULL, (fsent) ? END_BATCH : NOTHING_TO_DO, DO_WAZOO);	}	    sent_mail = 1;}/*------------------------------------------------------------------ * Do an EMSI session *//* this mostly copied from b_wazoo.c and modified */static short EMSI_session(Boolean sender){	short	stat;//	char	j[100];//	char	k[100];	short	error = EMSI_ABORT;	//*--------------------------------------------------------------------*//* Initialize WaZOO                                                   *//*--------------------------------------------------------------------*		stat =		got_arcmail =		got_packet = 0;	thy_request = 0;		//	reote made file request	we_request = 0;		//	we made file request	Netmail_Session = 1;	isOriginator = sender;	called_addr = remote_addr;	if (!CARRIER || CheckCancel())	{		goto endemsi;	}//	* Make sure we have the correct inbound area for the remote *//	nodefind(&remote_addr, FALSE);//	* Set up Wazoo compatible compatibilities *	if(emsi_remote_capability & (EMSI_P_NRQ | EMSI_O_HRQ))	// * Can we do File requests? *		remote_capabilities = 0;	else		remote_capabilities = WZ_FREQ;	if (emsi_protocol & (EMSI_P_CLP))	{		putlog ( lgNOPE, "Method:      Clasp" );		remote_capabilities |= DOES_CLASP;		Clasp_init (0);		if (Aborted)			goto endemsi;				putlog('?', "Clasp - 1st phase");				xHydraPhase = 1;		send_all_files(sender);		putlog('?', "Clasp - 2st phase");				xHydraPhase = 2;		send_all_files(sender);		putlog('?', "Clasp - end phase");				Clasp(NULL, NULL, CL_ENDSESSION);		Clasp_deinit (NULL);		FlushVol ( NULL, 0 );				if (!Aborted)			error = EMSI_SUCCESS;				goto endemsi;	}#ifndef LITE//	* Try Hydra first *	if (emsi_protocol & (EMSI_P_HYD|EMSI_P_HY8|EMSI_P_H16))	{//		status_line ("%s Janus", msgtxt[M_EMSI_METHOD]);				if (xHydraPhase == 1)			putlog ( lgNOPE, "Method:      xHydra %s",							 (emsi_protocol & EMSI_P_HY8) ? "(8K)" :							((emsi_protocol & EMSI_P_H16) ? "(16K)" : ""));		else			putlog ( lgNOPE, "Method:      Hydra %s",							 (emsi_protocol & EMSI_P_HY8) ? "(8K)" :							((emsi_protocol & EMSI_P_H16) ? "(16K)" : ""));		remote_capabilities |= DOES_HYDRA;		hydra_init (0, (emsi_protocol & EMSI_P_HY8) ? 4L :					  ((emsi_protocol & EMSI_P_H16) ? 8L : 1L));		if (Aborted)			goto endemsi;				send_all_files(sender);				if (xHydraPhase == 1)		{			xHydraPhase = 2;			send_all_files(sender);		}				hydra_deinit ();				FlushVol ( NULL, 0 );		if (!Aborted)			error = EMSI_SUCCESS;				goto endemsi;	}	xHydraPhase = 0;	if (emsi_protocol & (EMSI_P_JAN))	{//		status_line ("%s Janus", msgtxt[M_EMSI_METHOD]);		putlog ( lgNOPE, "Method:      Janus" );		remote_capabilities |= DOES_IANUS;		Janus ();		FlushVol ( NULL, 0 );				if (!Aborted)			error = EMSI_SUCCESS;				goto endemsi;	}#endif//	* See if we can both do ZEDZAP *	if (emsi_protocol & (EMSI_P_DZA))	{		putlog ( lgNOPE, "Method:      DirZap" );		remote_capabilities |= DIR_ZAPPER;	}	else		if (emsi_protocol & (EMSI_P_ZAP))		{			putlog ( lgNOPE, "Method:      ZedZap" );			remote_capabilities |= ZED_ZAPPER;		}		else			if (emsi_protocol & (EMSI_P_ZMO))			{				putlog ( lgNOPE, "Method:      ZedZip" );				remote_capabilities |= ZED_ZIPPER;			}			else			{	//			putlog ( lgALRT, "No compatible compatibilities." );	//			error = EMSI_ABORT;				putlog ( lgNOPE, "Method:      DietIFNA" );				if (sender)					FTSC_sender (1);				else					FTSC_receiver (1);				if (!Aborted)					error = EMSI_SUCCESS;				goto endemsi;			}	//	* ZMODEMBLOCKLEN  07/16/90 07:43pm *    //	*--------------------------------------------------------------------*//	* ORIGINATOR: send/receive/send                                      *//	*--------------------------------------------------------------------*	z_devinit (true);	//	ее	CHAT aware	    if (sender)    {		putMessage ( 2, "\pSending outbound bundles" );        //		z_devinit (true);	//	ее	CHAT aware        send_all_files(sender);		if (!CARRIER || CheckCancel())			goto endemsi1;				putMessage ( 2, "\pReceiving inbound bundles" );        //		z_devinit (true);	//	ее	CHAT aware		if(!get_Zmodem (inboundPath, NULL))		{			putlog ( lgATTN, "Receive fault..." );			FlushVol ( NULL, 0 );			goto endemsi1;		}			FlushVol ( NULL, 0 );				if (/*!CARRIER || */CheckCancel())			goto endemsi1;		//	we are calling and are we got reqs?				if (thy_request)		{			putMessage ( 2, "\pSending outbound bundles" );        //			z_devinit (true);	//	ее	CHAT aware#ifndef LITE			stat = respond_to_file_requests (0, WaZOO_callback /*EMSI_callback*/);    //	* was (i, WaZOO_callback) *#endif			if (Aborted)				goto endemsi1;						Send_Zmodem (NULL, NULL, ((stat) ? END_BATCH : NOTHING_TO_DO), DO_WAZOO);		}				error = EMSI_SUCCESS;		mail_finished = 1;    }//	*--------------------------------------------------------------------*//	* CALLED SYSTEM: receive/send/receive                                *//	*--------------------------------------------------------------------*    else    {		putMessage ( 2, "\pReceiving inbound bundles" );        //		z_devinit (true);	//	ее	CHAT aware		if(!get_Zmodem (inboundPath, NULL))		{			putlog ( lgATTN, "Receive fault..." );			FlushVol ( NULL, 0 );			goto endemsi1;		}		FlushVol ( NULL, 0 );				if (!CARRIER || CheckCancel ())			goto endemsi1;		putMessage ( 2, "\pSending outbound bundles" );        //		z_devinit (true);	//	ее	CHAT aware		send_all_files(sender);		if (!CARRIER || CheckCancel ())	// || !made_request)		{//			putlog ( lgATTN, "Sending fault..." );			goto endemsi1;		}		if (we_request)		{			putMessage ( 2, "\pReceiving requests" );        //			z_devinit (true);	//	ее	CHAT aware			if(!get_Zmodem (inboundPath, NULL))			{				putlog ( lgATTN, "Receive fault..." );				FlushVol ( NULL, 0 );				goto endemsi1;			}		}		FlushVol ( NULL, 0 );				error = EMSI_SUCCESS;	}endemsi1:	z_devinit (false);	//	ее	CHAT awareendemsi:	putMessage ( 3, "\p " );        	return error;}/* * Do session */short EMSI_sender(void){	emsi_capability = emsi_remote_capability = emsi_protocol = 0;	//	putlog  ( lgATTN, " + EMSI_sender" );	Rxtimeout = (short) (614400L / cur_baud);		if (Rxtimeout < 100)		Rxtimeout = 100;		if (Settings.lockPort & 0x0F)    /* MNP long timeouts... */		Rxtimeout += 500;		if(TxEMSI_DAT(TRUE))	{		putlog  ( '~', "EMSI Sender aborted after TxEMSI_DAT" );		return EMSI_ABORT;	}		if(RxEMSI_DAT(TRUE))	{		putlog  ( '~', "EMSI Sender aborted after RxEMSI_DAT" );		return EMSI_ABORT;	}		return EMSI_session(TRUE);}/* * Do Receiver session */short EMSI_receiver(void){//	putlog  ( lgATTN, " + EMSI_receiver" );    emsi_capability = emsi_remote_capability = emsi_protocol = 0;    if(RxEMSI_DAT(FALSE)) {		putlog  ( '~', "EMSI Sender aborted after RxEMSI_DAT" );		return EMSI_ABORT;    }	Rxtimeout = (short) (614400L / cur_baud);	if (Rxtimeout < 100)		Rxtimeout = 100;	if (Settings.lockPort & 0x0F)    /* MNP long timeouts... */		Rxtimeout += 100;	current_aka = matchaka (&remote_addr);		if (current_aka < 0)		current_aka = 0;		if(TxEMSI_DAT(FALSE))	{		putlog  ( '~', "EMSI Sender aborted after TxEMSI_DAT" );		return EMSI_ABORT;    }	return EMSI_session(FALSE);}