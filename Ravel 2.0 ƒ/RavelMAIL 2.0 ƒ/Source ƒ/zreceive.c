/*--------------------------------------------------------------------------*//*                                                                          *//*                                                                          *//*      ------------         Bit-Bucket Software, Co.                       *//*      \ 10001101 /         Writers and Distributors of                    *//*       \ 011110 /          Freely Available<tm> Software.                 *//*        \ 1011 /                                                          *//*         ------                                                           *//*                                                                          *//*              (C) Copyright 1987-96, Bit Bucket Software Co.              *//*                                                                          *//*                                                                          *//*                                                                          *//*                      Zmodem file reception module                        *//*                                                                          *//*                                                                          *//*    For complete  details  of the licensing restrictions, please refer    *//*    to the License  agreement,  which  is published in its entirety in    *//*    the MAKEFILE and BT.C, and also contained in the file LICENSE.260.    *//*                                                                          *//*    USE  OF THIS FILE IS SUBJECT TO THE  RESTRICTIONS CONTAINED IN THE    *//*    BINKLEYTERM  LICENSING  AGREEMENT.  IF YOU DO NOT FIND THE TEXT OF    *//*    THIS  AGREEMENT IN ANY OF THE  AFOREMENTIONED FILES,  OR IF YOU DO    *//*    NOT HAVE THESE FILES,  YOU  SHOULD  IMMEDIATELY CONTACT BIT BUCKET    *//*    SOFTWARE CO.  AT ONE OF THE  ADDRESSES  LISTED BELOW.  IN NO EVENT    *//*    SHOULD YOU  PROCEED TO USE THIS FILE  WITHOUT HAVING  ACCEPTED THE    *//*    TERMS  OF  THE  BINKLEYTERM  LICENSING  AGREEMENT,  OR  SUCH OTHER    *//*    AGREEMENT AS YOU ARE ABLE TO REACH WITH BIT BUCKET SOFTWARE, CO.      *//*                                                                          *//*                                                                          *//* You can contact Bit Bucket Software Co. at any one of the following      *//* addresses:                                                               *//*                                                                          *//* Bit Bucket Software Co.        FidoNet  1:104/501, 1:343/491             *//* P.O. Box 460398                AlterNet 7:42/1491                        *//* Aurora, CO 80046               BBS-Net  86:2030/1                        *//*                                Internet f491.n343.z1.fidonet.org         *//*                                                                          *//* Please feel free to contact us at any time to share your comments about  *//* our software and/or licensing policies.                                  *//*                                                                          *//*                                                                          *//*  This module is based largely on a similar module in OPUS-CBCS V1.03b.   *//*  The original work is (C) Copyright 1986, Wynn Wagner III. The original  *//*  authors have graciously allowed us to use their code in this work.      *//*                                                                          *//*--------------------------------------------------------------------------*//* Include this file before any other includes or defines! *///	#include "includes.h"#include <ctype.h>#include <stdio.h>#include <string.h>#include "Comm.h"#include "zmodem.h"#include "zfiles.h"#include "definitions.h"#include "zm.h"//#include "PascalStr.h"#include "Timing.h"#include "freq.h"#include "PascalStr.h"#include "pmain.h"#include "log.h"#include "Ravel_FTN.h"#include "Ravel_Prefs.h"#include "compatible.h"#include "history.h"//#include "debugging.h"/*--------------------------------------------------------------------------*//* Local routines                                                           *//*--------------------------------------------------------------------------*/static short RZ_ReceiveData (unsigned char *, short);static short RZ_32ReceiveData (unsigned char *, short);static short RZ_InitReceiver (void);static short RZ_ReceiveBatch (Ptr);static short RZ_ReceiveFile (Ptr);static short RZ_GetHeader (void);static short RZ_SaveToDisk (long *);static void RZ_AckBibi (void);/*--------------------------------------------------------------------------*//* Private declarations                                                     *//*--------------------------------------------------------------------------*/static long DiskAvail;static long filetime;static char realname[256];/*--------------------------------------------------------------------------*//* Private data                                                             *//*--------------------------------------------------------------------------*//* Parameters for ZSINIT frame */#define ZATTNLEN 32extern long				zoho;extern unsigned char	Txbuf[WAZOOMAX + 16];extern short			remote_capabilities;extern short			gotta_mail;				// somewhat received with ZedZapextern short			gotta_xmail;				// somewhat received with ZedZapextern short		thy_request;				//	reote made file requestextern short		we_request;				//	we made file requestextern short			fstblklen;static char Attn[ZATTNLEN + 1];	/* String rx sends to tx on err            *///static FILE *Outfile;				/* Handle of file being received           */static short	Outfile;static short Tryzhdrtype;				/* Hdr type to send for Last rx close      */static char isBinary;				/* Current file is binary mode             */static char EOFseen;					/* indicates cpm eof (^Z) was received     */static char Zconv;					/* ZMODEM file conversion request          */static short RxCount;					/* Count of data bytes received            */static char Upload_path[PATHLEN];/* Dest. path of file being received       */static long Filestart;				/* File offset we started this xfer from   */static unsigned long	RxStart;extern char				*Filename;extern long				file_length;extern unsigned long	cur_baud;	/* Current baud rate   */extern unsigned short	z_size;extern unsigned long cr3tab[];extern unsigned short crctab[];extern char Rxhdr[4];					/* Received header           */extern char Txhdr[4];					/* Transmitted header        */extern long Rxpos;			/* Received file position                       */static long	Rxpos_total;extern int Txfcs32;			/* TRUE means send binary frames with 32 bit FCS*/extern int Crc32t;			/* Display flag indicating 32 bit CRC being sent*/extern int Crc32;			/* Display flag indicating 32 bit CRC being rcvd*/extern int Znulls;			/* # of nulls to send at beginning of ZDATA hdr */extern int Rxtimeout;		/* Tenths of seconds to wait for something      */extern int Rxframeind;		/* ZBIN ZBIN32,ZHEX type of frame received      */extern h_pc_exch	pc_exch_pref;/*--------------------------------------------------------------------------*//* GET ZMODEM                                                               *//* Receive a batch of files.                                                *//* returns TRUE (1) for good xfer, FALSE (0) for bad                        *//* can be called from f_upload or to get mail from a WaZOO Opus             *//*--------------------------------------------------------------------------*///short get_Zmodem (char *rcvpath, FILE * xferinfo)short get_Zmodem (StringPtr rcvpath, Ptr xferinfo){	char namebuf[PATHLEN];	short i;	char *p;//	char *HoldName;	long t;#ifdef DEBUG	show_debug_name ("get_Zmodem");#endif	filetime = 0;//	gotta_mail = 0;//	IN_XON_ENABLE ();//	Outfile = NULL;	Outfile = 0;		//	zap inb. file ref	z_size = 0;	Rxtimeout = 100;	Tryzhdrtype = ZRINIT;	rcvpath[rcvpath[0]+1] = 0;	(void) strcpy (namebuf, (char *)&rcvpath[1]);	Filename = namebuf;	(void) strcpy (Upload_path, (char *)&rcvpath[1]);	p = Upload_path + strlen (Upload_path) - 1;	while (p >= Upload_path && *p != ':')		--p;	*(++p) = '\0';//	HoldName = HoldAreaNameMunge (&called_addr);//	(void) sprintf (Abortlog_name, "%s%s.Z\0",//		HoldName, Hex_Addr_Str (&remote_addr));//	DiskAvail = zfree (Upload_path);	DiskAvail = 0x0FFFFFFF;	if (((i = RZ_InitReceiver ()) == ZCOMPL) ||		((i == ZFILE) && ((RZ_ReceiveBatch (xferinfo)) == OK)))	{//		XON_DISABLE ();//		XON_ENABLE ();			/* Make sure xmitter is unstuck */		newMessage (lRNAME, "");		newMessage (lRSTAT, "");		drawProgressBar (IRBAR, -1, 0);		return 1;	}	newMessage (lRNAME, "");	newMessage (lRSTAT, "");	drawProgressBar (IRBAR, -1, 0);	CLEAR_OUTBOUND ();//	XON_DISABLE ();			/* Make sure xmitter is unstuck */	send_can ();				/* transmit at least 10 cans    */	t = timerset (200);		/* wait no more than 2 seconds  */	while (!timeup (t) && !OUT_EMPTY () && CARRIER)		z_slice ();		/* Give up slice while waiting  *///	XON_ENABLE ();				/* Turn XON/XOFF back on...     *///	if (Outfile)//		(void) fclose (Outfile);	if (Outfile)		FSClose (Outfile);	return 0;}								/* get_Zmodem *//*--------------------------------------------------------------------------*//* RZ RECEIVE DATA                                                          *//* Receive array buf of max length with ending ZDLE sequence                *//* and CRC.  Returns the ending character or error code.                    *//*--------------------------------------------------------------------------*/static short RZ_ReceiveData (register unsigned char * buf, register short length){	register short c;	register unsigned short crc;	char *endpos;	short d;#ifdef DEBUG	show_debug_name ("RZ_ReceiveData");#endif	if (Rxframeind == ZBIN32)		return RZ_32ReceiveData (buf, length);	crc = RxCount = 0;	buf[0] = buf[1] = 0;	endpos = (char *) buf + length;	while ((char *) buf <= endpos)	{		if ((c = Z_GetZDL ()) & ~0xFF)		{CRCfoo:			switch (c)			{			case GOTCRCE:			case GOTCRCG:			case GOTCRCQ:			case GOTCRCW:				/*-----------------------------------*/				/* C R C s                           */				/*-----------------------------------*/				crc = Z_UpdateCRC (((d = c) & 0xFF), crc);				if ((c = Z_GetZDL ()) & ~0xFF)					goto CRCfoo;				crc = Z_UpdateCRC (c, crc);				if ((c = Z_GetZDL ()) & ~0xFF)					goto CRCfoo;				crc = Z_UpdateCRC (c, crc);				if (crc & 0xFFFF)				{					putMessage (0, "\pBad CRC");//					z_message (MSG_TXT (M_CRC_MSG));					return ERROR;				}				RxCount = length - (short) (endpos - (char *) buf);				return d;			case GOTCAN:				/*-----------------------------------*/				/* Cancel                            */				/*-----------------------------------*/				putMessage (0, "\pCanceled");//				z_log (MSG_TXT (M_CAN_MSG));				return ZCAN;			case TIMEOUT:				/*-----------------------------------*/				/* Timeout                           */				/*-----------------------------------*/				putMessage (0, "\pTimeout");//				z_message (MSG_TXT (M_TIMEOUT));				return c;			case RCDO:				/*-----------------------------------*/				/* No carrier                        */				/*-----------------------------------*///				z_log (MSG_TXT (M_NO_CARRIER));				CLEAR_INBOUND ();				return c;			default:				/*-----------------------------------*/				/* Something bizarre                 */				/*-----------------------------------*/				putMessage (0, "\pSomething bizzare");//				z_message (MSG_TXT (M_DEBRIS));				CLEAR_INBOUND ();				return c;			}					/* switch */		}						/* if */		*buf++ = (unsigned char) c;		crc = Z_UpdateCRC (c, crc);	}							/* while(1) */	putMessage (0, "\pLong packet");//	z_message (MSG_TXT (M_LONG_PACKET));	return ERROR;}								/* RZ_ReceiveData *//*--------------------------------------------------------------------------*//* RZ RECEIVE DATA with 32 bit CRC                                          *//* Receive array buf of max length with ending ZDLE sequence                *//* and CRC.  Returns the ending character or error code.                    *//*--------------------------------------------------------------------------*/static short RZ_32ReceiveData (register unsigned char * buf, register short length){	register short c;	unsigned long crc;	char *endpos;	short d;#ifdef DEBUG	show_debug_name ("RZ_32ReceiveData");#endif	crc = 0xFFFFFFFF;	RxCount = 0;	buf[0] = buf[1] = 0;	endpos = (char *) buf + length;	while ((char *) buf <= endpos)	{		if ((c = Z_GetZDL ()) & ~0xFF)		{CRCfoo:			switch (c)			{			case GOTCRCE:			case GOTCRCG:			case GOTCRCQ:			case GOTCRCW:				/*-----------------------------------*/				/* C R C s                           */				/*-----------------------------------*/				d = c;				c &= 0377;				crc = Z_32UpdateCRC (c, crc);				if ((c = Z_GetZDL ()) & ~0xFF)					goto CRCfoo;				crc = Z_32UpdateCRC (c, crc);				if ((c = Z_GetZDL ()) & ~0xFF)					goto CRCfoo;				crc = Z_32UpdateCRC (c, crc);				if ((c = Z_GetZDL ()) & ~0xFF)					goto CRCfoo;				crc = Z_32UpdateCRC (c, crc);				if ((c = Z_GetZDL ()) & ~0xFF)					goto CRCfoo;				crc = Z_32UpdateCRC (c, crc);				if (crc != 0xDEBB20E3)				{					putMessage (0, "\pBad CRC32");//					z_message (MSG_TXT (M_CRC_MSG));					return ERROR;				}				RxCount = length - (short) (endpos - (char *) buf);				return d;			case GOTCAN:				/*-----------------------------------*/				/* Cancel                            */				/*-----------------------------------*/				putMessage (0, "\pCanceled");//				z_log (MSG_TXT (M_CAN_MSG));				return ZCAN;			case TIMEOUT:				/*-----------------------------------*/				/* Timeout                           */				/*-----------------------------------*/				putMessage (0, "\pTimeout");//				z_message (MSG_TXT (M_TIMEOUT));				return c;			case RCDO:				/*-----------------------------------*/				/* No carrier                        */				/*-----------------------------------*///				z_log (MSG_TXT (M_NO_CARRIER));				CLEAR_INBOUND ();				return c;			default:				/*-----------------------------------*/				/* Something bizarre                 */				/*-----------------------------------*/				putMessage (0, "\pSomething bizzare");//				z_message (MSG_TXT (M_DEBRIS));				CLEAR_INBOUND ();				return c;			}					/* switch */		}						/* if */		*buf++ = (unsigned char) c;		crc = Z_32UpdateCRC (c, crc);	}							/* while(1) */	putMessage (0, "\pLong packet");//	z_message (MSG_TXT (M_LONG_PACKET));	return ERROR;}								/* RZ_ReceiveData *//*--------------------------------------------------------------------------*//* RZ INIT RECEIVER                                                         *//* Initialize for Zmodem receive attempt, try to activate Zmodem sender     *//* Handles ZSINIT, ZFREECNT, and ZCOMMAND frames                            *//*                                                                          *//* Return codes:                                                            *//*    ZFILE .... Zmodem filename received                                   *//*    ZCOMPL ... transaction finished                                       *//*    ERROR .... any other condition                                        *//*--------------------------------------------------------------------------*/static short RZ_InitReceiver (){	register short n;	short errors = 0;	char *sptr;#ifdef DEBUG	show_debug_name ("RZ_InitReceiver");#endif	for (n = 12; --n >= 0;)	{		/*--------------------------------------------------------------*/		/* Set buffer length (0=unlimited, don't wait).                 */		/* Also set capability flags                                    */		/*--------------------------------------------------------------*/		Z_PutLongIntoHeader (0L);//		Txhdr[ZF0] = CANFC32 | CANFDX | CANOVIO;		Txhdr[ZF0] = zoho | CANFDX | CANOVIO;		Z_SendHexHeader (Tryzhdrtype, (unsigned char *) Txhdr);		if (Tryzhdrtype == ZSKIP)			Tryzhdrtype = ZRINIT;AGAIN:		switch (Z_GetHeader ((unsigned char *) Rxhdr))		{		case ZFILE:			Zconv = Rxhdr[ZF0];			Tryzhdrtype = ZRINIT;			if (RZ_ReceiveData (Txbuf, WAZOOMAX) == GOTCRCW)				return ZFILE;			Z_SendHexHeader (ZNAK, (unsigned char *) Txhdr);			if (--n < 0)			{				sptr = "ZFILE";				goto Err;			}			goto AGAIN;		case ZSINIT:			if (RZ_ReceiveData ((unsigned char *) Attn, ZATTNLEN) == GOTCRCW)			{				Z_PutLongIntoHeader (1L);				Z_SendHexHeader (ZACK, (unsigned char *) Txhdr);			}			else				Z_SendHexHeader (ZNAK, (unsigned char *) Txhdr);			if (--n < 0)			{				sptr = "ZSINIT";				goto Err;			}			goto AGAIN;		case ZFREECNT:			Z_PutLongIntoHeader (DiskAvail);			Z_SendHexHeader (ZACK, (unsigned char *) Txhdr);			goto AGAIN;		case ZCOMMAND:			/*-----------------------------------------*/			/* Paranoia is good for you...             */			/* Ignore command from remote, but lie and */			/* say we did the command ok.              */			/*-----------------------------------------*/			if (RZ_ReceiveData (Txbuf, WAZOOMAX) == GOTCRCW)			{				putMessage (0, "\pIgnore remote's ZCommand");//				status_line (MSG_TXT (M_Z_IGNORING), Txbuf);				Z_PutLongIntoHeader (0L);				do				{					Z_SendHexHeader (ZCOMPL, (unsigned char *) Txhdr);				}				while (++errors < 10 && Z_GetHeader ((unsigned char *) Rxhdr) != ZFIN);				RZ_AckBibi ();				return ZCOMPL;			}			else				Z_SendHexHeader (ZNAK, (unsigned char *) Txhdr);			if (--n < 0)			{				sptr = "CMD";				goto Err;			}			goto AGAIN;		case ZCOMPL:			if (--n < 0)			{				sptr = "COMPL";				goto Err;			}			goto AGAIN;		case ZFIN:			RZ_AckBibi ();			return ZCOMPL;		case ZCAN:			putMessage (0, "\pCanceled");//			sptr = MSG_TXT (M_CAN_MSG);			goto Err;		case RCDO://			sptr = &(MSG_TXT (M_NO_CARRIER)[1]);			CLEAR_INBOUND ();			goto Err;		}						/* switch */	}							/* for */	putMessage (0, "\pTimeout");//	sptr = MSG_TXT (M_TIMEOUT);Err://	(void) sprintf (e_input, MSG_TXT (M_Z_INITRECV), sptr);//	z_log (e_input);	return ERROR;}								/* RZ_InitReceiver *//*--------------------------------------------------------------------------*//* RZ_ReceiveBatch                                                          *//* Receive a batch of files using ZMODEM protocol                           *//*--------------------------------------------------------------------------*/static short RZ_ReceiveBatch (Ptr xferinfo){	register short c, ox;//	char namebuf[PATHLEN];	long sanity_timeout;	Str255	sptemp;#ifdef DEBUG	show_debug_name ("RZ_ReceiveBatch");#endif//	z_chatstart ();	sanity_timeout = timerset (12000); /* two minutes to get going */	while (!timeup (sanity_timeout))	{		switch (c = RZ_ReceiveFile (xferinfo))		{		case ZEOF:/*			if (Resume_WaZOO)			{				remove_abort (Abortlog_name, Resume_name);				(void) strcpy (namebuf, Upload_path);				(void) strcat (namebuf, Resume_name);				unique_name (namebuf);				(void) rename (Filename, namebuf);			}*/			sanity_timeout = timerset (12000); /* reset timeout */			/* fallthrough */		case ZFERR:		case ZSKIP:			switch (RZ_InitReceiver ())			{			case ZCOMPL:				return OK;			default:				return ERROR;			case ZFILE:				break;			}					/* switch */			break;		default://			(void) fclose (Outfile);//			Outfile = NULL;			FSClose (Outfile);						strcpy ((char *) &sptemp[1], Filename);			sptemp[0] = strlen (Filename);	//	1	-	arcmail//	2	-	pkt//	0	-	other files			ox = ResolveExtension (sptemp);						if (ox == 2 || ox == 3)			{				putlog (lgATTN, "Kill aborted %s", trunc_path (Filename));				FSDelete (sptemp, 0);			}			else			{				SetInfoFile ( 0, 0, sptemp, 'RvlM', 'ZMPT', filetime, filetime );				history_add_traff (false, Rxpos_total - Filestart);				putlog (lgATTN, "Save partialy received %s (%ldb)", trunc_path (Filename), Rxpos_total);			}			Outfile = 0;/*			if (remote_capabilities)			{				if (!Resume_WaZOO)				{					add_abort (Abortlog_name, Resume_name, Filename, Upload_path, Resume_info);				}			}			else				(void) unlink (Filename);*/			return c;		}						/* switch */	}							/* while */	return ERROR;}								/* RZ_ReceiveBatch *//*--------------------------------------------------------------------------*//* RZ RECEIVE FILE                                                          *//* Receive one file; assumes file name frame is preloaded in Txbuf         *//*--------------------------------------------------------------------------*/static short RZ_ReceiveFile (Ptr xferinfo){#pragma unused (xferinfo)	register short c;	short		n;	long		rxbytes, cps;//	char		*sptr;//	struct utimbuf utimes;	long		lSize;	char		j[50];	Str255		sptemp;		short			rz123;#ifdef DEBUG	show_debug_name ("RZ_ReceiveFile");#endif	RxStart = LMGetTicks ();	EOFseen = FALSE;	c = RZ_GetHeader ();	if (c == ERROR || c == ZSKIP)		return (Tryzhdrtype = ZSKIP);	else if (c == ZFERR)		return (Tryzhdrtype = ZFERR);	n = 10;	rxbytes = Filestart;	Rxpos_total = rxbytes;	for (;;)	{		Z_PutLongIntoHeader (rxbytes);		Z_SendHexHeader (ZRPOS, (unsigned char *) Txhdr);NxtHdr:		switch (c = Z_GetHeader ((unsigned char *) Rxhdr))		{		case ZDATA:			/*-----------------------------------------*/			/* Data Packet                             */			/*-----------------------------------------*/			if (Rxpos != rxbytes)			{				if (--n < 0)				{//					sptr = MSG_TXT (M_FUBAR_MSG);					putMessage (0, "\pBad position fault");					goto Err;				}				(void) sprintf (&j[1], "Bad position %ld/%ld", rxbytes, Rxpos);				j[0] = strlen (&j[1]);				putMessage (0, (StringPtr)j);				//				z_message (j);				Z_PutString ((unsigned char *) Attn);				continue;			}MoreData:			switch (c = RZ_ReceiveData (Txbuf, WAZOOMAX))			{			case ZCAN://				sptr = MSG_TXT (M_CAN_MSG);				putMessage (0, "\pCanceled");				goto Err;			case RCDO://				sptr = &(MSG_TXT (M_NO_CARRIER)[1]);				CLEAR_INBOUND ();				goto Err;			case ERROR:				/*-----------------------*/				/* CRC error             */				/*-----------------------*/				if (--n < 0)				{					putMessage (0, "\pError CRC fault");//					sptr = MSG_TXT (M_FUBAR_MSG);					goto Err;				}//				show_loc (rxbytes, n);				Z_PutString ((unsigned char *) Attn);				continue;			case TIMEOUT:				if (--n < 0)				{					putMessage (0, "\pTimeout");//					sptr = MSG_TXT (M_TIMEOUT);					goto Err;				}//				show_loc (rxbytes, n);				continue;			case GOTCRCW:				/*-----------------------*/				/* End of frame          */				/*-----------------------*/				n = 10;				if (RZ_SaveToDisk (&rxbytes) == ERROR)					return ERROR;				Z_PutLongIntoHeader (rxbytes);				Z_SendHexHeader (ZACK, (unsigned char *) Txhdr);				goto NxtHdr;			case GOTCRCQ:				/*-----------------------*/				/* Zack expected         */				/*-----------------------*/				n = 10;				if (RZ_SaveToDisk (&rxbytes) == ERROR)					return ERROR;				Z_PutLongIntoHeader (rxbytes);				Z_SendHexHeader (ZACK, (unsigned char *) Txhdr);				goto MoreData;			case GOTCRCG:				/*-----------------------*/				/* Non-stop              */				/*-----------------------*/				n = 10;				if (RZ_SaveToDisk (&rxbytes) == ERROR)					return ERROR;				goto MoreData;			case GOTCRCE:				/*-----------------------*/				/* Header to follow      */				/*-----------------------*/				n = 10;				if (RZ_SaveToDisk (&rxbytes) == ERROR)					return ERROR;				goto NxtHdr;			}					/* switch */			/* Default falls through */		case ZNAK:		case TIMEOUT:			/*-----------------------------------------*/			/* Packet was probably garbled             */			/*-----------------------------------------*/			if (--n < 0)			{				putMessage (0, "\pGarbled packet");//				sptr = MSG_TXT (M_JUNK_BLOCK);				goto Err;			}//			show_loc (rxbytes, n);			continue;		case ZFILE:			/*-----------------------------------------*/			/* Sender didn't see our ZRPOS yet         */			/*-----------------------------------------*/			(void) RZ_ReceiveData (Txbuf, WAZOOMAX);			continue;		case ZEOF:			/*-----------------------------------------*/			/* End of the file                         */			/* Ignore EOF if it's at wrong place; force*/			/* a timeout because the eof might have    */			/* gone out before we sent our ZRPOS       */			/*-----------------------------------------*///			if (locate_y && !(fullscreen && un_attended))//				gotoxy (2, (unsigned char) locate_y - 1);			if (Rxpos != rxbytes)				goto NxtHdr;			lSize = rxbytes - Filestart;//			lTime = throughput (2, rxbytes - Filestart);//			(void) fclose (Outfile);			FSClose (Outfile);//			status_line ("%s-Z%s %s", MSG_TXT (M_FILE_RECEIVED), Crc32 ? "/32" : "", realname);//	¥¥//			printf ("Received-Z%s %s\n", Crc32 ? "/32" : "", realname);			if ((LMGetTicks () - RxStart) != 0)//				cps = (((lSize * 60L) / (LMGetTicks () - RxStart)) * 1000L) / cur_baud;				cps = ((lSize * 60L) / (LMGetTicks () - RxStart));			else				cps = 0;			history_add_traff (false, lSize);			putlog (lgNOPE, "Received-Z%s %s [%ld cps]", Crc32 ? "/32" : "", trunc_path (realname), cps);//	¥¥//			update_files (0, realname, lSize, lTime, 0);//			if (filetime > 0) /* utime doesn't like negative numbers *///			{//				utimes.UT_ACTIME = filetime;//				utimes.modtime = filetime;//				(void) utime (Filename, (UTIMBUF *) & utimes);//			}//	¥¥	??						strcpy ((char *) &sptemp[1], Filename);			sptemp[0] = strlen (Filename);		//			SetInfoFile ( 0, 0, sptemp, 'RvlM', '????', filetime, filetime );//	1	-	arcmail//	2	-	pkt//	0	-	other files			switch (rz123 = ResolveExtension (sptemp))			{			case 0:							SetInfoFile (0, 0, sptemp, 'ALFA', 'TEXT', filetime, filetime);				break;						case 1:								SetInfoFile (0, 0, sptemp, 'ZIP ', '.PKT', filetime, filetime);				gotta_xmail = 1;				break;						case 2:							SetInfoFile (0, 0, sptemp, 'RvlM', '.PKT', filetime, filetime);				gotta_mail = 1;				break;						case 3:		//	freq arrived!			#ifndef LITE				thy_request = true;								{					long	eofreq;					short	reqref;					Ptr		ptmp;															FSOpen (sptemp, 0, &reqref);					GetEOF (reqref, &eofreq);										if (eofreq < 1024)		//	whatta hell req file more than 1K? :-O					{						ptmp = NewPtr (eofreq + 1);						FSRead (reqref, &eofreq, ptmp);						ptmp[eofreq] = 0;						appendrequests (ptmp);					}										FSClose (reqref);					FSDelete (sptemp, 0);				}#endif				break;							default:								if (rz123 < 0)				{//					SetInfoFile (0, 0, sptemp, (*pc_exch_pref)[-rz123-1].creator, (*pc_exch_pref)[-rz123-1].type, filetime, filetime);					SetInfoAndICTypeCreator (0, 0,	sptemp,	filetime, filetime, rz123);				}								break;			}			Outfile = 0;//			if (xferinfo != NULL)//			{//				(void) fprintf (xferinfo, "%s\n", Filename);//			}			return c;		case ERROR:			/*-----------------------------------------*/			/* Too much garbage in header search error */			/*-----------------------------------------*/			if (--n < 0)			{				putMessage (0, "\pToo much garbage in header");//				sptr = MSG_TXT (M_JUNK_BLOCK);				goto Err;			}//			show_loc (rxbytes, n);			Z_PutString ((unsigned char *) Attn);			continue;		case ZSKIP:			return c;		default:			putMessage (0, "\pUnknown error");//			sptr = IDUNNO_msg;			CLEAR_INBOUND ();			goto Err;		}						/* switch */	}							/* while */Err://	(void) sprintf (e_input, MSG_TXT (M_Z_RZ), sptr);//	z_log (e_input);	return ERROR;}								/* RZ_ReceiveFile *//*--------------------------------------------------------------------------*//* RZ GET HEADER                                                            *//* Process incoming file information header                                 *//*--------------------------------------------------------------------------*/static short RZ_GetHeader (){	register unsigned char *p;//	struct stat f;//	short		i;	char		*ourname;	char		*theirname;	long		filesize;	char		*fileinfo;//	char		j[80];	Str255		sptemp;	OSType		creator, type;	long		create_t;	long		fst_size, fst_mtime;	#ifdef DEBUG	show_debug_name ("RZ_GetHeader");#endif	/*--------------------------------------------------------------------*/	/* Setup the transfer mode                                            */	/*--------------------------------------------------------------------*/	isBinary = (char) ((!RXBINARY && Zconv == ZCNL) ? 0 : 1);//	Resume_WaZOO = 0;	/*--------------------------------------------------------------------*/	/* Extract and verify filesize, if given.                             */	/* Reject file if not at least 10K free                               */	/*--------------------------------------------------------------------*///	show_debug_name ((char *)Txbuf);	filesize = 0L;	filetime = 0L;	fileinfo = (char *) Txbuf + 1 + strlen ((char *) Txbuf);	if (*fileinfo)	{		putlog ('~', "<<%s>><<%s>>", Txbuf, fileinfo);		(void) sscanf (fileinfo, "%ld %lo", &filesize, &filetime);		UxConvertTime (true, (unsigned long *) &filetime);	}	if (filesize + 10240 > DiskAvail)	{//		status_line (MSG_TXT (M_OUT_OF_DISK_SPACE));		/*      return ERROR; */		return ZFERR;	}	/*--------------------------------------------------------------------*/	/* Get and/or fix filename for uploaded file                          */	/*--------------------------------------------------------------------*/	p = (unsigned char *) (Filename + strlen (Filename) - 1);	/* Find end of upload path */	while ((char *) p >= Filename && *p != ':')		p--;	ourname = (char *) ++p;	p = Txbuf + strlen ((char *) Txbuf) - 1;	/* Find transmitted simple filename */	while (p >= Txbuf && *p != '\\' && *p != '/' && *p != ':')		p--;	theirname = (char *) ++p;	/*--------------------------------------------------------------------*/	/* Rename .REQ file if this is a netmail session                      */	/*--------------------------------------------------------------------*//*    if (remote_capabilities)	{		i = strlen (theirname) - 4;		if ((i > 0) && (stricmp (&theirname[i], ".REQ") == 0))		{			theirname[i] = '\0';			status_line (MSG_TXT(M_REC_REQ_AS), theirname, theirname, TaskNumber);			sprintf (&theirname[i],".R%02x", TaskNumber);		}	}*/	(void) strcpy (ourname, theirname);	/* Start w/ our path & their name */	(void) strcpy (realname, Filename);	/*--------------------------------------------------------------------*/	/* Save info on WaZOO transfer in case of abort                       */	/*--------------------------------------------------------------------*//*	if (remote_capabilities)	{		(void) strcpy (Resume_name, theirname);		(void) sprintf (Resume_info, "%ld %lo", filesize, filetime);	}*/	/*--------------------------------------------------------------------*/	/* Check if this is a failed WaZOO transfer which should be resumed   */	/*--------------------------------------------------------------------*//*	if (remote_capabilities && dexists (Abortlog_name))	{		Resume_WaZOO = (unsigned char) check_failed (Abortlog_name, theirname, Resume_info, ourname);	}*/	/*--------------------------------------------------------------------*/	/* Open either the old or a new file, as appropriate                  */	/*--------------------------------------------------------------------*//*	if (Resume_WaZOO)	{		if (dexists (Filename))			p = (unsigned char *) "r+b";		else			p = (unsigned char *) write_binary;	}	else	{*/		(void) strcpy (ourname, theirname);		/*-----------------------------------------------------------------*/		/* If the file already exists:                                     */		/* 1. And the new file has the same time and size, return ZSKIP    */		/* 2. And OVERWRITE is turned on, delete the old copy              */		/* 3. Else create a unique file name in which to store new data    */		/*-----------------------------------------------------------------*/				strcpy ((char *) &sptemp[1], Filename);		sptemp[0] = strlen (Filename);		//		show_debug_name (Filename);				Filestart = 0L;		if (GetInfoFile (0, 0, sptemp, &creator, &type, &create_t, &fst_mtime, &fst_size) == 0)//		if (stat (Filename, &f) != -1)		{//	¥¥	If file already exists...			if (filesize == fst_size && filetime == fst_mtime)			{				putMessage (0, "\pSkip file");				putlog (lgNOPE, "Skip %s", trunc_path (ourname));				drawProgressCircle (IRCIRCLE, fst_size, 0);//				drawProgressBar (IRBAR, -1, 0);//				status_line (MSG_TXT (M_ALREADY_HAVE), Filename);				return ZSKIP;			}			//			i = strlen (Filename) - 1;//			if ((!overwrite) || (is_arcmail (Filename, i)))//			if ( ResolveExtension (sptemp) == 1 )//			{//				unique_name (Filename);//			}//			else						if (creator == 'RvlM' && type == 'ZMPT')			{//	¥¥	exist uncompletedÉ//	¥¥	do concatenation?							if (filetime != fst_mtime)				{//	¥¥	other file - kill it (maybe was addenum pack to it?)					FSDelete (sptemp, 0);					Filestart = 0L;					Create (sptemp, 0, 'RvlM', 'ZMPT');				}				else				{				//	¥¥	that file					Filestart = fst_size;				}			}			else			{				Str255		newname;				short		iErr;				//	¥¥	other file already present with this name				pStrCopy (sptemp, newname);				do {									newname[newname[0]]++;					if (newname[newname[0]] == ':')						newname[newname[0]]++;										iErr = HRename ( 0, 0, sptemp, newname );				} while (iErr == dupFNErr);								if (iErr)				{					putlog (lgATTN, "Kill dup file %s", trunc_path ((char *) &sptemp[1]));					FSDelete (sptemp, 0);				}				else				{					newname[newname[0]+1] = 0;					putlog (lgATTN, "Rename dup file %s to %s",												trunc_path ((char *) &sptemp[1]),												trunc_path ((char *) &newname[1]));								}								Filestart = 0L;				Create (sptemp, 0, 'RvlM', 'ZMPT');			}		}						/* if exist */		else			Create (sptemp, 0, 'RvlM', 'ZMPT');		//		if (strcmp (ourname, theirname))//		{//			status_line (MSG_TXT (M_RENAME_MSG), ourname);//		}//		p = (unsigned char *) write_binary;//	}/*	if ((Outfile = fopen (Filename, (char *) p)) == NULL)	{		(void) got_error (MSG_TXT (M_OPEN_MSG), Filename);		return ERROR;	}	if (isatty (fileno (Outfile)))	{		errno = 1;		(void) got_error (MSG_TXT (M_DEVICE_MSG), Filename);		(void) fclose (Outfile);		return (ERROR);	}*///	Filestart = (Resume_WaZOO) ? filelength (fileno (Outfile)) : 0L;	if (Filestart)	{		putMessage (0, "\pResume");		putlog (lgNOPE, "Resume file from %ld", Filestart);	}//		status_line (MSG_TXT (M_SYNCHRONIZING_OFFSET), Filestart);	FSOpen ( sptemp, 0, &Outfile );	SetFPos ( Outfile, fsFromStart, Filestart );	//	(void) fseek (Outfile, Filestart, SEEK_SET);//	if (remote_capabilities)//		p = (unsigned char *) check_netfile (theirname);//	else		p = NULL;//	(void) sprintf (j, "%s %s; %s%ldb, %ld min.",//		(p != NULL) ? (char *) p : MSG_TXT (M_RECEIVING),//		realname,//		(isBinary) ? "" : "ASCII ",//		filesize,//		((filesize - Filestart) * 10L / cur_baud.rate_value + 53L) / 54L);//¥¥//	printf ("Z-Receiving %s (%ldb %ld min.)\n",//		realname,//		filesize,//		((filesize - Filestart) * 10L / cur_baud + 53L) / 54L);	putlog (lgNOPE, "Z-Receiving: %s (%ldb %ld min)",		trunc_path (ourname),		filesize,		(long) (((filesize - Filestart) * 10L) / cur_baud + 53L) / 54L);		newMessage (lRNAME, "Z-Receiving: %s", ourname);	newMessage (lRSTAT, "%ld:%ld (0) [%ld min, 0 cps]", Filestart, filesize, (long) (((filesize - Filestart) * 10L) / cur_baud + 53L) / 54L );	drawProgressBar (IRBAR, -1, filesize);	drawProgressBar (IRBAR, Filestart, filesize);	drawProgressCircle (IRCIRCLE, Filestart, 0);//¥¥	file_length = filesize;/*	if (un_attended && fullscreen)	{		clear_filetransfer ();		sb_move (filewin, 1, 2);		sb_puts (filewin, j);		elapse_time ();		(void) sprintf (j, "%3d min",			(filesize * 10L / cur_baud.rate_value + 53L) / 54L);		sb_move (filewin, 2, 69);		sb_puts (filewin, j);		sb_show ();	}	else	{		set_xy (j);		set_xy (NULL);		locate_x += 2;	}	throughput (0, 0L);*/	return OK;}								/* RZ_GetHeader *//*--------------------------------------------------------------------------*//* RZ SAVE TO DISK                                                          *//* Writes the received file data to the output file.                        *//* If in ASCII mode, stops writing at first ^Z, and converts all            *//*   solo CR's or LF's to CR/LF pairs.                                      *//*--------------------------------------------------------------------------*/static short RZ_SaveToDisk (long *rxbytes){	static unsigned char lastsent;//	register unsigned char *p;	long count, cps;	short i;	char j[100];#ifdef DEBUG	show_debug_name ("RZ_SaveToDisk");#endif	count = RxCount;	if (z_keyabort ())	{		send_can ();			/* Cancel file */		while ((i = Z_GetByte (20)) != TIMEOUT && i != RCDO)	/* Wait for line to clear */			CLEAR_INBOUND ();		send_can ();			/* and Cancel Batch *///		z_log (MSG_TXT (M_KBD_MSG));		return ERROR;	}//	if (count != z_size)//		z_size = count;/*	if (count != z_size)	{		if (fullscreen && un_attended)		{			sb_move (filewin, 2, 12);			sb_puts (filewin, ultoa (((unsigned long) (z_size = count)), e_input, 10));			sb_puts (filewin, "    ");			elapse_time ();			sb_show ();		}		else		{			gotoxy (locate_x + 10, locate_y);			(void) cputs (ultoa (((unsigned long) (z_size = count)), e_input, 10));			(void) putch (' ');#if defined __IBMC__			fflush (stdout);#endif		}	}*//*	if (isBinary)	{		if (fwrite (Txbuf, 1, count, Outfile) != count)			goto oops;	}	else	{		if (EOFseen)			return OK;		for (p = Txbuf; count > 0; count--)		{			if (*p == CPMEOF)			{				EOFseen = TRUE;				return OK;			}			if (*p == '\n')			{				if (lastsent != '\r' && putc ('\r', Outfile) == EOF)					goto oops;			}			else			{				if (lastsent == '\r' && putc ('\n', Outfile) == EOF)					goto oops;			}			if (putc ((lastsent = *p++), Outfile) == EOF)				goto oops;		}	}*/		if (FSWrite ( Outfile, &count, Txbuf ))		goto oops;			if (count != RxCount)		goto oops;		*rxbytes += RxCount;	Rxpos_total = *rxbytes;	(void) sprintf (j, "%ld min",		(long) (((file_length - *rxbytes) * 10L) / cur_baud + 53L) / 54L);	if ((LMGetTicks () - RxStart) != 0)//		cps = (((*rxbytes * 60L) / (LMGetTicks () - RxStart)) * 1000L) / cur_baud;		cps = (((*rxbytes - Filestart) * 60L) / (LMGetTicks () - RxStart));	else		cps = 0;	newMessage (lRSTAT, "%ld:%ld (%ld) [%s, %ld cps]", *rxbytes, file_length, count, j, cps);	drawProgressBar (IRBAR, *rxbytes, file_length);	drawProgressCircle (IRCIRCLE, count, 0);	putMessage (0, "\pTransferring file(s)É");/*	if (fullscreen && un_attended)	{		elapse_time ();		sb_move (filewin, 2, 2);		sb_puts (filewin, ultoa (((unsigned long) (*rxbytes)), e_input, 10));		sb_move (filewin, 2, 69);		sb_puts (filewin, j);		elapse_time ();		sb_show ();	}	else	{		gotoxy (locate_x, locate_y);		(void) cputs (ultoa (((unsigned long) (*rxbytes)), e_input, 10));		gotoxy (locate_x + 20, locate_y);		(void) printf ("%s", j);		(void) putch (' ');#if defined __IBMC__		fflush (stdout);#endif	}*/	return OK;oops:	putlog (lgALRT, "Write error!");//	(void) got_error (MSG_TXT (M_WRITE_MSG), Filename);	return ERROR;}								/* RZ_SaveToDisk *//*--------------------------------------------------------------------------*//* RZ ACK BIBI                                                              *//* Ack a ZFIN packet, let byegones be byegones                              *//*--------------------------------------------------------------------------*/static void RZ_AckBibi (){	register short n;#ifdef DEBUG	show_debug_name ("RZ_AckBiBi");#endif	CLEAR_OUTBOUND ();	CLEAR_INBOUND ();	Z_PutLongIntoHeader (0L);	for (n = 4; --n;)	{		Z_SendHexHeader (ZFIN, (unsigned char *) Txhdr);		switch (Z_GetByte (100))		{		case 'O':			(void) Z_GetByte (1);	/* Discard 2nd 'O' */			/* Fall-through */		case TIMEOUT:		case RCDO:			return;		}						/* switch */	}							/* for */}								/* RZ_AckBibi */