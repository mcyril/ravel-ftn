#include <string.h>#include <stdio.h>#include "Ravel_FTN.h"#include "Ravel_Internal.h"#include "Ravel_Prefs.h"#include "compatible.h"#include "PascalStr.h"#include "Scheduler.h"#include "Unattended.h"#include "Manual.h"#include "myEnv.h"#include "freq.h"#include "log.h"#include "stringutl.h"#include "zfiles.h"#include "zmodem.h"pfreq	freqchain;extern	Str255	freqPath;extern	Boolean	Aborted;extern	long	freq_event_mask;extern	ADDR	remote_addr;extern	homeHndl		homesystem;			//	¥	Home system structshort matchaka ( ADDR *addrs );static char	*mnt[12] = { "Jan", "Feb", "Mar",						 "Apr", "May", "Jun",						 "Jul", "Aug", "Sep",						 "Oct", "Nov", "Dec" };static short pstrcasecmp ( StringPtr s1, StringPtr s2 ){	Str255	s11, s12;		pStrCopy ( s1, s11 );	pStrCopy ( s2, s12 );	UprText ( (Ptr) &s11[1], s11[0] );	UprText ( (Ptr) &s12[1], s12[0] );		return pStrComp ( s11, s12 );}static Boolean getFullPathFromAlias (StringPtr filename, short vRefNum, StringPtr gotta){	short		aliasFRef, oldFRef = CurResFile (), iErr;	AliasHandle	alias;	Boolean		Changed;	FSSpec		target;	aliasFRef = OpenRFPerm ( filename, vRefNum, fsRdWrPerm );	if (aliasFRef == -1)	{//		printf ("Can't open this resource fileÉ [%#s]\n", filename);		return false;	}		UseResFile (aliasFRef);	alias = (AliasHandle) Get1Resource ( 'alis', 0 );		if (!alias)	{//		printf ("No 'alis' resource found in this fileÉ[%#s]\n", filename);		UseResFile (oldFRef);		return false;	}	//	DetachResource ( (Handle) alias);//	UseResFile (oldFRef);//	CloseResFile (aliasFRef);		Changed = false;	iErr = ResolveAlias ( NULL, alias, &target, &Changed );	if (iErr == noErr && Changed)	{		ChangedResource ((Handle)alias);		WriteResource ((Handle)alias);		UpdateResFile (oldFRef);	}		ReleaseResource ((Handle)alias);	UseResFile (oldFRef);	CloseResFile (aliasFRef);//	DisposeHandle ((Handle) alias);		if (iErr)	{//		printf ("Can't resolve aliasÉ [error %d occured %#s]\n", iErr, filename);		return false;	}		PathNameFromDirID ( target.parID, target.vRefNum, gotta );	pStrConc (gotta, target.name, gotta);//	printf ("%#s is full path: %#s\n", filename, gotta);	return true;}static Boolean parseFreqFolder (StringPtr freq, StringPtr folderpath){	short		oldFRef = CurResFile (), idx, rc, vRefNum;//	AliasHandle	alias;//	Boolean		Changed;//	FSSpec		target;	Str255		filename;	CInfoPBRec	cipbr;						/* local pb */	HFileInfo	*fpb = (HFileInfo *)&cipbr;	/* to pointers */			if (!(vRefNum = myOpenWD (folderpath)))		return false;	UseResFile (oldFRef);	fpb->ioNamePtr = filename;	for ( idx=1; true; idx++ )	{											/* indexing loop */		fpb->ioDirID = 0L;						/* must set on each loop */		fpb->ioFDirIndex = idx;		fpb->ioVRefNum = vRefNum;		filename[0] = 0;				rc = PBGetCatInfoSync (&cipbr);				if (rc) break;							/* exit when no more entries */		if (!(fpb->ioFlAttrib & 16) && !pstrcasecmp (freq, filename))		{			CloseWD (vRefNum);			pStrConc (folderpath, "\p:", folderpath);			pStrConc (folderpath, filename, folderpath);			return true;		}	}	/* node cycle */	CloseWD (vRefNum);	return false;}Boolean parseFreqAliasFolder (StringPtr freq, StringPtr found){	short		oldFRef = CurResFile (), iErr, idx, rc, vRefNum;//	AliasHandle	alias;//	Boolean		Changed;//	FSSpec		target;	Str255		filename;	CInfoPBRec	cipbr;						/* local pb */	HFileInfo	*fpb = (HFileInfo *)&cipbr;	/* to pointers */			if (!(vRefNum = myOpenWD (freqPath)))		return false;	UseResFile (oldFRef);	fpb->ioNamePtr = filename;	for ( idx=1; true; idx++ )	{											/* indexing loop */		fpb->ioDirID = 0L;						/* must set on each loop */		fpb->ioFDirIndex = idx;		fpb->ioVRefNum = vRefNum;		filename[0] = 0;				rc = PBGetCatInfoSync (&cipbr);				if (rc) break;							/* exit when no more entries *///		if ( !(fpb->ioFlAttrib & 16) && (fpb->ioFlFndrInfo.fdType == 'adrp' || fpb->ioFlFndrInfo.fdType == 'fdrp') )		if ( (fpb->ioFlFndrInfo.fdFlags & 0x8000) )		{			if (fpb->ioFlFndrInfo.fdType == 'fdrp' || fpb->ioFlFndrInfo.fdType == 'faet')			{		//	¥	Going to folder adventure						if (getFullPathFromAlias (filename, vRefNum, found))					if (parseFreqFolder (freq, found))					{						CloseWD (vRefNum);//	putlog ('!', "Found: %#s", found);						return true;					}			}			else			{		//	¥	Check filealias name							if ( !pstrcasecmp (freq, filename) )				{					iErr = getFullPathFromAlias (filename, vRefNum, found);					CloseWD (vRefNum);//	putlog ('!', "Found: %#s", found);					return iErr;				}			}		}	}	/* node cycle *///	putlog ('!', "Not found");	CloseWD (vRefNum);	return false;}static void create_receipt (StringPtr pktname){	short		refnum, i;		FTS1PKTHDR	p;	FTS1PKTMSG	m;		char		temp[128], tmp[64];	daddr		orig;	DateTimeRec	dtr;	long		ioCount;		if (Create (pktname, 0, 'RvlM', 'PKT ') == noErr)	{		if (FSOpen (pktname, 0, &refnum) == noErr)		{//	pkt headr			memset (&p, 0, sizeof (FTS1PKTHDR));						i = matchaka (&remote_addr);			orig = (i == 0 || i == -1) ? (*homesystem)->mainAddr : (*homesystem)->AKAAddr[i-1];						GetTime (&dtr);						p.OrigNode = endshort (orig.ad.node);			p.DestNode = endshort (remote_addr.Node);			p.Year = endshort (dtr.year);			p.Month = endshort (dtr.month - 1);			p.Day = endshort (dtr.day);			p.Hour = endshort (dtr.hour);			p.Minute = endshort (dtr.minute);			p.Second = endshort (dtr.second);			p.Rate = 0;			p.Version = endshort (2);			p.OrigNet = endshort (orig.ad.net);			p.DestNet = endshort (remote_addr.Net);    			p.PCodeLo = PRODUCT_LO;			p.PRevMajor = MAJOR_VRS;			p.QMOrigZone = endshort (orig.ad.zone);			p.QMDestZone = endshort (remote_addr.Zone);			p.AuxNet = 0;			p.CWValidate = 0x0001;			p.PCodeHi = PRODUCT_HI;			p.PRevMinor = MINOR_VRS;			p.CWCapWord = endshort (0x0001);			p.OrigZone = endshort (orig.ad.zone);			p.DestZone = endshort (remote_addr.Zone);			p.OrigPoint = endshort (orig.ad.point);			p.DestPoint = endshort (remote_addr.Point);						ioCount = sizeof (FTS1PKTHDR);			FSWrite (refnum, &ioCount, &p);//	msg headr			memset (&m, 0, sizeof (FTS1PKTMSG));			m.Version = endshort (2);			m.OrigNode = endshort (orig.ad.node);			m.DestNode = endshort (remote_addr.Node);			m.OrigNet = endshort (orig.ad.net);			m.DestNet = endshort (remote_addr.Net);			m.Attr = endshort (MSGPRIVATE);			m.Cost = 0;			ioCount = sizeof (FTS1PKTMSG);			FSWrite (refnum, &ioCount, &m);//	date			dtr.year %= 100;			sprintf ( temp, "%.2d %s %.2d  %.2d:%.2d:%.2d",							dtr.day, mnt[dtr.month-1], dtr.year, dtr.hour, dtr.minute, dtr.second );						ioCount = strlen (temp) + 1;			FSWrite (refnum, &ioCount, temp);//	to user			sprintf (temp, "SysOp on %s", printaddr1 (&remote_addr, tmp));			ioCount = strlen (temp) + 1;			FSWrite (refnum, &ioCount, temp);//	from user			sprintf (temp, "RavelMAIL on %s", printaddr (&orig.ad, tmp));			ioCount = strlen (temp) + 1;			FSWrite (refnum, &ioCount, temp);//	subject			sprintf (temp, "Request statistic");			ioCount = strlen (temp) + 1;			FSWrite (refnum, &ioCount, temp);//	msg body			sprintf (temp, "\1INTL %d:%d/%d %d:%d/%d\r",				remote_addr.Zone, remote_addr.Net, remote_addr.Node,				orig.ad.zone, orig.ad.net, orig.ad.node );			ioCount = strlen (temp);			FSWrite (refnum, &ioCount, temp);			if (remote_addr.Point)			{				sprintf (temp, "\1TOPT %d\r", remote_addr.Point);				ioCount = strlen (temp);				FSWrite (refnum, &ioCount, temp);			}			if (orig.ad.point)			{				sprintf (temp, "\1FMPT %d\r", orig.ad.point);				ioCount = strlen (temp);				FSWrite (refnum, &ioCount, temp);			}						strcpy (temp, "Dear requestor,\rthe following file request(s) has been processed:\r\r");			ioCount = strlen (temp);			FSWrite (refnum, &ioCount, temp);//							          1         2         3         4         5         6         7//							01234567890123456789012345678901234567890123456789012345678901234567890			strcpy (temp,  " Alias            File                                 Size\r");			ioCount = strlen (temp);			FSWrite (refnum, &ioCount, temp);			strcpy (temp,  "=======================================================================\r\r");			ioCount = strlen (temp);			FSWrite (refnum, &ioCount, temp);						FSClose (refnum);		}	}}static void add_receipt (StringPtr pktname, StringPtr filename, char *msg){	short		refnum;	long		ioCount, fst_size = 0;	char		temp[128];	Str255		found;		if (FSOpen (pktname, 0, &refnum) == noErr)	{		SetFPos (refnum, fsFromLEOF, 0L);				if (msg)		{			sprintf (temp, "%s\r", msg);		}		else		{			filename[filename[0]+1] = 0;			if (parseFreqAliasFolder (filename, found))			{				found[found[0]+1] = 0;							GetInfoFile (0, 0, found, (unsigned long *) &ioCount, (unsigned long *) &ioCount, &ioCount, &ioCount, &fst_size);								if (!pstrcasecmp)					sprintf (temp, " %-16s %-32s      %ld%c\r",	" ",																trunc_path ((char *) &found[1]),																(fst_size > 1024L) ? fst_size / 1024L : fst_size,																(fst_size > 1024L) ? 'K' : 'b');				else					sprintf (temp, " %-16s %-32s      %ld%c\r",	&filename[1],																trunc_path ((char *) &found[1]),																(fst_size > 1024L) ? fst_size / 1024L : fst_size,																(fst_size > 1024L) ? 'K' : 'b');			}			else				sprintf (temp, " %-16s %-32s      %s\r", &filename[1], " ", "File not found");		}				ioCount = strlen (temp);		FSWrite (refnum, &ioCount, temp);		FSClose (refnum);	}}static char	*trailer = "\r=======================================================================\r\r\rSee ya!\r--- " \MAILERNAME " " RAVELVERS " " #ifndef LITERAVELISA #endif"\r";static void append_trailer (StringPtr pktname){	short		refnum;	long		ioCount, zero = 0L;			if (FSOpen (pktname, 0, &refnum) == noErr)	{		SetFPos (refnum, fsFromLEOF, 0L);				ioCount = strlen (trailer);		FSWrite (refnum, &ioCount, trailer);		ioCount = 3L;		FSWrite (refnum, &ioCount, &zero);		FSClose (refnum);	}}void appendrequests (char *textarray){	char	*p = textarray;	Str31	tmp;//	short	i;	pfreq	xfreqchain, xfreqchain1, receipt;	char	s[128];		if (freqchain && freqchain->next == NULL)		return;	if (!CheckEventNow (freq_event_mask))	{		if (!freqchain)		{			freqchain = (pfreq) NewPtr (sizeof (freq));			xfreqchain = freqchain;			xfreqchain->sumsent = true;			xfreqchain->wassent = false;			sprintf (&s[1], "%.8lX.PKT", LMGetTicks ());			s[0] = strlen (&s[1]);			pStrCopy ((StringPtr) s, xfreqchain->freqname);			xfreqchain->next = NULL;			create_receipt (xfreqchain->freqname);			add_receipt (xfreqchain->freqname, xfreqchain->freqname, "\rFile requests not allowed (in this time).");		}		return;	}		while (*p)	{		tmp[0] = 0;		while (*p > '!' && tmp[0] < 32)		{			tmp[0]++;			tmp[tmp[0]] = *p;			p++;		}				if (tmp[0] && tmp[0] < 32)		{			if (!freqchain)			{				freqchain = (pfreq) NewPtr (sizeof (freq));				xfreqchain = freqchain;								xfreqchain->next = (pfreq) NewPtr (sizeof (freq));				receipt = xfreqchain = xfreqchain->next;//	¥	Write to LAST in chain				xfreqchain->sumsent = true;				xfreqchain->wassent = false;				sprintf (&s[1], "%.8lX.PKT", LMGetTicks ());				s[0] = strlen (&s[1]);				pStrCopy ((StringPtr) s, xfreqchain->freqname);				xfreqchain->next = NULL;//	¥	Create pkt header and message here				create_receipt (xfreqchain->freqname);//	¥				xfreqchain = freqchain;			}			else			{				xfreqchain = freqchain;								while ((xfreqchain->next)->next)					xfreqchain = xfreqchain->next;								xfreqchain1 = xfreqchain->next;								if (xfreqchain1->wassent)				{//	¥	receipt was sent create new										xfreqchain1->next = (pfreq) NewPtr (sizeof (freq));					xfreqchain = xfreqchain1->next;										receipt = xfreqchain->next = (pfreq) NewPtr (sizeof (freq));					xfreqchain = xfreqchain->next;//	¥	Write to LAST in chain					xfreqchain->sumsent = true;					xfreqchain->wassent = false;					sprintf (&s[1], "%.8lX.PKT", LMGetTicks ());					s[0] = strlen (&s[1]);					pStrCopy ((StringPtr) s, xfreqchain->freqname);					xfreqchain->next = NULL;//	¥	Create pkt header and message here					create_receipt (xfreqchain->freqname);//	¥					xfreqchain = xfreqchain1->next;				}				else				{//	¥	insert before unsent receipt					xfreqchain->next = (pfreq) NewPtr (sizeof (freq));					xfreqchain = xfreqchain->next;					receipt = xfreqchain->next = xfreqchain1;				}			}						xfreqchain->sumsent = false;			xfreqchain->wassent = false;			pStrCopy (tmp, xfreqchain->freqname);						putlog (lgNOPE, "Incoming freq: %#s", xfreqchain->freqname);						add_receipt (receipt->freqname, xfreqchain->freqname, NULL);		}				while (*p > 0x1F)			p++;				//	bypass passwordsÉ not support yet			while (*p && *p < ' ')			p++;				//	bypass EOL	}//	putlog (lgATTN, "FREQ-");}short respond_to_file_requests (short fsent, short (*EMSI_callback)(StringPtr)){	short	res = fsent, rrr;	pfreq	xfreqchain;	Str255	found;		if (!freqPath[0])		return res;//	putlog (lgATTN, "FREQ respond");	if (xfreqchain = freqchain)	{		do {//	putlog (lgATTN, "look: %#s", xfreqchain->freqname);					if (!xfreqchain->wassent)			{				if (xfreqchain->sumsent)				{//	¥	Append trailer to receipt pkt										append_trailer (xfreqchain->freqname);				}								if (xfreqchain->sumsent || parseFreqAliasFolder (xfreqchain->freqname, found))				{					if (!xfreqchain->sumsent)						putlog (lgNOPE, "Processing freq: %#s", xfreqchain->freqname);					if ( (rrr = EMSI_callback ((xfreqchain->sumsent) ? xfreqchain->freqname : found )) != OK )					{						if (rrr != SPEC_COND)						{							Aborted = true;							putlog ( lgATTN, "Sending fault..." );							return 0;						}					}//					else						res++;				}								xfreqchain->wassent = true;			}						xfreqchain = xfreqchain->next;				} while (xfreqchain);	}//	putlog (lgATTN, "FREQ respond done");	return res;}