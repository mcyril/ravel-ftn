#include <string.h>#include "PopList.h"#define	max(a,b)	((a)>(b))?(a):(b)#define	min(a,b)	((a)<(b))?(a):(b)static pascal void PopLDEF (		short							lMessage,		Boolean							lSelect,		Rect							*lRect,		Cell							listCell,		short							lDataOffset,		short							lDataLen,		ListHandle						lHandle	){#pragma unused (listCell)	FontInfo 		fi;	PopListPtr		pi;	PopListPvtHdl	Pvt;//	unsigned char	oldMode;//	PenState		penState;	Rect			iRect;		if ((lMessage == lInitMsg) || (lMessage == lCloseMsg))		return ;		switch (lMessage)	{	case lDrawMsg:			if (lDataLen > 0)		{			memcpy (&pi, *((*lHandle)->cells)+lDataOffset, sizeof (PopListPtr));			EraseRect (lRect);						Pvt = (PopListPvtHdl) (*lHandle)->userHandle;						if (Pvt && (*Pvt)->drawProc)			{				iRect = *lRect;				iRect.right -= 16 + 3;								((*Pvt)->drawProc) (lHandle, (Ptr)&pi->data[0], pi->dataLength, &iRect, lDrawMsg);			}			else			{				GetFontInfo (&fi);				MoveTo (lRect->left+(*lHandle)->indent.h, lRect->top+(*lHandle)->indent.v + fi.ascent);				DrawText ((Ptr)&pi->data[0], 0, pi->dataLength);			}			if (pi->flag & kHasPopUp)			{				iRect = *lRect;//				iRect.top++;				iRect.right -= 3;				iRect.left = iRect.right - 16;				iRect.bottom = iRect.top + 16;								PlotIconID (&iRect, atNone, (((WindowPeek)((*lHandle)->port))->hilited) ? ttNone : ttDisabled, 5010);			}		}		else			EraseRect (lRect);		if (!lSelect)			break;			case lHiliteMsg:			LMSetHiliteMode(LMGetHiliteMode() & ~(1 << hiliteBit));		Pvt = (PopListPvtHdl) (*lHandle)->userHandle;		if (Pvt && (*Pvt)->drawProc)		{			if (lDataLen > 0)			{				memcpy (&pi, *((*lHandle)->cells)+lDataOffset, sizeof (PopListPtr));				((*Pvt)->drawProc) (lHandle, (Ptr)&pi->data[0], pi->dataLength, lRect, lHiliteMsg);			}			else				InvertRect (lRect);		}		else		{			InvertRect (lRect);		}		break;	}}ListHandle NewPopList (		const Rect					*viewRect,		const Point					*cellsize,		PopListDrawProc				drawProc,		char						listFlags	){	ListHandle		list;	Handle			iHandle, Pvt;	Rect			rDataBnds;	GrafPtr			currentPort;	GetPort(&currentPort);	iHandle = Get1Resource ( 'LDEF', LDEF_PopStub );#if defined(powerc) || defined(__powerc)	*((long *)((*iHandle)+2)) = (long) NewListDefProc ((ProcPtr) PopLDEF);#else	*((long *)((*iHandle)+2)) = (long) PopLDEF;#endif	Pvt = NewHandle (sizeof (PopListPvtRecord));		if (!Pvt)		return NULL;			(*((PopListPvtHdl) Pvt))->drawProc = drawProc;		SetRect ( &rDataBnds, 0, 0, 1, 0 );	list = LNew (				viewRect,				&rDataBnds,				*cellsize,				LDEF_PopStub,				currentPort,				true,				false,				false,				true			);		if (list)	{		(*list)->selFlags = listFlags;		(*list)->userHandle = Pvt;	}	else		DisposeHandle (Pvt);		return list;}void DisposePopList (ListHandle list){	DisposeHandle ((*list)->userHandle);	(*list)->userHandle = NULL;	LDispose (list);}PopListClickState PopListClick(		ListHandle					theList,		const EventRecord			*eventRecordPtr,		Cell						*selectedListCell	){		Cell						theCell;		Rect						hitRect;		Point						mousePt;		PopListClickState			result;		short						cellHeight;		short						visibleTop;		short						dataLen;		PopListPtr					pi;		mousePt = eventRecordPtr->where;		GlobalToLocal(&mousePt);		hitRect = (**theList).rView;		hitRect.right += 15;		if (!PtInRect(mousePt, &hitRect))			result = kPopListNotInList;		else		{			visibleTop = (**theList).visible.top;			cellHeight = (**theList).cellSize.v;			theCell.h = 0;			theCell.v =				((mousePt.v - (**theList).rView.top) / cellHeight)				+ visibleTop;			if (theCell.v >= (**theList).dataBounds.bottom)				goto usual_click;							dataLen = sizeof (PopListPtr);			LGetCell (&pi, &dataLen, theCell, theList);			if (dataLen == sizeof (PopListPtr) && (pi->flag & kHasPopUp))			{				Rect	cellRect;							LRect (&cellRect, theCell, theList);								if (cellRect.left == 0 && cellRect.right == 0 &&					cellRect.top == 0 && cellRect.bottom == 0)					goto usual_click;				else				{					cellRect.top++;					cellRect.right -= 3;					cellRect.left = cellRect.right - 16;					cellRect.bottom = cellRect.top + 16;										if (PtInRect (mousePt, &cellRect))					{						result = kPopListClickPopUp;						*selectedListCell = theCell;					}					else						goto usual_click;				}			}			else			{			usual_click:							result = (LClick(mousePt, eventRecordPtr->modifiers, theList))					? kPopListDoubleClick					: kPopListClick;				*selectedListCell = theCell;			}		}		return result;}void PopListSetCell (Ptr dataPtr, short dataLen, Cell theCell, ListHandle lHandle, Boolean PopList){	PopListPtr					pi;	pi = (PopListPtr) NewPtrClear (sizeof (PopListRecord) + dataLen);		if (pi)	{		memcpy (pi->data, dataPtr, dataLen);		pi->dataLength = dataLen;		pi->flag = (PopList) ? kHasPopUp : 0;				LSetCell (&pi, sizeof (PopListPtr), theCell, lHandle);	}}void PopListGetCell (Ptr dataPtr, short *dataLen, Cell theCell, ListHandle lHandle){	PopListPtr					pi;	short						len;	len = sizeof (PopListPtr);	LGetCell (&pi, &len, theCell, lHandle);		if (len == sizeof (PopListPtr))	{		memcpy (dataPtr, pi->data, min (*dataLen, pi->dataLength));		*dataLen = min (*dataLen, pi->dataLength);	}	else	{		*dataLen = 0;	}}void PopListDelCell (Cell theCell, ListHandle lHandle){	PopListPtr					pi;	short						len;	len = sizeof (PopListPtr);	LGetCell (&pi, &len, theCell, lHandle);		if (len == sizeof (PopListPtr))		DisposePtr ((Ptr) pi);}