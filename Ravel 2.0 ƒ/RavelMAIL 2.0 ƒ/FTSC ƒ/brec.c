#include <ctype.h>#include <stdio.h>#include <string.h>#include "PascalStr.h"#include "Ravel_FTN.h"#include "Ravel_Prefs.h"#include "Pathes.h"#include "ftsc.h"//#include "pkthdrs.h"#include "definitions.h"#include "ascii.h"#include "compatible.h"#include "stringutl.h"#include "Scheduler.h"#include "Unattended.h"#include "Attacher.h"#include "Comm.h"#include "Timing.h"#include "xmodem.h"#include "log.h"#include "freq.h"#include "myEnv.h"#include "zfiles.h"#include "state.h"#include "pmain.h"#include "Modem.h"#include "aglcrc.h"short  BRInit (XMARGSP, short);short  BREnd (XMARGSP, short);short  BRTestSL (XMARGSP);short  BRCheckSL (XMARGSP);short  BRCheckFNm (XMARGSP);short  BRCheckFile (XMARGSP);short  BRFindType (XMARGSP);STATES Batch_Receiver[] = {   { "BRInit", (ProcPtr) BRInit },   { "BREnd", (ProcPtr) BREnd },   { "BR0", (ProcPtr) BRTestSL },   { "BR1", (ProcPtr) BRCheckSL },   { "BR2", (ProcPtr) BRCheckFNm },   { "BR3", (ProcPtr) BRCheckFile },   { "BR4", (ProcPtr) BRFindType },};extern	short	no_sealink;short  BRInit (XMARGSP args, short start_state){// XON_DISABLE ();   args->filename = NewPtrClear (256);   return (start_state);}short  BREnd (XMARGSP args, short cur_state){   DisposePtr (args->filename);   return (cur_state);}short  BRTestSL (XMARGSP args){   if (!no_sealink)      SENDBYTE (WANTCRC, NULL);   args->T1 = timerset (1000);   args->T2 = timerset (12000);   return (BR1);}short  BRCheckSL (args)XMARGSP args;{   long BR1Timer;   BR1Timer = timerset (200);   while (!timeup (BR1Timer))      {      if (timeup (args->T2) || no_sealink)         {         args->result = Modem7_Receive_File (args->filename);         return (BR2);         }      if ((args->CHR = PEEKBYTE ()) >= 0)         {         return (BR4);         }      if (timeup (args->T1))         {         args->result = Modem7_Receive_File (args->filename);         return (BR2);         }      else         {         if (!CARRIER)            return (CARRIER_ERR);         else            time_release ();         }      }   SENDBYTE (WANTCRC, NULL);   return (BR1);}short  BRCheckFNm (args)XMARGSP args;{   char buff1[20];   char *p;   short i;   (void) memset (buff1, 0, 19);   /* Was it the last file */#ifdef NEW	/* SWG: 9th July 1991 : I think is wrong.. it stops FTS receiver from sending! */	if(args->result == SUCCESS_EOT)#else   if (args->result == EOT_RECEIVED)#endif      {      return (SUCCESS);      }   /* Did we get a valid filename */   else if (args->result == SUCCESS)      {      /* First set up the filename buffer */      p = buff1;      for (i = 0; i < 8; ++p, i++)         {         if (args->filename[i] != ' ')            {            *p = args->filename[i];            }         else            break;         }      *p = '.';      ++p;      *p = '\0';      for (i = 8; i < 11; ++p, i++)         {         if (args->filename[i] != ' ')            {            *p = args->filename[i];            }         else            break;         }      *p = '\0';      (void) strcpy (args->filename, buff1);      args->result = Xmodem_Receive_File (args->path, args->filename);      return (BR3);      }   /* Otherwise, we have to exit */   else      return (args->result);}short  BRCheckFile (XMARGSP args){   /* Was the file transfer good */   if ((args->result == SUCCESS) || (args->result == SUCCESS_EOT))      {      return (BR0);      }   else      {      return (args->result);      }}short  BRFindType (args)XMARGSP args;{   switch (args->CHR)      {      case NUL:         (void) TIMED_READ (0, NULL);         args->T1 = timerset (2000);         return (BR1);      case SOH:      case SYN:         args->result = Batch_Xmodem_Receive_File (args->path, args->filename);         return (BR3);      case EOT:         (void) TIMED_READ (0, NULL);         SENDBYTE (ACK, NULL);         return (SUCCESS);      default:         (void) TIMED_READ (0, NULL);         return (BR1);      }}short Batch_Receive (char *where){   XMARGS batch;   short res; 	newMessage (lTNAME, "");	newMessage (lTSTAT, "");	newMessage (lRNAME, "");	newMessage (lRSTAT, "");	batch.result = 0;	batch.path = where;	res = state_machine (Batch_Receiver, &batch, 2);	return (res);}