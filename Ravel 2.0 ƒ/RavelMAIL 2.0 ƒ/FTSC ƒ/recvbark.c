#include <ctype.h>#include <stdio.h>#include <string.h>#include "PascalStr.h"#include "Ravel_FTN.h"#include "Ravel_Prefs.h"#include "Pathes.h"#include "ftsc.h"//#include "pkthdrs.h"#include "definitions.h"#include "ascii.h"#include "compatible.h"#include "stringutl.h"#include "Scheduler.h"#include "Unattended.h"#include "Attacher.h"#include "Comm.h"#include "Timing.h"#include "xmodem.h"#include "log.h"#include "freq.h"#include "myEnv.h"#include "zfiles.h"#include "state.h"#include "pmain.h"#include "Modem.h"#include "aglcrc.h"#include "log.h"extern	ADDR	called_addr;extern long		freq_event_mask;static short get_req_str (char *);static void gen_req_name (char *);static short cdog_callback (unsigned char *reqs);short  RBInit (BARKARGSP, short);short  RBEnd (BARKARGSP, short);short  RBHonorReq (BARKARGSP);short  RBWaitBark (BARKARGSP);short  RBAckBark (BARKARGSP);short  RBWaitStrt (BARKARGSP);short  RBSendFile (BARKARGSP);STATES Bark_Receiver[] = {   { "RBInit", (ProcPtr) RBInit },   { "RBEnd", (ProcPtr) RBEnd },   { "RB0", (ProcPtr) RBHonorReq },   { "RB1", (ProcPtr) RBWaitBark },   { "RB2", (ProcPtr) RBAckBark },   { "RB3", (ProcPtr) RBWaitStrt },   { "RB4", (ProcPtr) RBSendFile }};short Receive_Bark_Packet (BARKARGSP args);short Receive_Bark_Packet (BARKARGSP args){   if (get_req_str (args->barkpacket))      {      gen_req_name (args->barkpacket);      args->barkok = 1;      return (0);      }   return (1);}short  RBInit (BARKARGSP args, short start_state){// XON_DISABLE ();   args->barkok = 0;   return (start_state);}short  RBEnd (BARKARGSP args, short cur_state){#pragma unused (args)	if (CheckEventNow (freq_event_mask))//	if (!no_requests)	{//		status_line (":%s %s %s", msgtxt[M_END_OF], msgtxt[M_INBOUND], msgtxt[M_FILE_REQUESTS]);		putlog (lgNOPE, "Processing incoming file request(s) complete.");	}		return (cur_state);	/* args; */}short  RBHonorReq (BARKARGSP args){	args->nfiles = 0;	if (CheckEventNow (freq_event_mask))//	if (!no_requests)	{//		status_line (":%s %s", msgtxt[M_INBOUND], msgtxt[M_FILE_REQUESTS]);		putlog (lgNOPE, "Processing incoming file request(s).");		SENDBYTE (ENQ, NULL);		args->T1 = timerset (200);		return (RB1);	}	else	{		SENDBYTE (CAN, NULL);//		status_line (msgtxt[M_REFUSING_IN_FREQ]);		putlog (lgNOPE, "Refusing incoming file request(s).");		return (SUCCESS);	}}short  RBWaitBark (BARKARGSP args){   short c;   long RB1Timer;   RB1Timer = timerset (2000);   for (;;)      {      while ((c = PEEKBYTE ()) < 0)         {         if (!CARRIER)            return (CARRIER_ERR);         time_release ();         if (timeup (args->T1))            {            break;            }         }      if (timeup (RB1Timer))         {/* Report error */         return (SENDBLOCK_ERR);         }      if ((c == 0xffff) && timeup (args->T1))         {         CLEAR_INBOUND ();         SENDBYTE (ENQ, NULL);         args->T1 = timerset (200);         continue;         }      c = TIMED_READ (0, NULL);      switch (c)         {         case ACK:            if (Receive_Bark_Packet (args) == 0)               return (RB2);            else               return (RB0);         case ETB:/* Report done */            return (SUCCESS);         case ENQ:            SENDBYTE (ETB, NULL);            break;         }      }}short  RBAckBark (args)BARKARGSP args;{   if (args->barkok)      {      SENDBYTE (ACK, NULL);      return (RB3);      }   else      {      SENDBYTE (NAK, NULL);      return (RB1);      }}short  RBWaitStrt (BARKARGSP args){#pragma unused (args)   short c = -1;   long RB3Timer;   long RB3Timer1;   RB3Timer = timerset (1500);   while (CARRIER && (!timeup (RB3Timer)))      {      RB3Timer1 = timerset (300);      while (!timeup (RB3Timer1))         {         if ((c = PEEKBYTE ()) >= 0)            break;         time_release ();         }      if (c < 0)         SENDBYTE (ACK, NULL);      else if ((c == 'C') || (c == NAK))         return (RB4);      }/* Return error */   return (SENDBLOCK_ERR);   /* args; */}short  RBSendFile (BARKARGSP args){   short nfiles1;putlog ('~', "BARK PACKET: %s", args->barkpacket);#ifndef LITE	appendrequests (args->barkpacket);	nfiles1 = args->nfiles;	args->nfiles = respond_to_file_requests (args->nfiles, cdog_callback);#endif	(void) Batch_Send (NULL);	return (RB0);}short SEA_recvreq (){   BARKARGS bark;//  Netmail_Session = 2;	CLEAR_INBOUND ();   return (state_machine (Bark_Receiver, &bark, RB0));}static short get_req_str (char *req){   unsigned short crc, crc1, crc2, crc3;   short i, j;   crc = i = 0;   while (CARRIER)      {      j = TIMED_READ (2, NULL);      if (j < 0)         return (0);		if ((j == ACK) && (i == 0))			{			/* Just skip the extra ACK */			continue;			}		if (i >= 100)			{			/* Too long of a string *///			status_line (msgtxt[M_BAD_BARK]);			putMessage (2, "\pBad BARK");			CLEAR_INBOUND ();			return (0);			}      if (j == ETX)         {	 crc1 = TIMED_READ (2, NULL);	 crc2 = TIMED_READ (2, NULL);         crc3 = (crc2 << 8) + crc1;         if (crc3 != crc)            {//          status_line (msgtxt[M_BAD_CRC]);			putMessage (2, "\pBad CRC");            return (0);            }         req[i] = '\0';         return (1);         }      else if (j == SUB)         {         return (0);         }      else         {	 req[i++] = j;	 crc = xcrc (crc, (unsigned char)j);         }      }   return (0);}/* * gen_req_name -- take the name [time] [password] fields from *                 the BARK file request format and reformat to *                 name [!password] [+time] WaZOO format for use *                 by the WaZOO file request routines. * * Input:          *req = pointer to character array with Bark string * Output:         *req array contents reformatted * */static void gen_req_name (char *req){   char *q, *q1;   char buf[48];   char *fsecs = NULL;   q = req;   q1 = buf;   /* Get the filename */   while ((*q) && (!isspace (*q)))      {      *q1++ = *q++;      }   *q1 = '\0';   /* If we have more characters, go on */   if (*q)      {      /* Skip the space */      fsecs = q++;      *fsecs = '+';      /* Skip the digits */      while ((*q) && (!isspace (*q)))         q++;      /* If we have more, get the password */      if (*q)         {         *q++ = '\0';                   /* Skip space, terminate the time */         *q1++ = ' ';         *q1++ = '!';         while (*q)            {            *q1++ = *q++;            }         *q1 = '\0';         }      /* If we got an update time          */      if (fsecs != NULL)         {         *q1++ = ' ';         while (*fsecs)            {            *q1++ = *fsecs++;            }         *q1 = '\0';         }      }   (void) strcpy (req, buf);   return;}static short cdog_callback (unsigned char *reqs){	if (reqs)		reqs[reqs[0]+1] = 0;   return (!Batch_Send ((reqs) ? ((char *) reqs+1) : (NULL)));}