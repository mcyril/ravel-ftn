#include <ctype.h>#include <stdio.h>#include <string.h>#include "PascalStr.h"#include "Ravel_FTN.h"#include "Ravel_Prefs.h"#include "Pathes.h"#include "ftsc.h"//#include "pkthdrs.h"#include "definitions.h"#include "ascii.h"#include "compatible.h"#include "stringutl.h"#include "Scheduler.h"#include "Unattended.h"#include "Attacher.h"#include "Comm.h"#include "Timing.h"#include "xmodem.h"#include "log.h"#include "freq.h"#include "myEnv.h"#include "zfiles.h"#include "state.h"#include "pmain.h"#include "Modem.h"#include "aglcrc.h"short  MRInit (XMARGSP, short);short  MREnd (XMARGSP, short);short  MRSendNak (XMARGSP);short  MRWaitAck (XMARGSP);short  MRWaitChar (XMARGSP);short  MRWaitOkCk (XMARGSP);STATES Modem7_Receiver[] = {   { "MRInit", (ProcPtr) MRInit },   { "MREnd", (ProcPtr) MREnd },   { "MR0", (ProcPtr) MRSendNak },   { "MR1", (ProcPtr) MRWaitAck },   { "MR2", (ProcPtr) MRWaitChar },   { "MR3", (ProcPtr) MRWaitOkCk }};short  MRInit (XMARGSP args, short start_state){   args->tries = 0;   return (start_state);}short  MREnd (XMARGSP args, short cur_state){   args->result = cur_state;   return (cur_state);}short  MRSendNak (XMARGSP args){   if (args->tries >= 10)      return (FNAME_ERR);   args->fptr = args->filename;   SENDBYTE (NAK, NULL);   ++(args->tries);   return (MR1);}short  MRWaitAck (XMARGSP args){   long MR1Timer;   short in_char;   MR1Timer = timerset (1000);   while (!timeup (MR1Timer))      {      if ((in_char = PEEKBYTE ()) >= 0)         {         (void) TIMED_READ (0, NULL);         switch (in_char)            {            case ACK:               return (MR2);            case EOT:               args->result = SUCCESS_EOT;               return (SUCCESS_EOT);            }         }      else         {         if (!CARRIER)            return (CARRIER_ERR);         else            time_release ();         }      }   return (MR0);}short  MRWaitChar (XMARGSP args){   short in_char;   unsigned char check;   char *p;   in_char = TIMED_READ (10, NULL);   switch (in_char)      {      case -1:         return (MR0);      case EOT:         return (SUCCESS);      case SUB:         for (p = args->filename, check = SUB; p != args->fptr; p++)            check += (unsigned char) *p;         SENDBYTE (check, NULL);         return (MR3);      case 'u':         return (MR0);      default:         *args->fptr++ = (char) (in_char & 0xff);         SENDBYTE (ACK, NULL);         return (MR2);      }}short  MRWaitOkCk (XMARGSP args){   short in_char;   in_char = TIMED_READ (10, NULL);   if (in_char == ACK)      {      args->result = SUCCESS;      return (SUCCESS);      }      return (MR0);}short Modem7_Receive_File (char *filename){   XMARGS batch;   short res;   batch.result = 0;   batch.filename = filename;   res = state_machine (Modem7_Receiver, &batch, 2);   return (res);}