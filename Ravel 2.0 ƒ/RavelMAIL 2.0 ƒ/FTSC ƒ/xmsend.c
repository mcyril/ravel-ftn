#include <stdio.h>#include <stdlib.h>#include <string.h>#include "PascalStr.h"#include "Ravel_FTN.h"#include "Ravel_Prefs.h"#include "Pathes.h"#include "ftsc.h"//#include "pkthdrs.h"#include "definitions.h"#include "ascii.h"#include "compatible.h"#include "stringutl.h"#include "Scheduler.h"#include "Unattended.h"#include "Attacher.h"#include "Comm.h"#include "Timing.h"#include "xmodem.h"#include "log.h"#include "freq.h"#include "pmain.h"#include "myEnv.h"#include "zfiles.h"#include "state.h"#include "aglcrc.h"#include "history.h"extern	char	*xfer_id;extern	unsigned long	cur_baud;extern	short	no_overdrive;	//ееextern	short	no_resync;extern	short	loc_no_sealink;extern	short	small_window;extern	Boolean	Aborted;//#define XDEBUGvoid Check_ACKNAK (XMARGSP args);void show_sending_blocks (XMARGSP args);void Send_Block (XMARGSP args);void Get_Block (XMARGSP args);void show_num (XMARGSP args, long b);short calc_window (void);short Receive_Resync (long *resync_block);static void Build_Header_Block (XMARGSP args, char type){//  struct FILEINFO dta;	SEADATAP	ttmp;	char		*onlyname = trunc_path (args->filename);	long		dtatime, dum;	get_info (args->filename, (OSType *) &dum, (OSType *) &dum, &dtatime, &dum);	args->save_header = type;	ttmp = (SEADATAP) &args->datablock;	(void) memset (ttmp, 0, sizeof (XMDATA));	args->header = type;	ttmp->block_num = 0;	ttmp->block_num_comp = 0xff;	ttmp->filelength[0] = args->filelen & 0xff;	ttmp->filelength[1] = (args->filelen >> 8) & 0xff;	ttmp->filelength[2] = (args->filelen >> 16) & 0xff;	ttmp->filelength[3] = (args->filelen >> 24) & 0xff;		memset(ttmp->sendingprog, 0, 15);	(void) strncpy (ttmp->sendingprog, xfer_id, 14);	if (type == SYN)	{		(void) memset (ttmp->filename, ' ', 16);		MSConvertTime (false, (unsigned long *) &dtatime);				ttmp->date[0] = dtatime & 0xff;		ttmp->date[1] = (dtatime >> 8) & 0xff;		ttmp->time[0] = (dtatime >> 16) & 0xff;		ttmp->time[1] = (dtatime >> 24) & 0xff;		/* This is the CRC bit in the TeLink header */		ttmp->Resync = 1;	}	else	{//GENERIC			/* NB This is probably a bit ST specific */		ttmp->date[0] = args->save_filetime.twowords.date & 0xff;		ttmp->date[1] = args->save_filetime.twowords.date & 0xff;		ttmp->time[0] = (args->save_filetime.twowords.time >> 8) & 0xff;		ttmp->time[1] = (args->save_filetime.twowords.time >> 8) & 0xff;		ttmp->SLO = (unsigned char) (((cur_baud >= 9600) && !no_overdrive)? 1 : 0);		ttmp->Resync = (unsigned char) (no_resync ? 0 : 1);//		ttmp->MACFLOW = 1;		ttmp->MACFLOW = 0;	}	if (args->temp_name != NULL)		(void) strncpy (ttmp->filename, args->temp_name, strlen (args->temp_name));	else		(void) strncpy (ttmp->filename, onlyname, strlen (onlyname));}void XSSetVars (XMARGSP);short XSInit (XMARGSP, short);short XSEnd (XMARGSP, short);short XSXmtStart (XMARGSP);short XSXmTeStrt (XMARGSP);short XSCheckACK (XMARGSP);short XSSendBlk (XMARGSP);short XSWaitEnd (XMARGSP);STATES Xmodem_Sender[] = {   { "XSInit", (ProcPtr) XSInit },   { "XSEnd",  (ProcPtr) XSEnd },   { "XS0",    (ProcPtr) XSXmtStart },   { "XS0T",   (ProcPtr) XSXmTeStrt },   { "XS1",    (ProcPtr) XSCheckACK },   { "XS2",    (ProcPtr) XSSendBlk },   { "XS3",    (ProcPtr) XSWaitEnd }};short  XSInit (XMARGSP args, short start_state){//	struct stat st;//	char		junkbuff[100];	char		*onlyname = trunc_path (args->filename);	long		dtatime, dum, flen;	/* Get the file information */	if (get_info (args->filename, (OSType *) &dum, (OSType *) &dum, &dtatime, &flen) != noErr)	{/* Print error message */		return (OPEN_ERR);	}	if (xfsopen (args->filename, 0, &args->file_pointer) != noErr)	{/* Print error message */		return (OPEN_ERR);	}	MSConvertTime (false, (unsigned long *) &dtatime);	/* Get important information out of it */	args->filelen = flen;	args->LastBlk = (flen + 127) / 128;	args->save_filetime.oneword.timedate = dtatime;	args->prev_bytes = 0L;	args->tot_errs = 0;	putlog ('~', "Sending: %s", args->filename);	newMessage (lTNAME, "X-Sending: %s", trunc_path (args->filename));	putlog (lgNOPE, "X-Sending: %s (%ldb %ld blks)", trunc_path (args->filename), flen, args->LastBlk);/*	(void) sprintf (junkbuff, msgtxt[M_SEND_MSG], args->LastBlk, args->filename, st.st_size);	if (un_attended && fullscreen)	{		clear_filetransfer ();		sb_move (filewin, 1, 2);		sb_puts (filewin, junkbuff);		elapse_time ();		sb_show ();	}	else	{		status_line ("+%s", junkbuff);		scr_printf ("\r\n");		scr_refresh();	}   locate_y = wherey ();   locate_x = wherex ();*/	/* Start the throughput calculations *///	throughput (0, 0L);   return (start_state);}short XSEnd (XMARGSP args, short cur_state){	args->result = cur_state;	/* Close file */	FSClose (args->file_pointer);	if (args->tot_errs > 3)	{//		status_line (msgtxt[M_CORRECTED_ERRORS], args->tot_errs, args->LastBlk);	}		/* Log that we sent it */	if (cur_state == SUCCESS)	{		putlog ('~', "Sent: %s", args->filename);		history_add_traff (true, args->filelen);		putlog (lgNOPE, "Sent-X %s", trunc_path (args->filename));//		throughput (1, (unsigned long) (args->filelen - args->prev_bytes));//		status_line ("%s: %s", msgtxt[M_FILE_SENT], args->filename);//		update_files (1);	}	return (cur_state);}void XSSetVars (XMARGSP args){	if (loc_no_sealink)	{		args->options.SLO = 0;		args->options.Resync = 0;	}	else	{		args->options.SLO = ((cur_baud >= 9600) && !no_overdrive) ? 1 : 0;		args->options.Resync = (~no_resync) & 1;	}	args->options.SEAlink = 0;	args->SendBLK = 1;	args->curr_byte = 0L;	args->NextBLK = 1;	args->ACKST = 0;	args->ACKBLK = -1L;	args->Window = 1;	args->ACKsRcvd = 0;	args->NumNAK = 0;	args->T1 = timerset (3000);}short XSXmtStart (XMARGSP args){	XSSetVars (args);	Build_Header_Block (args, SOH);	return (XS1);}short XSXmTeStrt (XMARGSP args){	XSSetVars (args);	Build_Header_Block (args, SYN);	return (XS1);}short XSCheckACK (XMARGSP args){	Check_ACKNAK (args);	return (XS2);}short XSSendBlk (XMARGSP args){	if (!CARRIER)	{		Aborted = true;		return (CARRIER_ERR);	}	if (CheckCancel ())	{		Aborted = true;//		status_line (msgtxt[M_KBD_MSG]);		return (KBD_ERR);	}	if ((args->NumNAK > 4) && (args->SendBLK == 0))	{		if (args->save_header == SOH)			return (XS0T);		else		{			args->NumNAK = 0;			++(args->ACKBLK);			++(args->SendBLK);			return (XS2);		}	}	if (args->NumNAK > 10)	{/* Too Many Errors */		return (SEND_RETRY_ERR);	}	if (timeup (args->T1))	{/* Fatal Timeout */		return (SEND_TIMEOUT);	}	if (args->SendBLK > (args->LastBlk + 1))		return (XS3);	if (args->SendBLK > (args->ACKBLK + args->Window))	{		time_release ();		return (XS1);	}	if (args->SendBLK == (args->LastBlk + 1))	{		SENDBYTE (EOT, NULL);		++(args->SendBLK);		args->T1 = timerset (3000);		show_sending_blocks (args);		time_release ();		return (XS1);	}	/*		Increment the block count before sending because we read the next		block immediately after sending this block.  On error free connects		we have a big net win because we never do a seek, and while we are		sending one block, we read the next.  If we do get errors, then we		have to seek back to the previous block, and that will be a bother.		With today's phone lines and modems, we'll assume error free is more		often than not, and take our chances.	*/	if (args->options.SLO && args->options.SEAlink)	{		args->ACKBLK = args->SendBLK;	}	++(args->SendBLK);	args->curr_byte += 128L;	Send_Block (args);	args->T1 = timerset (6000);	return (XS1);}short XSWaitEnd (XMARGSP args){	show_sending_blocks (args);	if (args->ACKBLK < (args->LastBlk + 1))		{		time_release ();		return (XS1);		}	if (!CARRIER)		return (CARRIER_ERR);	return (SUCCESS);}short SEAlink_Send_File (char *filename, char *sendname){   XMARGS xm;	xm.filename = filename;	xm.temp_name = sendname;   return (state_machine (Xmodem_Sender, &xm, XS0));}short Xmodem_Send_File (char *filename, char *sendname){	return (SEAlink_Send_File (filename, sendname));}short Telink_Send_File (char *filename, char *sendname){   XMARGS xm;	xm.filename = filename;	xm.temp_name = sendname;   return (state_machine (Xmodem_Sender, &xm, XS0T));}void Get_Block (XMARGSP args){	XMDATAP	xtmp;	long	ioCounter;	if (args->SendBLK == 0)	{		Build_Header_Block (args, args->save_header);		args->NextBLK = -1L;		return;	}	xtmp = (XMDATAP) &args->datablock;	/* Set up buffer as all ^Zs for EOF */	(void) memset (xtmp, SUB, sizeof (XMDATA));	/* Now set up the header stuff */	args->header = SOH;	xtmp->block_num = (unsigned char) (args->SendBLK & 0xff);	xtmp->block_num_comp = ~xtmp->block_num;	if (args->NextBLK != args->SendBLK)	{//		(void) fseek (args->file_pointer, (args->SendBLK - 1) * 128, SEEK_SET);		SetFPos (args->file_pointer, fsFromStart, (args->SendBLK - 1L) * 128L);	}	args->NextBLK = args->SendBLK + 1;	/* Can we read any data? *///	if (fread ((char *) xtmp->data_bytes, 1, 128, args->file_pointer) <= 0)//		return;	ioCounter = 128;	FSRead (args->file_pointer, &ioCounter, xtmp->data_bytes);	/* Looks good */	return;}void Send_Block (XMARGSP args){	if ((!(args->options.do_CRC)) || (args->header == SYN))	{		Data_Check ((XMDATAP) &args->datablock, CHECKSUM);#ifdef XDEBUG		status_line(">sendblock: header=%02x, block=%02x|%02x, check=%02x",		args->header, args->datablock.block_num, args->datablock.block_num_comp,		args->datablock.data_check[0]);#endif		SENDBYTE(args->header, NULL);		SENDCHARS ((unsigned char *) &args->datablock, sizeof (XMDATA) - 1, 1, NULL);	}	else	{		Data_Check ((XMDATAP) &args->datablock, CRC);#ifdef XDEBUG		status_line(">sendblock: header=%02x, block=%02x, check=%02x %02x",		args->header, args->datablock.block_num,		args->datablock.data_check[0],		args->datablock.data_check[1]);#endif		SENDBYTE(args->header, NULL);		SENDCHARS ((unsigned char *) &args->datablock, sizeof (XMDATA), 1, NULL);	}	UNBUFFER_BYTES (NULL);	show_sending_blocks (args);	Get_Block (args);}void show_num (XMARGSP args, long b){#pragma unused (args, b)/*	if (b > args->LastBlk)	{		if (fullscreen && un_attended)			sb_puts (filewin, "EOT");		else			scr_printf ("EOT");	}	else if (b >= 0L)	{		if (fullscreen && un_attended)	      sb_puts (filewin, ultoa (((unsigned long) b), e_input, 10));		else	      scr_printf (ultoa (((unsigned long) b), e_input, 10));	}*/}void show_sending_blocks (XMARGSP args){//	char j[100];	short i;	long k, l;	k = args->filelen - args->curr_byte;	if (k < 0L)		k = 0L;	i = (short) ((k * 10 / cur_baud * 100 /			((args->save_header == SOH) ? 94 : 70) + 59) / 60);	//	sprintf (j, "%3d min", i);	if (args->options.SLO)	{		if ((!((args->SendBLK - 1) & 0x1f)) || ((args->SendBLK - 1) > args->LastBlk))		{			l = (args->SendBLK - 1) * 128L;			newMessage (lTSTAT, "%ld:%ld %3d min. *Overdrive*",								(l > args->filelen) ? args->filelen : l,								args->filelen,								i);		/*			if (fullscreen && un_attended)			{				elapse_time();				sb_move (filewin, 2, 2);				show_num (args, args->SendBLK - 1);				(void) sb_putc (filewin, ':');				show_num (args, args->ACKBLK);				(void) sb_puts (filewin, " *Overdrive*  ");				sb_move (filewin, 2, 69);				sb_puts (filewin, j);				sb_show ();			}			else			{				gotoxy (locate_x, locate_y);				show_num (args, args->SendBLK - 1);				scr_printf (":");				show_num (args, args->ACKBLK);				scr_printf (" *Overdrive*  ");				scr_refresh();			}		*/		}	}	else	{		l = (args->SendBLK - 1) * 128L;		newMessage (lTSTAT, "%ld:%ld %3d min.",								(l > args->filelen) ? args->filelen : l,								args->filelen,								i);/*		if (fullscreen && un_attended)		{			elapse_time();			sb_move (filewin, 2, 2);			show_num (args, args->SendBLK - 1);			(void) sb_putc (filewin, ':');			show_num (args, args->ACKBLK);			sb_puts (filewin, "              ");			sb_move (filewin, 2, 69);			sb_puts (filewin, j);			sb_show ();		}		else		{			gotoxy (locate_x, locate_y);			show_num (args, args->SendBLK - 1);			scr_printf (":");			show_num (args, args->ACKBLK);			scr_printf ("              ");			scr_refresh();		}*/	}}short  ACInit (XMARGSP, short);short  ACEnd (XMARGSP, short);short  ACChkRcvd (XMARGSP);short  ACSLCheck (XMARGSP);short  ACSLVerify (XMARGSP);short  ACSLACKNAK (XMARGSP);short  ACXMCheck (XMARGSP);short  ACSLOCheck (XMARGSP);short  ACSL1Check (XMARGSP);short  ACACKNAK (XMARGSP);short  ACXMACK (XMARGSP);short  ACXMNAK (XMARGSP);short  ACRESYNC (XMARGSP);STATES ACKNAK_Check[] = {   { "ACInit", (ProcPtr) ACInit },   { "ACEnd",  (ProcPtr) ACEnd },   { "AC0",    (ProcPtr) ACChkRcvd },   { "AC1",    (ProcPtr) ACSLCheck },   { "AC2",    (ProcPtr) ACSLVerify },   { "AC3",    (ProcPtr) ACSLACKNAK },   { "AC4",    (ProcPtr) ACXMCheck },   { "AC5",    (ProcPtr) ACSLOCheck },   { "AC6",    (ProcPtr) ACSL1Check },   { "AC7",    (ProcPtr) ACACKNAK },   { "AC8",    (ProcPtr) ACXMACK },   { "AC9",    (ProcPtr) ACXMNAK },   { "AC10",   (ProcPtr) ACRESYNC }};short  ACInit (XMARGSP args, short start_state){	args->result = 0;   return (start_state);}short  ACEnd (XMARGSP args, short cur_state){   args->result = cur_state;   return (cur_state);}short  ACChkRcvd (XMARGSP args){   if (PEEKBYTE () >= 0)      {      args->CHR = TIMED_READ (0, NULL);		return (AC1);      }	return (SUCCESS);}short  ACSLCheck (XMARGSP args){	if (args->ACKST > 2)		return (AC2);	return (AC6);}short  ACSLVerify (XMARGSP args){   if (args->ARBLK8 == (unsigned char) ((~args->CHR) & 0xff))      {		args->ARBLK = args->SendBLK - ((args->SendBLK - args->ARBLK8) & 0xff);		return (AC3);      }	args->options.SEAlink = 0;	args->Window = 1;	args->ACKST = 0;	return (AC6);}short  ACSLACKNAK (XMARGSP args){   if ((args->ARBLK < 0) ||       (args->ARBLK > args->SendBLK) ||       (args->ARBLK <= (args->SendBLK - 128)))      {		return (AC0);      }   if (args->ACKST == 3)      {		args->options.SEAlink = (~loc_no_sealink) & 1;		args->Window = calc_window ();		args->ACKBLK = args->ARBLK;		++(args->ACKsRcvd);		args->ACKST = 0;		return (AC5);      }	args->SendBLK = args->ARBLK;   args->curr_byte = (args->SendBLK - 1) * 128L;   if (args->curr_byte < 0L)      args->curr_byte = 0L;	if (args->SendBLK > 0)		++(args->tot_errs);	Get_Block (args);	args->ACKST = 0;/* This stuff was in 2.38 why?   CLEAR_OUTBOUND ();   if (*SLO)      *sealink = 0;*/	return (AC4);}short  ACXMCheck (XMARGSP args){   if (args->NumNAK < 4)      {		args->options.SEAlink = (~loc_no_sealink) & 1;		args->Window = calc_window ();		}	else		{	   args->options.SEAlink = 0;		args->Window = 1;		}	return (SUCCESS);}short  ACSLOCheck (XMARGSP args){	if ((args->options.SLO == 0) || (args->ACKsRcvd < 10))		return (SUCCESS);	args->options.SLO = 0;	return (SUCCESS);}short  ACSL1Check (XMARGSP args){	if ((args->ACKST == 1) || (args->ACKST == 2))		{		args->ARBLK8 = (unsigned char) args->CHR;		args->ACKST += 2;		return (AC6);		}	if ((args->options.SEAlink == 0) || (args->ACKST == 0))		return (AC7);	return (AC0);}short  ACACKNAK (XMARGSP args){	long mac_timer;	switch (args->CHR)		{		case ACK:			args->ACKST = 1;			args->NumNAK = 0;			return (AC8);		case WANTCRC:			args->options.do_CRC = 1;			/* Fallthrough */		case NAK:         args->ACKST = 2;			++(args->NumNAK);			CLEAR_OUTBOUND ();			timer (6);			return (AC9);		case SYN:			CLEAR_OUTBOUND ();         if (!no_resync)            {   			args->result = Receive_Resync (&(args->resync_block));	   		args->ACKST = 0;		   	return (AC10);            }         else            {            return (AC0);            }		case DC3: /* ^S */			if (args->options.SEAlink && (args->ACKST == 0))				{				mac_timer = timerset (1000);				while (CARRIER && !timeup (mac_timer))					{					if (TIMED_READ (0, NULL) == DC1)						break;					time_release ();					}				return (AC0);				}			/* Otherwise, fallthrough */		default:			return (AC0);		}}short  ACXMACK (XMARGSP args){	if (!args->options.SEAlink)		++(args->ACKBLK);	return (AC0);}short  ACXMNAK (XMARGSP args){	if (!args->options.SEAlink)		{		args->SendBLK = args->ACKBLK + 1;      args->curr_byte = (args->SendBLK - 1) * 128L;      if (args->curr_byte < 0L)         args->curr_byte = 0L;		if (args->SendBLK > 0)			++(args->tot_errs);		Get_Block (args);		}	return (AC0);}short ACRESYNC (XMARGSP args){	CLEAR_OUTBOUND ();	if (args->result != SUCCESS)	{		SENDBYTE (NAK, NULL);		return (SUCCESS);	}	if (args->SendBLK == 1)	{		args->prev_bytes = (args->resync_block - 1) * 128;		if (args->prev_bytes > args->filelen)			args->prev_bytes = args->filelen;//		status_line (msgtxt[M_SYNCHRONIZING], args->prev_bytes);	}	else	{		++(args->tot_errs);	}	args->options.SEAlink = 1;	args->Window = calc_window ();	args->SendBLK = args->resync_block;	args->curr_byte = (args->SendBLK - 1) * 128L;	if (args->curr_byte < 0L)    	 args->curr_byte = 0L;	Get_Block (args);	args->ACKBLK = args->SendBLK - 1;	SENDBYTE (ACK, NULL);	return (SUCCESS);}void Check_ACKNAK (XMARGSP args){	state_machine (ACKNAK_Check, args, AC0);}short Receive_Resync (long *resync_block){   char resyncit[30];   char *p;   unsigned char a, b;   unsigned short nak_crc, his_crc;   p = resyncit;   while ((*p = TIMED_READ(1, NULL)) != ETX)      {      if ((*p < '0') || (*p > '9'))        {//	 status_line (">SEAlink Send: Resync bad unsigned char '%02x'", (unsigned char)*p);         return (RESYNC_ERR);         }      ++p;      }   *p = '\0';   nak_crc = crc_block ((unsigned char *) resyncit, strlen (resyncit));   a = TIMED_READ (1, NULL);   b = TIMED_READ (1, NULL);   his_crc = (b << 8) + a;   if (nak_crc != his_crc)      {//      status_line (">SEAlink Send: Resync bad crc %04x/%04x", nak_crc, his_crc);      return (CRC_ERR);      }   *resync_block = atol (resyncit);//   status_line (">SEAlink Send: Resync to %ld", *resync_block);   return (SUCCESS);}short calc_window (){   short window;   window = (short) (cur_baud / 400);   if (window <= 0)      window = 2;   if (small_window)      window = (window > 6) ? 6 : window;   return (window);}