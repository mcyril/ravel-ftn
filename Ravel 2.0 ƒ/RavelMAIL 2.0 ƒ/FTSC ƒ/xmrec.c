#include <ctype.h>#include <stdio.h>#include <string.h>#include "PascalStr.h"#include "Ravel_FTN.h"#include "Ravel_Prefs.h"#include "Pathes.h"#include "ftsc.h"//#include "pkthdrs.h"#include "definitions.h"#include "ascii.h"#include "compatible.h"#include "stringutl.h"#include "Scheduler.h"#include "Unattended.h"#include "Attacher.h"#include "Comm.h"#include "Timing.h"#include "xmodem.h"#include "log.h"#include "freq.h"#include "myEnv.h"#include "zfiles.h"#include "state.h"#include "pmain.h"#include "Modem.h"#include "aglcrc.h"#include "history.h"#include "nodelist.h"extern	short	no_sealink;extern	short	no_resync;extern	short	no_overdrive;extern	short	gotta_mail;extern	short	gotta_xmail;extern	short	remote_capabilities;extern	ADDR	remote_addr;extern	unsigned long	cur_baud;extern h_pc_exch	pc_exch_pref;static	char	sending_program[32];#define XDEBUGvoid Find_Char (short);size_t Header_in_data (unsigned char *);void Send_ACK (XMARGSP);void Send_NAK (XMARGSP);static long Open_Xmodem_File (XMARGSP);long Set_Up_Restart (XMARGSP args);void Finish_Xmodem_Receive (XMARGSP args);void Get_Telink_Info (XMARGSP args);short Read_Block (XMARGSP args);void Xmodem_Error (char *s, long block_number);void show_block (long b, char *c, XMARGSP args);short  XRInit (XMARGSP, short);short  XREnd (XMARGSP, short);short  XRRecInit (XMARGSP);short  XRBrecInit (XMARGSP);short  XRRecStart (XMARGSP);short  XRWaitFirst (XMARGSP);short  XRWaitBlock (XMARGSP);short  XRRestart (XMARGSP);short  XRSetOvrdr (XMARGSP);STATES Xmodem_Receiver[] = {   { "XRInit",  (ProcPtr) XRInit },   { "XREnd",  (ProcPtr) XREnd },   { "XR0",  (ProcPtr) XRRecInit },   { "XR0B", (ProcPtr) XRBrecInit },   { "XR1",  (ProcPtr) XRRecStart },   { "XR2",  (ProcPtr) XRWaitFirst },   { "XR3",  (ProcPtr) XRWaitBlock },   { "XR4",  (ProcPtr) XRRestart },   { "XR5",  (ProcPtr) XRSetOvrdr }};static long Open_Xmodem_File (XMARGSP args){//	Cyril's NOTE: maybe the point of savefile faults in this function?//	char *s2;	if (args->file_pointer == NULL)	{		args->temp_name = NewPtr (256);//		putlog ('~',"Open_Xmodem_File: new ptr");		if (args->path != NULL)			strcpy (args->temp_name, args->path);		else			args->temp_name[0] = '\0';		strcat (args->temp_name, "$$TEMP$$");//		s2 = mktemp (args->temp_name);		xfscreate (args->temp_name, 0, 'RvlM', 'TEMP');				if (xfsopen (args->temp_name, 0, &args->file_pointer))//		if ((s2 == NULL) || ((args->file_pointer = buff_fopen (args->temp_name, write_binary)) == NULL))		{//			status_line (msgtxt[M_TEMP_NOT_OPEN], args->temp_name);			return (-1L);		}	}#ifdef XDEBUG	putlog('~',">Created temporary file %s", args->temp_name);#endif//	throughput (0, 0L);	return (0L);}long Set_Up_Restart (XMARGSP args){	char foo[256];//	char foo1[256];		long			create, flen;	unsigned long	creator, type;	//	struct stat st;	args->sub_results = 0;	/* Look for file in directory */	if ((args->received_name != NULL) &&		(strlen (args->received_name) > 0) &&		args->options.Resync)	{		if (args->path != NULL)			strcpy (foo, args->path);		else			foo[0] = 0;					strcat (foo, args->received_name);		if (get_info (foo, &creator, &type, &create, &flen) == noErr)//		if (stat (foo, &st) == 0)		{			putlog (lgNOPE, "%s already exists.", trunc_path (foo));			MSConvertTime (false, (unsigned long *) &create);					if ((flen == args->filelen) && (create == args->save_filetime.oneword.timedate))			{				if (xfsopen (foo, 0, &args->file_pointer) == noErr)//				if ((args->file_pointer = buff_fopen (foo, read_binary_plus)) != NULL)				{//					throughput (0, 0L);//					fseek (args->file_pointer, 0L, SEEK_END);					SetFPos (args->file_pointer, fsFromLEOF, 0L);					args->sub_results = DID_RESYNC;					args->temp_name = NewPtr (256);//	putlog ('~',"Set_Up_Restart:1 new ptr");					strcpy (args->temp_name, foo);					args->prev_bytes = args->filelen;					putlog (lgNOPE, "Synchronizing EOF.");//					status_line (msgtxt[M_ALREADY_HAVE], foo);//					status_line (msgtxt[M_SYNCHRONIZING_EOF]);					return (args->total_blocks + 1L);				}			}			else				if ((creator == 'ZMPT') && (create == args->save_filetime.oneword.timedate))				{					if (xfsopen (foo, 0, &args->file_pointer) == noErr)//					if ((args->file_pointer = buff_fopen (foo, read_binary_plus)) != NULL)					{//						stat (foo, &st);//						throughput (0, 0L);						args->temp_name = NewPtr (256);//	putlog ('~',"Set_Up_Restart:2 new ptr");						strcpy (args->temp_name, foo);						args->prev_bytes = (flen / 128L) * 128L;//						fseek (args->file_pointer, args->prev_bytes, SEEK_SET);												SetFPos (args->file_pointer, fsFromStart, args->prev_bytes);												putlog (lgNOPE, "Synchronizing offset from %ld", args->prev_bytes);						//						status_line (msgtxt[M_SYNCHRONIZING_OFFSET], args->prev_bytes);						return (args->prev_bytes / 128L + 1L);					}				}		}/* Look for file in .Z file *		if (dexists (Abortlog_name))		{			sprintf (Resume_info, "%ld %lo", args->filelen, args->save_filetime.oneword.timedate);			if (check_failed (Abortlog_name, args->received_name, Resume_info, foo1))			{				foo[0] = '\0';//				* Here it looks like it was a failed WaZOO session *				if (args->path != NULL)					strcpy (foo, args->path);				strcat (foo, foo1);				if ((args->file_pointer = buff_fopen (foo, read_binary_plus)) != NULL)				{					stat (foo, &st);					throughput (0, 0L);					args->temp_name = calloc (1, 80);					strcpy (args->temp_name, foo);					args->prev_bytes = (st.st_size / 128L) * 128L;					fseek (args->file_pointer, args->prev_bytes, SEEK_SET);					status_line (msgtxt[M_SYNCHRONIZING_OFFSET], args->prev_bytes);					return (args->prev_bytes / 128L + 1L);				}			}		}*/	}	return (Open_Xmodem_File (args));}void Finish_Xmodem_Receive (XMARGSP args){//	struct stat		st;	char			new_name[256];//	struct utimbuf	times;	size_t			i,j;	short			err;	unsigned long	times;	unsigned long	creator, typer;	long			dum, create;	Str255			fname, fname1;	short			rz123;#ifdef XDEBUG	putlog('~',">Finish_Xmodem_Receive");#endif	/* Set the file's time and date stamp */	if ((args->save_header == SOH) || (args->save_header == SYN))	{//		(void) buff_fclose (args->file_pointer);				FSClose (args->file_pointer);		args->file_pointer = 0;		//		times.modtime = (long) args->save_filetime.oneword.timedate;//		times.actime = (long) args->save_filetime.oneword.timedate;//		(void) utime (args->temp_name, &times);				times = args->save_filetime.oneword.timedate;		MSConvertTime (true, &times);		set_info (args->temp_name, 'RvlM', 'ZMPT', times);	}	else	{		(void) strcpy (args->received_name, "");		if(args->file_pointer)	/* Added SWG!.. problem with aborted sessions */		{			FSClose (args->file_pointer);			args->file_pointer = 0;		}	}	if (args->result == SUCCESS)	{#ifdef XDEBUG		putlog('~',">temp_name=%s, path=%s", args->temp_name, args->path ? args->path : "NULL");#endif		/* Get the file information *///		(void) stat (args->temp_name, &st);#ifdef XDEBUG//		putlog('~',">length=%ld", st.st_size);#endif//		throughput (1, (unsigned long) (st.st_size - args->prev_bytes));//		update_files (0);//ее	--Cyril ???		if ((args->sub_results & DID_RESYNC) != 0)		{//			status_line ("%s: %s", msgtxt[M_FILE_RECEIVED], args->temp_name);			history_add_traff (false, args->filelen);			putlog ('~', "Did Resync: %s", args->temp_name);			putlog (lgNOPE, "Received-X %s", trunc_path (args->temp_name));		}		else		{			new_name[0] = '\0';						if (args->path != NULL)			{				putlog ('~', "Path: %s", args->path);				(void) strcpy (new_name, args->path);			}						if ((args->filename == NULL) || (strlen (args->filename) == 0))			{				if (strlen (args->received_name) > 0)					(void) strcat (new_name, args->received_name);				else					(void) strcat (new_name, "bad_file.000");			}			else			{				(void) strcat (new_name, args->filename);			}			i = strlen (args->temp_name) - 1;			j = strlen (new_name) - 1;			if (args->temp_name[i] == '.')				args->temp_name[i] = '\0';						if (new_name[j] == '.')			{				new_name[j] = '\0';				--j;			}			i = 0;			history_add_traff (false, args->filelen);			putlog (lgNOPE, "Received-X %s", trunc_path (new_name));			putlog ('~', "new_name: <<%s>>, temp_name: <<%s>>", new_name, args->temp_name);			err = get_info (args->temp_name, &creator, &typer, (long *) &create, (long *) &dum);			putlog ('~', "getinfo (temp_name) err: <<%d>>", err);						strcpy ((char *) &fname[1], new_name);			fname[0] = strlen (new_name);			putlog ('~', "fname: <<%#s>>", fname);			switch (rz123 = ResolveExtension (fname))			{			case 0:							set_info (args->temp_name, 'ALFA', 'TEXT', create);				break;						case 1:								set_info (args->temp_name, 'ZIP ', '.PKT', create);				gotta_xmail = 1;				break;						case 2:							set_info (args->temp_name, 'RvlM', '.PKT', create);				gotta_mail = 1;				break;							default:								if (rz123 < 0)				{//					set_info (args->temp_name, (*pc_exch_pref)[-rz123-1].creator, (*pc_exch_pref)[-rz123-1].type, create);					set_ic_info (args->temp_name, create, rz123);				}								break;			}			strcpy ((char *) &fname1[1], args->temp_name);			fname1[0] = strlen (args->temp_name);			putlog ('~', "fname: <<%#s>>, fname1: <<%#s>>", fname, fname1);			if (pStrComp (fname, fname1))			//ее ++Cyril KLUDGE instead DID_RESYNC				while (err = Rename (fname1, 0, fname))				{					putlog ('~', "Rename (%#s -> %#s) err: <<%d>>", fname1, fname, err);									if (isdigit (new_name[j]))						new_name[j]++;					else						new_name[j] = '0';										if (!isdigit (new_name[j]))					{						return;					}					strcpy ((char *) &fname[1], new_name);					fname[0] = strlen (new_name);					i = 1;				}			if (i)			{//				if (locate_y && !(fullscreen && un_attended))//				gotoxy (2, locate_y - 1);//				status_line (msgtxt[M_RENAME_MSG], new_name);				putlog (lgNOPE, "File renamed to %s", trunc_path (new_name));			}		}//		remove_abort (Abortlog_name, args->received_name);	}	else	{		if ((args->received_name != NULL) && (strlen (args->received_name) > 0) && (args->save_header != 0))		{//			sprintf (Resume_info, "%ld %lo", args->filelen, args->save_filetime.oneword.timedate);//			add_abort (Abortlog_name, args->received_name, args->temp_name, args->path, Resume_info);			putlog (lgNOPE, "Save partitial received %s", args->temp_name);		}		else		{			/* File aborted, so remove all traces of it */			if (args->temp_name != NULL)			{				putlog (lgNOPE, "Delete partitial received %s", args->temp_name);				xfsdelete (args->temp_name, 0);			}		}	}	if (args->temp_name != NULL)	{//	putlog ('~',"Finish_Xmodem_Receive: dispos ptr (%s)", args->temp_name);		DisposePtr (args->temp_name);		args->temp_name = NULL;	}}void Get_Telink_Info (XMARGSP args){	char	*p1;//	char	junkbuff[100];	TLDATAP	t;	unsigned long	create;	/* Figure out how many blocks we will get */	t = (TLDATAP) &args->datablock;	args->total_blocks = (long)	(127L +										t->filelength[0] +								((long)	t->filelength[1] << 8) +								((long)	t->filelength[2] << 16) +								((long)	t->filelength[3] << 24)) / 128L;	t->nullbyte = '\0';	p1 = strchr (t->filename, ' ');	if (p1 != NULL)		*p1 = '\0';		strcpy (args->received_name, t->filename);	args->save_header = args->header;		if (args->save_header == SYN)	{	/* May need some fiddling!!! */	//	//	е I've got it from 2.60	++Cyril		create = LMGetTime ();		MSConvertTime (false, &create);		args->save_filetime.oneword.timedate = create;	}	else	{	/* I dont understand the difference here..! No doubt Ill find out */	/* when it doesnt work :-|*/			args->save_filetime.twowords.time = t->time[0] + (t->time[1] << 8);		args->save_filetime.twowords.date = t->date[0] + (t->date[1] << 8);	}	args->filelen = (long)									t->filelength[0] +							((long)	t->filelength[1] << 8) +							((long)	t->filelength[2] << 16) +							((long)	t->filelength[3] << 24);		putlog (lgNOPE, "X-Receiving: %s (%ldb %ld blks)", trunc_path (t->filename), args->filelen, args->total_blocks);	newMessage (lRNAME, "X-Receiving: %s", trunc_path (t->filename));	strcpy (sending_program, t->sendingprog);/*	if (un_attended && fullscreen)	{		clear_filetransfer ();		sb_move (filewin, 1, 2);		sb_puts (filewin, junkbuff);		elapse_time ();		sb_show ();	}	else	{		status_line ("+%s", junkbuff);		set_xy(NULL);		scr_refresh();	}*/}short Read_Block (XMARGSP args){	unsigned char *p; /* Pointers to XMODEM data */	size_t i;            /* Counter */	size_t j;            /* Counter start */	unsigned char c;  /* character being processed */	short in_char;	Str255 junkbuff;	long head_timer;	addr tad;	if (CheckCancel ())	{//		status_line (msgtxt[M_KBD_MSG]);		return (KBD_ERR);	}	/* Set up to point into the XMODEM data structure */	p = (unsigned char *) &args->datablock;	/* Get the first character that is waiting */#if 0	*p = (unsigned char) TIMED_READ (8);#else	args->header = TIMED_READ(8, NULL);#endif#ifdef XDEBUG	putlog('~',">Read_Block: header=%02x", *p);#endif	head_timer = timerset (6000);	j = 0;	while (!timeup (head_timer))	{		/* Now key off of the header character */		switch (args->header)		{		case EOT:   /* End of file */			/* Is this a valid EOT */			if (args->total_blocks <= args->WriteBLK)			{				return (EOT_BLOCK);			}			else			{//				status_line (msgtxt[M_UNEXPECTED_EOF], args->total_blocks);				return (BAD_BLOCK);			}		case SYN:   /* Telink block */#ifdef XDEBUG			putlog('~',">Read_Block: Telink");#endif			/* For Telink, read all of the data except the checksum */			for (i = 0; i < sizeof (TLDATA) - 2; i++)			{				/* If we go more than 5 second, then we have a short block */				if ((in_char = TIMED_READ (5, NULL)) < 0)				{					return (BAD_BLOCK);				}				*p++ = (unsigned char) (in_char & 0xff);			}#ifdef XDEBUG			putlog('~',">Read_Block, block=%02x, com=%02x",			args->datablock.block_num, args->datablock.block_num_comp);#endif			/* if the block number or its complement are wrong, return error */			if ((args->datablock.block_num != 0) || (args->datablock.block_num_comp != 0xff))			{				return (BAD_BLOCK);			}			/* Now calculate the checksum - Telink block always checksum mode */			Data_Check (&args->datablock, CHECKSUM);			/* See if we can receive the checksum byte */			if ((in_char = TIMED_READ (10, NULL)) < 0)			{				Xmodem_Error ("msgtxt[M_TIMEOUT]", 0L);				return (BAD_BLOCK);			}			/* Was it right */			c = (unsigned char) (in_char & 0xff);#ifdef XDEBUG			putlog('~',">Received block: header=%02x, block=%02x, check=%02x %02x",							args->header, args->datablock.block_num,							args->datablock.data_check[0],							args->datablock.data_check[1]);			putlog('~',">c=%02x, size=%d, %02x %02x %02x %02x ... %02x %02x",							c, (short)sizeof(TLDATA)-2,							args->datablock.data_bytes[0],							args->datablock.data_bytes[1],							args->datablock.data_bytes[2],							args->datablock.data_bytes[3],							args->datablock.data_bytes[126],							args->datablock.data_bytes[127]);#endif			if (c != args->datablock.data_check[0])			{#ifdef XDEBUG				putlog('~',">Checksum c=%02x  data=%02x", c, args->datablock.data_check[0]);#endif				Xmodem_Error ("msgtxt[M_CHECKSUM]", 0L);				return (BAD_BLOCK);			}				/* Everything looks good, it must be a legal TELINK block */			Get_Telink_Info (args);			return (TELINK_BLOCK);		case SOH:   /* Normal data block */			args->datalen = 128;			/* Read in all of the data for an XMODEM block except the checksum */			p += j;			for (i = j; i < sizeof (XMDATA) - 2; i++)			{				/* If we go more than 5 seconds, then it is a short block */				if ((in_char = TIMED_READ (5, NULL)) < 0)				{					return (BAD_BLOCK);				}				*p++ = (unsigned char) (in_char & 0xff);			}			/* The block number is 0 to 255 inclusive */			c = (unsigned char) (args->blocknum & 0xff);			/* Properly calculate the CRC or checksum */			Data_Check (&args->datablock, args->options.do_CRC ? CRC : CHECKSUM);			/* Can we get the checksum byte */			if ((in_char = TIMED_READ (10, NULL)) < 0)			{				Xmodem_Error ("msgtxt[M_TIMEOUT]", args->WriteBLK);				return (BAD_BLOCK);			}			/* Is it the right value */			c = (unsigned char) (in_char & 0xff);			if (c != args->datablock.data_check[0])			{//				status_line (">Xmodem Receive: Bad %s", (args->options.do_CRC)?"CRC":"checksum");				Xmodem_Error ("msgtxt[M_CRC_MSG]", args->WriteBLK);				if (args->options.do_CRC)					(void) TIMED_READ (5, NULL);								return (BAD_BLOCK);			}		/* If we are in CRC mode, do the second byte */			if (args->options.do_CRC)			{				/* Can we get the character */				if ((in_char = TIMED_READ (10, NULL)) < 0)				{//					status_line (">Xmodem Receive: Timeout waiting for CRC byte 2");					Xmodem_Error ("msgtxt[M_TIMEOUT]", args->WriteBLK);					return (BAD_BLOCK);				}				/* Is it right */				c = (unsigned char) (in_char & 0xff);				if (c != args->datablock.data_check[1])				{#ifdef XDEBUG					putlog('~',">CRC c=%02x  data=%02x", c, args->datablock.data_check[1]);#endif					Xmodem_Error ("msgtxt[M_CRC_MSG]", args->WriteBLK);					return (BAD_BLOCK);				}			}			/* Do we have a valid data block */			if (args->datablock.block_num_comp != ((~(args->datablock.block_num)) & 0xff))			{				if (!(args->options.SEAlink))				{					Xmodem_Error ("msgtxt[M_JUNK_BLOCK]", args->WriteBLK);					return (BAD_BLOCK);				}				p = (unsigned char *) &args->datablock;				j = Header_in_data (p);				if (j)				{					j--;					continue;				}				j = 0;				Find_Char (SOH);				args->header = (unsigned char) TIMED_READ (0, NULL);			}			if ((args->WriteBLK == 1) && (args->header == SOH) && (args->datablock.block_num == 0))			{				Get_Telink_Info (args);				return (SEALINK_BLOCK);			}			if (first_block)			{				struct _pkthdr *packet;				packet = (struct _pkthdr *) args->datablock.data_bytes;								if (!remote_capabilities)				{					remote_addr.Zone = endshort(packet->orig_zone);					remote_addr.Net = endshort(packet->orig_net);					remote_addr.Node = endshort(packet->orig_node);					if (endshort(packet->rate) == 2)					{						/* This is a special type 2.2 packet! */						remote_addr.Point = (unsigned) endshort(packet->year);						packet->B_fill3 = 0L;						packet->B_fill2[8] = '\0';						remote_addr.Domain = NULL;					}					else					{						remote_addr.Point = 0;						remote_addr.Domain = NULL;					}				}								if (who_is_he)				{					if (!remote_addr.Zone && !remote_addr.Net && !remote_addr.Node)					{						hang_up ();						return(CARRIER_ERR);          /* Get out of here!     */					}					tad.zone = remote_addr.Zone;					tad.net = remote_addr.Net;					tad.node = remote_addr.Node;					tad.point = remote_addr.Point;					if (!GetInfoFromAddr (&tad, junkbuff))					{						putlog (lgNOPE, "System:      Unknown (%d:%d/%d.%d)", remote_addr.Zone, remote_addr.Net, remote_addr.Node, remote_addr.Point);						putlog (lgNOPE, "SysOp:       Unknown");					}					else					{						putlog (lgNOPE, "System:      %#s (%d:%d/%d.%d)", junkbuff, remote_addr.Zone, remote_addr.Net, remote_addr.Node, remote_addr.Point);						putlog (lgNOPE, "SysOp:       %#s", junkbuff);					}				}								if (sending_program[0] != '\0')				{//					status_line ("%s %s", msgtxt[M_REMOTE_USES], sending_program);					putlog (lgNOPE, "Remote uses: %s v. %hd.%hd [#%.4X]",								sending_program,									(short)((struct _pkthdr39 *)packet)->product_hi,									packet->serial,									(short)(((short)((struct _pkthdr39 *)packet)->product_hi) << 8) | packet->product);				}				else				{					putlog ( lgNOPE, "Remote uses: Unknown v. %hd.%hd [#%.4X]",									(short)((struct _pkthdr39 *)packet)->product_hi,									packet->serial,									(short) (((short)((struct _pkthdr39 *)packet)->product_hi) << 8) | packet->product);				}				who_is_he = 0;				first_block = 0;			}			if (args->WriteBLK == args->total_blocks)			{				args->datalen = (size_t) (args->filelen - ((args->WriteBLK - 1) * 128));			}			/* If we got this far, it is a valid data block */			args->recblock = args->datablock.block_num;			return (XMODEM_BLOCK);		default:    /* Bad block */			if ((args->blocknum <= 1) || (PEEKBYTE () < 0))				return (BAD_BLOCK);			/* Garbage header, return bad */				*p = (unsigned char) TIMED_READ (0, NULL);		}	}	return (BAD_BLOCK);}short  XRInit (XMARGSP args, short start_state){//	char *HoldName;	args->tries = 0;	args->goodfile = 1;//	XON_DISABLE ();	args->file_pointer = 0;		sending_program[0] = '\0';	return (start_state);}short  XREnd (XMARGSP args, short cur_state){   args->result = cur_state;   Finish_Xmodem_Receive (args);   return (cur_state);}short  XRRecInit (XMARGSP args){   args->options.SEAlink = 0;   args->options.SLO = 0;   args->options.Resync = 0;   args->options.MacFlow = 0;   args->options.do_CRC = 1;   args->blocknum = 0;   args->WriteBLK = 1;   args->curr_byte = 0L;   args->tries = 0;   return (XR1);}short  XRBrecInit (XMARGSP args){   args->options.SEAlink = 0;   args->options.SLO = 0;   args->options.Resync = 0;   args->options.MacFlow = 0;   args->options.do_CRC = 1;   args->blocknum = 0;   args->WriteBLK = 1;   args->curr_byte = 0L;   args->tries = 0;   return (XR2);}short  XRRecStart (XMARGSP args){   Send_NAK (args);   return (XR2);}short  XRWaitFirst (XMARGSP args){	long	XR2Timer;	long	ioCounter;	XR2Timer = timerset (800);	if (args->tries >= 10)	{		args->goodfile = 0;		return (TIME_ERR);	}	if (args->tries == 5)	{		args->options.do_CRC = 0;		++(args->tries);		return (XR1);	}	while (CARRIER)	{		switch (Read_Block (args))		{		case EOT_BLOCK:#ifdef XDEBUG			putlog('~',">XRWaitFirst() => EOT_BLOCK");#endif			args->WriteBLK = 0;			Send_ACK (args);			return (SUCCESS_EOT);		case TELINK_BLOCK:#ifdef XDEBUG			putlog('~',">XRWaitFirst() => TELINK_BLOCK");#endif			//ее	++Cyril						args->sub_results = 0;			if (Open_Xmodem_File (args) == -1L)				return (OPEN_ERR);					Send_ACK (args);			args->tries = 0;			return (XR3);		case SEALINK_BLOCK:		#ifdef XDEBUG			putlog('~',">XRWaitFirst() => SEALINK_BLOCK");#endif			args->options.SEAlink = no_sealink ? 0 : 1;						if (args->options.SEAlink && !no_resync)				args->options.Resync = (((SEADATAP) (&args->datablock))->Resync) != 0;				return (XR4);		case XMODEM_BLOCK:#ifdef XDEBUG			putlog('~',">XRWaitFirst() => XMODEM_BLOCK");#endif			if (args->recblock == 1)			{				if (Open_Xmodem_File (args) == -1L)					return (OPEN_ERR);				ioCounter = args->datalen;				FSWrite (args->file_pointer, &ioCounter, args->datablock.data_bytes);//				(void) buff_fwrite ((char *)args->datablock.data_bytes, sizeof (unsigned char), args->datalen, args->file_pointer);				++(args->WriteBLK);				args->curr_byte = 128L;				++(args->blocknum);				Send_ACK (args);				args->tries = 0;				return (XR3);			}		/* Fallthrough on wrong block */		case BAD_BLOCK:#ifdef XDEBUG			putlog('~',">XRWaitFirst() => BAD_BLOCK");#endif			++(args->tries);			return (XR1);		case CARRIER_ERR:		case KBD_ERR:			return (CARRIER_ERR);		}		if (timeup (XR2Timer))		{			++(args->tries);			return (XR1);		}	}	return (CARRIER_ERR);}short  XRWaitBlock (XMARGSP args){	long	ioCounter;		if (args->tries >= 10)	{		args->goodfile = 0;		return (TIME_ERR);	}	while (CARRIER)	{		switch (Read_Block (args))		{		case EOT_BLOCK:			args->options.SLO = 0;			Send_ACK (args);			return (SUCCESS);		case XMODEM_BLOCK:			if (args->recblock == (unsigned char) ((args->blocknum - 1) & 0xff))			{				--(args->blocknum);				Send_ACK (args);				return (XR3);			}			if (args->recblock == args->blocknum)			{				ioCounter = args->datalen;				FSWrite (args->file_pointer, &ioCounter, args->datablock.data_bytes);//				(void) buff_fwrite ((char *)args->datablock.data_bytes, sizeof (unsigned char), args->datalen, args->file_pointer);				++(args->WriteBLK);				args->curr_byte += 128L;				Send_ACK (args);				args->tries = 0;				return (XR3);			}			if (args->recblock < args->blocknum)			{				args->recblock += 256;			}			if ((args->recblock > (unsigned) args->blocknum) && (args->recblock <= ((unsigned) (((unsigned) args->blocknum) + 127))))			{				if (args->tries != 0)				{			/* We have sent at least one nak, now only send them				every so often to allow buffers to drain */					if ((args->recblock - (unsigned) args->blocknum) % 16)						return (XR3);			/* If it is a multiple of 16, then check that it is				higher than 32 */							if ((args->recblock - (unsigned) args->blocknum) / 16 < 2)						return (XR3);				}			}		/* fallthrough on bad block */		case BAD_BLOCK:			Send_NAK (args);			++(args->tries);			return (XR3);		case CARRIER_ERR:		case KBD_ERR:				return (CARRIER_ERR);		}	}	return (CARRIER_ERR);}short  XRRestart (XMARGSP args){   long c;   c = Set_Up_Restart (args);   if (c == -1L)      return (OPEN_ERR);   if ((!c) || (!(args->options.Resync)))      {      Send_ACK (args);      args->tries = 0;      }   else      {      args->WriteBLK = c;      args->curr_byte = (c - 1) * 128L;      args->blocknum = (unsigned char) ((args->WriteBLK) & 0xff);      Send_NAK (args);      }   return (XR5);}short  XRSetOvrdr (XMARGSP args){	if (!no_overdrive)		args->options.SLO = (((SEADATAP) (&args->datablock))->SLO) != 0;	if (args->options.SLO)		show_block ((long) (args->WriteBLK - 1), " *Overdrive*", args);	return (XR3);}short Xmodem_Receive_File (char *path, char *filename){	XMARGS xmfile;	short res;//	locate_y = wherey ();//	locate_x = wherex ();	memset (&xmfile, 0, sizeof (XMARGS));	xmfile.path = path;	xmfile.filename = filename;	xmfile.file_pointer = 0;	xmfile.total_blocks = -1L;	xmfile.sent_ACK = 0;	res = state_machine (Xmodem_Receiver, &xmfile, XR0);	return (res);}short Batch_Xmodem_Receive_File (char *path, char *filename){	XMARGS xmfile;	short res;//	locate_y = wherey ();//	locate_x = wherex ();	memset (&xmfile, 0, sizeof (XMARGS));	xmfile.path = path;	xmfile.filename = filename;	xmfile.file_pointer = 0;	xmfile.total_blocks = -1L;	xmfile.sent_ACK = 0;	res = state_machine (Xmodem_Receiver, &xmfile, XR0B);	return (res);}short  SAInit (XMARGSP, short);short  SAEnd (XMARGSP, short);short  SAClearLine (XMARGSP);short  SASendACK (XMARGSP);short  SASEAlink (XMARGSP);short  SAIncBlk (XMARGSP);STATES ACK_States[] = {   { "SAInit", (ProcPtr) SAInit },   { "SAEnd", (ProcPtr) SAEnd },   { "SA0", (ProcPtr) SAClearLine },   { "SA1", (ProcPtr) SASendACK },   { "SA2", (ProcPtr) SASEAlink },   { "SA3", (ProcPtr) SAIncBlk }};short  SAInit (XMARGSP args, short start_state){#pragma unused (args)   return (start_state);   /* args; */}short  SAEnd (XMARGSP args, short cur_state){#pragma unused (args)   return (cur_state);   /* args; */}short  SAClearLine (XMARGSP args){   long SA0Timer;   SA0Timer = timerset (3000);   if (args->options.SLO)      return (SA3);   if (args->options.SEAlink)      return (SA1);   while (CARRIER && !timeup (SA0Timer))      {      if (PEEKBYTE () >= 0)         {         (void) TIMED_READ (0, NULL);         time_release ();         continue;         }      return (SA1);      }   return (TIME_ERR);}short  SASendACK (XMARGSP args){   SENDBYTE (ACK, NULL);   args->sent_ACK = 1;   return (SA2);}short  SASEAlink (XMARGSP args){   if (!(args->options.SEAlink))      return (SA3);   SENDBYTE (args->blocknum, NULL);   SENDBYTE ((unsigned char)~args->blocknum, NULL);   return (SA3);}void show_block (long b, char *c, XMARGSP args){//	char j[100];	short i;	long k, l;//	if (fullscreen && un_attended)//	{//		elapse_time();//		sb_move (filewin, 2, 2);//		sb_puts (filewin, ultoa (((unsigned long) b), e_input, 10));		//		if (c)//			(void) sb_puts (filewin, c);		k = args->filelen - args->curr_byte;				if (k < 0L)			k = 0L;		i = (short) ((k * 10 / cur_baud * 100 /				((args->save_header == SOH) ? 94 : 70) + 59) / 60);				l = b*128L;		newMessage (lRSTAT, "%ld:%ld %3d min. %s", (l > args->filelen) ? args->filelen : l, args->filelen, i, (c) ? c : "");//		sprintf (j, "%3d min", i);//		sb_move (filewin, 2, 69);//		sb_puts (filewin, j);//		sb_show ();//	}//	else//	{//		gotoxy (locate_x, locate_y);//		scr_printf (ultoa (((unsigned long) b), e_input, 10));//		if (c)//			scr_printf (c);		//		scr_refresh();//	}}short  SAIncBlk (XMARGSP args){   ++(args->blocknum);   if ((args->options.SLO) &&		(((args->WriteBLK > 0) && (!((args->WriteBLK - 1) & 0x001F)) && (args->WriteBLK < args->total_blocks)) ||      (args->WriteBLK >= args->total_blocks)))      {		show_block ((long) (args->WriteBLK - 1), " *Overdrive*", args);      }	else if ((!(args->options.SLO)) && (args->WriteBLK > 0))      {		show_block ((long) (args->WriteBLK - 1), NULL, args);      }   return (SUCCESS);}void Send_ACK (XMARGSP args){   state_machine (ACK_States, args, SA0);}void Send_Resync_Packet (XMARGSP);short  SNInit (XMARGSP, short);short  SNEnd (XMARGSP, short);short  SNClearLine (XMARGSP);short  SNSendNAK (XMARGSP);short  SNSEAlink (XMARGSP);short  SNAckResync (XMARGSP);STATES NAK_States[] = {   { "SNInit",  (ProcPtr) SNInit },   { "SNEnd",  (ProcPtr) SNEnd },   { "SN0",  (ProcPtr) SNClearLine },   { "SN1",  (ProcPtr) SNSendNAK },   { "SN2",  (ProcPtr) SNSEAlink },   { "SN3",  (ProcPtr) SNAckResync }};short  SNInit (XMARGSP args, short start_state){#pragma unused (args)   return (start_state);   /* args; */}short  SNEnd (XMARGSP args, short cur_state){#pragma unused (args)   return (cur_state);   /* args; */}short  SNClearLine (XMARGSP args){   long SN0Timer;   SN0Timer = timerset (3000);   if (args->options.Resync)      {      Send_Resync_Packet (args);      return (SN3);      }   if (args->options.SEAlink)      return (SN1);   while (CARRIER && !timeup (SN0Timer))      {      if (PEEKBYTE () >= 0)         {         (void) TIMED_READ (0, NULL);         time_release ();         continue;         }      return (SN1);      }   return (TIME_ERR);}short  SNSendNAK (XMARGSP args){   if (args->options.do_CRC && (args->sent_ACK == 0))      SENDBYTE (WANTCRC, NULL);   else      SENDBYTE (NAK, NULL);   return (SN2);}short  SNSEAlink (XMARGSP args){   if (!(args->options.SEAlink))      return (SUCCESS);   SENDBYTE (args->blocknum, NULL);   SENDBYTE ((unsigned char)~(args->blocknum), NULL);   return (SUCCESS);}short  SNAckResync (XMARGSP args){   long SN3Timer;   short c;   SN3Timer = timerset (3000);   while (CARRIER && !timeup (SN3Timer))      {      if ((c = TIMED_READ (10, NULL)) == 0xffff)         {         Send_Resync_Packet (args);         continue;         }      if (c == ACK)			{			big_pause (1);			c = PEEKBYTE();			if ((c == SOH) || (c == EOT))	         return (SUCCESS);			}      }   if (!CARRIER)      return (CARRIER_ERR);   else      return (TIME_ERR);}void Send_NAK (XMARGSP args){   state_machine (NAK_States, args, SN0);}void Send_Resync_Packet (XMARGSP args){   char resyncit[30];   unsigned short nak_crc;   SENDBYTE (SYN, NULL);   (void) sprintf (resyncit, "%ld", args->WriteBLK);   SENDCHARS ((unsigned char *) resyncit, strlen (resyncit), 1, NULL);   nak_crc = crc_block ((unsigned char *) resyncit, strlen (resyncit));   SENDBYTE (ETX, NULL);   SENDBYTE ((unsigned char) nak_crc, NULL);   CLEAR_INBOUND ();   SENDBYTE ((unsigned char) (nak_crc >> 8), NULL);}void Xmodem_Error (char *s, long block_number){#pragma unused (s, block_number)//	char j[50];//	char k[50];/*	(void) sprintf (j, "%s %s %ld", s, msgtxt[M_ON_BLOCK], block_number);	(void) sprintf (k, "%-49.49s", j);	status_line (">Xmodem Error: %s", k);	if (fullscreen && un_attended)	{		sb_move (filewin, 2, 20);		sb_puts (filewin, k);		sb_show ();	}	else	{		gotoxy (locate_x + 20, locate_y);		scr_printf (k);		scr_refresh();	}*/}void Find_Char (short c){   long t1;   long t2;   t1 = timerset (3000);   t2 = timerset (100);   while (!timeup (t1) && !timeup (t2))      {      if (!CARRIER)         break;      if (PEEKBYTE () == (c & 0xff))         break;      else if (PEEKBYTE () >= 0)         {         (void) TIMED_READ (0, NULL);         t2 = timerset (100);         }      }}size_t Header_in_data (unsigned char *p){   size_t i;   size_t j;   char *p1;   p1 = (char *) p;   /* ++p1; */   j = sizeof (XMDATA) - 2;   for (i = 0; i < j; i++)   {      if (*p1++ == SOH)      {         memcpy (p, p1, j-i-1);         return (j - i);      }   }   return (0);}