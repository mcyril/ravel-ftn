#include <ctype.h>#include <stdio.h>#include <string.h>#include "PascalStr.h"#include "Ravel_FTN.h"#include "Ravel_Prefs.h"#include "Pathes.h"#include "ftsc.h"//#include "pkthdrs.h"#include "definitions.h"#include "ascii.h"#include "compatible.h"#include "stringutl.h"#include "Scheduler.h"#include "Unattended.h"#include "Attacher.h"#include "Comm.h"#include "Timing.h"#include "xmodem.h"#include "log.h"#include "freq.h"#include "myEnv.h"#include "zfiles.h"#include "state.h"#include "pmain.h"#include "Modem.h"#include "aglcrc.h"#define NO_SEALINK_IS_TELINK 1short  BSInit (XMARGSP, short);short  BSEnd (XMARGSP, short);short  BSMoreFiles (XMARGSP);short  BSWaitType (XMARGSP);short  BSCheckFNm (XMARGSP);short  BSCheckFile (XMARGSP);short  BSEndSend (XMARGSP);STATES Batch_Sender[] = {   { "BSInit", (ProcPtr) BSInit },   { "BSEnd", (ProcPtr) BSEnd },   { "BS0", (ProcPtr) BSMoreFiles },   { "BS1", (ProcPtr) BSWaitType },   { "BS2", (ProcPtr) BSCheckFNm },   { "BS3", (ProcPtr) BSCheckFile },   { "BS4", (ProcPtr) BSEndSend  },};extern	short	no_sealink;short  BSInit (XMARGSP args, short start_state){   args->result = start_state;// XON_DISABLE ();   return (start_state);}short  BSEnd (XMARGSP args, short cur_state){   args->result = cur_state;   return (cur_state);}short  BSMoreFiles (XMARGSP args){   if (args->filename != NULL)      {      /* BS0.1 */      return (BS1);      }   else      {      /* BS0.2 */      return (BS4);      }}short  BSWaitType (XMARGSP args){   long BS1Timer;   short in_char;   BS1Timer = timerset (2000);   while (!timeup (BS1Timer))      {      if ((in_char = PEEKBYTE ()) >= 0)         {         switch (in_char)            {            case NAK:               /* State BS1.1 */               args->result = Modem7_Send_File (args->filename);               return (BS2);            case WANTCRC:               /* State BS1.2 */               if (!no_sealink)                  {                  args->result = SEAlink_Send_File (args->filename, NULL);                  return (BS3);                  }#ifdef NO_SEALINK_IS_TELINK               else                  {                  args->result = Telink_Send_File (args->filename, NULL);                  return (BS3);                  }#endif               /* Fallthrough if we aren't doing SEAlink */            default:               /* State BS1.3 */               (void) TIMED_READ (0, NULL);               time_release ();            }         }      else         {         if (!CARRIER)            return (CARRIER_ERR);         else            time_release ();         }      }   /* State BS1.4 */   return (TIME_ERR);}short  BSCheckFNm (XMARGSP args){   if (args->result == SUCCESS)      {      /* State BS2.1 */      args->result = Telink_Send_File (args->filename, NULL);      return (BS3);      }   else      {      /* State BS2.2 */      return (FNAME_ERR);      }}short  BSCheckFile (XMARGSP args){   return (args->result);}short  BSEndSend (XMARGSP args){   long BS4Timer;   BS4Timer = timerset (1000);   while (!timeup (BS4Timer))      {      switch (TIMED_READ (1, NULL))         {         case NAK:         case WANTCRC:            SENDBYTE (EOT, NULL);            args->result = SUCCESS;            return (SUCCESS);         }      }   /* State BS4.2 */   SENDBYTE (EOT, NULL);   args->result = SUCCESS;   return (SUCCESS);}short Batch_Send (char *filename){   XMARGS batch;   short res;	newMessage (lTNAME, "");	newMessage (lTSTAT, "");	newMessage (lRNAME, "");	newMessage (lRSTAT, "");   batch.result = 0;   batch.filename = filename;   res = state_machine (Batch_Sender, &batch, 2);   return (res);}