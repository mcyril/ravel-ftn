#include <stdio.h>#include <string.h>#include "PascalStr.h"#include "Ravel_FTN.h"#include "Ravel_Prefs.h"#include "Pathes.h"#include "ftsc.h"//#include "pkthdrs.h"#include "definitions.h"#include "ascii.h"#include "compatible.h"#include "addresses.h"#include "stringutl.h"#include "Scheduler.h"#include "Unattended.h"#include "Attacher.h"#include "pmain.h"#include "Comm.h"#include "Timing.h"#include "xmodem.h"#include "zmodem.h"#include "hydra_chat.h"#include "log.h"#include "freq.h"#include "myEnv.h"#include "zfiles.h"#include "busy.h"#include "history.h"static short FTSC_callback (unsigned char *);static short FTSC_time (long);static short FTSC_sendmail (void);static short FTSC_recvmail (void);static	StringPtr	pollModes[3] = { "\p.CLO", "\p.DLO", "\p.HLO" };static	StringPtr	requestSuffix = "\p.REQ";#define NUM_FLAGS 4//ее//ееextern	ADDR	remote_addr;extern	ADDR	called_addr;extern	short	current_aka;extern	char	*session_password;extern	short	remote_capabilities;extern	Boolean	Aborted;extern	short	isOriginator;//extern	Boolean	ftsc_session;extern long		freq_event_mask;extern	short	we_request;					//	we made file requestextern	homeHndl		homesystem;			//	е	Home system structshort	first_block;short	who_is_he;//short	overwrite;				//	еее//short	on_our_nickel;			//	еееshort	no_pickup = 0;			//	еее		a la PUP, PUA, etc... other which I don't support//short	no_requests;			//	еее		NRQ, imho//short	requests_ok;			//	еееshort	loc_no_sealink = 0;	//ее		lika no_wazoo, etc.?short	no_sealink = 0;		//ее		lika no_wazoo, etc.?short	no_resync = 0;		//ееshort	no_overdrive = 0;	//ееshort	small_window = 0;	//ееchar	*xfer_id = MAILERNAME;extern	short	Netmail_Session;extern	short	net_problems;extern	short	got_arcmail;extern	short	got_packet;extern	short	got_mail;extern	short	sent_mail;extern	unsigned long	cur_baud;extern	short	gotta_mail;extern	short	gotta_xmail;Boolean haspassword ( ADDR *addr, char **pass );Boolean check_no_protocol ( ADDR *called_addr, long protocol );static short is_wazoo_session;#define NUM_FLAGS 4void FTSC_sender (short wz){	short	j;//	char	junkbuff[128];	long	t1;putlog ('~', "+FTSC_sender (%d)", wz);	is_wazoo_session = wz;//	XON_DISABLE ();	first_block = 0;	we_request = 0;	remote_addr = called_addr;		//ее	++Cyril	if (!wz)	{		first_block = 1;	//     status_line (msgtxt[M_SEND_FALLBACK]);		who_is_he = 0;	//      (void) sprintf (junkbuff, "*%s (%s)",	//              newnodedes.SystemName,	//              Pretty_Addr_Str (&remote_addr));	//     status_line (junkbuff);		putlog (lgNOPE, "Address      %d:%d/%d.%d accessed", remote_addr.Zone, remote_addr.Net, remote_addr.Node, remote_addr.Point);	}	history_add_address1 (&remote_addr);	loc_no_sealink = no_sealink || check_no_protocol (&called_addr, NODE_NOSEALINK);	Netmail_Session = 1;	(void) FTSC_sendmail ();		t1 = timerset (45*60);	/* See what the receiver would like us to do */	while ((!timeup (t1)) && CARRIER)	{		if ((j = PEEKBYTE ()) >= 0)		{			switch (j)			{			case TSYNC:				CLEAR_INBOUND ();								putlog ('~', "FTSC_recmail by TSYNC");								if (FTSC_recvmail ())					goto get_out;								t1 = timerset (45*60);							break;			case SYN:							CLEAR_INBOUND ();				#ifndef LITE				if (CheckEventNow (freq_event_mask))				{					putlog ('~', "Respond requests by SYN");					(void) SEA_recvreq ();				}				else#endif				{					SENDBYTE (CAN, NULL);					putlog (lgNOPE, "Refusing file requests");				}				t1 = timerset (45*60);							break;			case ENQ:							CLEAR_INBOUND ();				SEA_sendreq ();				goto get_out;			case NAK:			case 'C':				CLEAR_INBOUND ();				SENDBYTE (EOT, NULL);							t1 = timerset (45*60);							break;			default:				CLEAR_INBOUND ();				SENDBYTE (SUB, NULL);							break;			}		}		else		{			time_release ();		}	}	if (!CARRIER)	{//		status_line (msgtxt[M_NO_CARRIER]);				CLEAR_INBOUND ();		first_block = 0;				Aborted = true;				return;	}	if (timeup (t1))	{		putlog ('~', "FTSC_recmail by timeout");		(void) FTSC_recvmail ();//		status_line (msgtxt[M_TOO_LONG]);	}get_out:	if (net_problems)		Aborted = true;	first_block = 0;	t1 = timerset (60);	while (!timeup (t1))		time_release ();	if (!wz)	{//		status_line (msgtxt[M_0001_END]);	}}short FTSC_receiver (short wz){//	char			fname[64];	Str255			flo, flops;	FSSpec			spec;	short			havemail, done;	//	, np;	unsigned short	i;	long			t1, t2;putlog ('~', "+FTSC_receiver (%d)", wz);	is_wazoo_session = wz;	first_block = 0;//	XON_DISABLE ();	we_request = 0;	if (!wz)	{		first_block = 1;//		status_line (msgtxt[M_RECV_FALLBACK]);		who_is_he = 1;	}	Netmail_Session = 1;	CLEAR_INBOUND ();	/* Save the state of pickup for now */	done = no_pickup;	no_pickup = 0;	if (FTSC_recvmail ())	{		/* Restore the state of pickup */		no_pickup = done;		if (!wz)		{		// status_line (msgtxt[M_0001_END]);		}		if (net_problems)			Aborted = true;		first_block = 0;		return (1);	}	/* Restore the state of pickup */	no_pickup = done;	called_addr = remote_addr;	history_add_address1 (&remote_addr);	havemail = PathForOutbound (&remote_addr, flo);	if (havemail)	{		havemail = false;				for (i = 0; i < 3; i++)		{			pStrConc (flo, pollModes[i], flops);						if (FSMakeFSSpec (0, 0, flops, &spec) == noErr)				break;		}				if (i == 3)		{			havemail = true;		}	}	else		havemail = true;no_send:	if (havemail)	{		putlog (lgNOPE, "Nothing to send");//		status_line (msgtxt[M_NOTHING_TO_SEND], Pretty_Addr_Str (&remote_addr));	}	else	{//		status_line (msgtxt[M_GIVING_MAIL], Pretty_Addr_Str (&remote_addr));		/* Send the TSYNC's until we get a C or NAK or CAN back */				t1 = timerset (30*60);                      /* set 30 second timeout */		done = 0;				while (!timeup (t1) && CARRIER && !done)   /* till then or CD lost  */		{			SENDBYTE (TSYNC, NULL);			t2 = timerset (3*60);			while (CARRIER && (!timeup (t2)) && !done)			{				switch (TIMED_READ (0, NULL))				{				case 'C':				case NAK:					done = 1;					(void) FTSC_sendmail ();					break;				case CAN:								done = 1;//					status_line (msgtxt[M_REFUSE_PICKUP], Pretty_Addr_Str (&remote_addr));					break;				default:						time_release ();				}			}		}	}	first_block = 0;//   if (wz)//      {//      flag_file (CLEAR_FLAG, &called_addr, 1);//      return TRUE;                      /* All done if this is WaZOO *///      }   /* Now see if we want to request anything */	pStrConc (flo, requestSuffix, flops);	if (FSMakeFSSpec (0, 0, flops, &spec) == noErr)	{		/* Send the SYN character and wait for an ENQ or CAN */		t1 = timerset (30*60);                      /* set 30 second timeout */		done = 0;		while (!timeup (t1) && CARRIER && !done)   /* till then or CD lost  */		{			SENDBYTE (SYN, NULL);			t2 = timerset (5*60);			while (CARRIER && (!timeup (t2)) && !done)			{				i = (unsigned) TIMED_READ (0, NULL);				switch (i)				{				case ENQ:					SEA_sendreq ();					break;				case CAN:							done = 1;					break;				case 'C':				case NAK:										SENDBYTE (EOT, NULL);					break;				case SUB:					SENDBYTE (SYN, NULL);					break;				default:							time_release ();				}			}		}	}	/* Finally, can he request anything from us *///	if (!no_requests)//		(void) SEA_recvreq ();	if (CheckEventNow (freq_event_mask))	{		putlog ('~', "Respond requests");		(void) SEA_recvreq ();	}	// status_line (msgtxt[M_0001_END]);	// flag_file (CLEAR_FLAG, &called_addr, 1);	return TRUE;}static short FTSC_sendmail (){	short			fp;//	char			fname[80];	char			s[80];//	char			*sptr;//	char			*HoldName;//	short			c;//	short			i;	short			j = 0;//	struct stat buf;	struct _pkthdr	*tmppkt;	long			t1, zeroid, ioCounter;//	struct tm *tm1;	daddr		my__tmpaddr;	my__tmpaddr = (current_aka == 0) ? (*homesystem)->mainAddr : (*homesystem)->AKAAddr[current_aka-1];putlog ('~', "+FTSC_sendmail");putlog ('~', "use aka %s", printaddr (&my__tmpaddr.ad, s));putlog ('~', "use pwd %s", (session_password) ? session_password : "<<nope>>");//	XON_DISABLE ();//	sptr = s;	/*--------------------------------------------------------------------*/	/* Send all waiting ?UT files (mail packets)                          */	/*--------------------------------------------------------------------*///	*ext_flags = 'o';//	HoldName = HoldAreaNameMunge(&called_addr);	/*--- Build a dummy PKT file name */	sprintf (s, "%.8lX.PKT", LMGetTicks ());	putlog ('~', "build dummy packet %s (always!) now", s);//	status_line (msgtxt[M_PACKET_MSG]);	if (xfscreate (s, 0, 'RvlM', 'TEMP') != noErr)	{		putlog (lgALRT, "Can't create dummy PKT");		Aborted = true;		return 1;	}		if (xfsopen (s, 0, &fp) != noErr)	{		putlog (lgALRT, "Can't open dummy PKT");		Aborted = true;		return 1;	}	//	t1 = time (NULL);//	tm1 = localtime (&t1);	tmppkt = (struct _pkthdr *) NewPtrClear (sizeof (struct _pkthdr));	if (tmppkt == NULL)	{//		status_line (msgtxt[M_MEM_ERROR]);		putlog (lgALRT, "Can't create dummy PKT (mem. err.)");		FSClose (fp);		return (1);	}	tmppkt->product = PRODUCT_LO;	tmppkt->serial = MAJOR_VRS;	tmppkt->ver = endshort(PKTVER);		((struct _pkthdr39 *)tmppkt)->product_hi = PRODUCT_HI;	((struct _pkthdr39 *)tmppkt)->prod_rev_low = MINOR_VRS;		if (session_password)	{//		(void) strupr (remote_password);		(void) strncpy ((char *) (tmppkt->password), session_password, 8);	}/*	if (n_getpassword (&called_addr))	{		if (remote_password != NULL)		{			(void) strupr (remote_password);			(void) strncpy ((char *) (tmppkt->password), remote_password, 8);		}	}*/	tmppkt->orig_zone = endshort(my__tmpaddr.ad.zone);	tmppkt->dest_zone = endshort(called_addr.Zone);	if (my__tmpaddr.ad.point || called_addr.Point)	{//		type 2.2			tmppkt->orig_node = endshort(my__tmpaddr.ad.node);		tmppkt->dest_node = endshort(called_addr.Node);		tmppkt->dest_net = endshort(called_addr.Net);		tmppkt->orig_net = endshort(my__tmpaddr.ad.net);		tmppkt->year = endshort(my__tmpaddr.ad.point);		tmppkt->month = endshort(called_addr.Point);		tmppkt->day = endshort(0);		tmppkt->hour = endshort(0);		tmppkt->minute = endshort(0);		tmppkt->second = endshort(0);		tmppkt->rate = endshort(2);	}	else	{		DateTimeRec	dtr;		GetTime (&dtr);//		type 2		tmppkt->orig_node = endshort(my__tmpaddr.ad.node);		tmppkt->dest_node = endshort(called_addr.Node);		tmppkt->dest_net = endshort(called_addr.Net);		tmppkt->orig_net = endshort(my__tmpaddr.ad.net);		tmppkt->year = endshort (dtr.year);		tmppkt->month = endshort (dtr.month);		tmppkt->day = endshort (dtr.day);		tmppkt->hour = endshort (dtr.hour);		tmppkt->minute = endshort (dtr.minute);		tmppkt->second = endshort (dtr.second);		tmppkt->rate = 0;	}/*	if ((called_addr.Domain != NULL) &&		(called_addr.Domain != alias[assumed].ad.Domain) &&		(alias[0].ad.Domain))	{//		Make it a type 2.2 packet instead		tmppkt->orig_node = endshort(alias[assumed].ad.Node);		tmppkt->dest_node = endshort(called_addr.Node);		tmppkt->dest_net = endshort(called_addr.Net);		tmppkt->orig_net = endshort(alias[assumed].ad.Net);		tmppkt->year = endshort(alias[assumed].ad.Point);		tmppkt->month = endshort(called_addr.Point);		tmppkt->day = endshort(0);		tmppkt->hour = endshort(0);		tmppkt->minute = endshort(0);		tmppkt->second = endshort(0);		tmppkt->rate = endshort(2);		if (alias[assumed].ad.Domain != NULL)		{			for (i = 0; domain_name[i] != NULL; i++)			{				if (domain_name[i] == alias[assumed].ad.Domain)				{					break;				}			}				if (i < 49)			{				strncpy ((char *)tmppkt->B_fill2, domain_abbrev[i], 8);			}		}			for (i = 0; domain_name[i] != NULL; i++)		{			if (domain_name[i] == called_addr.Domain)			{				break;			}		}			if (i < 49)		{			strncpy ((char *)&(tmppkt->B_fill2[8]), domain_abbrev[i], 8);		}	}	else	{		if(called_addr.Point || alias[assumed].ad.Point)	// Remap		{			tmppkt->orig_node.w = endshort(alias[assumed].ad.Point);			tmppkt->orig_net.w = endshort(alias[assumed].fakenet);			tmppkt->dest_node.w = endshort(called_addr.Point);			tmppkt->dest_net.w = endshort(alias[assumed].fakenet);		}		else		{			tmppkt->orig_node.w = endshort(alias[assumed].ad.Node);			tmppkt->dest_node.w = endshort(called_addr.Node);			tmppkt->dest_net.w = endshort(called_addr.Net);			tmppkt->orig_net.w = endshort(alias[assumed].ad.Net);		}		tmppkt->year.w = endshort(tm1->tm_year);		tmppkt->month.w = endshort(tm1->tm_mon);		tmppkt->day.w = endshort(tm1->tm_mday);		tmppkt->hour.w = endshort(tm1->tm_hour);		tmppkt->minute.w = endshort(tm1->tm_min);		tmppkt->second.w = endshort(tm1->tm_sec);		tmppkt->rate.w = endshort(0);	}*/	ioCounter = sizeof (struct _pkthdr);	FSWrite (fp, &ioCounter, tmppkt);	ioCounter = 2;	zeroid = 0L;	FSWrite (fp, &ioCounter, &zeroid);	FSClose (fp);	DisposePtr ((Ptr) tmppkt);	net_problems = (loc_no_sealink) ? Telink_Send_File (s, s) : SEAlink_Send_File (s, s);//ееFOR TEST PURPOSES ONLY! KILL LATER!!	xfsdelete (s, 0);		if (net_problems != 0)	{		Aborted = true;		return (net_problems);	}	/*--------------------------------------------------------------------*/	/* Send files listed in ?LO files (attached files)                    */	/*--------------------------------------------------------------------*///	status_line (" %s %s", msgtxt[M_OUTBOUND], msgtxt[M_FILE_ATTACHES]);	if (!do_FLOfile (&called_addr, FTSC_callback))	{		Aborted = true;		return FALSE;	}	/*--------------------------------------------------------------------*/	/* Send our File requests to other system if it's a WaZOO             */	/*--------------------------------------------------------------------*//*				ее					WAS SENT AS FLO	if (remote_capabilities)	{		sprintf (fname, request_template, HoldName, Hex_Addr_Str(&called_addr));		if (!stat (fname, &buf))		{			if (!(((unsigned) remote_capabilities) & WZ_FREQ))			// status_line (msgtxt[M_FREQ_DECLINED]);			else			{				// status_line (msgtxt[M_MAKING_FREQ]);				if (FTSC_callback (fname))					(void) unlink (fname);			}		}	}*/	/*--------------------------------------------------------------------*/	/* Process WaZOO file requests from other system                      */	/*--------------------------------------------------------------------*/#ifndef LITE	j = respond_to_file_requests (j, FTSC_callback);#endif	/* Now close out the file attaches */	sent_mail = 1;//	*sptr = 0;//	status_line (" %s %s %s", msgtxt[M_END_OF], msgtxt[M_OUTBOUND], msgtxt[M_FILE_ATTACHES]);	(void) Batch_Send (NULL);	t1 = timerset (60);	return TRUE;}static short FTSC_recvmail (){	char			fname[256];	char			fname1[80];	struct _pkthdr	tmppkt;	short			fp;	short			done;//	short			j;//	char			*p;	long			ioCounter;   // status_line (msgtxt[M_RECV_MAIL]);	if (!CARRIER)	{//		status_line (msgtxt[M_NO_CARRIER]);				Aborted = true;		CLEAR_INBOUND ();		return (1);	}//	XON_DISABLE ();	done = 0;/* If we don't want to pickup stuff */	if (no_pickup)	{//		status_line (msgtxt[M_NO_PICKUP]);		SENDBYTE (CAN, NULL);	}	else	{//		status_line (" %s %s", msgtxt[M_INBOUND], msgtxt[M_MAIL_PACKET]);	/* Invent a dummy name for the packet */		sprintf (fname1, "%.8lX.PKT", LMGetTicks ());	putlog ('~', "receive 1st PKT %s now", fname1);	/* Receive the packet with special netmail protocol */		CLEAR_INBOUND ();//		p = (char *) &inboundPath[1];		if (Xmodem_Receive_File ((char *) &inboundPath[1], fname1) == 0)		{			got_packet = 1;		}		/* concatenate path */			(void) sprintf (fname, "%s%s", (char *) &inboundPath[1], fname1);putlog ('~', "path %s now", (char *) &inboundPath[1]);putlog ('~', "conc. receive 1st PKT %s now", fname);	/* Check the password if there is one */		if (haspassword (&remote_addr, &session_password))		{			got_packet = 0;						if (xfsopen (fname, 0, &fp) != noErr)			{			// status_line (msgtxt[M_PWD_ERR_ASSUMED]);				putlog (lgALRT, "Can't open incoming pkt");				return (1);			}			ioCounter = sizeof (struct _pkthdr);			FSRead (fp, &ioCounter, &tmppkt);						FSClose (fp);//			xfsdelete (fname, 0);						if (ioCounter != sizeof (struct _pkthdr))			{				putlog (lgALRT, "Can't read incoming pkt");				return (1);			}			if (strncasecmp (session_password, (char *) (tmppkt.password), 8))			{				putlog (lgALRT, "Bad password!");				return (1);			}			got_packet = 1;		}		got_mail = got_packet;//		if (isOriginator)		{			addr	tad;						tad.zone = remote_addr.Zone;			tad.net = remote_addr.Net;			tad.node = remote_addr.Node;			tad.point = remote_addr.Point;//еее			if (!isOriginator || (isOriginator && !cmp2addrs1 (&tad, &called_addr)))				if (bsy_raise (&tad, workPath))					return (1);//			bsy_raise (&tad, workPath);						called_addr = remote_addr;		}//е	Cyril-- (was interpreted by me... then turned back)//		called_addr = remote_addr;		done = 0;	/* Now receive the files if possible */	//	status_line (" %s %s", msgtxt[M_INBOUND], msgtxt[M_FILE_ATTACHES]);		done = Batch_Receive ((char *) &inboundPath[1]);	}putlog ('~', "path %s now", (char *) &inboundPath[1]);   // status_line (" %s %s %s", msgtxt[M_END_OF], msgtxt[M_INBOUND], msgtxt[M_FILE_ATTACHES]);   CLEAR_INBOUND ();   return (done);}static short FTSC_callback (unsigned char *sptr){	if (sptr)		sptr[sptr[0]+1] = 0;	newMessage (lTNAME, "");	newMessage (lTSTAT, "");	newMessage (lRNAME, "");	newMessage (lRSTAT, "");	net_problems = Batch_Send ((sptr) ? ((char *) sptr+1) : NULL);	newMessage (lTNAME, "");	newMessage (lTSTAT, "");	newMessage (lRNAME, "");	newMessage (lRSTAT, "");	if (net_problems != 0)	{		Aborted = true;		net_problems = 1;		return XFER_ABORT;	}	return OK;}