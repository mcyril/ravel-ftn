#include <ctype.h>#include <stdio.h>#include <string.h>#include "PascalStr.h"#include "Ravel_FTN.h"#include "Ravel_Prefs.h"#include "Pathes.h"#include "ftsc.h"//#include "pkthdrs.h"#include "definitions.h"#include "ascii.h"#include "compatible.h"#include "stringutl.h"#include "Scheduler.h"#include "Unattended.h"#include "Attacher.h"#include "Comm.h"#include "Timing.h"#include "xmodem.h"#include "log.h"#include "freq.h"#include "myEnv.h"#include "zfiles.h"#include "state.h"#include "pmain.h"#include "Modem.h"#include "aglcrc.h"static short  MSInit (XMARGSP, short);static short  MSEnd (XMARGSP, short);static short  MSWaitNak (XMARGSP);static short  MSWaitChAck (XMARGSP);static short  MSWaitCksm (XMARGSP);STATES Modem7_Sender[] = {   { "MSInit", (ProcPtr) MSInit },   { "MSEnd", (ProcPtr) MSEnd },   { "MS0", (ProcPtr) MSWaitNak },   { "MS1", (ProcPtr) MSWaitChAck },   { "MS2", (ProcPtr) MSWaitCksm }};static short  MSInit (XMARGSP args, short start_state){	char *p;	short i;//	struct FILEINFO dta;//	XON_DISABLE ();	args->tries = 0;//	if (!dfind (&dta, args->filename, 0))//		dir_close();		(void) strcpy (args->m7name, "           ");		for (i = 0, p = trunc_path (args->filename); i < 8; p++, i++)		if ((*p != '.') && (*p != '\0'))			args->m7name[i] = toupper(*p);		else			break;	if (*p == '.')		++p;		for (i = 8; i < 11; p++, i++)		if ((*p != '.') && (*p != '\0'))			args->m7name[i] = toupper(*p);		else			break;	/* Now do the checksum */	args->check = SUB;	for (i = 0; i < 11; i++)		args->check += (unsigned char) args->m7name[i];	return (start_state);}static short  MSEnd (XMARGSP args, short cur_state){   args->result = cur_state;   return (cur_state);}static short  MSWaitNak (XMARGSP args){   if (args->tries >= 10)      return (FNAME_ERR);   if (!CARRIER)      return (CARRIER_ERR);   if (TIMED_READ (10, NULL) != NAK)      {      ++args->tries;      return (MS0);      }   SENDBYTE (ACK, NULL);   SENDBYTE ((unsigned char) *(args->m7name), NULL);   args->fptr = args->m7name + 1;   return (MS1);}static short  MSWaitChAck (XMARGSP args){   if (!CARRIER)      return (CARRIER_ERR);   if (TIMED_READ (10, NULL) != ACK)      {      ++args->tries;      SENDBYTE ('u', NULL);      return (MS0);      }   /* If filename done */   if (*(args->fptr) == '\0')      {      SENDBYTE (SUB, NULL);      return (MS2);      }   else      {      /* Send next char of name */      SENDBYTE ((unsigned char) *args->fptr++, NULL);      return (MS1);      }}static short  MSWaitCksm (XMARGSP args){   short in_char;   if (!CARRIER)      return (CARRIER_ERR);   if (((in_char = TIMED_READ (10, NULL)) < 0) || (in_char != args->check))      {      SENDBYTE ('u', NULL);      ++args->tries;      return (MS0);      }   else      {      SENDBYTE (ACK, NULL);      return (SUCCESS);      }}short Modem7_Send_File (char *filename){   XMARGS batch;   short res;   batch.result = 0;   batch.filename = filename;   res = state_machine (Modem7_Sender, &batch, 2);   return (res);}