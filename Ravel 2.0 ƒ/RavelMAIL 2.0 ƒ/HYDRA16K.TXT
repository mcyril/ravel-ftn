Модификация Hydra. Hydra с 8K и 16K блоками.--------------------------------------------  Реализовано в мэйлерах:  Xenolink (Amiga), Zeus (Amiga), GMS (до версии 1.1.83 включительно, Amiga),Ravel (Macintosh). Позже qico (U*ix) и GP-Mail (OS/2). В qico не собирается в дефолтной конфигурациии заявлена опасной модификацией в следствии конфликтов с некоторыми U*ix системами имодемами определенных моделей. Похоже, драйвера в U*ix'ах сосут.  Информация предоставлена Робертом Дэйлом, Xenolink Developers Team.  В EMSI используются флаги капабилити HY8 и H16. Соответственно, Hydraс 8K и 16K блоками. Выбор протокола осуществляется стандартным методом.  Измененная Hydra включается только при скорости соединения:    Hydra 8K  - от 14400  Hydra 16K - от 28800  Смысл заключается только в смене максимального размера блока.    Реализовано в Ravel след. образом:// EMSI modifications// .......................  emsi_capability = 0;  if (cur_baud >= 28800 && YesHydra16K)    emsi_capability |= EMSI_P_H16;  if (cur_baud >= 14400 && YesHydra8K)    emsi_capability |= EMSI_P_HY8;  if (YesHydra)    emsi_capability |= EMSI_P_HYD;// .......................  /* Compatibility codes */  ptr = add_field('{', ptr);  if (sender)  {    if(emsi_capability & EMSI_P_H16)      ptr = add_str("H16,", ptr);    if(emsi_capability & EMSI_P_HY8)      ptr = add_str("HY8,", ptr);    if(emsi_capability & EMSI_P_HYD)      ptr = add_str("HYD,", ptr);// .......................  }  else            /* Pick best protocol */  {    if (emsi_capability & emsi_remote_capability & EMSI_P_H16)    {      ptr = add_str("H16,", ptr);      emsi_protocol = EMSI_P_H16;    }    else if (emsi_capability & emsi_remote_capability & EMSI_P_HY8)    {      ptr = add_str("HY8,", ptr);      emsi_protocol = EMSI_P_HY8;    }    else if (emsi_capability & emsi_remote_capability & EMSI_P_HYD)    {      ptr = add_str("HYD,", ptr);      emsi_protocol = EMSI_P_HYD;    }// .......................  }// SESSION// .......................//  * Try Hydra first *  if (emsi_protocol & (EMSI_P_HYD|EMSI_P_HY8|EMSI_P_H16))  {// .......................    hydra_init (0, (emsi_protocol & EMSI_P_HY8) ? 4L :            ((emsi_protocol & EMSI_P_H16) ? 8L : 1L));// .......................  }// Hydra modifications#define H_MINBLKLEN    64         /* Min. length of a HYDRA data block */#define H_MAXBLKLEN(n) (2048*(n)) /* Max. length of a HYDRA data block */#define H_OVERHEAD     8          /* Max. no. control bytes in a pkt   */#define H_MAXPKTLEN(n) ((H_MAXBLKLEN(n) + H_OVERHEAD + 5) * 3)                                  /* Encoded pkt */#define H_BUFLEN(n)    (H_MAXPKTLEN(n) + 16)                                  /* Buffer sizes: max.enc.pkt + slack */void hydra_init (unsigned long want_options, long hmodifier){// .......................  hydra_modifier = hmodifier;    txbuf = (unsigned char *) malloc (H_BUFLEN(hydra_modifier));  rxbuf = (unsigned char *) malloc (H_BUFLEN(hydra_modifier));// .......................    txbufin = txbuf + ((H_MAXBLKLEN(hydra_modifier) + H_OVERHEAD + 5) * 2);  rxbufmax = rxbuf + H_MAXPKTLEN(hydra_modifier);// .......................	if (hydra_modifier == 1)	{		txmaxblklen = (short) ((cur_baud / 300) * 128);		if (txmaxblklen < 256)			txmaxblklen = 256;		else if (txmaxblklen > H_MAXBLKLEN(1))			txmaxblklen = H_MAXBLKLEN(1);		rxblklen = txblklen = (cur_baud < 2400U) ? 256 : 512;	}	else	{		txmaxblklen = H_MAXBLKLEN(hydra_modifier);		rxblklen = txblklen = txmaxblklen / 4;	}// .......................}short hydra (char *txpathname, char *txalias){// .......................// .......................    case HPKT_DATA:      if (rxstate == HRX_DATA)      {        if (intell (h_long1 (rxbuf)) != rxpos ||          intell (h_long1 (rxbuf)) < 0L)        {// .......................          if (!h_timer_running (rxtimer) ||            h_timer_expired (rxtimer, h_timer_get ()))          {// .......................            rxblklen /= 2;            i = rxblklen;            if (i <= 64)              i = 64;            else if (i <= 128)              i = 128;            else if (i <= 256)              i = 256;            else if (i <= 512)              i = 512;            else if (i <= 1024)              i = 1024;            else if (i <= 2048)              i = 2048;            else if (i <= 4096)              i = 4096;            else              i = 8192;                        if (hydra_modifier == 8 && i > 8192)              i = 8192;            else if (hydra_modifier == 4 && i > 4096)              i = 4096;            else if (hydra_modifier == 1 && i > 1024)              i = 1024;            // .......................          }        }        else        {        // .......................        }      }      break;// .......................// .......................    case HPKT_RPOS:      if (txstate == HTX_XDATA || txstate == HTX_DATAACK ||        txstate == HTX_XWAIT ||        txstate == HTX_EOF || txstate == HTX_EOFACK)      {// .......................        if (txblklen > (unsigned short) intell (h_long2 (rxbuf)))          txblklen = (unsigned short) intell (h_long2 (rxbuf));        else          txblklen >>= 1;        if (txblklen <= 64)          txblklen = 64;        else if (txblklen <= 128)          txblklen = 128;        else if (txblklen <= 256)          txblklen = 256;        else if (txblklen <= 512)          txblklen = 512;        else if (txblklen <= 1024)          txblklen = 1024;        else if (txblklen <= 2048)          txblklen = 2048;        else if (txblklen <= 4096)          txblklen = 4096;        else          txblklen = 8192;        if (hydra_modifier == 8 && txblklen > 8192)          txblklen = 8192;        else if (hydra_modifier == 4 && txblklen > 4096)          txblklen = 4096;        else if (hydra_modifier == 1 && txblklen > 1024)          txblklen = 1024;// .......................      }      break;// .......................// .......................    case HPKT_EOF:      if (rxstate == HRX_DATA)      {        if (intell (h_long1 (rxbuf)) < 0L)        {// .......................        }        else          if (intell (h_long1 (rxbuf)) != rxpos)          {// .......................            if (!h_timer_running (rxtimer) ||              h_timer_expired (rxtimer, h_timer_get ()))            {// .......................              rxblklen /= 2;              i = rxblklen;              if (i <= 64)                i = 64;              else if (i <= 128)                i = 128;              else if (i <= 256)                i = 256;              else if (i <= 512)                i = 512;              else if (i <= 1024)                i = 1024;              else if (i <= 2048)                i = 2048;              else if (i <= 4096)                i = 4096;              else                i = 8192;                            if (hydra_modifier == 8 && i > 8192)                i = 8192;              else if (hydra_modifier == 4 && i > 4096)                i = 4096;              else if (hydra_modifier == 1 && i > 1024)                i = 1024;// .......................            }          }          else          {// .......................          }      }// .......................      break;// .......................// .......................}