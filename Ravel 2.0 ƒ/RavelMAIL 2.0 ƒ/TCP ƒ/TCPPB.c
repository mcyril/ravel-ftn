#include <Devices.h>#include <MacTCP.h>#include <string.h>#include "AddressXlation.h"#include "myTCP.h"/*********************************************************** PBControl Interface Procedures*/static	short	gIPPDriverRefNum;OSErr _TCPInit (void){	ParamBlockRec		pb;	OSErr				osErr;			pb.ioParam.ioCompletion		= 0; 	pb.ioParam.ioNamePtr		= "\p.ipp"; 	pb.ioParam.ioPermssn		= fsCurPerm;		osErr = PBOpen(&pb, false);	if (osErr == noErr) {		gIPPDriverRefNum		= pb.ioParam.ioRefNum;	}	return osErr;}OSErr _TCPGetIP (GetAddrParamBlock *pb, ip_addr *ip, long *netMask, GetIPIOCompletionUPP ioCompletion, Boolean async){	OSErr					osErr;		pb->ioCompletion			= ioCompletion;	pb->ioCRefNum					= gIPPDriverRefNum;	pb->csCode						= ipctlGetAddr;			osErr = PBControl((ParmBlkPtr) pb, async);	if (!async && (osErr == noErr)) {		*ip							= pb->ourAddress;		*netMask					= pb->ourNetMask;	}			return osErr;}OSErr _TCPCreate (TCPiopb *pb, StreamPtr *stream, Ptr rcvBufPtr, long rcvBufLen, TCPNotifyUPP aNotifyProc, Ptr userDataPtr, TCPIOCompletionUPP ioCompletion, Boolean async){	OSErr					osErr;		memchr ((char *)pb, 0, sizeof(TCPiopb));	pb->ioCompletion					= ioCompletion;	pb->ioCRefNum						= gIPPDriverRefNum;	pb->csCode							= TCPCreate;		pb->csParam.create.rcvBuff			= rcvBufPtr;		pb->csParam.create.rcvBuffLen		= rcvBufLen;		pb->csParam.create.notifyProc		= aNotifyProc;	pb->csParam.create.userDataPtr		= userDataPtr;		osErr = PBControl((ParmBlkPtr) pb, async);	if (!async && (osErr == noErr)) {		*stream							= pb->tcpStream;	}			return osErr;}OSErr _TCPPassiveOpen (TCPiopb *pb, StreamPtr stream, ip_addr *remoteIP, tcp_port *remotePort, ip_addr *localIP, tcp_port *localPort, Ptr userData, TCPIOCompletionUPP ioCompletion, Boolean async){	OSErr					osErr;	short					index;		pb->ioCompletion						= ioCompletion;	pb->ioCRefNum							= gIPPDriverRefNum;	pb->csCode								= TCPPassiveOpen;	pb->tcpStream							= stream;		pb->csParam.open.ulpTimeoutValue		= 120;	pb->csParam.open.ulpTimeoutAction		= 1;	pb->csParam.open.validityFlags			= 0xC0;		pb->csParam.open.commandTimeoutValue	= 120;		pb->csParam.open.remoteHost				= *remoteIP;		pb->csParam.open.remotePort				= *remotePort;		pb->csParam.open.localHost				= 0;		pb->csParam.open.localPort				= *localPort;		pb->csParam.open.tosFlags				= 0x07;		pb->csParam.open.precedence				= 1;		pb->csParam.open.dontFrag				= 0;		pb->csParam.open.timeToLive				= 0;	pb->csParam.open.security				= 0;		pb->csParam.open.optionCnt				= 0;	for (index = 0; index < sizeof(pb->csParam.open.options); ++index)			pb->csParam.open.options[index]		= 0;		pb->csParam.open.userDataPtr			= userData;		osErr = PBControl((ParmBlkPtr) pb, async);	if (!async && (osErr == noErr)) {		*remoteIP							= pb->csParam.open.remoteHost;			*remotePort							= pb->csParam.open.remotePort;			*localIP							= pb->csParam.open.localHost;			*localPort							= pb->csParam.open.localPort;	}	return osErr;}OSErr _TCPActiveOpen (TCPiopb *pb, StreamPtr stream, ip_addr remoteIP, tcp_port remotePort, ip_addr *localIP, tcp_port *localPort, Ptr userData, TCPIOCompletionUPP ioCompletion, Boolean async){	OSErr					osErr;	short					index;		pb->ioCompletion						= ioCompletion;	pb->ioCRefNum							= gIPPDriverRefNum;	pb->csCode								= TCPActiveOpen;	pb->tcpStream							= stream;		pb->csParam.open.ulpTimeoutValue		= 60;	pb->csParam.open.ulpTimeoutAction		= 1;	pb->csParam.open.validityFlags			= 0xC0;	/*	pb->csParam.open.commandTimeoutValue	= 30;  not available with this csCode */	pb->csParam.open.remoteHost				= remoteIP;		pb->csParam.open.remotePort				= remotePort;		pb->csParam.open.localHost				= 0;		pb->csParam.open.localPort				= *localPort;		pb->csParam.open.tosFlags				= 0x07;		pb->csParam.open.precedence				= 1;		pb->csParam.open.dontFrag				= 0;		pb->csParam.open.timeToLive				= 0;	pb->csParam.open.security				= 0;		pb->csParam.open.optionCnt				= 0;	for (index = 0; index < sizeof(pb->csParam.open.options); ++index)			pb->csParam.open.options[index]		= 0;		pb->csParam.open.userDataPtr			= userData;		osErr = PBControl((ParmBlkPtr) pb, async);	if (!async && (osErr == noErr)) {		*localIP							= pb->csParam.open.localHost;			*localPort							= pb->csParam.open.localPort;	}	return osErr;}OSErr _TCPSend (TCPiopb *pb, StreamPtr stream, wdsEntry *wdsPtr, Ptr userData, TCPIOCompletionUPP ioCompletion, Boolean async){	OSErr					osErr;		pb->ioCompletion					= ioCompletion;	pb->ioCRefNum						= gIPPDriverRefNum;	pb->csCode							= TCPSend;	pb->tcpStream						= stream;		pb->csParam.send.ulpTimeoutValue	= 30;		pb->csParam.send.ulpTimeoutAction	= 1;		pb->csParam.send.validityFlags		= 0xC0;		pb->csParam.send.pushFlag			= 0;		pb->csParam.send.urgentFlag			= 0;		pb->csParam.send.wdsPtr				= (Ptr) wdsPtr;		pb->csParam.send.sendFree			= 0;		pb->csParam.send.sendLength			= 0;		pb->csParam.send.userDataPtr		= userData;		osErr = PBControl((ParmBlkPtr) pb, async);	return osErr;}OSErr _TCPNoCopyRcv (TCPiopb *pb, StreamPtr stream, rdsEntry *rdsPtr, unsigned short rdsLength, Ptr userData, TCPIOCompletionUPP ioCompletion, Boolean async){	OSErr					osErr;		pb->ioCompletion							= ioCompletion;	pb->ioCRefNum								= gIPPDriverRefNum;	pb->csCode									= TCPNoCopyRcv;	pb->tcpStream								= stream;		pb->csParam.receive.commandTimeoutValue		= 30;		pb->csParam.receive.urgentFlag				= 0;		pb->csParam.receive.markFlag				= 0;		pb->csParam.receive.rdsPtr					= (Ptr) rdsPtr;		pb->csParam.receive.rdsLength				= rdsLength;		pb->csParam.receive.userDataPtr				= userData;		osErr = PBControl((ParmBlkPtr) pb, async);	return osErr;}OSErr _TCPRcv (TCPiopb *pb, StreamPtr stream, Ptr rcvBufPtr, unsigned short *rcvBufLen, Ptr userData, TCPIOCompletionUPP ioCompletion, Boolean async){	OSErr					osErr;		pb->ioCompletion							= ioCompletion;	pb->ioCRefNum								= gIPPDriverRefNum;	pb->csCode									= TCPRcv;	pb->tcpStream								= stream;		pb->csParam.receive.commandTimeoutValue		= 30;		pb->csParam.receive.urgentFlag				= 0;		pb->csParam.receive.markFlag				= 0;		pb->csParam.receive.rcvBuff					= rcvBufPtr;		pb->csParam.receive.rcvBuffLen				= *rcvBufLen;		pb->csParam.receive.userDataPtr				= userData;		osErr = PBControl((ParmBlkPtr) pb, async);	if (! async)		*rcvBufLen = pb->csParam.receive.rcvBuffLen;	return osErr;}OSErr _TCPBfrReturn (TCPiopb *pb, StreamPtr stream, Ptr rdsPtr, Ptr userData, TCPIOCompletionUPP ioCompletion, Boolean async){	OSErr					osErr;		pb->ioCompletion					= ioCompletion;	pb->ioCRefNum						= gIPPDriverRefNum;	pb->csCode							= TCPRcvBfrReturn;	pb->tcpStream						= stream;		pb->csParam.receive.rdsPtr			= rdsPtr;		pb->csParam.receive.userDataPtr		= userData;		osErr = PBControl((ParmBlkPtr) pb, async);	return osErr;}OSErr _TCPClose (TCPiopb *pb, StreamPtr stream, Ptr userData, TCPIOCompletionUPP ioCompletion, Boolean async){	OSErr					osErr;		pb->ioCompletion					= ioCompletion;	pb->ioCRefNum						= gIPPDriverRefNum;	pb->csCode							= TCPClose;	pb->tcpStream						= stream;		pb->csParam.close.ulpTimeoutValue	= 30;		pb->csParam.close.ulpTimeoutAction	= 1;		pb->csParam.close.validityFlags		= 0xC0;		pb->csParam.close.userDataPtr		= userData;		osErr = PBControl((ParmBlkPtr) pb, async);	return osErr;}OSErr _TCPAbort (TCPiopb *pb, StreamPtr stream, Ptr userData, TCPIOCompletionUPP ioCompletion, Boolean async){	OSErr					osErr;		pb->ioCompletion					= ioCompletion;	pb->ioCRefNum						= gIPPDriverRefNum;	pb->csCode							= TCPAbort;	pb->tcpStream						= stream;		pb->csParam.abort.userDataPtr		= userData;		osErr = PBControl((ParmBlkPtr) pb, async);	return osErr;}OSErr _TCPStatus (TCPiopb *pb, StreamPtr stream, struct TCPStatusPB *status, Ptr userData, TCPIOCompletionUPP ioCompletion, Boolean async){	OSErr					osErr;		pb->ioCompletion					= ioCompletion;	pb->ioCRefNum						= gIPPDriverRefNum;	pb->csCode							= TCPStatus;	pb->tcpStream						= stream;		pb->csParam.status.userDataPtr		= userData;		osErr = PBControl((ParmBlkPtr) pb, async);	if (!async && (osErr == noErr)) {		*status							= pb->csParam.status;		}	return osErr;}OSErr _TCPRelease (TCPiopb *pb, StreamPtr stream, Ptr *rcvBufPtr, long *rcvBufLen, TCPIOCompletionUPP ioCompletion, Boolean async){	OSErr					osErr;		pb->ioCompletion					= ioCompletion;	pb->ioCRefNum						= gIPPDriverRefNum;	pb->csCode							= TCPRelease;	pb->tcpStream						= stream;		osErr = PBControl((ParmBlkPtr) pb, async);	if (!async && (osErr == noErr)) {		*rcvBufPtr						= pb->csParam.create.rcvBuff;			*rcvBufLen						= pb->csParam.create.rcvBuffLen;		}	return osErr;}